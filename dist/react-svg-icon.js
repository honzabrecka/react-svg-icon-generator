(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["library-boilerplate"] = factory();
	else
		root["library-boilerplate"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = configureSvgIcon;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _configureGenerator = __webpack_require__(128);

	var _configureGenerator2 = _interopRequireDefault(_configureGenerator);

	var _gulp = __webpack_require__(219);

	var _gulp2 = _interopRequireDefault(_gulp);

	function configureSvgIcon(config) {
	  _gulp2['default'].task('svg-icon', _configureGenerator2['default'](config));
	}

	exports.configureGenerator = _configureGenerator2['default'];

/***/ },
/* 1 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};

	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.

	var cachedSetTimeout;
	var cachedClearTimeout;

	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }


	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }



	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */

	'use strict'

	var base64 = __webpack_require__(134)
	var ieee754 = __webpack_require__(224)
	var isArray = __webpack_require__(64)

	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50

	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.

	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
	  ? global.TYPED_ARRAY_SUPPORT
	  : typedArraySupport()

	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()

	function typedArraySupport () {
	  try {
	    var arr = new Uint8Array(1)
	    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
	    return arr.foo() === 42 && // typed array instances can be augmented
	        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
	        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
	  } catch (e) {
	    return false
	  }
	}

	function kMaxLength () {
	  return Buffer.TYPED_ARRAY_SUPPORT
	    ? 0x7fffffff
	    : 0x3fffffff
	}

	function createBuffer (that, length) {
	  if (kMaxLength() < length) {
	    throw new RangeError('Invalid typed array length')
	  }
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = new Uint8Array(length)
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    if (that === null) {
	      that = new Buffer(length)
	    }
	    that.length = length
	  }

	  return that
	}

	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */

	function Buffer (arg, encodingOrOffset, length) {
	  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
	    return new Buffer(arg, encodingOrOffset, length)
	  }

	  // Common case.
	  if (typeof arg === 'number') {
	    if (typeof encodingOrOffset === 'string') {
	      throw new Error(
	        'If encoding is specified then the first argument must be a string'
	      )
	    }
	    return allocUnsafe(this, arg)
	  }
	  return from(this, arg, encodingOrOffset, length)
	}

	Buffer.poolSize = 8192 // not used by this implementation

	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
	  arr.__proto__ = Buffer.prototype
	  return arr
	}

	function from (that, value, encodingOrOffset, length) {
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number')
	  }

	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    return fromArrayBuffer(that, value, encodingOrOffset, length)
	  }

	  if (typeof value === 'string') {
	    return fromString(that, value, encodingOrOffset)
	  }

	  return fromObject(that, value)
	}

	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
	  return from(null, value, encodingOrOffset, length)
	}

	if (Buffer.TYPED_ARRAY_SUPPORT) {
	  Buffer.prototype.__proto__ = Uint8Array.prototype
	  Buffer.__proto__ = Uint8Array
	  if (typeof Symbol !== 'undefined' && Symbol.species &&
	      Buffer[Symbol.species] === Buffer) {
	    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
	    Object.defineProperty(Buffer, Symbol.species, {
	      value: null,
	      configurable: true
	    })
	  }
	}

	function assertSize (size) {
	  if (typeof size !== 'number') {
	    throw new TypeError('"size" argument must be a number')
	  } else if (size < 0) {
	    throw new RangeError('"size" argument must not be negative')
	  }
	}

	function alloc (that, size, fill, encoding) {
	  assertSize(size)
	  if (size <= 0) {
	    return createBuffer(that, size)
	  }
	  if (fill !== undefined) {
	    // Only pay attention to encoding if it's a string. This
	    // prevents accidentally sending in a number that would
	    // be interpretted as a start offset.
	    return typeof encoding === 'string'
	      ? createBuffer(that, size).fill(fill, encoding)
	      : createBuffer(that, size).fill(fill)
	  }
	  return createBuffer(that, size)
	}

	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
	  return alloc(null, size, fill, encoding)
	}

	function allocUnsafe (that, size) {
	  assertSize(size)
	  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) {
	    for (var i = 0; i < size; ++i) {
	      that[i] = 0
	    }
	  }
	  return that
	}

	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
	  return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
	  return allocUnsafe(null, size)
	}

	function fromString (that, string, encoding) {
	  if (typeof encoding !== 'string' || encoding === '') {
	    encoding = 'utf8'
	  }

	  if (!Buffer.isEncoding(encoding)) {
	    throw new TypeError('"encoding" must be a valid string encoding')
	  }

	  var length = byteLength(string, encoding) | 0
	  that = createBuffer(that, length)

	  var actual = that.write(string, encoding)

	  if (actual !== length) {
	    // Writing a hex string, for example, that contains invalid characters will
	    // cause everything after the first invalid character to be ignored. (e.g.
	    // 'abxxcd' will be treated as 'ab')
	    that = that.slice(0, actual)
	  }

	  return that
	}

	function fromArrayLike (that, array) {
	  var length = array.length < 0 ? 0 : checked(array.length) | 0
	  that = createBuffer(that, length)
	  for (var i = 0; i < length; i += 1) {
	    that[i] = array[i] & 255
	  }
	  return that
	}

	function fromArrayBuffer (that, array, byteOffset, length) {
	  array.byteLength // this throws if `array` is not a valid ArrayBuffer

	  if (byteOffset < 0 || array.byteLength < byteOffset) {
	    throw new RangeError('\'offset\' is out of bounds')
	  }

	  if (array.byteLength < byteOffset + (length || 0)) {
	    throw new RangeError('\'length\' is out of bounds')
	  }

	  if (byteOffset === undefined && length === undefined) {
	    array = new Uint8Array(array)
	  } else if (length === undefined) {
	    array = new Uint8Array(array, byteOffset)
	  } else {
	    array = new Uint8Array(array, byteOffset, length)
	  }

	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    // Return an augmented `Uint8Array` instance, for best performance
	    that = array
	    that.__proto__ = Buffer.prototype
	  } else {
	    // Fallback: Return an object instance of the Buffer class
	    that = fromArrayLike(that, array)
	  }
	  return that
	}

	function fromObject (that, obj) {
	  if (Buffer.isBuffer(obj)) {
	    var len = checked(obj.length) | 0
	    that = createBuffer(that, len)

	    if (that.length === 0) {
	      return that
	    }

	    obj.copy(that, 0, 0, len)
	    return that
	  }

	  if (obj) {
	    if ((typeof ArrayBuffer !== 'undefined' &&
	        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
	      if (typeof obj.length !== 'number' || isnan(obj.length)) {
	        return createBuffer(that, 0)
	      }
	      return fromArrayLike(that, obj)
	    }

	    if (obj.type === 'Buffer' && isArray(obj.data)) {
	      return fromArrayLike(that, obj.data)
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}

	function checked (length) {
	  // Note: cannot use `length < kMaxLength()` here because that fails when
	  // length is NaN (which is otherwise coerced to zero.)
	  if (length >= kMaxLength()) {
	    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
	                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
	  }
	  return length | 0
	}

	function SlowBuffer (length) {
	  if (+length != length) { // eslint-disable-line eqeqeq
	    length = 0
	  }
	  return Buffer.alloc(+length)
	}

	Buffer.isBuffer = function isBuffer (b) {
	  return !!(b != null && b._isBuffer)
	}

	Buffer.compare = function compare (a, b) {
	  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
	    throw new TypeError('Arguments must be Buffers')
	  }

	  if (a === b) return 0

	  var x = a.length
	  var y = b.length

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i]
	      y = b[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	Buffer.isEncoding = function isEncoding (encoding) {
	  switch (String(encoding).toLowerCase()) {
	    case 'hex':
	    case 'utf8':
	    case 'utf-8':
	    case 'ascii':
	    case 'latin1':
	    case 'binary':
	    case 'base64':
	    case 'ucs2':
	    case 'ucs-2':
	    case 'utf16le':
	    case 'utf-16le':
	      return true
	    default:
	      return false
	  }
	}

	Buffer.concat = function concat (list, length) {
	  if (!isArray(list)) {
	    throw new TypeError('"list" argument must be an Array of Buffers')
	  }

	  if (list.length === 0) {
	    return Buffer.alloc(0)
	  }

	  var i
	  if (length === undefined) {
	    length = 0
	    for (i = 0; i < list.length; ++i) {
	      length += list[i].length
	    }
	  }

	  var buffer = Buffer.allocUnsafe(length)
	  var pos = 0
	  for (i = 0; i < list.length; ++i) {
	    var buf = list[i]
	    if (!Buffer.isBuffer(buf)) {
	      throw new TypeError('"list" argument must be an Array of Buffers')
	    }
	    buf.copy(buffer, pos)
	    pos += buf.length
	  }
	  return buffer
	}

	function byteLength (string, encoding) {
	  if (Buffer.isBuffer(string)) {
	    return string.length
	  }
	  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
	      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
	    return string.byteLength
	  }
	  if (typeof string !== 'string') {
	    string = '' + string
	  }

	  var len = string.length
	  if (len === 0) return 0

	  // Use a for loop to avoid recursion
	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'ascii':
	      case 'latin1':
	      case 'binary':
	        return len
	      case 'utf8':
	      case 'utf-8':
	      case undefined:
	        return utf8ToBytes(string).length
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return len * 2
	      case 'hex':
	        return len >>> 1
	      case 'base64':
	        return base64ToBytes(string).length
	      default:
	        if (loweredCase) return utf8ToBytes(string).length // assume utf8
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}
	Buffer.byteLength = byteLength

	function slowToString (encoding, start, end) {
	  var loweredCase = false

	  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
	  // property of a typed array.

	  // This behaves neither like String nor Uint8Array in that we set start/end
	  // to their upper/lower bounds if the value passed is out of range.
	  // undefined is handled specially as per ECMA-262 6th Edition,
	  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
	  if (start === undefined || start < 0) {
	    start = 0
	  }
	  // Return early if start > this.length. Done here to prevent potential uint32
	  // coercion fail below.
	  if (start > this.length) {
	    return ''
	  }

	  if (end === undefined || end > this.length) {
	    end = this.length
	  }

	  if (end <= 0) {
	    return ''
	  }

	  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
	  end >>>= 0
	  start >>>= 0

	  if (end <= start) {
	    return ''
	  }

	  if (!encoding) encoding = 'utf8'

	  while (true) {
	    switch (encoding) {
	      case 'hex':
	        return hexSlice(this, start, end)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Slice(this, start, end)

	      case 'ascii':
	        return asciiSlice(this, start, end)

	      case 'latin1':
	      case 'binary':
	        return latin1Slice(this, start, end)

	      case 'base64':
	        return base64Slice(this, start, end)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return utf16leSlice(this, start, end)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = (encoding + '').toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true

	function swap (b, n, m) {
	  var i = b[n]
	  b[n] = b[m]
	  b[m] = i
	}

	Buffer.prototype.swap16 = function swap16 () {
	  var len = this.length
	  if (len % 2 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 16-bits')
	  }
	  for (var i = 0; i < len; i += 2) {
	    swap(this, i, i + 1)
	  }
	  return this
	}

	Buffer.prototype.swap32 = function swap32 () {
	  var len = this.length
	  if (len % 4 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 32-bits')
	  }
	  for (var i = 0; i < len; i += 4) {
	    swap(this, i, i + 3)
	    swap(this, i + 1, i + 2)
	  }
	  return this
	}

	Buffer.prototype.swap64 = function swap64 () {
	  var len = this.length
	  if (len % 8 !== 0) {
	    throw new RangeError('Buffer size must be a multiple of 64-bits')
	  }
	  for (var i = 0; i < len; i += 8) {
	    swap(this, i, i + 7)
	    swap(this, i + 1, i + 6)
	    swap(this, i + 2, i + 5)
	    swap(this, i + 3, i + 4)
	  }
	  return this
	}

	Buffer.prototype.toString = function toString () {
	  var length = this.length | 0
	  if (length === 0) return ''
	  if (arguments.length === 0) return utf8Slice(this, 0, length)
	  return slowToString.apply(this, arguments)
	}

	Buffer.prototype.equals = function equals (b) {
	  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
	  if (this === b) return true
	  return Buffer.compare(this, b) === 0
	}

	Buffer.prototype.inspect = function inspect () {
	  var str = ''
	  var max = exports.INSPECT_MAX_BYTES
	  if (this.length > 0) {
	    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
	    if (this.length > max) str += ' ... '
	  }
	  return '<Buffer ' + str + '>'
	}

	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
	  if (!Buffer.isBuffer(target)) {
	    throw new TypeError('Argument must be a Buffer')
	  }

	  if (start === undefined) {
	    start = 0
	  }
	  if (end === undefined) {
	    end = target ? target.length : 0
	  }
	  if (thisStart === undefined) {
	    thisStart = 0
	  }
	  if (thisEnd === undefined) {
	    thisEnd = this.length
	  }

	  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
	    throw new RangeError('out of range index')
	  }

	  if (thisStart >= thisEnd && start >= end) {
	    return 0
	  }
	  if (thisStart >= thisEnd) {
	    return -1
	  }
	  if (start >= end) {
	    return 1
	  }

	  start >>>= 0
	  end >>>= 0
	  thisStart >>>= 0
	  thisEnd >>>= 0

	  if (this === target) return 0

	  var x = thisEnd - thisStart
	  var y = end - start
	  var len = Math.min(x, y)

	  var thisCopy = this.slice(thisStart, thisEnd)
	  var targetCopy = target.slice(start, end)

	  for (var i = 0; i < len; ++i) {
	    if (thisCopy[i] !== targetCopy[i]) {
	      x = thisCopy[i]
	      y = targetCopy[i]
	      break
	    }
	  }

	  if (x < y) return -1
	  if (y < x) return 1
	  return 0
	}

	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
	  // Empty buffer means no match
	  if (buffer.length === 0) return -1

	  // Normalize byteOffset
	  if (typeof byteOffset === 'string') {
	    encoding = byteOffset
	    byteOffset = 0
	  } else if (byteOffset > 0x7fffffff) {
	    byteOffset = 0x7fffffff
	  } else if (byteOffset < -0x80000000) {
	    byteOffset = -0x80000000
	  }
	  byteOffset = +byteOffset  // Coerce to Number.
	  if (isNaN(byteOffset)) {
	    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
	    byteOffset = dir ? 0 : (buffer.length - 1)
	  }

	  // Normalize byteOffset: negative offsets start from the end of the buffer
	  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
	  if (byteOffset >= buffer.length) {
	    if (dir) return -1
	    else byteOffset = buffer.length - 1
	  } else if (byteOffset < 0) {
	    if (dir) byteOffset = 0
	    else return -1
	  }

	  // Normalize val
	  if (typeof val === 'string') {
	    val = Buffer.from(val, encoding)
	  }

	  // Finally, search either indexOf (if dir is true) or lastIndexOf
	  if (Buffer.isBuffer(val)) {
	    // Special case: looking for empty string/buffer always fails
	    if (val.length === 0) {
	      return -1
	    }
	    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
	  } else if (typeof val === 'number') {
	    val = val & 0xFF // Search for a byte value [0-255]
	    if (Buffer.TYPED_ARRAY_SUPPORT &&
	        typeof Uint8Array.prototype.indexOf === 'function') {
	      if (dir) {
	        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
	      } else {
	        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
	      }
	    }
	    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
	  }

	  throw new TypeError('val must be string, number or Buffer')
	}

	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
	  var indexSize = 1
	  var arrLength = arr.length
	  var valLength = val.length

	  if (encoding !== undefined) {
	    encoding = String(encoding).toLowerCase()
	    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
	        encoding === 'utf16le' || encoding === 'utf-16le') {
	      if (arr.length < 2 || val.length < 2) {
	        return -1
	      }
	      indexSize = 2
	      arrLength /= 2
	      valLength /= 2
	      byteOffset /= 2
	    }
	  }

	  function read (buf, i) {
	    if (indexSize === 1) {
	      return buf[i]
	    } else {
	      return buf.readUInt16BE(i * indexSize)
	    }
	  }

	  var i
	  if (dir) {
	    var foundIndex = -1
	    for (i = byteOffset; i < arrLength; i++) {
	      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
	        if (foundIndex === -1) foundIndex = i
	        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
	      } else {
	        if (foundIndex !== -1) i -= i - foundIndex
	        foundIndex = -1
	      }
	    }
	  } else {
	    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
	    for (i = byteOffset; i >= 0; i--) {
	      var found = true
	      for (var j = 0; j < valLength; j++) {
	        if (read(arr, i + j) !== read(val, j)) {
	          found = false
	          break
	        }
	      }
	      if (found) return i
	    }
	  }

	  return -1
	}

	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
	  return this.indexOf(val, byteOffset, encoding) !== -1
	}

	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}

	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
	  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}

	function hexWrite (buf, string, offset, length) {
	  offset = Number(offset) || 0
	  var remaining = buf.length - offset
	  if (!length) {
	    length = remaining
	  } else {
	    length = Number(length)
	    if (length > remaining) {
	      length = remaining
	    }
	  }

	  // must be an even number of digits
	  var strLen = string.length
	  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

	  if (length > strLen / 2) {
	    length = strLen / 2
	  }
	  for (var i = 0; i < length; ++i) {
	    var parsed = parseInt(string.substr(i * 2, 2), 16)
	    if (isNaN(parsed)) return i
	    buf[offset + i] = parsed
	  }
	  return i
	}

	function utf8Write (buf, string, offset, length) {
	  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}

	function asciiWrite (buf, string, offset, length) {
	  return blitBuffer(asciiToBytes(string), buf, offset, length)
	}

	function latin1Write (buf, string, offset, length) {
	  return asciiWrite(buf, string, offset, length)
	}

	function base64Write (buf, string, offset, length) {
	  return blitBuffer(base64ToBytes(string), buf, offset, length)
	}

	function ucs2Write (buf, string, offset, length) {
	  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}

	Buffer.prototype.write = function write (string, offset, length, encoding) {
	  // Buffer#write(string)
	  if (offset === undefined) {
	    encoding = 'utf8'
	    length = this.length
	    offset = 0
	  // Buffer#write(string, encoding)
	  } else if (length === undefined && typeof offset === 'string') {
	    encoding = offset
	    length = this.length
	    offset = 0
	  // Buffer#write(string, offset[, length][, encoding])
	  } else if (isFinite(offset)) {
	    offset = offset | 0
	    if (isFinite(length)) {
	      length = length | 0
	      if (encoding === undefined) encoding = 'utf8'
	    } else {
	      encoding = length
	      length = undefined
	    }
	  // legacy write(string, encoding, offset, length) - remove in v0.13
	  } else {
	    throw new Error(
	      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
	    )
	  }

	  var remaining = this.length - offset
	  if (length === undefined || length > remaining) length = remaining

	  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
	    throw new RangeError('Attempt to write outside buffer bounds')
	  }

	  if (!encoding) encoding = 'utf8'

	  var loweredCase = false
	  for (;;) {
	    switch (encoding) {
	      case 'hex':
	        return hexWrite(this, string, offset, length)

	      case 'utf8':
	      case 'utf-8':
	        return utf8Write(this, string, offset, length)

	      case 'ascii':
	        return asciiWrite(this, string, offset, length)

	      case 'latin1':
	      case 'binary':
	        return latin1Write(this, string, offset, length)

	      case 'base64':
	        // Warning: maxLength not taken into account in base64Write
	        return base64Write(this, string, offset, length)

	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return ucs2Write(this, string, offset, length)

	      default:
	        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
	        encoding = ('' + encoding).toLowerCase()
	        loweredCase = true
	    }
	  }
	}

	Buffer.prototype.toJSON = function toJSON () {
	  return {
	    type: 'Buffer',
	    data: Array.prototype.slice.call(this._arr || this, 0)
	  }
	}

	function base64Slice (buf, start, end) {
	  if (start === 0 && end === buf.length) {
	    return base64.fromByteArray(buf)
	  } else {
	    return base64.fromByteArray(buf.slice(start, end))
	  }
	}

	function utf8Slice (buf, start, end) {
	  end = Math.min(buf.length, end)
	  var res = []

	  var i = start
	  while (i < end) {
	    var firstByte = buf[i]
	    var codePoint = null
	    var bytesPerSequence = (firstByte > 0xEF) ? 4
	      : (firstByte > 0xDF) ? 3
	      : (firstByte > 0xBF) ? 2
	      : 1

	    if (i + bytesPerSequence <= end) {
	      var secondByte, thirdByte, fourthByte, tempCodePoint

	      switch (bytesPerSequence) {
	        case 1:
	          if (firstByte < 0x80) {
	            codePoint = firstByte
	          }
	          break
	        case 2:
	          secondByte = buf[i + 1]
	          if ((secondByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
	            if (tempCodePoint > 0x7F) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 3:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
	            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
	              codePoint = tempCodePoint
	            }
	          }
	          break
	        case 4:
	          secondByte = buf[i + 1]
	          thirdByte = buf[i + 2]
	          fourthByte = buf[i + 3]
	          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
	            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
	            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
	              codePoint = tempCodePoint
	            }
	          }
	      }
	    }

	    if (codePoint === null) {
	      // we did not generate a valid codePoint so insert a
	      // replacement char (U+FFFD) and advance only 1 byte
	      codePoint = 0xFFFD
	      bytesPerSequence = 1
	    } else if (codePoint > 0xFFFF) {
	      // encode to utf16 (surrogate pair dance)
	      codePoint -= 0x10000
	      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
	      codePoint = 0xDC00 | codePoint & 0x3FF
	    }

	    res.push(codePoint)
	    i += bytesPerSequence
	  }

	  return decodeCodePointsArray(res)
	}

	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000

	function decodeCodePointsArray (codePoints) {
	  var len = codePoints.length
	  if (len <= MAX_ARGUMENTS_LENGTH) {
	    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
	  }

	  // Decode in chunks to avoid "call stack size exceeded".
	  var res = ''
	  var i = 0
	  while (i < len) {
	    res += String.fromCharCode.apply(
	      String,
	      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
	    )
	  }
	  return res
	}

	function asciiSlice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i] & 0x7F)
	  }
	  return ret
	}

	function latin1Slice (buf, start, end) {
	  var ret = ''
	  end = Math.min(buf.length, end)

	  for (var i = start; i < end; ++i) {
	    ret += String.fromCharCode(buf[i])
	  }
	  return ret
	}

	function hexSlice (buf, start, end) {
	  var len = buf.length

	  if (!start || start < 0) start = 0
	  if (!end || end < 0 || end > len) end = len

	  var out = ''
	  for (var i = start; i < end; ++i) {
	    out += toHex(buf[i])
	  }
	  return out
	}

	function utf16leSlice (buf, start, end) {
	  var bytes = buf.slice(start, end)
	  var res = ''
	  for (var i = 0; i < bytes.length; i += 2) {
	    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
	  }
	  return res
	}

	Buffer.prototype.slice = function slice (start, end) {
	  var len = this.length
	  start = ~~start
	  end = end === undefined ? len : ~~end

	  if (start < 0) {
	    start += len
	    if (start < 0) start = 0
	  } else if (start > len) {
	    start = len
	  }

	  if (end < 0) {
	    end += len
	    if (end < 0) end = 0
	  } else if (end > len) {
	    end = len
	  }

	  if (end < start) end = start

	  var newBuf
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    newBuf = this.subarray(start, end)
	    newBuf.__proto__ = Buffer.prototype
	  } else {
	    var sliceLen = end - start
	    newBuf = new Buffer(sliceLen, undefined)
	    for (var i = 0; i < sliceLen; ++i) {
	      newBuf[i] = this[i + start]
	    }
	  }

	  return newBuf
	}

	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
	  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
	  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}

	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }

	  return val
	}

	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    checkOffset(offset, byteLength, this.length)
	  }

	  var val = this[offset + --byteLength]
	  var mul = 1
	  while (byteLength > 0 && (mul *= 0x100)) {
	    val += this[offset + --byteLength] * mul
	  }

	  return val
	}

	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  return this[offset]
	}

	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return this[offset] | (this[offset + 1] << 8)
	}

	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  return (this[offset] << 8) | this[offset + 1]
	}

	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return ((this[offset]) |
	      (this[offset + 1] << 8) |
	      (this[offset + 2] << 16)) +
	      (this[offset + 3] * 0x1000000)
	}

	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] * 0x1000000) +
	    ((this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    this[offset + 3])
	}

	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var val = this[offset]
	  var mul = 1
	  var i = 0
	  while (++i < byteLength && (mul *= 0x100)) {
	    val += this[offset + i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) checkOffset(offset, byteLength, this.length)

	  var i = byteLength
	  var mul = 1
	  var val = this[offset + --i]
	  while (i > 0 && (mul *= 0x100)) {
	    val += this[offset + --i] * mul
	  }
	  mul *= 0x80

	  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

	  return val
	}

	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 1, this.length)
	  if (!(this[offset] & 0x80)) return (this[offset])
	  return ((0xff - this[offset] + 1) * -1)
	}

	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset] | (this[offset + 1] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 2, this.length)
	  var val = this[offset + 1] | (this[offset] << 8)
	  return (val & 0x8000) ? val | 0xFFFF0000 : val
	}

	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset]) |
	    (this[offset + 1] << 8) |
	    (this[offset + 2] << 16) |
	    (this[offset + 3] << 24)
	}

	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)

	  return (this[offset] << 24) |
	    (this[offset + 1] << 16) |
	    (this[offset + 2] << 8) |
	    (this[offset + 3])
	}

	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, true, 23, 4)
	}

	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 4, this.length)
	  return ieee754.read(this, offset, false, 23, 4)
	}

	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, true, 52, 8)
	}

	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
	  if (!noAssert) checkOffset(offset, 8, this.length)
	  return ieee754.read(this, offset, false, 52, 8)
	}

	function checkInt (buf, value, offset, ext, max, min) {
	  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
	  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}

	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var mul = 1
	  var i = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  byteLength = byteLength | 0
	  if (!noAssert) {
	    var maxBytes = Math.pow(2, 8 * byteLength) - 1
	    checkInt(this, value, offset, byteLength, maxBytes, 0)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    this[offset + i] = (value / mul) & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	function objectWriteUInt16 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
	    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
	      (littleEndian ? i : 1 - i) * 8
	  }
	}

	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	function objectWriteUInt32 (buf, value, offset, littleEndian) {
	  if (value < 0) value = 0xffffffff + value + 1
	  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
	    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
	  }
	}

	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset + 3] = (value >>> 24)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 1] = (value >>> 8)
	    this[offset] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = 0
	  var mul = 1
	  var sub = 0
	  this[offset] = value & 0xFF
	  while (++i < byteLength && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) {
	    var limit = Math.pow(2, 8 * byteLength - 1)

	    checkInt(this, value, offset, byteLength, limit - 1, -limit)
	  }

	  var i = byteLength - 1
	  var mul = 1
	  var sub = 0
	  this[offset + i] = value & 0xFF
	  while (--i >= 0 && (mul *= 0x100)) {
	    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
	      sub = 1
	    }
	    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
	  }

	  return offset + byteLength
	}

	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
	  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
	  if (value < 0) value = 0xff + value + 1
	  this[offset] = (value & 0xff)
	  return offset + 1
	}

	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	  } else {
	    objectWriteUInt16(this, value, offset, true)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 8)
	    this[offset + 1] = (value & 0xff)
	  } else {
	    objectWriteUInt16(this, value, offset, false)
	  }
	  return offset + 2
	}

	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value & 0xff)
	    this[offset + 1] = (value >>> 8)
	    this[offset + 2] = (value >>> 16)
	    this[offset + 3] = (value >>> 24)
	  } else {
	    objectWriteUInt32(this, value, offset, true)
	  }
	  return offset + 4
	}

	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
	  value = +value
	  offset = offset | 0
	  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
	  if (value < 0) value = 0xffffffff + value + 1
	  if (Buffer.TYPED_ARRAY_SUPPORT) {
	    this[offset] = (value >>> 24)
	    this[offset + 1] = (value >>> 16)
	    this[offset + 2] = (value >>> 8)
	    this[offset + 3] = (value & 0xff)
	  } else {
	    objectWriteUInt32(this, value, offset, false)
	  }
	  return offset + 4
	}

	function checkIEEE754 (buf, value, offset, ext, max, min) {
	  if (offset + ext > buf.length) throw new RangeError('Index out of range')
	  if (offset < 0) throw new RangeError('Index out of range')
	}

	function writeFloat (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 23, 4)
	  return offset + 4
	}

	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
	  return writeFloat(this, value, offset, false, noAssert)
	}

	function writeDouble (buf, value, offset, littleEndian, noAssert) {
	  if (!noAssert) {
	    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
	  }
	  ieee754.write(buf, value, offset, littleEndian, 52, 8)
	  return offset + 8
	}

	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, true, noAssert)
	}

	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
	  return writeDouble(this, value, offset, false, noAssert)
	}

	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
	  if (!start) start = 0
	  if (!end && end !== 0) end = this.length
	  if (targetStart >= target.length) targetStart = target.length
	  if (!targetStart) targetStart = 0
	  if (end > 0 && end < start) end = start

	  // Copy 0 bytes; we're done
	  if (end === start) return 0
	  if (target.length === 0 || this.length === 0) return 0

	  // Fatal error conditions
	  if (targetStart < 0) {
	    throw new RangeError('targetStart out of bounds')
	  }
	  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
	  if (end < 0) throw new RangeError('sourceEnd out of bounds')

	  // Are we oob?
	  if (end > this.length) end = this.length
	  if (target.length - targetStart < end - start) {
	    end = target.length - targetStart + start
	  }

	  var len = end - start
	  var i

	  if (this === target && start < targetStart && targetStart < end) {
	    // descending copy from end
	    for (i = len - 1; i >= 0; --i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
	    // ascending copy from start
	    for (i = 0; i < len; ++i) {
	      target[i + targetStart] = this[i + start]
	    }
	  } else {
	    Uint8Array.prototype.set.call(
	      target,
	      this.subarray(start, start + len),
	      targetStart
	    )
	  }

	  return len
	}

	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
	  // Handle string cases:
	  if (typeof val === 'string') {
	    if (typeof start === 'string') {
	      encoding = start
	      start = 0
	      end = this.length
	    } else if (typeof end === 'string') {
	      encoding = end
	      end = this.length
	    }
	    if (val.length === 1) {
	      var code = val.charCodeAt(0)
	      if (code < 256) {
	        val = code
	      }
	    }
	    if (encoding !== undefined && typeof encoding !== 'string') {
	      throw new TypeError('encoding must be a string')
	    }
	    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
	      throw new TypeError('Unknown encoding: ' + encoding)
	    }
	  } else if (typeof val === 'number') {
	    val = val & 255
	  }

	  // Invalid ranges are not set to a default, so can range check early.
	  if (start < 0 || this.length < start || this.length < end) {
	    throw new RangeError('Out of range index')
	  }

	  if (end <= start) {
	    return this
	  }

	  start = start >>> 0
	  end = end === undefined ? this.length : end >>> 0

	  if (!val) val = 0

	  var i
	  if (typeof val === 'number') {
	    for (i = start; i < end; ++i) {
	      this[i] = val
	    }
	  } else {
	    var bytes = Buffer.isBuffer(val)
	      ? val
	      : utf8ToBytes(new Buffer(val, encoding).toString())
	    var len = bytes.length
	    for (i = 0; i < end - start; ++i) {
	      this[i + start] = bytes[i % len]
	    }
	  }

	  return this
	}

	// HELPER FUNCTIONS
	// ================

	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

	function base64clean (str) {
	  // Node strips out invalid characters like \n and \t from the string, base64-js does not
	  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
	  // Node converts strings with length < 2 to ''
	  if (str.length < 2) return ''
	  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
	  while (str.length % 4 !== 0) {
	    str = str + '='
	  }
	  return str
	}

	function stringtrim (str) {
	  if (str.trim) return str.trim()
	  return str.replace(/^\s+|\s+$/g, '')
	}

	function toHex (n) {
	  if (n < 16) return '0' + n.toString(16)
	  return n.toString(16)
	}

	function utf8ToBytes (string, units) {
	  units = units || Infinity
	  var codePoint
	  var length = string.length
	  var leadSurrogate = null
	  var bytes = []

	  for (var i = 0; i < length; ++i) {
	    codePoint = string.charCodeAt(i)

	    // is surrogate component
	    if (codePoint > 0xD7FF && codePoint < 0xE000) {
	      // last char was a lead
	      if (!leadSurrogate) {
	        // no lead yet
	        if (codePoint > 0xDBFF) {
	          // unexpected trail
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        } else if (i + 1 === length) {
	          // unpaired lead
	          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	          continue
	        }

	        // valid lead
	        leadSurrogate = codePoint

	        continue
	      }

	      // 2 leads in a row
	      if (codePoint < 0xDC00) {
	        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	        leadSurrogate = codePoint
	        continue
	      }

	      // valid surrogate pair
	      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
	    } else if (leadSurrogate) {
	      // valid bmp char, but last char was a lead
	      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
	    }

	    leadSurrogate = null

	    // encode utf8
	    if (codePoint < 0x80) {
	      if ((units -= 1) < 0) break
	      bytes.push(codePoint)
	    } else if (codePoint < 0x800) {
	      if ((units -= 2) < 0) break
	      bytes.push(
	        codePoint >> 0x6 | 0xC0,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x10000) {
	      if ((units -= 3) < 0) break
	      bytes.push(
	        codePoint >> 0xC | 0xE0,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else if (codePoint < 0x110000) {
	      if ((units -= 4) < 0) break
	      bytes.push(
	        codePoint >> 0x12 | 0xF0,
	        codePoint >> 0xC & 0x3F | 0x80,
	        codePoint >> 0x6 & 0x3F | 0x80,
	        codePoint & 0x3F | 0x80
	      )
	    } else {
	      throw new Error('Invalid code point')
	    }
	  }

	  return bytes
	}

	function asciiToBytes (str) {
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    // Node's code seems to be doing this and not & 0x7F..
	    byteArray.push(str.charCodeAt(i) & 0xFF)
	  }
	  return byteArray
	}

	function utf16leToBytes (str, units) {
	  var c, hi, lo
	  var byteArray = []
	  for (var i = 0; i < str.length; ++i) {
	    if ((units -= 2) < 0) break

	    c = str.charCodeAt(i)
	    hi = c >> 8
	    lo = c % 256
	    byteArray.push(lo)
	    byteArray.push(hi)
	  }

	  return byteArray
	}

	function base64ToBytes (str) {
	  return base64.toByteArray(base64clean(str))
	}

	function blitBuffer (src, dst, offset, length) {
	  for (var i = 0; i < length; ++i) {
	    if ((i + offset >= dst.length) || (i >= src.length)) break
	    dst[i + offset] = src[i]
	  }
	  return i
	}

	function isnan (val) {
	  return val !== val // eslint-disable-line no-self-compare
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Stream;

	var EE = __webpack_require__(11).EventEmitter;
	var inherits = __webpack_require__(7);

	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(274);
	Stream.Writable = __webpack_require__(275);
	Stream.Duplex = __webpack_require__(271);
	Stream.Transform = __webpack_require__(71);
	Stream.PassThrough = __webpack_require__(273);

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};


/***/ },
/* 4 */
/***/ function(module, exports) {

	'use strict';

	// http://www.w3.org/TR/SVG/intro.html#Definitions
	exports.elemsGroups = {
	    animation: ['animate', 'animateColor', 'animateMotion', 'animateTransform', 'set'],
	    descriptive: ['desc', 'metadata', 'title'],
	    shape: ['circle', 'ellipse', 'line', 'path', 'polygon', 'polyline', 'rect'],
	    structural: ['defs', 'g', 'svg', 'symbol', 'use'],
	    paintServer: ['solidColor', 'linearGradient', 'radialGradient', 'meshGradient', 'pattern', 'hatch'],
	    nonRendering: ['linearGradient', 'radialGradient', 'pattern', 'clipPath', 'mask', 'marker', 'symbol', 'filter', 'solidColor'],
	    container: ['a', 'defs', 'g', 'marker', 'mask', 'missing-glyph', 'pattern', 'svg', 'switch', 'symbol', 'foreignObject'],
	    textContent: ['altGlyph', 'altGlyphDef', 'altGlyphItem', 'glyph', 'glyphRef', 'textPath', 'text', 'tref', 'tspan'],
	    textContentChild: ['altGlyph', 'textPath', 'tref', 'tspan'],
	    lightSource: ['feDiffuseLighting', 'feSpecularLighting', 'feDistantLight', 'fePointLight', 'feSpotLight'],
	    filterPrimitive: ['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feFlood', 'feGaussianBlur', 'feImage', 'feMerge', 'feMorphology', 'feOffset', 'feSpecularLighting', 'feTile', 'feTurbulence']
	};

	exports.pathElems = ['path', 'glyph', 'missing-glyph'];

	// http://www.w3.org/TR/SVG/intro.html#Definitions
	exports.attrsGroups = {
	    animationAddition: ['additive', 'accumulate'],
	    animationAttributeTarget: ['attributeType', 'attributeName'],
	    animationEvent: ['onbegin', 'onend', 'onrepeat', 'onload'],
	    animationTiming: ['begin', 'dur', 'end', 'min', 'max', 'restart', 'repeatCount', 'repeatDur', 'fill'],
	    animationValue: ['calcMode', 'values', 'keyTimes', 'keySplines', 'from', 'to', 'by'],
	    conditionalProcessing: ['requiredFeatures', 'requiredExtensions', 'systemLanguage'],
	    core: ['id', 'tabindex', 'xml:base', 'xml:lang', 'xml:space'],
	    graphicalEvent: ['onfocusin', 'onfocusout', 'onactivate', 'onclick', 'onmousedown', 'onmouseup', 'onmouseover', 'onmousemove', 'onmouseout', 'onload'],
	    presentation: [
	        'alignment-baseline',
	        'baseline-shift',
	        'buffered-rendering',
	        'clip',
	        'clip-path',
	        'clip-rule',
	        'color',
	        'color-interpolation',
	        'color-interpolation-filters',
	        'color-profile',
	        'color-rendering',
	        'cursor',
	        'direction',
	        'display',
	        'dominant-baseline',
	        'enable-background',
	        'fill',
	        'fill-opacity',
	        'fill-rule',
	        'filter',
	        'flood-color',
	        'flood-opacity',
	        'font-family',
	        'font-size',
	        'font-size-adjust',
	        'font-stretch',
	        'font-style',
	        'font-variant',
	        'font-weight',
	        'glyph-orientation-horizontal',
	        'glyph-orientation-vertical',
	        'image-rendering',
	        'kerning',
	        'letter-spacing',
	        'lighting-color',
	        'marker-end',
	        'marker-mid',
	        'marker-start',
	        'mask',
	        'opacity',
	        'overflow',
	        'pointer-events',
	        'shape-rendering',
	        'solid-color',
	        'solid-opacity',
	        'stop-color',
	        'stop-opacity',
	        'stroke',
	        'stroke-dasharray',
	        'stroke-dashoffset',
	        'stroke-linecap',
	        'stroke-linejoin',
	        'stroke-miterlimit',
	        'stroke-opacity',
	        'stroke-width',
	        'paint-order',
	        'text-anchor',
	        'text-decoration',
	        'text-overflow',
	        'white-space',
	        'text-rendering',
	        'unicode-bidi',
	        'vector-effect',
	        'viewport-fill',
	        'viewport-fill-opacity',
	        'visibility',
	        'white-space',
	        'word-spacing',
	        'writing-mode'
	    ],
	    xlink: ['xlink:href', 'xlink:show', 'xlink:actuate', 'xlink:type', 'xlink:role', 'xlink:arcrole', 'xlink:title'],
	    documentEvent: ['onunload', 'onabort', 'onerror', 'onresize', 'onscroll', 'onzoom'],
	    filterPrimitive: ['x', 'y', 'width', 'height', 'result'],
	    transferFunction: ['type', 'tableValues', 'slope', 'intercept', 'amplitude', 'exponent', 'offset']
	};

	exports.attrsGroupsDefaults = {
	    core: {'xml:space': 'preserve'},
	    filterPrimitive: {x: '0', y: '0', width: '100%', height: '100%'},
	    presentation: {
	        clip: 'auto',
	        'clip-path': 'none',
	        'clip-rule': 'nonzero',
	        mask: 'none',
	        opacity: '1',
	        'solid-color': '#000',
	        'solid-opacity': '1',
	        'stop-color': '#000',
	        'stop-opacity': '1',
	        'fill-opacity': '1',
	        'fill-rule': 'nonzero',
	        fill: '#000',
	        stroke: 'none',
	        'stroke-width': '1',
	        'stroke-linecap': 'butt',
	        'stroke-linejoin': 'miter',
	        'stroke-miterlimit': '4',
	        'stroke-dasharray': 'none',
	        'stroke-dashoffset': '0',
	        'stroke-opacity': '1',
	        'paint-order': 'normal',
	        'vector-effect': 'none',
	        'viewport-fill': 'none',
	        'viewport-fill-opacity': '1',
	        display: 'inline',
	        visibility: 'visible',
	        'marker-start': 'none',
	        'marker-mid': 'none',
	        'marker-end': 'none',
	        'color-interpolation': 'sRGB',
	        'color-interpolation-filters': 'linearRGB',
	        'color-rendering': 'auto',
	        'shape-rendering': 'auto',
	        'text-rendering': 'auto',
	        'image-rendering': 'auto',
	        'buffered-rendering': 'auto',
	        'font-style': 'normal',
	        'font-variant': 'normal',
	        'font-weight': 'normal',
	        'font-stretch': 'normal',
	        'font-size': 'medium',
	        'font-size-adjust': 'none',
	        kerning: 'auto',
	        'letter-spacing': 'normal',
	        'word-spacing': 'normal',
	        'text-decoration': 'none',
	        'text-anchor': 'start',
	        'text-overflow': 'clip',
	        'writing-mode': 'lr-tb',
	        'glyph-orientation-vertical': 'auto',
	        'glyph-orientation-horizontal': '0deg',
	        direction: 'ltr',
	        'unicode-bidi': 'normal',
	        'dominant-baseline': 'auto',
	        'alignment-baseline': 'baseline',
	        'baseline-shift': 'baseline'
	    },
	    transferFunction: {slope: '1', intercept: '0', amplitude: '1', exponent: '1', offset: '0'}
	};

	// http://www.w3.org/TR/SVG/eltindex.html
	exports.elems = {
	    a: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'target'
	        ],
	        defaults: {
	            target: '_self'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    altGlyph: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'x',
	            'y',
	            'dx',
	            'dy',
	            'glyphRef',
	            'format',
	            'rotate'
	        ]
	    },
	    altGlyphDef: {
	        attrsGroups: [
	            'core'
	        ],
	        content: [
	            'glyphRef'
	        ]
	    },
	    altGlyphItem: {
	        attrsGroups: [
	            'core'
	        ],
	        content: [
	            'glyphRef',
	            'altGlyphItem'
	        ]
	    },
	    animate: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'animationAddition',
	            'animationAttributeTarget',
	            'animationEvent',
	            'animationTiming',
	            'animationValue',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'externalResourcesRequired'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    animateColor: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'animationEvent',
	            'xlink',
	            'animationAttributeTarget',
	            'animationTiming',
	            'animationValue',
	            'animationAddition',
	            'presentation'
	        ],
	        attrs: [
	            'externalResourcesRequired'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    animateMotion: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'animationEvent',
	            'xlink',
	            'animationTiming',
	            'animationValue',
	            'animationAddition'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'path',
	            'keyPoints',
	            'rotate',
	            'origin'
	        ],
	        defaults: {
	            'rotate': '0'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'mpath'
	        ]
	    },
	    animateTransform: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'animationEvent',
	            'xlink',
	            'animationAttributeTarget',
	            'animationTiming',
	            'animationValue',
	            'animationAddition'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'type'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    circle: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'cx',
	            'cy',
	            'r'
	        ],
	        defaults: {
	            cx: '0',
	            cy: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    clipPath: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'clipPathUnits'
	        ],
	        defaults: {
	            clipPathUnits: 'userSpaceOnUse'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape'
	        ],
	        content: [
	            'text',
	            'use'
	        ]
	    },
	    'color-profile': {
	        attrsGroups: [
	            'core',
	            'xlink'
	        ],
	        attrs: [
	            'local',
	            'name',
	            'rendering-intent'
	        ],
	        defaults: {
	            name: 'sRGB',
	            'rendering-intent': 'auto'
	        },
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    cursor: {
	        attrsGroups: [
	            'core',
	            'conditionalProcessing',
	            'xlink'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'x',
	            'y'
	        ],
	        defaults: {
	            x: '0',
	            y: '0'
	        },
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    defs: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    desc: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ]
	    },
	    ellipse: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'cx',
	            'cy',
	            'rx',
	            'ry'
	        ],
	        defaults: {
	            cx: '0',
	            cy: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    feBlend: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            // TODO: in - 'If no value is provided and this is the first filter primitive,
	            // then this filter primitive will use SourceGraphic as its input'
	            'in',
	            'in2',
	            'mode'
	        ],
	        defaults: {
	            mode: 'normal'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feColorMatrix: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'type',
	            'values'
	        ],
	        defaults: {
	            type: 'matrix'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feComponentTransfer: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in'
	        ],
	        content: [
	            'feFuncA',
	            'feFuncB',
	            'feFuncG',
	            'feFuncR'
	        ]
	    },
	    feComposite: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'in2',
	            'operator',
	            'k1',
	            'k2',
	            'k3',
	            'k4'
	        ],
	        defaults: {
	            operator: 'over',
	            k1: '0',
	            k2: '0',
	            k3: '0',
	            k4: '0'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feConvolveMatrix: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'order',
	            'kernelMatrix',
	            // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
	            // with the exception that if the sum is zero, then the divisor is set to 1'
	            'divisor',
	            'bias',
	            // TODO: targetX - 'By default, the convolution matrix is centered in X over each
	            // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
	            'targetX',
	            'targetY',
	            'edgeMode',
	            // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
	            // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
	            'kernelUnitLength',
	            'preserveAlpha'
	        ],
	        defaults: {
	            order: '3',
	            bias: '0',
	            edgeMode: 'duplicate',
	            preserveAlpha: 'false'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feDiffuseLighting: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'surfaceScale',
	            'diffuseConstant',
	            'kernelUnitLength'
	        ],
	        defaults: {
	            surfaceScale: '1',
	            diffuseConstant: '1'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            // TODO: 'exactly one light source element, in any order'
	            'feDistantLight',
	            'fePointLight',
	            'feSpotLight'
	        ]
	    },
	    feDisplacementMap: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'in2',
	            'scale',
	            'xChannelSelector',
	            'yChannelSelector'
	        ],
	        defaults: {
	            scale: '0',
	            xChannelSelector: 'A',
	            yChannelSelector: 'A'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feDistantLight: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'azimuth',
	            'elevation'
	        ],
	        defaults: {
	            azimuth: '0',
	            elevation: '0'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feFlood: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ],
	        content: [
	            'animate',
	            'animateColor',
	            'set'
	        ]
	    },
	    feFuncA: {
	        attrsGroups: [
	            'core',
	            'transferFunction'
	        ],
	        content: [
	            'set',
	            'animate'
	        ]
	    },
	    feFuncB: {
	        attrsGroups: [
	            'core',
	            'transferFunction'
	        ],
	        content: [
	            'set',
	            'animate'
	        ]
	    },
	    feFuncG: {
	        attrsGroups: [
	            'core',
	            'transferFunction'
	        ],
	        content: [
	            'set',
	            'animate'
	        ]
	    },
	    feFuncR: {
	        attrsGroups: [
	            'core',
	            'transferFunction'
	        ],
	        content: [
	            'set',
	            'animate'
	        ]
	    },
	    feGaussianBlur: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'stdDeviation'
	        ],
	        defaults: {
	            stdDeviation: '0'
	        },
	        content: [
	            'set',
	            'animate'
	        ]
	    },
	    feImage: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'preserveAspectRatio',
	            'xlink:href'
	        ],
	        defaults: {
	            preserveAspectRatio: 'xMidYMid meet'
	        },
	        content: [
	            'animate',
	            'animateTransform',
	            'set'
	        ]
	    },
	    feMerge: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ],
	        content: [
	            'feMergeNode'
	        ]
	    },
	    feMergeNode: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'in'
	        ],
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feMorphology: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'operator',
	            'radius'
	        ],
	        defaults: {
	            operator: 'erode',
	            radius: '0'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feOffset: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'dx',
	            'dy'
	        ],
	        defaults: {
	            dx: '0',
	            dy: '0'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    fePointLight: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'x',
	            'y',
	            'z'
	        ],
	        defaults: {
	            x: '0',
	            y: '0',
	            z: '0'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feSpecularLighting: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in',
	            'surfaceScale',
	            'specularConstant',
	            'specularExponent',
	            'kernelUnitLength'
	        ],
	        defaults: {
	            surfaceScale: '1',
	            specularConstant: '1',
	            specularExponent: '1'
	        },
	        contentGroups: [
	            'descriptive',
	            // TODO: exactly one 'light source element'
	            'lightSource'
	        ]
	    },
	    feSpotLight: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'x',
	            'y',
	            'z',
	            'pointsAtX',
	            'pointsAtY',
	            'pointsAtZ',
	            'specularExponent',
	            'limitingConeAngle'
	        ],
	        defaults: {
	            x: '0',
	            y: '0',
	            z: '0',
	            pointsAtX: '0',
	            pointsAtY: '0',
	            pointsAtZ: '0',
	            specularExponent: '1'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feTile: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'in'
	        ],
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    feTurbulence: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'filterPrimitive'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'baseFrequency',
	            'numOctaves',
	            'seed',
	            'stitchTiles',
	            'type'
	        ],
	        defaults: {
	            baseFrequency: '0',
	            numOctaves: '1',
	            seed: '0',
	            stitchTiles: 'noStitch',
	            type: 'turbulence'
	        },
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    filter: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'x',
	            'y',
	            'width',
	            'height',
	            'filterRes',
	            'filterUnits',
	            'primitiveUnits',
	            'xlink:href'
	        ],
	        defaults: {
	            primitiveUnits: 'userSpaceOnUse',
	            x: '-10%',
	            y: '-10%',
	            width: '120%',
	            height: '120%'
	        },
	        contentGroups: [
	            'descriptive',
	            'filterPrimitive'
	        ],
	        content: [
	            'animate',
	            'set'
	        ]
	    },
	    font: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'horiz-origin-x',
	            'horiz-origin-y',
	            'horiz-adv-x',
	            'vert-origin-x',
	            'vert-origin-y',
	            'vert-adv-y'
	        ],
	        defaults: {
	            'horiz-origin-x': '0',
	            'horiz-origin-y': '0'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'font-face',
	            'glyph',
	            'hkern',
	            'missing-glyph',
	            'vkern'
	        ]
	    },
	    'font-face': {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'font-family',
	            'font-style',
	            'font-variant',
	            'font-weight',
	            'font-stretch',
	            'font-size',
	            'unicode-range',
	            'units-per-em',
	            'panose-1',
	            'stemv',
	            'stemh',
	            'slope',
	            'cap-height',
	            'x-height',
	            'accent-height',
	            'ascent',
	            'descent',
	            'widths',
	            'bbox',
	            'ideographic',
	            'alphabetic',
	            'mathematical',
	            'hanging',
	            'v-ideographic',
	            'v-alphabetic',
	            'v-mathematical',
	            'v-hanging',
	            'underline-position',
	            'underline-thickness',
	            'strikethrough-position',
	            'strikethrough-thickness',
	            'overline-position',
	            'overline-thickness'
	        ],
	        defaults: {
	            'font-style': 'all',
	            'font-variant': 'normal',
	            'font-weight': 'all',
	            'font-stretch': 'normal',
	            'unicode-range': 'U+0-10FFFF',
	            'units-per-em': '1000',
	            'panose-1': '0 0 0 0 0 0 0 0 0 0',
	            'slope': '0'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            // TODO: "at most one 'font-face-src' element"
	            'font-face-src'
	        ]
	    },
	    // TODO: empty content
	    'font-face-format': {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'string'
	        ]
	    },
	    'font-face-name': {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'name'
	        ]
	    },
	    'font-face-src': {
	        attrsGroups: [
	            'core'
	        ],
	        content: [
	            'font-face-name',
	            'font-face-uri'
	        ]
	    },
	    'font-face-uri': {
	        attrsGroups: [
	            'core',
	            'xlink'
	        ],
	        attrs: [
	            'xlink:href'
	        ],
	        content: [
	            'font-face-format'
	        ]
	    },
	    foreignObject: {
	        attrsGroups: [
	            'core',
	            'conditionalProcessing',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'x',
	            'y',
	            'width',
	            'height'
	        ],
	        defaults: {
	            x: 0,
	            y: 0
	        }
	    },
	    g: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    glyph: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'd',
	            'horiz-adv-x',
	            'vert-origin-x',
	            'vert-origin-y',
	            'vert-adv-y',
	            'unicode',
	            'glyph-name',
	            'orientation',
	            'arabic-form',
	            'lang'
	        ],
	        defaults: {
	            'arabic-form': 'initial'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ],
	    },
	    glyphRef: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'd',
	            'horiz-adv-x',
	            'vert-origin-x',
	            'vert-origin-y',
	            'vert-adv-y'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    hatch: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'x',
	            'y',
	            'pitch',
	            'rotate',
	            'hatchUnits',
	            'hatchContentUnits',
	            'transform'
	        ],
	        defaults: {
	            hatchUnits: 'objectBoundingBox',
	            hatchContentUnits: 'userSpaceOnUse',
	            x: '0',
	            y: '0',
	            pitch: '0',
	            rotate: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ],
	        content: [
	            'hatchPath'
	        ]
	    },
	    hatchPath: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'd',
	            'offset'
	        ],
	        defaults: {
	            offset: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    hkern: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'u1',
	            'g1',
	            'u2',
	            'g2',
	            'k'
	        ]
	    },
	    image: {
	        attrsGroups: [
	            'core',
	            'conditionalProcessing',
	            'graphicalEvent',
	            'xlink',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'preserveAspectRatio',
	            'transform',
	            'x',
	            'y',
	            'width',
	            'height',
	            'xlink:href'
	        ],
	        defaults: {
	            x: '0',
	            y: '0',
	            preserveAspectRatio: 'xMidYMid meet'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    line: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'x1',
	            'y1',
	            'x2',
	            'y2'
	        ],
	        defaults: {
	            x1: '0',
	            y1: '0',
	            x2: '0',
	            y2: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    linearGradient: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'x1',
	            'y1',
	            'x2',
	            'y2',
	            'gradientUnits',
	            'gradientTransform',
	            'spreadMethod',
	            'xlink:href'
	        ],
	        defaults: {
	            x1: '0',
	            y1: '0',
	            x2: '100%',
	            y2: '0',
	            spreadMethod: 'pad'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'animate',
	            'animateTransform',
	            'set',
	            'stop'
	        ]
	    },
	    marker: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'viewBox',
	            'preserveAspectRatio',
	            'refX',
	            'refY',
	            'markerUnits',
	            'markerWidth',
	            'markerHeight',
	            'orient'
	        ],
	        defaults: {
	            markerUnits: 'strokeWidth',
	            refX: '0',
	            refY: '0',
	            markerWidth: '3',
	            markerHeight: '3'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    mask: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'x',
	            'y',
	            'width',
	            'height',
	            'maskUnits',
	            'maskContentUnits'
	        ],
	        defaults: {
	            maskUnits: 'objectBoundingBox',
	            maskContentUnits: 'userSpaceOnUse',
	            x: '-10%',
	            y: '-10%',
	            width: '120%',
	            height: '120%'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    metadata: {
	        attrsGroups: [
	            'core'
	        ]
	    },
	    'missing-glyph': {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'd',
	            'horiz-adv-x',
	            'vert-origin-x',
	            'vert-origin-y',
	            'vert-adv-y'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    mpath: {
	        attrsGroups: [
	            'core',
	            'xlink'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'xlink:href'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    path: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'd',
	            'pathLength'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    pattern: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'viewBox',
	            'preserveAspectRatio',
	            'x',
	            'y',
	            'width',
	            'height',
	            'patternUnits',
	            'patternContentUnits',
	            'patternTransform',
	            'xlink:href'
	        ],
	        defaults: {
	            patternUnits: 'objectBoundingBox',
	            patternContentUnits: 'userSpaceOnUse',
	            x: '0',
	            y: '0',
	            width: '0',
	            height: '0',
	            preserveAspectRatio: 'xMidYMid meet'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'paintServer',
	            'shape',
	            'structural'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    polygon: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'points'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    polyline: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'points'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    radialGradient: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'cx',
	            'cy',
	            'r',
	            'fx',
	            'fy',
	            'fr',
	            'gradientUnits',
	            'gradientTransform',
	            'spreadMethod',
	            'xlink:href'
	        ],
	        defaults: {
	            gradientUnits: 'objectBoundingBox',
	            cx: '50%',
	            cy: '50%',
	            r: '50%'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'animate',
	            'animateTransform',
	            'set',
	            'stop'
	        ]
	    },
	    meshGradient: {
	        attrsGroups: [
	            'core',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'x',
	            'y',
	            'gradientUnits',
	            'transform'
	        ],
	        contentGroups: [
	            'descriptive',
	            'paintServer',
	            'animation',
	        ],
	        content: [
	            'meshRow'
	        ]
	    },
	    meshRow: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ],
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'meshPatch'
	        ]
	    },
	    meshPatch: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ],
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'stop'
	        ]
	    },
	    rect: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'x',
	            'y',
	            'width',
	            'height',
	            'rx',
	            'ry'
	        ],
	        defaults: {
	            x: '0',
	            y: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    script: {
	        attrsGroups: [
	            'core',
	            'xlink'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'type',
	            'xlink:href'
	        ]
	    },
	    set: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'animation',
	            'xlink',
	            'animationAttributeTarget',
	            'animationTiming',
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'to'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    solidColor: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ],
	        contentGroups: [
	            'paintServer'
	        ]
	    },
	    stop: {
	        attrsGroups: [
	            'core',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'offset',
	            'path'
	        ],
	        contentGroups: [
	            'animate',
	            'animateColor',
	            'set'
	        ]
	    },
	    style: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'type',
	            'media',
	            'title'
	        ],
	        defaults: {
	            type: 'text/css'
	        }
	    },
	    svg: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'documentEvent',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'x',
	            'y',
	            'width',
	            'height',
	            'viewBox',
	            'preserveAspectRatio',
	            'zoomAndPan',
	            'version',
	            'baseProfile',
	            'contentScriptType',
	            'contentStyleType'
	        ],
	        defaults: {
	            x: '0',
	            y: '0',
	            width: '100%',
	            height: '100%',
	            preserveAspectRatio: 'xMidYMid meet',
	            zoomAndPan: 'magnify',
	            version: '1.1',
	            baseProfile: 'none',
	            contentScriptType: 'application/ecmascript',
	            contentStyleType: 'text/css'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    switch: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform'
	        ],
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape'
	        ],
	        content: [
	            'a',
	            'foreignObject',
	            'g',
	            'image',
	            'svg',
	            'switch',
	            'text',
	            'use'
	        ]
	    },
	    symbol: {
	        attrsGroups: [
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'preserveAspectRatio',
	            'viewBox',
	            'refX',
	            'refY'
	        ],
	        defaults: {
	            refX: 0,
	            refY: 0
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'shape',
	            'structural',
	            'paintServer'
	        ],
	        content: [
	            'a',
	            'altGlyphDef',
	            'clipPath',
	            'color-profile',
	            'cursor',
	            'filter',
	            'font',
	            'font-face',
	            'foreignObject',
	            'image',
	            'marker',
	            'mask',
	            'pattern',
	            'script',
	            'style',
	            'switch',
	            'text',
	            'view'
	        ]
	    },
	    text: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'lengthAdjust',
	            'x',
	            'y',
	            'dx',
	            'dy',
	            'rotate',
	            'textLength'
	        ],
	        defaults: {
	            x: '0',
	            y: '0',
	            lengthAdjust: 'spacing'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive',
	            'textContentChild'
	        ],
	        content: [
	            'a'
	        ]
	    },
	    textPath: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'xlink:href',
	            'startOffset',
	            'method',
	            'spacing',
	            'd'
	        ],
	        defaults: {
	            startOffset: '0',
	            method: 'align',
	            spacing: 'exact'
	        },
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'a',
	            'altGlyph',
	            'animate',
	            'animateColor',
	            'set',
	            'tref',
	            'tspan'
	        ]
	    },
	    title: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'class',
	            'style'
	        ]
	    },
	    tref: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'xlink:href'
	        ],
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'animate',
	            'animateColor',
	            'set'
	        ]
	    },
	    tspan: {
	        attrsGroups: [
	            'conditionalProcessing',
	            'core',
	            'graphicalEvent',
	            'presentation'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'x',
	            'y',
	            'dx',
	            'dy',
	            'rotate',
	            'textLength',
	            'lengthAdjust'
	        ],
	        contentGroups: [
	            'descriptive'
	        ],
	        content: [
	            'a',
	            'altGlyph',
	            'animate',
	            'animateColor',
	            'set',
	            'tref',
	            'tspan'
	        ]
	    },
	    use: {
	        attrsGroups: [
	            'core',
	            'conditionalProcessing',
	            'graphicalEvent',
	            'presentation',
	            'xlink'
	        ],
	        attrs: [
	            'class',
	            'style',
	            'externalResourcesRequired',
	            'transform',
	            'x',
	            'y',
	            'width',
	            'height',
	            'xlink:href'
	        ],
	        defaults: {
	            x: '0',
	            y: '0'
	        },
	        contentGroups: [
	            'animation',
	            'descriptive'
	        ]
	    },
	    view: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'externalResourcesRequired',
	            'viewBox',
	            'preserveAspectRatio',
	            'zoomAndPan',
	            'viewTarget'
	        ],
	        contentGroups: [
	            'descriptive'
	        ]
	    },
	    vkern: {
	        attrsGroups: [
	            'core'
	        ],
	        attrs: [
	            'u1',
	            'g1',
	            'u2',
	            'g2',
	            'k'
	        ]
	    }
	};

	// http://wiki.inkscape.org/wiki/index.php/Inkscape-specific_XML_attributes
	exports.editorNamespaces = [
	    'http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd',
	    'http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd',
	    'http://www.inkscape.org/namespaces/inkscape',
	    'http://www.bohemiancoding.com/sketch/ns',
	    'http://ns.adobe.com/AdobeIllustrator/10.0/',
	    'http://ns.adobe.com/Graphs/1.0/',
	    'http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/',
	    'http://ns.adobe.com/Variables/1.0/',
	    'http://ns.adobe.com/SaveForWeb/1.0/',
	    'http://ns.adobe.com/Extensibility/1.0/',
	    'http://ns.adobe.com/Flows/1.0/',
	    'http://ns.adobe.com/ImageReplacement/1.0/',
	    'http://ns.adobe.com/GenericCustomNamespace/1.0/',
	    'http://ns.adobe.com/XPath/1.0/'
	];

	// http://www.w3.org/TR/SVG/linking.html#processingIRI
	exports.referencesProps = [
	    'clip-path',
	    'color-profile',
	    'fill',
	    'filter',
	    'marker-start',
	    'marker-mid',
	    'marker-end',
	    'mask',
	    'stroke',
	    'style'
	];

	// http://www.w3.org/TR/SVG/propidx.html
	exports.inheritableAttrs = [
	    'clip-rule',
	    'color',
	    'color-interpolation',
	    'color-interpolation-filters',
	    'color-profile',
	    'color-rendering',
	    'cursor',
	    'direction',
	    'fill',
	    'fill-opacity',
	    'fill-rule',
	    'font',
	    'font-family',
	    'font-size',
	    'font-size-adjust',
	    'font-stretch',
	    'font-style',
	    'font-variant',
	    'font-weight',
	    'glyph-orientation-horizontal',
	    'glyph-orientation-vertical',
	    'image-rendering',
	    'kerning',
	    'letter-spacing',
	    'marker',
	    'marker-end',
	    'marker-mid',
	    'marker-start',
	    'pointer-events',
	    'shape-rendering',
	    'stroke',
	    'stroke-dasharray',
	    'stroke-dashoffset',
	    'stroke-linecap',
	    'stroke-linejoin',
	    'stroke-miterlimit',
	    'stroke-opacity',
	    'stroke-width',
	    'text-anchor',
	    'text-rendering',
	    'transform',
	    'visibility',
	    'white-space',
	    'word-spacing',
	    'writing-mode'
	];

	// http://www.w3.org/TR/SVG/single-page.html#types-ColorKeywords
	exports.colorsNames = {
	    'aliceblue': '#f0f8ff',
	    'antiquewhite': '#faebd7',
	    'aqua': '#0ff',
	    'aquamarine': '#7fffd4',
	    'azure': '#f0ffff',
	    'beige': '#f5f5dc',
	    'bisque': '#ffe4c4',
	    'black': '#000',
	    'blanchedalmond': '#ffebcd',
	    'blue': '#00f',
	    'blueviolet': '#8a2be2',
	    'brown': '#a52a2a',
	    'burlywood': '#deb887',
	    'cadetblue': '#5f9ea0',
	    'chartreuse': '#7fff00',
	    'chocolate': '#d2691e',
	    'coral': '#ff7f50',
	    'cornflowerblue': '#6495ed',
	    'cornsilk': '#fff8dc',
	    'crimson': '#dc143c',
	    'cyan': '#0ff',
	    'darkblue': '#00008b',
	    'darkcyan': '#008b8b',
	    'darkgoldenrod': '#b8860b',
	    'darkgray': '#a9a9a9',
	    'darkgreen': '#006400',
	    'darkkhaki': '#bdb76b',
	    'darkmagenta': '#8b008b',
	    'darkolivegreen': '#556b2f',
	    'darkorange': '#ff8c00',
	    'darkorchid': '#9932cc',
	    'darkred': '#8b0000',
	    'darksalmon': '#e9967a',
	    'darkseagreen': '#8fbc8f',
	    'darkslateblue': '#483d8b',
	    'darkslategray': '#2f4f4f',
	    'darkturquoise': '#00ced1',
	    'darkviolet': '#9400d3',
	    'deeppink': '#ff1493',
	    'deepskyblue': '#00bfff',
	    'dimgray': '#696969',
	    'dodgerblue': '#1e90ff',
	    'firebrick': '#b22222',
	    'floralwhite': '#fffaf0',
	    'forestgreen': '#228b22',
	    'fuchsia': '#f0f',
	    'gainsboro': '#dcdcdc',
	    'ghostwhite': '#f8f8ff',
	    'gold': '#ffd700',
	    'goldenrod': '#daa520',
	    'gray': '#808080',
	    'green': '#008000',
	    'greenyellow': '#adff2f',
	    'honeydew': '#f0fff0',
	    'hotpink': '#ff69b4',
	    'indianred': '#cd5c5c',
	    'indigo': '#4b0082',
	    'ivory': '#fffff0',
	    'khaki': '#f0e68c',
	    'lavender': '#e6e6fa',
	    'lavenderblush': '#fff0f5',
	    'lawngreen': '#7cfc00',
	    'lemonchiffon': '#fffacd',
	    'lightblue': '#add8e6',
	    'lightcoral': '#f08080',
	    'lightcyan': '#e0ffff',
	    'lightgoldenrodyellow': '#fafad2',
	    'lightgreen': '#90ee90',
	    'lightgrey': '#d3d3d3',
	    'lightpink': '#ffb6c1',
	    'lightsalmon': '#ffa07a',
	    'lightseagreen': '#20b2aa',
	    'lightskyblue': '#87cefa',
	    'lightslategray': '#789',
	    'lightsteelblue': '#b0c4de',
	    'lightyellow': '#ffffe0',
	    'lime': '#0f0',
	    'limegreen': '#32cd32',
	    'linen': '#faf0e6',
	    'magenta': '#f0f',
	    'maroon': '#800000',
	    'mediumaquamarine': '#66cdaa',
	    'mediumblue': '#0000cd',
	    'mediumorchid': '#ba55d3',
	    'mediumpurple': '#9370db',
	    'mediumseagreen': '#3cb371',
	    'mediumslateblue': '#7b68ee',
	    'mediumspringgreen': '#00fa9a',
	    'mediumturquoise': '#48d1cc',
	    'mediumvioletred': '#c71585',
	    'midnightblue': '#191970',
	    'mintcream': '#f5fffa',
	    'mistyrose': '#ffe4e1',
	    'moccasin': '#ffe4b5',
	    'navajowhite': '#ffdead',
	    'navy': '#000080',
	    'oldlace': '#fdf5e6',
	    'olive': '#808000',
	    'olivedrab': '#6b8e23',
	    'orange': '#ffa500',
	    'orangered': '#ff4500',
	    'orchid': '#da70d6',
	    'palegoldenrod': '#eee8aa',
	    'palegreen': '#98fb98',
	    'paleturquoise': '#afeeee',
	    'palevioletred': '#db7093',
	    'papayawhip': '#ffefd5',
	    'peachpuff': '#ffdab9',
	    'peru': '#cd853f',
	    'pink': '#ffc0cb',
	    'plum': '#dda0dd',
	    'powderblue': '#b0e0e6',
	    'purple': '#800080',
	    'red': '#f00',
	    'rosybrown': '#bc8f8f',
	    'royalblue': '#4169e1',
	    'saddlebrown': '#8b4513',
	    'salmon': '#fa8072',
	    'sandybrown': '#f4a460',
	    'seagreen': '#2e8b57',
	    'seashell': '#fff5ee',
	    'sienna': '#a0522d',
	    'silver': '#c0c0c0',
	    'skyblue': '#87ceeb',
	    'slateblue': '#6a5acd',
	    'slategray': '#708090',
	    'snow': '#fffafa',
	    'springgreen': '#00ff7f',
	    'steelblue': '#4682b4',
	    'tan': '#d2b48c',
	    'teal': '#008080',
	    'thistle': '#d8bfd8',
	    'tomato': '#ff6347',
	    'turquoise': '#40e0d0',
	    'violet': '#ee82ee',
	    'wheat': '#f5deb3',
	    'white': '#fff',
	    'whitesmoke': '#f5f5f5',
	    'yellow': '#ff0',
	    'yellowgreen': '#9acd32'
	};

	exports.colorsShortNames = {
	  '#f0ffff': 'azure',
	  '#f5f5dc': 'beige',
	  '#ffe4c4': 'bisque',
	  '#a52a2a': 'brown',
	  '#ff7f50': 'coral',
	  '#ffd700': 'gold',
	  '#808080': 'gray',
	  '#008000': 'green',
	  '#4b0082': 'indigo',
	  '#fffff0': 'ivory',
	  '#f0e68c': 'khaki',
	  '#faf0e6': 'linen',
	  '#800000': 'maroon',
	  '#000080': 'navy',
	  '#808000': 'olive',
	  '#ffa500': 'orange',
	  '#da70d6': 'orchid',
	  '#cd853f': 'peru',
	  '#ffc0cb': 'pink',
	  '#dda0dd': 'plum',
	  '#800080': 'purple',
	  '#f00': 'red',
	  '#fa8072': 'salmon',
	  '#a0522d': 'sienna',
	  '#c0c0c0': 'silver',
	  '#fffafa': 'snow',
	  '#d2b48c': 'tan',
	  '#008080': 'teal',
	  '#ff6347': 'tomato',
	  '#ee82ee': 'violet',
	  '#f5deb3': 'wheat'
	};

	// http://www.w3.org/TR/SVG/single-page.html#types-DataTypeColor
	exports.colorsProps = [
	    'color', 'fill', 'stroke', 'stop-color', 'flood-color', 'lighting-color'
	];


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var YAMLException = __webpack_require__(26);

	var TYPE_CONSTRUCTOR_OPTIONS = [
	  'kind',
	  'resolve',
	  'construct',
	  'instanceOf',
	  'predicate',
	  'represent',
	  'defaultStyle',
	  'styleAliases'
	];

	var YAML_NODE_KINDS = [
	  'scalar',
	  'sequence',
	  'mapping'
	];

	function compileStyleAliases(map) {
	  var result = {};

	  if (map !== null) {
	    Object.keys(map).forEach(function (style) {
	      map[style].forEach(function (alias) {
	        result[String(alias)] = style;
	      });
	    });
	  }

	  return result;
	}

	function Type(tag, options) {
	  options = options || {};

	  Object.keys(options).forEach(function (name) {
	    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
	      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
	    }
	  });

	  // TODO: Add tag format check.
	  this.tag          = tag;
	  this.kind         = options['kind']         || null;
	  this.resolve      = options['resolve']      || function () { return true; };
	  this.construct    = options['construct']    || function (data) { return data; };
	  this.instanceOf   = options['instanceOf']   || null;
	  this.predicate    = options['predicate']    || null;
	  this.represent    = options['represent']    || null;
	  this.defaultStyle = options['defaultStyle'] || null;
	  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

	  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
	    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
	  }
	}

	module.exports = Type;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// resolves . and .. elements in a path array with directory names there
	// must be no slashes, empty elements, or device names (c:\) in the array
	// (so also no leading and trailing slashes - it does not distinguish
	// relative and absolute paths)
	function normalizeArray(parts, allowAboveRoot) {
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = parts.length - 1; i >= 0; i--) {
	    var last = parts[i];
	    if (last === '.') {
	      parts.splice(i, 1);
	    } else if (last === '..') {
	      parts.splice(i, 1);
	      up++;
	    } else if (up) {
	      parts.splice(i, 1);
	      up--;
	    }
	  }

	  // if the path is allowed to go above the root, restore leading ..s
	  if (allowAboveRoot) {
	    for (; up--; up) {
	      parts.unshift('..');
	    }
	  }

	  return parts;
	}

	// Split a filename into [root, dir, basename, ext], unix version
	// 'root' is just a slash, or nothing.
	var splitPathRe =
	    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
	var splitPath = function(filename) {
	  return splitPathRe.exec(filename).slice(1);
	};

	// path.resolve([from ...], to)
	// posix version
	exports.resolve = function() {
	  var resolvedPath = '',
	      resolvedAbsolute = false;

	  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
	    var path = (i >= 0) ? arguments[i] : process.cwd();

	    // Skip empty and invalid entries
	    if (typeof path !== 'string') {
	      throw new TypeError('Arguments to path.resolve must be strings');
	    } else if (!path) {
	      continue;
	    }

	    resolvedPath = path + '/' + resolvedPath;
	    resolvedAbsolute = path.charAt(0) === '/';
	  }

	  // At this point the path should be resolved to a full absolute path, but
	  // handle relative paths to be safe (might happen when process.cwd() fails)

	  // Normalize the path
	  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
	    return !!p;
	  }), !resolvedAbsolute).join('/');

	  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
	};

	// path.normalize(path)
	// posix version
	exports.normalize = function(path) {
	  var isAbsolute = exports.isAbsolute(path),
	      trailingSlash = substr(path, -1) === '/';

	  // Normalize the path
	  path = normalizeArray(filter(path.split('/'), function(p) {
	    return !!p;
	  }), !isAbsolute).join('/');

	  if (!path && !isAbsolute) {
	    path = '.';
	  }
	  if (path && trailingSlash) {
	    path += '/';
	  }

	  return (isAbsolute ? '/' : '') + path;
	};

	// posix version
	exports.isAbsolute = function(path) {
	  return path.charAt(0) === '/';
	};

	// posix version
	exports.join = function() {
	  var paths = Array.prototype.slice.call(arguments, 0);
	  return exports.normalize(filter(paths, function(p, index) {
	    if (typeof p !== 'string') {
	      throw new TypeError('Arguments to path.join must be strings');
	    }
	    return p;
	  }).join('/'));
	};


	// path.relative(from, to)
	// posix version
	exports.relative = function(from, to) {
	  from = exports.resolve(from).substr(1);
	  to = exports.resolve(to).substr(1);

	  function trim(arr) {
	    var start = 0;
	    for (; start < arr.length; start++) {
	      if (arr[start] !== '') break;
	    }

	    var end = arr.length - 1;
	    for (; end >= 0; end--) {
	      if (arr[end] !== '') break;
	    }

	    if (start > end) return [];
	    return arr.slice(start, end - start + 1);
	  }

	  var fromParts = trim(from.split('/'));
	  var toParts = trim(to.split('/'));

	  var length = Math.min(fromParts.length, toParts.length);
	  var samePartsLength = length;
	  for (var i = 0; i < length; i++) {
	    if (fromParts[i] !== toParts[i]) {
	      samePartsLength = i;
	      break;
	    }
	  }

	  var outputParts = [];
	  for (var i = samePartsLength; i < fromParts.length; i++) {
	    outputParts.push('..');
	  }

	  outputParts = outputParts.concat(toParts.slice(samePartsLength));

	  return outputParts.join('/');
	};

	exports.sep = '/';
	exports.delimiter = ':';

	exports.dirname = function(path) {
	  var result = splitPath(path),
	      root = result[0],
	      dir = result[1];

	  if (!root && !dir) {
	    // No dirname whatsoever
	    return '.';
	  }

	  if (dir) {
	    // It has a dirname, strip trailing slash
	    dir = dir.substr(0, dir.length - 1);
	  }

	  return root + dir;
	};


	exports.basename = function(path, ext) {
	  var f = splitPath(path)[2];
	  // TODO: make this comparison case-insensitive on windows?
	  if (ext && f.substr(-1 * ext.length) === ext) {
	    f = f.substr(0, f.length - ext.length);
	  }
	  return f;
	};


	exports.extname = function(path) {
	  return splitPath(path)[3];
	};

	function filter (xs, f) {
	    if (xs.filter) return xs.filter(f);
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        if (f(xs[i], i, xs)) res.push(xs[i]);
	    }
	    return res;
	}

	// String.prototype.substr - negative index don't work in IE8
	var substr = 'ab'.substr(-1) === 'b'
	    ? function (str, start, len) { return str.substr(start, len) }
	    : function (str, start, len) {
	        if (start < 0) start = str.length + start;
	        return str.substr(start, len);
	    }
	;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var formatRegExp = /%[sdj%]/g;
	exports.format = function(f) {
	  if (!isString(f)) {
	    var objects = [];
	    for (var i = 0; i < arguments.length; i++) {
	      objects.push(inspect(arguments[i]));
	    }
	    return objects.join(' ');
	  }

	  var i = 1;
	  var args = arguments;
	  var len = args.length;
	  var str = String(f).replace(formatRegExp, function(x) {
	    if (x === '%%') return '%';
	    if (i >= len) return x;
	    switch (x) {
	      case '%s': return String(args[i++]);
	      case '%d': return Number(args[i++]);
	      case '%j':
	        try {
	          return JSON.stringify(args[i++]);
	        } catch (_) {
	          return '[Circular]';
	        }
	      default:
	        return x;
	    }
	  });
	  for (var x = args[i]; i < len; x = args[++i]) {
	    if (isNull(x) || !isObject(x)) {
	      str += ' ' + x;
	    } else {
	      str += ' ' + inspect(x);
	    }
	  }
	  return str;
	};


	// Mark that a method should not be used.
	// Returns a modified function which warns once by default.
	// If --no-deprecation is set, then it is a no-op.
	exports.deprecate = function(fn, msg) {
	  // Allow for deprecating things in the process of starting up.
	  if (isUndefined(global.process)) {
	    return function() {
	      return exports.deprecate(fn, msg).apply(this, arguments);
	    };
	  }

	  if (process.noDeprecation === true) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (process.throwDeprecation) {
	        throw new Error(msg);
	      } else if (process.traceDeprecation) {
	        console.trace(msg);
	      } else {
	        console.error(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	};


	var debugs = {};
	var debugEnviron;
	exports.debuglog = function(set) {
	  if (isUndefined(debugEnviron))
	    debugEnviron = process.env.NODE_DEBUG || '';
	  set = set.toUpperCase();
	  if (!debugs[set]) {
	    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
	      var pid = process.pid;
	      debugs[set] = function() {
	        var msg = exports.format.apply(exports, arguments);
	        console.error('%s %d: %s', set, pid, msg);
	      };
	    } else {
	      debugs[set] = function() {};
	    }
	  }
	  return debugs[set];
	};


	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 */
	/* legacy: obj, showHidden, depth, colors*/
	function inspect(obj, opts) {
	  // default options
	  var ctx = {
	    seen: [],
	    stylize: stylizeNoColor
	  };
	  // legacy...
	  if (arguments.length >= 3) ctx.depth = arguments[2];
	  if (arguments.length >= 4) ctx.colors = arguments[3];
	  if (isBoolean(opts)) {
	    // legacy...
	    ctx.showHidden = opts;
	  } else if (opts) {
	    // got an "options" object
	    exports._extend(ctx, opts);
	  }
	  // set default options
	  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	  if (isUndefined(ctx.depth)) ctx.depth = 2;
	  if (isUndefined(ctx.colors)) ctx.colors = false;
	  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	  if (ctx.colors) ctx.stylize = stylizeWithColor;
	  return formatValue(ctx, obj, ctx.depth);
	}
	exports.inspect = inspect;


	// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
	inspect.colors = {
	  'bold' : [1, 22],
	  'italic' : [3, 23],
	  'underline' : [4, 24],
	  'inverse' : [7, 27],
	  'white' : [37, 39],
	  'grey' : [90, 39],
	  'black' : [30, 39],
	  'blue' : [34, 39],
	  'cyan' : [36, 39],
	  'green' : [32, 39],
	  'magenta' : [35, 39],
	  'red' : [31, 39],
	  'yellow' : [33, 39]
	};

	// Don't use 'blue' not visible on cmd.exe
	inspect.styles = {
	  'special': 'cyan',
	  'number': 'yellow',
	  'boolean': 'yellow',
	  'undefined': 'grey',
	  'null': 'bold',
	  'string': 'green',
	  'date': 'magenta',
	  // "name": intentionally not styling
	  'regexp': 'red'
	};


	function stylizeWithColor(str, styleType) {
	  var style = inspect.styles[styleType];

	  if (style) {
	    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
	           '\u001b[' + inspect.colors[style][1] + 'm';
	  } else {
	    return str;
	  }
	}


	function stylizeNoColor(str, styleType) {
	  return str;
	}


	function arrayToHash(array) {
	  var hash = {};

	  array.forEach(function(val, idx) {
	    hash[val] = true;
	  });

	  return hash;
	}


	function formatValue(ctx, value, recurseTimes) {
	  // Provide a hook for user-specified inspect functions.
	  // Check that value is an object with an inspect function on it
	  if (ctx.customInspect &&
	      value &&
	      isFunction(value.inspect) &&
	      // Filter out the util module, it's inspect function is special
	      value.inspect !== exports.inspect &&
	      // Also filter out any prototype objects using the circular check.
	      !(value.constructor && value.constructor.prototype === value)) {
	    var ret = value.inspect(recurseTimes, ctx);
	    if (!isString(ret)) {
	      ret = formatValue(ctx, ret, recurseTimes);
	    }
	    return ret;
	  }

	  // Primitive types cannot have properties
	  var primitive = formatPrimitive(ctx, value);
	  if (primitive) {
	    return primitive;
	  }

	  // Look up the keys of the object.
	  var keys = Object.keys(value);
	  var visibleKeys = arrayToHash(keys);

	  if (ctx.showHidden) {
	    keys = Object.getOwnPropertyNames(value);
	  }

	  // IE doesn't make error fields non-enumerable
	  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	  if (isError(value)
	      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
	    return formatError(value);
	  }

	  // Some type of object without properties can be shortcutted.
	  if (keys.length === 0) {
	    if (isFunction(value)) {
	      var name = value.name ? ': ' + value.name : '';
	      return ctx.stylize('[Function' + name + ']', 'special');
	    }
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    }
	    if (isDate(value)) {
	      return ctx.stylize(Date.prototype.toString.call(value), 'date');
	    }
	    if (isError(value)) {
	      return formatError(value);
	    }
	  }

	  var base = '', array = false, braces = ['{', '}'];

	  // Make Array say that they are Array
	  if (isArray(value)) {
	    array = true;
	    braces = ['[', ']'];
	  }

	  // Make functions say that they are functions
	  if (isFunction(value)) {
	    var n = value.name ? ': ' + value.name : '';
	    base = ' [Function' + n + ']';
	  }

	  // Make RegExps say that they are RegExps
	  if (isRegExp(value)) {
	    base = ' ' + RegExp.prototype.toString.call(value);
	  }

	  // Make dates with properties first say the date
	  if (isDate(value)) {
	    base = ' ' + Date.prototype.toUTCString.call(value);
	  }

	  // Make error with message first say the error
	  if (isError(value)) {
	    base = ' ' + formatError(value);
	  }

	  if (keys.length === 0 && (!array || value.length == 0)) {
	    return braces[0] + base + braces[1];
	  }

	  if (recurseTimes < 0) {
	    if (isRegExp(value)) {
	      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	    } else {
	      return ctx.stylize('[Object]', 'special');
	    }
	  }

	  ctx.seen.push(value);

	  var output;
	  if (array) {
	    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	  } else {
	    output = keys.map(function(key) {
	      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
	    });
	  }

	  ctx.seen.pop();

	  return reduceToSingleString(output, base, braces);
	}


	function formatPrimitive(ctx, value) {
	  if (isUndefined(value))
	    return ctx.stylize('undefined', 'undefined');
	  if (isString(value)) {
	    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
	                                             .replace(/'/g, "\\'")
	                                             .replace(/\\"/g, '"') + '\'';
	    return ctx.stylize(simple, 'string');
	  }
	  if (isNumber(value))
	    return ctx.stylize('' + value, 'number');
	  if (isBoolean(value))
	    return ctx.stylize('' + value, 'boolean');
	  // For some reason typeof null is "object", so special case here.
	  if (isNull(value))
	    return ctx.stylize('null', 'null');
	}


	function formatError(value) {
	  return '[' + Error.prototype.toString.call(value) + ']';
	}


	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	  var output = [];
	  for (var i = 0, l = value.length; i < l; ++i) {
	    if (hasOwnProperty(value, String(i))) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          String(i), true));
	    } else {
	      output.push('');
	    }
	  }
	  keys.forEach(function(key) {
	    if (!key.match(/^\d+$/)) {
	      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
	          key, true));
	    }
	  });
	  return output;
	}


	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	  var name, str, desc;
	  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
	  if (desc.get) {
	    if (desc.set) {
	      str = ctx.stylize('[Getter/Setter]', 'special');
	    } else {
	      str = ctx.stylize('[Getter]', 'special');
	    }
	  } else {
	    if (desc.set) {
	      str = ctx.stylize('[Setter]', 'special');
	    }
	  }
	  if (!hasOwnProperty(visibleKeys, key)) {
	    name = '[' + key + ']';
	  }
	  if (!str) {
	    if (ctx.seen.indexOf(desc.value) < 0) {
	      if (isNull(recurseTimes)) {
	        str = formatValue(ctx, desc.value, null);
	      } else {
	        str = formatValue(ctx, desc.value, recurseTimes - 1);
	      }
	      if (str.indexOf('\n') > -1) {
	        if (array) {
	          str = str.split('\n').map(function(line) {
	            return '  ' + line;
	          }).join('\n').substr(2);
	        } else {
	          str = '\n' + str.split('\n').map(function(line) {
	            return '   ' + line;
	          }).join('\n');
	        }
	      }
	    } else {
	      str = ctx.stylize('[Circular]', 'special');
	    }
	  }
	  if (isUndefined(name)) {
	    if (array && key.match(/^\d+$/)) {
	      return str;
	    }
	    name = JSON.stringify('' + key);
	    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
	      name = name.substr(1, name.length - 2);
	      name = ctx.stylize(name, 'name');
	    } else {
	      name = name.replace(/'/g, "\\'")
	                 .replace(/\\"/g, '"')
	                 .replace(/(^"|"$)/g, "'");
	      name = ctx.stylize(name, 'string');
	    }
	  }

	  return name + ': ' + str;
	}


	function reduceToSingleString(output, base, braces) {
	  var numLinesEst = 0;
	  var length = output.reduce(function(prev, cur) {
	    numLinesEst++;
	    if (cur.indexOf('\n') >= 0) numLinesEst++;
	    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
	  }, 0);

	  if (length > 60) {
	    return braces[0] +
	           (base === '' ? '' : base + '\n ') +
	           ' ' +
	           output.join(',\n  ') +
	           ' ' +
	           braces[1];
	  }

	  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
	}


	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	function isArray(ar) {
	  return Array.isArray(ar);
	}
	exports.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	exports.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	exports.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	exports.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	exports.isUndefined = isUndefined;

	function isRegExp(re) {
	  return isObject(re) && objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;

	function isDate(d) {
	  return isObject(d) && objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;

	function isError(e) {
	  return isObject(e) &&
	      (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	exports.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;

	exports.isBuffer = __webpack_require__(302);

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}


	function pad(n) {
	  return n < 10 ? '0' + n.toString(10) : n.toString(10);
	}


	var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
	              'Oct', 'Nov', 'Dec'];

	// 26 Feb 16:19:34
	function timestamp() {
	  var d = new Date();
	  var time = [pad(d.getHours()),
	              pad(d.getMinutes()),
	              pad(d.getSeconds())].join(':');
	  return [d.getDate(), months[d.getMonth()], time].join(' ');
	}


	// log is just a thin wrapper to console.log that prepends a timestamp
	exports.log = function() {
	  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
	};


	/**
	 * Inherit the prototype methods from one constructor into another.
	 *
	 * The Function.prototype.inherits from lang.js rewritten as a standalone
	 * function (not on Function.prototype). NOTE: If this file is to be loaded
	 * during bootstrapping this function needs to be rewritten using some native
	 * functions as prototype setup using normal JavaScript does not work as
	 * expected during bootstrapping (see mirror.js in r114903).
	 *
	 * @param {function} ctor Constructor function which needs to inherit the
	 *     prototype.
	 * @param {function} superCtor Constructor function to inherit prototype from.
	 */
	exports.inherits = __webpack_require__(301);

	exports._extend = function(origin, add) {
	  // Don't do anything if add isn't an object
	  if (!add || !isObject(add)) return origin;

	  var keys = Object.keys(add);
	  var i = keys.length;
	  while (i--) {
	    origin[keys[i]] = add[keys[i]];
	  }
	  return origin;
	};

	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 10 */
/***/ function(module, exports) {

	function walkRules(node, item, list) {
	    switch (node.type) {
	        case 'StyleSheet':
	            var oldStylesheet = this.stylesheet;
	            this.stylesheet = node;

	            node.rules.each(walkRules, this);

	            this.stylesheet = oldStylesheet;
	            break;

	        case 'Atrule':
	            if (node.block !== null) {
	                walkRules.call(this, node.block);
	            }

	            this.fn(node, item, list);
	            break;

	        case 'Ruleset':
	            this.fn(node, item, list);
	            break;
	    }

	}

	function walkRulesRight(node, item, list) {
	    switch (node.type) {
	        case 'StyleSheet':
	            var oldStylesheet = this.stylesheet;
	            this.stylesheet = node;

	            node.rules.eachRight(walkRulesRight, this);

	            this.stylesheet = oldStylesheet;
	            break;

	        case 'Atrule':
	            if (node.block !== null) {
	                walkRulesRight.call(this, node.block);
	            }

	            this.fn(node, item, list);
	            break;

	        case 'Ruleset':
	            this.fn(node, item, list);
	            break;
	    }
	}

	function walkAll(node, item, list) {
	    switch (node.type) {
	        case 'StyleSheet':
	            var oldStylesheet = this.stylesheet;
	            this.stylesheet = node;

	            node.rules.each(walkAll, this);

	            this.stylesheet = oldStylesheet;
	            break;

	        case 'Atrule':
	            if (node.expression !== null) {
	                walkAll.call(this, node.expression);
	            }
	            if (node.block !== null) {
	                walkAll.call(this, node.block);
	            }
	            break;

	        case 'Ruleset':
	            this.ruleset = node;

	            if (node.selector !== null) {
	                walkAll.call(this, node.selector);
	            }
	            walkAll.call(this, node.block);

	            this.ruleset = null;
	            break;

	        case 'Selector':
	            var oldSelector = this.selector;
	            this.selector = node;

	            node.selectors.each(walkAll, this);

	            this.selector = oldSelector;
	            break;

	        case 'Block':
	            node.declarations.each(walkAll, this);
	            break;

	        case 'Declaration':
	            this.declaration = node;

	            walkAll.call(this, node.property);
	            walkAll.call(this, node.value);

	            this.declaration = null;
	            break;

	        case 'Attribute':
	            walkAll.call(this, node.name);
	            if (node.value !== null) {
	                walkAll.call(this, node.value);
	            }
	            break;

	        case 'FunctionalPseudo':
	        case 'Function':
	            this['function'] = node;

	            node.arguments.each(walkAll, this);

	            this['function'] = null;
	            break;

	        case 'AtruleExpression':
	            this.atruleExpression = node;

	            node.sequence.each(walkAll, this);

	            this.atruleExpression = null;
	            break;

	        case 'Value':
	        case 'Argument':
	        case 'SimpleSelector':
	        case 'Braces':
	        case 'Negation':
	            node.sequence.each(walkAll, this);
	            break;

	        case 'Url':
	        case 'Progid':
	            walkAll.call(this, node.value);
	            break;

	        // nothig to do with
	        // case 'Property':
	        // case 'Combinator':
	        // case 'Dimension':
	        // case 'Hash':
	        // case 'Identifier':
	        // case 'Nth':
	        // case 'Class':
	        // case 'Id':
	        // case 'Percentage':
	        // case 'PseudoClass':
	        // case 'PseudoElement':
	        // case 'Space':
	        // case 'Number':
	        // case 'String':
	        // case 'Operator':
	        // case 'Raw':
	    }

	    this.fn(node, item, list);
	}

	function createContext(root, fn) {
	    var context = {
	        fn: fn,
	        root: root,
	        stylesheet: null,
	        atruleExpression: null,
	        ruleset: null,
	        selector: null,
	        declaration: null,
	        function: null
	    };

	    return context;
	}

	module.exports = {
	    all: function(root, fn) {
	        walkAll.call(createContext(root, fn), root);
	    },
	    rules: function(root, fn) {
	        walkRules.call(createContext(root, fn), root);
	    },
	    rulesRight: function(root, fn) {
	        walkRulesRight.call(createContext(root, fn), root);
	    }
	};


/***/ },
/* 11 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	function EventEmitter() {
	  this._events = this._events || {};
	  this._maxListeners = this._maxListeners || undefined;
	}
	module.exports = EventEmitter;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	EventEmitter.defaultMaxListeners = 10;

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function(n) {
	  if (!isNumber(n) || n < 0 || isNaN(n))
	    throw TypeError('n must be a positive number');
	  this._maxListeners = n;
	  return this;
	};

	EventEmitter.prototype.emit = function(type) {
	  var er, handler, len, args, i, listeners;

	  if (!this._events)
	    this._events = {};

	  // If there is no 'error' event listener then throw.
	  if (type === 'error') {
	    if (!this._events.error ||
	        (isObject(this._events.error) && !this._events.error.length)) {
	      er = arguments[1];
	      if (er instanceof Error) {
	        throw er; // Unhandled 'error' event
	      } else {
	        // At least give some kind of context to the user
	        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
	        err.context = er;
	        throw err;
	      }
	    }
	  }

	  handler = this._events[type];

	  if (isUndefined(handler))
	    return false;

	  if (isFunction(handler)) {
	    switch (arguments.length) {
	      // fast cases
	      case 1:
	        handler.call(this);
	        break;
	      case 2:
	        handler.call(this, arguments[1]);
	        break;
	      case 3:
	        handler.call(this, arguments[1], arguments[2]);
	        break;
	      // slower
	      default:
	        args = Array.prototype.slice.call(arguments, 1);
	        handler.apply(this, args);
	    }
	  } else if (isObject(handler)) {
	    args = Array.prototype.slice.call(arguments, 1);
	    listeners = handler.slice();
	    len = listeners.length;
	    for (i = 0; i < len; i++)
	      listeners[i].apply(this, args);
	  }

	  return true;
	};

	EventEmitter.prototype.addListener = function(type, listener) {
	  var m;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events)
	    this._events = {};

	  // To avoid recursion in the case that type === "newListener"! Before
	  // adding it to the listeners, first emit "newListener".
	  if (this._events.newListener)
	    this.emit('newListener', type,
	              isFunction(listener.listener) ?
	              listener.listener : listener);

	  if (!this._events[type])
	    // Optimize the case of one listener. Don't need the extra array object.
	    this._events[type] = listener;
	  else if (isObject(this._events[type]))
	    // If we've already got an array, just append.
	    this._events[type].push(listener);
	  else
	    // Adding the second element, need to change to array.
	    this._events[type] = [this._events[type], listener];

	  // Check for listener leak
	  if (isObject(this._events[type]) && !this._events[type].warned) {
	    if (!isUndefined(this._maxListeners)) {
	      m = this._maxListeners;
	    } else {
	      m = EventEmitter.defaultMaxListeners;
	    }

	    if (m && m > 0 && this._events[type].length > m) {
	      this._events[type].warned = true;
	      console.error('(node) warning: possible EventEmitter memory ' +
	                    'leak detected. %d listeners added. ' +
	                    'Use emitter.setMaxListeners() to increase limit.',
	                    this._events[type].length);
	      if (typeof console.trace === 'function') {
	        // not supported in IE 10
	        console.trace();
	      }
	    }
	  }

	  return this;
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.once = function(type, listener) {
	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  var fired = false;

	  function g() {
	    this.removeListener(type, g);

	    if (!fired) {
	      fired = true;
	      listener.apply(this, arguments);
	    }
	  }

	  g.listener = listener;
	  this.on(type, g);

	  return this;
	};

	// emits a 'removeListener' event iff the listener was removed
	EventEmitter.prototype.removeListener = function(type, listener) {
	  var list, position, length, i;

	  if (!isFunction(listener))
	    throw TypeError('listener must be a function');

	  if (!this._events || !this._events[type])
	    return this;

	  list = this._events[type];
	  length = list.length;
	  position = -1;

	  if (list === listener ||
	      (isFunction(list.listener) && list.listener === listener)) {
	    delete this._events[type];
	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);

	  } else if (isObject(list)) {
	    for (i = length; i-- > 0;) {
	      if (list[i] === listener ||
	          (list[i].listener && list[i].listener === listener)) {
	        position = i;
	        break;
	      }
	    }

	    if (position < 0)
	      return this;

	    if (list.length === 1) {
	      list.length = 0;
	      delete this._events[type];
	    } else {
	      list.splice(position, 1);
	    }

	    if (this._events.removeListener)
	      this.emit('removeListener', type, listener);
	  }

	  return this;
	};

	EventEmitter.prototype.removeAllListeners = function(type) {
	  var key, listeners;

	  if (!this._events)
	    return this;

	  // not listening for removeListener, no need to emit
	  if (!this._events.removeListener) {
	    if (arguments.length === 0)
	      this._events = {};
	    else if (this._events[type])
	      delete this._events[type];
	    return this;
	  }

	  // emit removeListener for all listeners on all events
	  if (arguments.length === 0) {
	    for (key in this._events) {
	      if (key === 'removeListener') continue;
	      this.removeAllListeners(key);
	    }
	    this.removeAllListeners('removeListener');
	    this._events = {};
	    return this;
	  }

	  listeners = this._events[type];

	  if (isFunction(listeners)) {
	    this.removeListener(type, listeners);
	  } else if (listeners) {
	    // LIFO order
	    while (listeners.length)
	      this.removeListener(type, listeners[listeners.length - 1]);
	  }
	  delete this._events[type];

	  return this;
	};

	EventEmitter.prototype.listeners = function(type) {
	  var ret;
	  if (!this._events || !this._events[type])
	    ret = [];
	  else if (isFunction(this._events[type]))
	    ret = [this._events[type]];
	  else
	    ret = this._events[type].slice();
	  return ret;
	};

	EventEmitter.prototype.listenerCount = function(type) {
	  if (this._events) {
	    var evlistener = this._events[type];

	    if (isFunction(evlistener))
	      return 1;
	    else if (evlistener)
	      return evlistener.length;
	  }
	  return 0;
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  return emitter.listenerCount(type);
	};

	function isFunction(arg) {
	  return typeof arg === 'function';
	}

	function isNumber(arg) {
	  return typeof arg === 'number';
	}

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}

	function isUndefined(arg) {
	  return arg === void 0;
	}


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var require;var require;/* WEBPACK VAR INJECTION */(function(module, process) {;(function (require, exports, module, platform) {

	if (module) module.exports = minimatch
	else exports.minimatch = minimatch

	if (!__webpack_require__(200)) {
	  require = function (id) {
	    switch (id) {
	      case "sigmund": return function sigmund (obj) {
	        return JSON.stringify(obj)
	      }
	      case "path": return { basename: function (f) {
	        f = f.split(/[\/\\]/)
	        var e = f.pop()
	        if (!e) e = f.pop()
	        return e
	      }}
	      case "lru-cache": return function LRUCache () {
	        // not quite an LRU, but still space-limited.
	        var cache = {}
	        var cnt = 0
	        this.set = function (k, v) {
	          cnt ++
	          if (cnt >= 100) cache = {}
	          cache[k] = v
	        }
	        this.get = function (k) { return cache[k] }
	      }
	    }
	  }
	}

	minimatch.Minimatch = Minimatch

	var LRU = require("lru-cache")
	  , cache = minimatch.cache = new LRU({max: 100})
	  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	  , sigmund = require("sigmund")

	var path = require("path")
	  // any single thing other than /
	  // don't need to escape / when using new RegExp()
	  , qmark = "[^/]"

	  // * => any number of characters
	  , star = qmark + "*?"

	  // ** when dots are allowed.  Anything goes, except .. and .
	  // not (^ or / followed by one or two dots followed by $ or /),
	  // followed by anything, any number of times.
	  , twoStarDot = "(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?"

	  // not a ^ or / followed by a dot,
	  // followed by anything, any number of times.
	  , twoStarNoDot = "(?:(?!(?:\\\/|^)\\.).)*?"

	  // characters that need to be escaped in RegExp.
	  , reSpecials = charSet("().*{}+?[]^$\\!")

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split("").reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}


	function minimatch (p, pattern, options) {
	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === "") return p === ""

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options, cache)
	  }

	  if (typeof pattern !== "string") {
	    throw new TypeError("glob pattern string required")
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    pattern = pattern.split("\\").join("/")
	  }

	  // lru storage.
	  // these things aren't particularly big, but walking down the string
	  // and turning it into a regexp can get pretty costly.
	  var cacheKey = pattern + "\n" + sigmund(options)
	  var cached = minimatch.cache.get(cacheKey)
	  if (cached) return cached
	  minimatch.cache.set(cacheKey, this)

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function() {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === "#") {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return -1 === s.indexOf(false)
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	    , negate = false
	    , options = this.options
	    , negateOffset = 0

	  if (options.nonegate) return

	  for ( var i = 0, l = pattern.length
	      ; i < l && pattern.charAt(i) === "!"
	      ; i ++) {
	    negate = !negate
	    negateOffset ++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return new Minimatch(pattern, options).braceExpand()
	}

	Minimatch.prototype.braceExpand = braceExpand
	function braceExpand (pattern, options) {
	  options = options || this.options
	  pattern = typeof pattern === "undefined"
	    ? this.pattern : pattern

	  if (typeof pattern === "undefined") {
	    throw new Error("undefined pattern")
	  }

	  if (options.nobrace ||
	      !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  var escaping = false

	  // examples and comments refer to this crazy pattern:
	  // a{b,c{d,e},{f,g}h}x{y,z}
	  // expected:
	  // abxy
	  // abxz
	  // acdxy
	  // acdxz
	  // acexy
	  // acexz
	  // afhxy
	  // afhxz
	  // aghxy
	  // aghxz

	  // everything before the first \{ is just a prefix.
	  // So, we pluck that off, and work with the rest,
	  // and then prepend it to everything we find.
	  if (pattern.charAt(0) !== "{") {
	    this.debug(pattern)
	    var prefix = null
	    for (var i = 0, l = pattern.length; i < l; i ++) {
	      var c = pattern.charAt(i)
	      this.debug(i, c)
	      if (c === "\\") {
	        escaping = !escaping
	      } else if (c === "{" && !escaping) {
	        prefix = pattern.substr(0, i)
	        break
	      }
	    }

	    // actually no sets, all { were escaped.
	    if (prefix === null) {
	      this.debug("no sets")
	      return [pattern]
	    }

	   var tail = braceExpand.call(this, pattern.substr(i), options)
	    return tail.map(function (t) {
	      return prefix + t
	    })
	  }

	  // now we have something like:
	  // {b,c{d,e},{f,g}h}x{y,z}
	  // walk through the set, expanding each part, until
	  // the set ends.  then, we'll expand the suffix.
	  // If the set only has a single member, then'll put the {} back

	  // first, handle numeric sets, since they're easier
	  var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
	  if (numset) {
	    this.debug("numset", numset[1], numset[2])
	    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)
	      , start = +numset[1]
	      , end = +numset[2]
	      , inc = start > end ? -1 : 1
	      , set = []
	    for (var i = start; i != (end + inc); i += inc) {
	      // append all the suffixes
	      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	        set.push(i + suf[ii])
	      }
	    }
	    return set
	  }

	  // ok, walk through the set
	  // We hope, somewhat optimistically, that there
	  // will be a } at the end.
	  // If the closing brace isn't found, then the pattern is
	  // interpreted as braceExpand("\\" + pattern) so that
	  // the leading \{ will be interpreted literally.
	  var i = 1 // skip the \{
	    , depth = 1
	    , set = []
	    , member = ""
	    , sawEnd = false
	    , escaping = false

	  function addMember () {
	    set.push(member)
	    member = ""
	  }

	  this.debug("Entering for")
	  FOR: for (i = 1, l = pattern.length; i < l; i ++) {
	    var c = pattern.charAt(i)
	    this.debug("", i, c)

	    if (escaping) {
	      escaping = false
	      member += "\\" + c
	    } else {
	      switch (c) {
	        case "\\":
	          escaping = true
	          continue

	        case "{":
	          depth ++
	          member += "{"
	          continue

	        case "}":
	          depth --
	          // if this closes the actual set, then we're done
	          if (depth === 0) {
	            addMember()
	            // pluck off the close-brace
	            i ++
	            break FOR
	          } else {
	            member += c
	            continue
	          }

	        case ",":
	          if (depth === 1) {
	            addMember()
	          } else {
	            member += c
	          }
	          continue

	        default:
	          member += c
	          continue
	      } // switch
	    } // else
	  } // for

	  // now we've either finished the set, and the suffix is
	  // pattern.substr(i), or we have *not* closed the set,
	  // and need to escape the leading brace
	  if (depth !== 0) {
	    this.debug("didn't close", pattern)
	    return braceExpand.call(this, "\\" + pattern, options)
	  }

	  // x{y,z} -> ["xy", "xz"]
	  this.debug("set", set)
	  this.debug("suffix", pattern.substr(i))
	  var suf = braceExpand.call(this, pattern.substr(i), options)
	  // ["b", "c{d,e}","{f,g}h"] ->
	  //   [["b"], ["cd", "ce"], ["fh", "gh"]]
	  var addBraces = set.length === 1
	  this.debug("set pre-expanded", set)
	  set = set.map(function (p) {
	    return braceExpand.call(this, p, options)
	  }, this)
	  this.debug("set expanded", set)


	  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->
	  //   ["b", "cd", "ce", "fh", "gh"]
	  set = set.reduce(function (l, r) {
	    return l.concat(r)
	  })

	  if (addBraces) {
	    set = set.map(function (s) {
	      return "{" + s + "}"
	    })
	  }

	  // now attach the suffixes.
	  var ret = []
	  for (var i = 0, l = set.length; i < l; i ++) {
	    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {
	      ret.push(set[i] + suf[ii])
	    }
	  }
	  return ret
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === "**") return GLOBSTAR
	  if (pattern === "") return ""

	  var re = ""
	    , hasMagic = !!options.nocase
	    , escaping = false
	    // ? => one single character
	    , patternListStack = []
	    , plType
	    , stateChar
	    , inClass = false
	    , reClassStart = -1
	    , classStart = -1
	    // . and .. never match anything that doesn't start with .,
	    // even when options.dot is set.
	    , patternStart = pattern.charAt(0) === "." ? "" // anything
	      // not (start or / followed by . or .. followed by / or end)
	      : options.dot ? "(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))"
	      : "(?!\\.)"
	    , self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case "*":
	          re += star
	          hasMagic = true
	          break
	        case "?":
	          re += qmark
	          hasMagic = true
	          break
	        default:
	          re += "\\"+stateChar
	          break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for ( var i = 0, len = pattern.length, c
	      ; (i < len) && (c = pattern.charAt(i))
	      ; i ++ ) {

	    this.debug("%s\t%s %s %j", pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += "\\" + c
	      escaping = false
	      continue
	    }

	    SWITCH: switch (c) {
	      case "/":
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case "\\":
	        clearStateChar()
	        escaping = true
	        continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case "?":
	      case "*":
	      case "+":
	      case "@":
	      case "!":
	        this.debug("%s\t%s %s %j <-- stateChar", pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === "!" && i === classStart + 1) c = "^"
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	        continue

	      case "(":
	        if (inClass) {
	          re += "("
	          continue
	        }

	        if (!stateChar) {
	          re += "\\("
	          continue
	        }

	        plType = stateChar
	        patternListStack.push({ type: plType
	                              , start: i - 1
	                              , reStart: re.length })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === "!" ? "(?:(?!" : "(?:"
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	        continue

	      case ")":
	        if (inClass || !patternListStack.length) {
	          re += "\\)"
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        re += ")"
	        plType = patternListStack.pop().type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case "!":
	            re += "[^/]*?)"
	            break
	          case "?":
	          case "+":
	          case "*": re += plType
	          case "@": break // the default anyway
	        }
	        continue

	      case "|":
	        if (inClass || !patternListStack.length || escaping) {
	          re += "\\|"
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += "|"
	        continue

	      // these are mostly the same in regexp and glob
	      case "[":
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += "\\" + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	        continue

	      case "]":
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += "\\" + c
	          escaping = false
	          continue
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	        continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	                   && !(c === "^" && inClass)) {
	          re += "\\"
	        }

	        re += c

	    } // switch
	  } // for


	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    var cs = pattern.substr(classStart + 1)
	      , sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + "\\[" + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  var pl
	  while (pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = "\\"
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + "|"
	    })

	    this.debug("tail=%j\n   %s", tail, tail)
	    var t = pl.type === "*" ? star
	          : pl.type === "?" ? qmark
	          : "\\" + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart)
	       + t + "\\("
	       + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += "\\\\"
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case ".":
	    case "[":
	    case "(": addPatternStart = true
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== "" && hasMagic) re = "(?=.)" + re

	  if (addPatternStart) re = patternStart + re

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [ re, hasMagic ]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? "i" : ""
	    , regExp = new RegExp("^" + re + "$", flags)

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) return this.regexp = false
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	      : options.dot ? twoStarDot
	      : twoStarNoDot
	    , flags = options.nocase ? "i" : ""

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	           : (typeof p === "string") ? regExpEscape(p)
	           : p._src
	    }).join("\\\/")
	  }).join("|")

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = "^(?:" + re + ")$"

	  // can match anything, as long as it's not this.
	  if (this.negate) re = "^(?!" + re + ").*$"

	  try {
	    return this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    return this.regexp = false
	  }
	}

	minimatch.match = function (list, pattern, options) {
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug("match", f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ""

	  if (f === "/" && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  // On other platforms, \ is a valid (albeit bad) filename char.
	  if (platform === "win32") {
	    f = f.split("\\").join("/")
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, "split", f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, "set", set)

	  var splitFile = path.basename(f.join("/")).split("/")

	  for (var i = 0, l = set.length; i < l; i ++) {
	    var pattern = set[i], file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = splitFile
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug("matchOne",
	              { "this": this
	              , file: file
	              , pattern: pattern })

	  this.debug("matchOne", file.length, pattern.length)

	  for ( var fi = 0
	          , pi = 0
	          , fl = file.length
	          , pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi ++, pi ++ ) {

	    this.debug("matchOne loop")
	    var p = pattern[pi]
	      , f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	        , pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for ( ; fi < fl; fi ++) {
	          if (file[fi] === "." || file[fi] === ".." ||
	              (!options.dot && file[fi].charAt(0) === ".")) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      WHILE: while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while',
	                    file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === "." || swallowee === ".." ||
	              (!options.dot && swallowee.charAt(0) === ".")) {
	            this.debug("dot detected!", file, fr, pattern, pr)
	            break WHILE
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr ++
	        }
	      }
	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then 
	      if (partial) {
	        // ran out of file
	        this.debug("\n>>> no match, partial?", file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === "string") {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug("string match", p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug("pattern match", p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error("wtf?")
	}


	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, "$1")
	}


	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&")
	}

	})( typeof require === "function" ? require : null,
	    this,
	     true ? module : null,
	    typeof process === "object" ? process.platform : "win32"
	  )

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module), __webpack_require__(1)))

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* global a2c */
	'use strict';

	var regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\s*/,
	    regPathData = /[-+]?(?:\d*\.\d+|\d+\.?)([eE][-+]?\d+)?/g,
	    regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/,
	    transform2js = __webpack_require__(14).transform2js,
	    transformsMultiply = __webpack_require__(14).transformsMultiply,
	    transformArc = __webpack_require__(14).transformArc,
	    collections = __webpack_require__(4),
	    referencesProps = collections.referencesProps,
	    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],
	    cleanupOutData = __webpack_require__(22).cleanupOutData,
	    removeLeadingZero = __webpack_require__(22).removeLeadingZero,
	    prevCtrlPoint;

	/**
	 * Convert path string to JS representation.
	 *
	 * @param {String} pathString input string
	 * @param {Object} params plugin params
	 * @return {Array} output array
	 */
	exports.path2js = function(path) {
	    if (path.pathJS) return path.pathJS;

	    var paramsLength = { // Number of parameters of every path command
	            H: 1, V: 1, M: 2, L: 2, T: 2, Q: 4, S: 4, C: 6, A: 7,
	            h: 1, v: 1, m: 2, l: 2, t: 2, q: 4, s: 4, c: 6, a: 7
	        },
	        pathData = [],   // JS representation of the path data
	        instruction, // current instruction context
	        startMoveto = false;

	    // splitting path string into array like ['M', '10 50', 'L', '20 30']
	    path.attr('d').value.split(regPathInstructions).forEach(function(data) {
	        if (!data) return;
	        if (!startMoveto) {
	            if (data == 'M' || data == 'm') {
	                startMoveto = true;
	            } else return;
	        }

	        // instruction item
	        if (regPathInstructions.test(data)) {
	            instruction = data;

	            // z - instruction w/o data
	            if (instruction == 'Z' || instruction == 'z') {
	                pathData.push({
	                    instruction: 'z'
	                });
	            }
	        // data item
	        } else {
	            data = data.match(regPathData);
	            if (!data) return;

	            data = data.map(Number);

	            // Subsequent moveto pairs of coordinates are threated as implicit lineto commands
	            // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands
	            if (instruction == 'M' || instruction == 'm') {
	                pathData.push({
	                    instruction: pathData.length == 0 ? 'M' : instruction,
	                    data: data.splice(0, 2)
	                });
	                instruction = instruction == 'M' ? 'L' : 'l';
	            }

	            for (var pair = paramsLength[instruction]; data.length;) {
	                pathData.push({
	                    instruction: instruction,
	                    data: data.splice(0, pair)
	                });
	            }
	        }
	    });

	    // First moveto is actually absolute. Subsequent coordinates were separated above.
	    if (pathData.length && pathData[0].instruction == 'm') {
	        pathData[0].instruction = 'M';
	    }
	    path.pathJS = pathData;

	    return pathData;
	};

	/**
	 * Convert relative Path data to absolute.
	 *
	 * @param {Array} data input data
	 * @return {Array} output data
	 */
	var relative2absolute = exports.relative2absolute = function(data) {
	    var currentPoint = [0, 0],
	        subpathPoint = [0, 0],
	        i;

	    data = data.map(function(item) {

	        var instruction = item.instruction,
	            itemData = item.data && item.data.slice();

	        if (instruction == 'M') {

	            set(currentPoint, itemData);
	            set(subpathPoint, itemData);

	        } else if ('mlcsqt'.indexOf(instruction) > -1) {

	            for (i = 0; i < itemData.length; i++) {
	                itemData[i] += currentPoint[i % 2];
	            }
	            set(currentPoint, itemData);

	            if (instruction == 'm') {
	                set(subpathPoint, itemData);
	            }

	        } else if (instruction == 'a') {

	            itemData[5] += currentPoint[0];
	            itemData[6] += currentPoint[1];
	            set(currentPoint, itemData);

	        } else if (instruction == 'h') {

	            itemData[0] += currentPoint[0];
	            currentPoint[0] = itemData[0];

	        } else if (instruction == 'v') {

	            itemData[0] += currentPoint[1];
	            currentPoint[1] = itemData[0];

	        } else if ('MZLCSQTA'.indexOf(instruction) > -1) {

	            set(currentPoint, itemData);

	        } else if (instruction == 'H') {

	            currentPoint[0] = itemData[0];

	        } else if (instruction == 'V') {

	            currentPoint[1] = itemData[0];

	        } else if (instruction == 'z') {

	            set(currentPoint, subpathPoint);

	        }

	        return instruction == 'z' ?
	            { instruction: 'z' } :
	            {
	                instruction: instruction.toUpperCase(),
	                data: itemData
	            };

	    });

	    return data;
	};

	/**
	 * Apply transformation(s) to the Path data.
	 *
	 * @param {Object} elem current element
	 * @param {Array} path input path data
	 * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)
	 * @return {Array} output path data
	 */
	exports.applyTransforms = function(elem, path, params) {
	    // if there are no 'stroke' attr and references to other objects such as
	    // gradiends or clip-path which are also subjects to transform.
	    if (!elem.hasAttr('transform') || !elem.attr('transform').value ||
	        elem.someAttr(function(attr) {
	            return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');
	        }))
	        return path;

	    var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),
	        stroke = elem.computedAttr('stroke'),
	        id = elem.computedAttr('id'),
	        transformPrecision = params.transformPrecision,
	        newPoint, scale;

	    if (stroke && stroke != 'none') {
	        if (!params.applyTransformsStroked ||
	            (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) &&
	            (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
	            return path;

	        // "stroke-width" should be inside the part with ID, otherwise it can be overrided in <use>
	        if (id) {
	            var idElem = elem,
	                hasStrokeWidth = false;

	            do {
	                if (idElem.hasAttr('stroke-width')) hasStrokeWidth = true;
	            } while (!idElem.hasAttr('id', id) && !hasStrokeWidth && (idElem = idElem.parentNode));

	            if (!hasStrokeWidth) return path;
	        }

	        scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);

	        if (scale !== 1) {
	            var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;

	            if (elem.hasAttr('stroke-width')) {
	                elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim()
	                    .replace(regNumericValues, function(num) { return removeLeadingZero(num * scale) });
	            } else {
	                elem.addAttr({
	                    name: 'stroke-width',
	                    prefix: '',
	                    local: 'stroke-width',
	                    value: strokeWidth.replace(regNumericValues, function(num) { return removeLeadingZero(num * scale) })
	                });
	            }
	        }
	    } else if (id) { // Stroke and stroke-width can be redefined with <use>
	        return path;
	    }

	    path.forEach(function(pathItem) {

	        if (pathItem.data) {

	            // h -> l
	            if (pathItem.instruction === 'h') {

	                pathItem.instruction = 'l';
	                pathItem.data[1] = 0;

	            // v -> l
	            } else if (pathItem.instruction === 'v') {

	                pathItem.instruction = 'l';
	                pathItem.data[1] = pathItem.data[0];
	                pathItem.data[0] = 0;

	            }

	            // if there is a translate() transform
	            if (pathItem.instruction === 'M' &&
	                (matrix.data[4] !== 0 ||
	                matrix.data[5] !== 0)
	            ) {

	                // then apply it only to the first absoluted M
	                newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);
	                set(pathItem.data, newPoint);
	                set(pathItem.coords, newPoint);

	                // clear translate() data from transform matrix
	                matrix.data[4] = 0;
	                matrix.data[5] = 0;

	            } else {

	                if (pathItem.instruction == 'a') {

	                    transformArc(pathItem.data, matrix.data);

	                    // reduce number of digits in rotation angle
	                    if (Math.abs(pathItem.data[2]) > 80) {
	                        var a = pathItem.data[0],
	                            rotation = pathItem.data[2];
	                        pathItem.data[0] = pathItem.data[1];
	                        pathItem.data[1] = a;
	                        pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);
	                    }

	                    newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);
	                    pathItem.data[5] = newPoint[0];
	                    pathItem.data[6] = newPoint[1];

	                } else {

	                    for (var i = 0; i < pathItem.data.length; i += 2) {
	                        newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);
	                        pathItem.data[i] = newPoint[0];
	                        pathItem.data[i + 1] = newPoint[1];
	                    }
	                }

	                pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];
	                pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];

	            }

	        }

	    });

	    // remove transform attr
	    elem.removeAttr('transform');

	    return path;
	};

	/**
	 * Apply transform 3x3 matrix to x-y point.
	 *
	 * @param {Array} matrix transform 3x3 matrix
	 * @param {Array} point x-y point
	 * @return {Array} point with new coordinates
	 */
	function transformPoint(matrix, x, y) {

	    return [
	        matrix[0] * x + matrix[2] * y + matrix[4],
	        matrix[1] * x + matrix[3] * y + matrix[5]
	    ];

	}

	/**
	 * Compute Cubic Bézie bounding box.
	 *
	 * @see http://processingjs.nihongoresources.com/bezierinfo/
	 *
	 * @param {Float} xa
	 * @param {Float} ya
	 * @param {Float} xb
	 * @param {Float} yb
	 * @param {Float} xc
	 * @param {Float} yc
	 * @param {Float} xd
	 * @param {Float} yd
	 *
	 * @return {Object}
	 */
	exports.computeCubicBoundingBox = function(xa, ya, xb, yb, xc, yc, xd, yd) {

	    var minx = Number.POSITIVE_INFINITY,
	        miny = Number.POSITIVE_INFINITY,
	        maxx = Number.NEGATIVE_INFINITY,
	        maxy = Number.NEGATIVE_INFINITY,
	        ts,
	        t,
	        x,
	        y,
	        i;

	    // X
	    if (xa < minx) { minx = xa; }
	    if (xa > maxx) { maxx = xa; }
	    if (xd < minx) { minx= xd; }
	    if (xd > maxx) { maxx = xd; }

	    ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);

	    for (i = 0; i < ts.length; i++) {

	        t = ts[i];

	        if (t >= 0 && t <= 1) {
	            x = computeCubicBaseValue(t, xa, xb, xc, xd);
	            // y = computeCubicBaseValue(t, ya, yb, yc, yd);

	            if (x < minx) { minx = x; }
	            if (x > maxx) { maxx = x; }
	        }

	    }

	    // Y
	    if (ya < miny) { miny = ya; }
	    if (ya > maxy) { maxy = ya; }
	    if (yd < miny) { miny = yd; }
	    if (yd > maxy) { maxy = yd; }

	    ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);

	    for (i = 0; i < ts.length; i++) {

	        t = ts[i];

	        if (t >= 0 && t <= 1) {
	            // x = computeCubicBaseValue(t, xa, xb, xc, xd);
	            y = computeCubicBaseValue(t, ya, yb, yc, yd);

	            if (y < miny) { miny = y; }
	            if (y > maxy) { maxy = y; }
	        }

	    }

	    return {
	        minx: minx,
	        miny: miny,
	        maxx: maxx,
	        maxy: maxy
	    };

	};

	// compute the value for the cubic bezier function at time=t
	function computeCubicBaseValue(t, a, b, c, d) {

	    var mt = 1 - t;

	    return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;

	}

	// compute the value for the first derivative of the cubic bezier function at time=t
	function computeCubicFirstDerivativeRoots(a, b, c, d) {

	    var result = [-1, -1],
	        tl = -a + 2 * b - c,
	        tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),
	        dn = -a + 3 * b - 3 * c + d;

	    if (dn !== 0) {
	        result[0] = (tl + tr) / dn;
	        result[1] = (tl - tr) / dn;
	    }

	    return result;

	}

	/**
	 * Compute Quadratic Bézier bounding box.
	 *
	 * @see http://processingjs.nihongoresources.com/bezierinfo/
	 *
	 * @param {Float} xa
	 * @param {Float} ya
	 * @param {Float} xb
	 * @param {Float} yb
	 * @param {Float} xc
	 * @param {Float} yc
	 *
	 * @return {Object}
	 */
	exports.computeQuadraticBoundingBox = function(xa, ya, xb, yb, xc, yc) {

	    var minx = Number.POSITIVE_INFINITY,
	        miny = Number.POSITIVE_INFINITY,
	        maxx = Number.NEGATIVE_INFINITY,
	        maxy = Number.NEGATIVE_INFINITY,
	        t,
	        x,
	        y;

	    // X
	    if (xa < minx) { minx = xa; }
	    if (xa > maxx) { maxx = xa; }
	    if (xc < minx) { minx = xc; }
	    if (xc > maxx) { maxx = xc; }

	    t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);

	    if (t >= 0 && t <= 1) {
	        x = computeQuadraticBaseValue(t, xa, xb, xc);
	        // y = computeQuadraticBaseValue(t, ya, yb, yc);

	        if (x < minx) { minx = x; }
	        if (x > maxx) { maxx = x; }
	    }

	    // Y
	    if (ya < miny) { miny = ya; }
	    if (ya > maxy) { maxy = ya; }
	    if (yc < miny) { miny = yc; }
	    if (yc > maxy) { maxy = yc; }

	    t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);

	    if (t >= 0 && t <=1 ) {
	        // x = computeQuadraticBaseValue(t, xa, xb, xc);
	        y = computeQuadraticBaseValue(t, ya, yb, yc);

	        if (y < miny) { miny = y; }
	        if (y > maxy) { maxy = y ; }

	    }

	    return {
	        minx: minx,
	        miny: miny,
	        maxx: maxx,
	        maxy: maxy
	    };

	};

	// compute the value for the quadratic bezier function at time=t
	function computeQuadraticBaseValue(t, a, b, c) {

	    var mt = 1 - t;

	    return mt * mt * a + 2 * mt * t * b + t * t * c;

	}

	// compute the value for the first derivative of the quadratic bezier function at time=t
	function computeQuadraticFirstDerivativeRoot(a, b, c) {

	    var t = -1,
	        denominator = a - 2 * b + c;

	    if (denominator !== 0) {
	        t = (a - b) / denominator;
	    }

	    return t;

	}

	/**
	 * Convert path array to string.
	 *
	 * @param {Array} path input path data
	 * @param {Object} params plugin params
	 * @return {String} output path string
	 */
	exports.js2path = function(path, data, params) {

	    path.pathJS = data;

	    if (params.collapseRepeated) {
	        data = collapseRepeated(data);
	    }

	    path.attr('d').value = data.reduce(function(pathString, item) {
	        return pathString += item.instruction + (item.data ? cleanupOutData(item.data, params) : '');
	    }, '');

	};

	/**
	 * Collapse repeated instructions data
	 *
	 * @param {Array} path input path data
	 * @return {Array} output path data
	 */
	function collapseRepeated(data) {

	    var prev,
	        prevIndex;

	    // copy an array and modifieds item to keep original data untouched
	    data = data.reduce(function(newPath, item) {
	        if (
	            prev && item.data &&
	            item.instruction == prev.instruction
	        ) {
	            // concat previous data with current
	            if (item.instruction != 'M') {
	                prev = newPath[prevIndex] = {
	                    instruction: prev.instruction,
	                    data: prev.data.concat(item.data),
	                    coords: item.coords,
	                    base: prev.base
	                };
	            } else {
	                prev.data = item.data;
	                prev.coords = item.coords;
	            }
	        } else {
	            newPath.push(item);
	            prev = item;
	            prevIndex = newPath.length - 1;
	        }

	        return newPath;
	    }, []);

	    return data;

	}

	function set(dest, source) {
	    dest[0] = source[source.length - 2];
	    dest[1] = source[source.length - 1];
	    return dest;
	}

	/**
	 * Checks if two paths have an intersection by checking convex hulls
	 * collision using Gilbert-Johnson-Keerthi distance algorithm
	 * http://entropyinteractive.com/2011/04/gjk-algorithm/
	 *
	 * @param {Array} path1 JS path representation
	 * @param {Array} path2 JS path representation
	 * @return {Boolean}
	 */
	exports.intersects = function(path1, path2) {
	    if (path1.length < 3 || path2.length < 3) return false; // nothing to fill

	    // Collect points of every subpath.
	    var points1 = relative2absolute(path1).reduce(gatherPoints, []),
	        points2 = relative2absolute(path2).reduce(gatherPoints, []);

	    // Axis-aligned bounding box check.
	    if (points1.maxX <= points2.minX || points2.maxX <= points1.minX ||
	        points1.maxY <= points2.minY || points2.maxY <= points1.minY ||
	        points1.every(function (set1) {
	            return points2.every(function (set2) {
	                return set1[set1.maxX][0] <= set2[set2.minX][0] ||
	                    set2[set2.maxX][0] <= set1[set1.minX][0] ||
	                    set1[set1.maxY][1] <= set2[set2.minY][1] ||
	                    set2[set2.maxY][1] <= set1[set1.minY][1];
	            });
	        })
	    ) return false;

	    // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).
	    var hullNest1 = points1.map(convexHull),
	        hullNest2 = points2.map(convexHull);

	    // Check intersection of every subpath of the first path with every subpath of the second.
	    return hullNest1.some(function(hull1) {
	        if (hull1.length < 3) return false;

	        return hullNest2.some(function(hull2) {
	            if (hull2.length < 3) return false;

	            var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex
	                direction = minus(simplex[0]); // set the direction to point towards the origin

	            var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough
	            while (true) {
	                if (iterations-- == 0) {
	                    console.error('Error: infinite loop while processing mergePaths plugin.');
	                    return true; // true is the safe value that means “do nothing with paths”
	                }
	                // add a new point
	                simplex.push(getSupport(hull1, hull2, direction));
	                // see if the new point was on the correct side of the origin
	                if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
	                // process the simplex
	                if (processSimplex(simplex, direction)) return true;
	            }
	        });
	    });

	    function getSupport(a, b, direction) {
	        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
	    }

	    // Computes farthest polygon point in particular direction.
	    // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.
	    // Since we're working on convex hull, the dot product is increasing until we find the farthest point.
	    function supportPoint(polygon, direction) {
	        var index = direction[1] >= 0 ?
	                direction[0] < 0 ? polygon.maxY : polygon.maxX :
	                direction[0] < 0 ? polygon.minX : polygon.minY,
	            max = -Infinity,
	            value;
	        while ((value = dot(polygon[index], direction)) > max) {
	            max = value;
	            index = ++index % polygon.length;
	        }
	        return polygon[(index || polygon.length) - 1];
	    }
	};

	function processSimplex(simplex, direction) {
	    /* jshint -W004 */

	    // we only need to handle to 1-simplex and 2-simplex
	    if (simplex.length == 2) { // 1-simplex
	        var a = simplex[1],
	            b = simplex[0],
	            AO = minus(simplex[1]),
	            AB = sub(b, a);
	        // AO is in the same direction as AB
	        if (dot(AO, AB) > 0) {
	            // get the vector perpendicular to AB facing O
	            set(direction, orth(AB, a));
	        } else {
	            set(direction, AO);
	            // only A remains in the simplex
	            simplex.shift();
	        }
	    } else { // 2-simplex
	        var a = simplex[2], // [a, b, c] = simplex
	            b = simplex[1],
	            c = simplex[0],
	            AB = sub(b, a),
	            AC = sub(c, a),
	            AO = minus(a),
	            ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C
	            ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B

	        if (dot(ACB, AO) > 0) {
	            if (dot(AB, AO) > 0) { // region 4
	                set(direction, ACB);
	                simplex.shift(); // simplex = [b, a]
	            } else { // region 5
	                set(direction, AO);
	                simplex.splice(0, 2); // simplex = [a]
	            }
	        } else if (dot(ABC, AO) > 0) {
	            if (dot(AC, AO) > 0) { // region 6
	                set(direction, ABC);
	                simplex.splice(1, 1); // simplex = [c, a]
	            } else { // region 5 (again)
	                set(direction, AO);
	                simplex.splice(0, 2); // simplex = [a]
	            }
	        } else // region 7
	            return true;
	    }
	    return false;
	}

	function minus(v) {
	    return [-v[0], -v[1]];
	}

	function sub(v1, v2) {
	    return [v1[0] - v2[0], v1[1] - v2[1]];
	}

	function dot(v1, v2) {
	    return v1[0] * v2[0] + v1[1] * v2[1];
	}

	function orth(v, from) {
	    var o = [-v[1], v[0]];
	    return dot(o, minus(from)) < 0 ? minus(o) : o;
	}

	function gatherPoints(points, item, index, path) {

	    var subPath = points.length && points[points.length - 1],
	        prev = index && path[index - 1],
	        basePoint = subPath.length && subPath[subPath.length - 1],
	        data = item.data,
	        ctrlPoint = basePoint;

	    switch (item.instruction) {
	        case 'M':
	            points.push(subPath = []);
	            break;
	        case 'H':
	            addPoint(subPath, [data[0], basePoint[1]]);
	            break;
	        case 'V':
	            addPoint(subPath, [basePoint[0], data[0]]);
	            break;
	        case 'Q':
	            addPoint(subPath, data.slice(0, 2));
	            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand
	            break;
	        case 'T':
	            if (prev.instruction == 'Q' && prev.instruction == 'T') {
	                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];
	                addPoint(subPath, ctrlPoint);
	                prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
	            }
	            break;
	        case 'C':
	            // Approximate quibic Bezier curve with middle points between control points
	            addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);
	            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);
	            addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);
	            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand
	            break;
	        case 'S':
	            if (prev.instruction == 'C' && prev.instruction == 'S') {
	                addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);
	                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];
	            }
	            addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1]+ data[1])]);
	            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);
	            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
	            break;
	        case 'A':
	            // Convert the arc to bezier curves and use the same approximation
	            var curves = a2c.apply(0, basePoint.concat(data));
	            for (var cData; (cData = curves.splice(0,6).map(toAbsolute)).length;) {
	                addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);
	                addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);
	                addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);
	                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));
	            }
	            break;
	    }
	    // Save final command coordinates
	    if (data && data.length >= 2) addPoint(subPath, data.slice(-2));
	    return points;

	    function toAbsolute(n, i) { return n + basePoint[i % 2] }

	    // Writes data about the extreme points on each axle
	    function addPoint(path, point) {
	        if (!path.length || point[1] > path[path.maxY][1]) {
	            path.maxY = path.length;
	            points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];
	        }
	        if (!path.length || point[0] > path[path.maxX][0]) {
	            path.maxX = path.length;
	            points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];
	        }
	        if (!path.length || point[1] < path[path.minY][1]) {
	            path.minY = path.length;
	            points.minY = points.length ? Math.min(point[1], points.minY) : point[1];
	        }
	        if (!path.length || point[0] < path[path.minX][0]) {
	            path.minX = path.length;
	            points.minX = points.length ? Math.min(point[0], points.minX) : point[0];
	        }
	        path.push(point);
	    }
	}

	/**
	 * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.
	 * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain
	 *
	 * @param points An array of [X, Y] coordinates
	 */
	function convexHull(points) {
	    /* jshint -W004 */

	    points.sort(function(a, b) {
	        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
	    });

	    var lower = [],
	        minY = 0,
	        bottom = 0;
	    for (var i = 0; i < points.length; i++) {
	        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {
	            lower.pop();
	        }
	        if (points[i][1] < points[minY][1]) {
	            minY = i;
	            bottom = lower.length;
	        }
	        lower.push(points[i]);
	    }

	    var upper = [],
	        maxY = points.length - 1,
	        top = 0;
	    for (var i = points.length; i--;) {
	        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {
	            upper.pop();
	        }
	        if (points[i][1] > points[maxY][1]) {
	            maxY = i;
	            top = upper.length;
	        }
	        upper.push(points[i]);
	    }

	    // last points are equal to starting points of the other part
	    upper.pop();
	    lower.pop();

	    var hull = lower.concat(upper);

	    hull.minX = 0; // by sorting
	    hull.maxX = lower.length;
	    hull.minY = bottom;
	    hull.maxY = (lower.length + top) % hull.length;

	    return hull;
	}

	function cross(o, a, b) {
	    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
	}

	/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/
	 * Thanks to Dmitry Baranovskiy for his great work!
	 */

	// jshint ignore: start
	function a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
	    // for more information of where this Math came from visit:
	    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes
	    var _120 = Math.PI * 120 / 180,
	        rad = Math.PI / 180 * (+angle || 0),
	        res = [],
	        rotateX = function(x, y, rad) { return x * Math.cos(rad) - y * Math.sin(rad) },
	        rotateY = function(x, y, rad) { return x * Math.sin(rad) + y * Math.cos(rad) };
	    if (!recursive) {
	        x1 = rotateX(x1, y1, -rad);
	        y1 = rotateY(x1, y1, -rad);
	        x2 = rotateX(x2, y2, -rad);
	        y2 = rotateY(x2, y2, -rad);
	        var x = (x1 - x2) / 2,
	            y = (y1 - y2) / 2;
	        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);
	        if (h > 1) {
	            h = Math.sqrt(h);
	            rx = h * rx;
	            ry = h * ry;
	        }
	        var rx2 = rx * rx,
	            ry2 = ry * ry,
	            k = (large_arc_flag == sweep_flag ? -1 : 1) *
	                Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),
	            cx = k * rx * y / ry + (x1 + x2) / 2,
	            cy = k * -ry * x / rx + (y1 + y2) / 2,
	            f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),
	            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));

	        f1 = x1 < cx ? Math.PI - f1 : f1;
	        f2 = x2 < cx ? Math.PI - f2 : f2;
	        f1 < 0 && (f1 = Math.PI * 2 + f1);
	        f2 < 0 && (f2 = Math.PI * 2 + f2);
	        if (sweep_flag && f1 > f2) {
	            f1 = f1 - Math.PI * 2;
	        }
	        if (!sweep_flag && f2 > f1) {
	            f2 = f2 - Math.PI * 2;
	        }
	    } else {
	        f1 = recursive[0];
	        f2 = recursive[1];
	        cx = recursive[2];
	        cy = recursive[3];
	    }
	    var df = f2 - f1;
	    if (Math.abs(df) > _120) {
	        var f2old = f2,
	            x2old = x2,
	            y2old = y2;
	        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
	        x2 = cx + rx * Math.cos(f2);
	        y2 = cy + ry * Math.sin(f2);
	        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
	    }
	    df = f2 - f1;
	    var c1 = Math.cos(f1),
	        s1 = Math.sin(f1),
	        c2 = Math.cos(f2),
	        s2 = Math.sin(f2),
	        t = Math.tan(df / 4),
	        hx = 4 / 3 * rx * t,
	        hy = 4 / 3 * ry * t,
	        m = [
	            - hx * s1, hy * c1,
	            x2 + hx * s2 - x1, y2 - hy * c2 - y1,
	            x2 - x1, y2 - y1
	        ];
	    if (recursive) {
	        return m.concat(res);
	    } else {
	        res = m.concat(res);
	        var newres = [];
	        for (var i = 0, n = res.length; i < n; i++) {
	            newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);
	        }
	        return newres;
	    }
	}
	// jshint ignore: end


/***/ },
/* 14 */
/***/ function(module, exports) {

	'use strict';

	var regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,
	    regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/,
	    regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

	/**
	 * Convert transform string to JS representation.
	 *
	 * @param {String} transformString input string
	 * @param {Object} params plugin params
	 * @return {Array} output array
	 */
	exports.transform2js = function(transformString) {

	        // JS representation of the transform data
	    var transforms = [],
	        // current transform context
	        current;

	    // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']
	    transformString.split(regTransformSplit).forEach(function(item) {
	        /*jshint -W084 */
	        var num;

	        if (item) {
	            // if item is a translate function
	            if (regTransformTypes.test(item)) {
	                // then collect it and change current context
	                transforms.push(current = { name: item });
	            // else if item is data
	            } else {
	                // then split it into [10, 50] and collect as context.data
	                while (num = regNumericValues.exec(item)) {
	                    num = Number(num);
	                    if (current.data)
	                        current.data.push(num);
	                    else
	                        current.data = [num];
	                }
	            }
	        }
	    });

	    return transforms;

	};

	/**
	 * Multiply transforms into one.
	 *
	 * @param {Array} input transforms array
	 * @return {Array} output matrix array
	 */
	exports.transformsMultiply = function(transforms) {

	    // convert transforms objects to the matrices
	    transforms = transforms.map(function(transform) {
	        if (transform.name === 'matrix') {
	            return transform.data;
	        }
	        return transformToMatrix(transform);
	    });

	    // multiply all matrices into one
	    transforms = {
	        name: 'matrix',
	        data: transforms.reduce(function(a, b) {
	            return multiplyTransformMatrices(a, b);
	        })
	    };

	    return transforms;

	};

	/**
	 * Do math like a schoolgirl.
	 *
	 * @type {Object}
	 */
	var mth = exports.mth = {

	    rad: function(deg) {
	        return deg * Math.PI / 180;
	    },

	    deg: function(rad) {
	        return rad * 180 / Math.PI;
	    },

	    cos: function(deg) {
	        return Math.cos(this.rad(deg));
	    },

	    acos: function(val, floatPrecision) {
	        return +(this.deg(Math.acos(val)).toFixed(floatPrecision));
	    },

	    sin: function(deg) {
	        return Math.sin(this.rad(deg));
	    },

	    asin: function(val, floatPrecision) {
	        return +(this.deg(Math.asin(val)).toFixed(floatPrecision));
	    },

	    tan: function(deg) {
	        return Math.tan(this.rad(deg));
	    },

	    atan: function(val, floatPrecision) {
	        return +(this.deg(Math.atan(val)).toFixed(floatPrecision));
	    }

	};

	/**
	 * Decompose matrix into simple transforms. See
	 * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices
	 *
	 * @param {Object} data matrix transform object
	 * @return {Object|Array} transforms array or original transform object
	 */
	exports.matrixToTransform = function(transform, params) {
	    var floatPrecision = params.floatPrecision,
	        data = transform.data,
	        transforms = [],
	        sx = +Math.sqrt(data[0] * data[0] + data[1] * data[1]).toFixed(params.transformPrecision),
	        sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),
	        colsSum = data[0] * data[2] + data[1] * data[3],
	        rowsSum = data[0] * data[1] + data[2] * data[3],
	        scaleBefore = rowsSum || +(sx == sy);

	    // [..., ..., ..., ..., tx, ty] → translate(tx, ty)
	    if (data[4] || data[5]) {
	        transforms.push({ name: 'translate', data: data.slice(4, data[5] ? 6 : 5) });
	    }

	    // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)
	    if (!data[1] && data[2]) {
	        transforms.push({ name: 'skewX', data: [mth.atan(data[2] / sy, floatPrecision)] });

	    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)
	    } else if (data[1] && !data[2]) {
	        transforms.push({ name: 'skewY', data: [mth.atan(data[1] / data[0], floatPrecision)] });
	        sx = data[0];
	        sy = data[3];

	    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or
	    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)
	    } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {
	        if (!scaleBefore) {
	            sx = (data[0] < 0 ? -1 : 1) * Math.sqrt(data[0] * data[0] + data[2] * data[2]);
	            sy = (data[3] < 0 ? -1 : 1) * Math.sqrt(data[1] * data[1] + data[3] * data[3]);
	            transforms.push({ name: 'scale', data: [sx, sy] });
	        }
	        var rotate = [mth.acos(data[0] / sx, floatPrecision) * (data[1] * sy < 0 ? -1 : 1)];

	        if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });

	        if (rowsSum && colsSum) transforms.push({
	            name: 'skewX',
	            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]
	        });

	        // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)
	        if (rotate[0] && (data[4] || data[5])) {
	            transforms.shift();
	            var cos = data[0] / sx,
	                sin = data[1] / (scaleBefore ? sx : sy),
	                x = data[4] * (scaleBefore || sy),
	                y = data[5] * (scaleBefore || sx),
	                denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);
	            rotate.push(((1 - cos) * x - sin * y) / denom);
	            rotate.push(((1 - cos) * y + sin * x) / denom);
	        }

	    // Too many transformations, return original matrix if it isn't just a scale/translate
	    } else if (data[1] || data[2]) {
	        return transform;
	    }

	    if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({
	        name: 'scale',
	        data: sx == sy ? [sx] : [sx, sy]
	    });

	    return transforms;
	};

	/**
	 * Convert transform to the matrix data.
	 *
	 * @param {Object} transform transform object
	 * @return {Array} matrix data
	 */
	function transformToMatrix(transform) {

	    if (transform.name === 'matrix') return transform.data;

	    var matrix;

	    switch (transform.name) {
	        case 'translate':
	            // [1, 0, 0, 1, tx, ty]
	            matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
	            break;
	        case 'scale':
	            // [sx, 0, 0, sy, 0, 0]
	            matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];
	            break;
	        case 'rotate':
	            // [cos(a), sin(a), -sin(a), cos(a), x, y]
	            var cos = mth.cos(transform.data[0]),
	                sin = mth.sin(transform.data[0]),
	                cx = transform.data[1] || 0,
	                cy = transform.data[2] || 0;

	            matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];
	            break;
	        case 'skewX':
	            // [1, 0, tan(a), 1, 0, 0]
	            matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
	            break;
	        case 'skewY':
	            // [1, tan(a), 0, 1, 0, 0]
	            matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
	            break;
	    }

	    return matrix;

	}

	/**
	 * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it
	 * by the transformation matrix and use a singular value decomposition to represent in a form
	 * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.
	 * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})
	 *
	 * @param {Array} arc [a, b, rotation in deg]
	 * @param {Array} transform transformation matrix
	 * @return {Array} arc transformed input arc
	 */
	exports.transformArc = function(arc, transform) {

	    var a = arc[0],
	        b = arc[1],
	        rot = arc[2] * Math.PI / 180,
	        cos = Math.cos(rot),
	        sin = Math.sin(rot),
	        h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) +
	            Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);
	    if (h > 1) {
	        h = Math.sqrt(h);
	        a *= h;
	        b *= h;
	    }
	    var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],
	        m = multiplyTransformMatrices(transform, ellipse),
	        // Decompose the new ellipse matrix
	        lastCol = m[2] * m[2] + m[3] * m[3],
	        squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,
	        root = Math.sqrt(
	            (Math.pow(m[0] - m[3], 2) + Math.pow(m[1] + m[2], 2)) *
	            (Math.pow(m[0] + m[3], 2) + Math.pow(m[1] - m[2], 2))
	        );

	    if (!root) { // circle
	        arc[0] = arc[1] = Math.sqrt(squareSum / 2);
	        arc[2] = 0;
	    } else {
	        var majorAxisSqr = (squareSum + root) / 2,
	            minorAxisSqr = (squareSum - root) / 2,
	            major = Math.abs(majorAxisSqr - lastCol) > 1e-6,
	            sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,
	            rowsSum = m[0] * m[2] + m[1] * m[3],
	            term1 = m[0] * sub + m[2] * rowsSum,
	            term2 = m[1] * sub + m[3] * rowsSum;
	        arc[0] = Math.sqrt(majorAxisSqr);
	        arc[1] = Math.sqrt(minorAxisSqr);
	        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) *
	            Math.acos((major ? term1 : term2) / Math.sqrt(term1 * term1 + term2 * term2)) * 180 / Math.PI;
	    }
	    return arc;

	};

	/**
	 * Multiply transformation matrices.
	 *
	 * @param {Array} a matrix A data
	 * @param {Array} b matrix B data
	 * @return {Array} result
	 */
	function multiplyTransformMatrices(a, b) {

	    return [
	        a[0] * b[0] + a[2] * b[1],
	        a[1] * b[0] + a[3] * b[1],
	        a[0] * b[2] + a[2] * b[3],
	        a[1] * b[2] + a[3] * b[3],
	        a[0] * b[4] + a[2] * b[5] + a[4],
	        a[1] * b[4] + a[3] * b[5] + a[5]
	    ];

	}


/***/ },
/* 15 */
/***/ function(module, exports) {

	//
	//            item        item        item        item
	//          /------\    /------\    /------\    /------\
	//          | data |    | data |    | data |    | data |
	//  null <--+-prev |<---+-prev |<---+-prev |<---+-prev |
	//          | next-+--->| next-+--->| next-+--->| next-+--> null
	//          \------/    \------/    \------/    \------/
	//             ^                                    ^
	//             |                list                |
	//             |              /------\              |
	//             \--------------+-head |              |
	//                            | tail-+--------------/
	//                            \------/
	//

	function createItem(data) {
	    return {
	        data: data,
	        next: null,
	        prev: null
	    };
	}

	var List = function(values) {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;

	    if (Array.isArray(values)) {
	        var cursor = null;

	        for (var i = 0; i < values.length; i++) {
	            var item = createItem(values[i]);

	            if (cursor !== null) {
	                cursor.next = item;
	            } else {
	                this.head = item;
	            }

	            item.prev = cursor;
	            cursor = item;
	        }

	        this.tail = cursor;
	    }
	};

	Object.defineProperty(List.prototype, 'size', {
	    get: function() {
	        var size = 0;
	        var cursor = this.head;

	        while (cursor) {
	            size++;
	            cursor = cursor.next;
	        }

	        return size;
	    }
	});

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};
	List.prototype.toJSON = function() {
	    return this.toArray();
	};

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;
	    var cursor = {
	        prev: null,
	        next: this.head,
	        cursor: this.cursor
	    };

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    this.cursor = cursor;

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    this.cursor = this.cursor.cursor;
	};

	List.prototype.eachRight = function(fn, context) {
	    var item;
	    var cursor = {
	        prev: this.tail,
	        next: null,
	        cursor: this.cursor
	    };

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    this.cursor = cursor;

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    this.cursor = this.cursor.cursor;
	};

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;
	    var cursor = {
	        prev: null,
	        next: start,
	        cursor: this.cursor
	    };

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    this.cursor = cursor;

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    this.cursor = this.cursor.cursor;
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;
	    var cursor = {
	        prev: start,
	        next: null,
	        cursor: this.cursor
	    };

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    this.cursor = cursor;

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    this.cursor = this.cursor.cursor;
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = [];
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.push(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (prevNew === true || cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (nextNew === true || cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t below to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //     item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if list has a tail, then it also has a head, but head doesn't change

	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = item;
	        }

	        // tail always start point to new item
	        this.tail = item;
	    }
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t below to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t below to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.appendList = function(list) {
	    // ignore empty lists
	    if (list.head === null) {
	        return;
	    }

	    this.updateCursors(this.tail, list.tail, null, list.head);

	    // insert to end of the list
	    if (this.tail !== null) {
	        // if destination list has a tail, then it also has a head,
	        // but head doesn't change

	        // dest tail -> source head
	        this.tail.next = list.head;

	        // dest tail <- source head
	        list.head.prev = this.tail;
	    } else {
	        // if list has no a tail, then it also has no a head
	        // in this case points head to new item
	        this.head = list.head;
	    }

	    // tail always start point to new item
	    this.tail = list.tail;

	    list.head = null;
	    list.tail = null;
	};

	module.exports = List;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	'use strict';

	/*<replacement>*/

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	module.exports = Duplex;

	/*<replacement>*/
	var processNextTick = __webpack_require__(43);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var Readable = __webpack_require__(70);
	var Writable = __webpack_require__(45);

	util.inherits(Duplex, Readable);

	var keys = objectKeys(Writable.prototype);
	for (var v = 0; v < keys.length; v++) {
	  var method = keys[v];
	  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  processNextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = __webpack_require__(2).Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     }


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = exports.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}


/***/ },
/* 18 */
/***/ function(module, exports) {

	function each(list) {
	    if (list.head === null) {
	        return '';
	    }

	    if (list.head === list.tail) {
	        return translate(list.head.data);
	    }

	    return list.map(translate).join('');
	}

	function eachDelim(list, delimeter) {
	    if (list.head === null) {
	        return '';
	    }

	    if (list.head === list.tail) {
	        return translate(list.head.data);
	    }

	    return list.map(translate).join(delimeter);
	}

	function translate(node) {
	    switch (node.type) {
	        case 'StyleSheet':
	            return each(node.rules);

	        case 'Atrule':
	            var result = '@' + node.name;

	            if (node.expression && !node.expression.sequence.isEmpty()) {
	                result += ' ' + translate(node.expression);
	            }

	            if (node.block) {
	                return result + '{' + translate(node.block) + '}';
	            } else {
	                return result + ';';
	            }

	        case 'Ruleset':
	            return translate(node.selector) + '{' + translate(node.block) + '}';

	        case 'Selector':
	            return eachDelim(node.selectors, ',');

	        case 'SimpleSelector':
	            return node.sequence.map(function(node) {
	                // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced
	                if (node.type === 'Combinator' && node.name === '/deep/') {
	                    return ' ' + translate(node) + ' ';
	                }

	                return translate(node);
	            }).join('');

	        case 'Declaration':
	            return translate(node.property) + ':' + translate(node.value);

	        case 'Property':
	            return node.name;

	        case 'Value':
	            return node.important
	                ? each(node.sequence) + '!important'
	                : each(node.sequence);

	        case 'Attribute':
	            var result = translate(node.name);

	            if (node.operator !== null) {
	                result += node.operator;

	                if (node.value !== null) {
	                    result += translate(node.value);

	                    if (node.flags !== null) {
	                        result += (node.value.type !== 'String' ? ' ' : '') + node.flags;
	                    }
	                }
	            }

	            return '[' + result + ']';

	        case 'FunctionalPseudo':
	            return ':' + node.name + '(' + eachDelim(node.arguments, ',') + ')';

	        case 'Function':
	            return node.name + '(' + eachDelim(node.arguments, ',') + ')';

	        case 'Block':
	            return eachDelim(node.declarations, ';');

	        case 'Negation':
	            return ':not(' + eachDelim(node.sequence, ',') + ')';

	        case 'Braces':
	            return node.open + each(node.sequence) + node.close;

	        case 'Argument':
	        case 'AtruleExpression':
	            return each(node.sequence);

	        case 'Url':
	            return 'url(' + translate(node.value) + ')';

	        case 'Progid':
	            return translate(node.value);

	        case 'Combinator':
	            return node.name;

	        case 'Identifier':
	            return node.name;

	        case 'PseudoClass':
	            return ':' + node.name;

	        case 'PseudoElement':
	            return '::' + node.name;

	        case 'Class':
	            return '.' + node.name;

	        case 'Id':
	            return '#' + node.name;

	        case 'Hash':
	            return '#' + node.value;

	        case 'Dimension':
	            return node.value + node.unit;

	        case 'Nth':
	            return node.value;

	        case 'Number':
	            return node.value;

	        case 'String':
	            return node.value;

	        case 'Operator':
	            return node.value;

	        case 'Raw':
	            return node.value;

	        case 'Unknown':
	            return node.value;

	        case 'Percentage':
	            return node.value + '%';

	        case 'Space':
	            return ' ';

	        case 'Comment':
	            return '/*' + node.value + '*/';

	        default:
	            throw new Error('Unknown node type: ' + node.type);
	    }
	}

	module.exports = translate;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var Readable = __webpack_require__(52);
	var Writable = __webpack_require__(54);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 20 */
/***/ function(module, exports) {

	'use strict';


	function isNothing(subject) {
	  return (typeof subject === 'undefined') || (subject === null);
	}


	function isObject(subject) {
	  return (typeof subject === 'object') && (subject !== null);
	}


	function toArray(sequence) {
	  if (Array.isArray(sequence)) return sequence;
	  else if (isNothing(sequence)) return [];

	  return [ sequence ];
	}


	function extend(target, source) {
	  var index, length, key, sourceKeys;

	  if (source) {
	    sourceKeys = Object.keys(source);

	    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
	      key = sourceKeys[index];
	      target[key] = source[key];
	    }
	  }

	  return target;
	}


	function repeat(string, count) {
	  var result = '', cycle;

	  for (cycle = 0; cycle < count; cycle += 1) {
	    result += string;
	  }

	  return result;
	}


	function isNegativeZero(number) {
	  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
	}


	module.exports.isNothing      = isNothing;
	module.exports.isObject       = isObject;
	module.exports.toArray        = toArray;
	module.exports.repeat         = repeat;
	module.exports.isNegativeZero = isNegativeZero;
	module.exports.extend         = extend;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*eslint-disable max-len*/

	var common        = __webpack_require__(20);
	var YAMLException = __webpack_require__(26);
	var Type          = __webpack_require__(5);


	function compileList(schema, name, result) {
	  var exclude = [];

	  schema.include.forEach(function (includedSchema) {
	    result = compileList(includedSchema, name, result);
	  });

	  schema[name].forEach(function (currentType) {
	    result.forEach(function (previousType, previousIndex) {
	      if (previousType.tag === currentType.tag) {
	        exclude.push(previousIndex);
	      }
	    });

	    result.push(currentType);
	  });

	  return result.filter(function (type, index) {
	    return exclude.indexOf(index) === -1;
	  });
	}


	function compileMap(/* lists... */) {
	  var result = {}, index, length;

	  function collectType(type) {
	    result[type.tag] = type;
	  }

	  for (index = 0, length = arguments.length; index < length; index += 1) {
	    arguments[index].forEach(collectType);
	  }

	  return result;
	}


	function Schema(definition) {
	  this.include  = definition.include  || [];
	  this.implicit = definition.implicit || [];
	  this.explicit = definition.explicit || [];

	  this.implicit.forEach(function (type) {
	    if (type.loadKind && type.loadKind !== 'scalar') {
	      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
	    }
	  });

	  this.compiledImplicit = compileList(this, 'implicit', []);
	  this.compiledExplicit = compileList(this, 'explicit', []);
	  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
	}


	Schema.DEFAULT = null;


	Schema.create = function createSchema() {
	  var schemas, types;

	  switch (arguments.length) {
	    case 1:
	      schemas = Schema.DEFAULT;
	      types = arguments[0];
	      break;

	    case 2:
	      schemas = arguments[0];
	      types = arguments[1];
	      break;

	    default:
	      throw new YAMLException('Wrong number of arguments for Schema.create function');
	  }

	  schemas = common.toArray(schemas);
	  types = common.toArray(types);

	  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
	    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
	  }

	  if (!types.every(function (type) { return type instanceof Type; })) {
	    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
	  }

	  return new Schema({
	    include: schemas,
	    explicit: types
	  });
	};


	module.exports = Schema;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	/**
	 * Encode plain SVG data string into Data URI string.
	 *
	 * @param {String} str input string
	 * @param {String} type Data URI type
	 * @return {String} output string
	 */
	exports.encodeSVGDatauri = function(str, type) {

	    var prefix = 'data:image/svg+xml';

	    // base64
	    if (!type || type === 'base64') {

	        prefix += ';base64,';

	        str = prefix + new Buffer(str).toString('base64');

	    // URI encoded
	    } else if (type === 'enc') {

	        str = prefix + ',' + encodeURIComponent(str);

	    // unencoded
	    } else if (type === 'unenc') {

	        str = prefix + ',' + str;

	    }

	    return str;

	};

	/**
	 * Decode SVG Data URI string into plain SVG string.
	 *
	 * @param {string} str input string
	 * @return {String} output string
	 */
	exports.decodeSVGDatauri = function(str) {
	    var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
	    var match = regexp.exec(str);

	    // plain string
	    if (!match) return str;

	    var data = match[3];

	    // base64
	    if (match[2]) {

	        str = new Buffer(data, 'base64').toString('utf8');

	    // URI encoded
	    } else if (data.charAt(0) === '%') {

	        str = decodeURIComponent(data);

	    // unencoded
	    } else if (data.charAt(0) === '<') {

	        str = data;

	    }

	    return str;
	};

	exports.intersectArrays = function(a, b) {
	    return a.filter(function(n) {
	        return b.indexOf(n) > -1;
	    });
	};

	exports.cleanupOutData = function(data, params) {

	    var str = '',
	        delimiter,
	        prev;

	    data.forEach(function(item, i) {

	        // space delimiter by default
	        delimiter = ' ';

	        // no extra space in front of first number
	        if (i === 0) {
	            delimiter = '';
	        }

	        // remove floating-point numbers leading zeros
	        // 0.5 → .5
	        // -0.5 → -.5
	        if (params.leadingZero) {
	            item = removeLeadingZero(item);
	        }

	        // no extra space in front of negative number or
	        // in front of a floating number if a previous number is floating too
	        if (
	            params.negativeExtraSpace &&
	            (item < 0 ||
	                (/^\./.test(item) && prev % 1 !== 0)
	            )
	        ) {
	            delimiter = '';
	        }

	        // save prev item value
	        prev = item;

	        str += delimiter + item;

	    });

	    return str;

	};

	/**
	 * Remove floating-point numbers leading zero.
	 *
	 * @example
	 * 0.5 → .5
	 *
	 * @example
	 * -0.5 → -.5
	 *
	 * @param {Float} num input number
	 *
	 * @return {String} output number as string
	 */
	var removeLeadingZero = exports.removeLeadingZero = function(num) {

	    if (num > 0 && num < 1) {
	        num = ('' + num).slice(1);
	    } else if (num < 0 && num > -1) {
	        num = '-' + ('' + num).slice(2);
	    }

	    return num;

	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Monkey-patching the fs module.
	// It's ugly, but there is simply no other way to do this.
	var fs = module.exports = __webpack_require__(122)

	var assert = __webpack_require__(30)

	// fix up some busted stuff, mostly on windows and old nodes
	__webpack_require__(314)

	var util = __webpack_require__(9)

	function noop () {}

	var debug = noop
	if (util.debuglog)
	  debug = util.debuglog('gfs')
	else if (/\bgfs\b/i.test(process.env.NODE_DEBUG || ''))
	  debug = function() {
	    var m = util.format.apply(util, arguments)
	    m = 'GFS: ' + m.split(/\n/).join('\nGFS: ')
	    console.error(m)
	  }

	if (/\bgfs\b/i.test(process.env.NODE_DEBUG || '')) {
	  process.on('exit', function() {
	    debug('fds', fds)
	    debug(queue)
	    assert.equal(queue.length, 0)
	  })
	}


	var originalOpen = fs.open
	fs.open = open

	function open(path, flags, mode, cb) {
	  if (typeof mode === "function") cb = mode, mode = null
	  if (typeof cb !== "function") cb = noop
	  new OpenReq(path, flags, mode, cb)
	}

	function OpenReq(path, flags, mode, cb) {
	  this.path = path
	  this.flags = flags
	  this.mode = mode
	  this.cb = cb
	  Req.call(this)
	}

	util.inherits(OpenReq, Req)

	OpenReq.prototype.process = function() {
	  originalOpen.call(fs, this.path, this.flags, this.mode, this.done)
	}

	var fds = {}
	OpenReq.prototype.done = function(er, fd) {
	  debug('open done', er, fd)
	  if (fd)
	    fds['fd' + fd] = this.path
	  Req.prototype.done.call(this, er, fd)
	}


	var originalReaddir = fs.readdir
	fs.readdir = readdir

	function readdir(path, cb) {
	  if (typeof cb !== "function") cb = noop
	  new ReaddirReq(path, cb)
	}

	function ReaddirReq(path, cb) {
	  this.path = path
	  this.cb = cb
	  Req.call(this)
	}

	util.inherits(ReaddirReq, Req)

	ReaddirReq.prototype.process = function() {
	  originalReaddir.call(fs, this.path, this.done)
	}

	ReaddirReq.prototype.done = function(er, files) {
	  if (files && files.sort)
	    files = files.sort()
	  Req.prototype.done.call(this, er, files)
	  onclose()
	}


	var originalClose = fs.close
	fs.close = close

	function close (fd, cb) {
	  debug('close', fd)
	  if (typeof cb !== "function") cb = noop
	  delete fds['fd' + fd]
	  originalClose.call(fs, fd, function(er) {
	    onclose()
	    cb(er)
	  })
	}


	var originalCloseSync = fs.closeSync
	fs.closeSync = closeSync

	function closeSync (fd) {
	  try {
	    return originalCloseSync(fd)
	  } finally {
	    onclose()
	  }
	}


	// Req class
	function Req () {
	  // start processing
	  this.done = this.done.bind(this)
	  this.failures = 0
	  this.process()
	}

	Req.prototype.done = function (er, result) {
	  var tryAgain = false
	  if (er) {
	    var code = er.code
	    var tryAgain = code === "EMFILE" || code === "ENFILE"
	    if (process.platform === "win32")
	      tryAgain = tryAgain || code === "OK"
	  }

	  if (tryAgain) {
	    this.failures ++
	    enqueue(this)
	  } else {
	    var cb = this.cb
	    cb(er, result)
	  }
	}

	var queue = []

	function enqueue(req) {
	  queue.push(req)
	  debug('enqueue %d %s', queue.length, req.constructor.name, req)
	}

	function onclose() {
	  var req = queue.shift()
	  if (req) {
	    debug('process', req.constructor.name, req)
	    req.process()
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__( 322 );

/***/ },
/* 25 */
/***/ function(module, exports) {

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var knownKeywords = Object.create(null);
	var knownProperties = Object.create(null);

	function getVendorPrefix(string) {
	    if (string[0] === '-') {
	        // skip 2 chars to avoid wrong match with variables names
	        var secondDashIndex = string.indexOf('-', 2);

	        if (secondDashIndex !== -1) {
	            return string.substr(0, secondDashIndex + 1);
	        }
	    }

	    return '';
	}

	function getKeywordInfo(keyword) {
	    if (hasOwnProperty.call(knownKeywords, keyword)) {
	        return knownKeywords[keyword];
	    }

	    var lowerCaseKeyword = keyword.toLowerCase();
	    var vendor = getVendorPrefix(lowerCaseKeyword);
	    var name = lowerCaseKeyword;

	    if (vendor) {
	        name = name.substr(vendor.length);
	    }

	    return knownKeywords[keyword] = Object.freeze({
	        vendor: vendor,
	        prefix: vendor,
	        name: name
	    });
	}

	function getPropertyInfo(property) {
	    if (hasOwnProperty.call(knownProperties, property)) {
	        return knownProperties[property];
	    }

	    var lowerCaseProperty = property.toLowerCase();
	    var hack = lowerCaseProperty[0];

	    if (hack === '*' || hack === '_' || hack === '$') {
	        lowerCaseProperty = lowerCaseProperty.substr(1);
	    } else if (hack === '/' && property[1] === '/') {
	        hack = '//';
	        lowerCaseProperty = lowerCaseProperty.substr(2);
	    } else {
	        hack = '';
	    }

	    var vendor = getVendorPrefix(lowerCaseProperty);
	    var name = lowerCaseProperty;

	    if (vendor) {
	        name = name.substr(vendor.length);
	    }

	    return knownProperties[property] = Object.freeze({
	        hack: hack,
	        vendor: vendor,
	        prefix: hack + vendor,
	        name: name
	    });
	}

	module.exports = {
	    keyword: getKeywordInfo,
	    property: getPropertyInfo
	};


/***/ },
/* 26 */
/***/ function(module, exports) {

	// YAML error class. http://stackoverflow.com/questions/8458984
	//
	'use strict';

	function YAMLException(reason, mark) {
	  // Super constructor
	  Error.call(this);

	  // Include stack trace in error object
	  if (Error.captureStackTrace) {
	    // Chrome and NodeJS
	    Error.captureStackTrace(this, this.constructor);
	  } else {
	    // FF, IE 10+ and Safari 6+. Fallback for others
	    this.stack = (new Error()).stack || '';
	  }

	  this.name = 'YAMLException';
	  this.reason = reason;
	  this.mark = mark;
	  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
	}


	// Inherit from Error
	YAMLException.prototype = Object.create(Error.prototype);
	YAMLException.prototype.constructor = YAMLException;


	YAMLException.prototype.toString = function toString(compact) {
	  var result = this.name + ': ';

	  result += this.reason || '(unknown reason)';

	  if (!compact && this.mark) {
	    result += ' ' + this.mark.toString();
	  }

	  return result;
	};


	module.exports = YAMLException;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `safeLoad` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on standard YAML's Core schema and includes most of
	// extra types described at YAML tag repository. (http://yaml.org/type/)


	'use strict';


	var Schema = __webpack_require__(21);


	module.exports = new Schema({
	  include: [
	    __webpack_require__(65)
	  ],
	  implicit: [
	    __webpack_require__(248),
	    __webpack_require__(241)
	  ],
	  explicit: [
	    __webpack_require__(233),
	    __webpack_require__(243),
	    __webpack_require__(244),
	    __webpack_require__(246)
	  ]
	});


/***/ },
/* 28 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.]*)(?::(\d+))?(\S*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || !!aPath.match(urlRegexp);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = mappingA.source - mappingB.source;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return mappingA.name - mappingB.name;
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Transform = __webpack_require__(297)
	  , inherits  = __webpack_require__(9).inherits
	  , xtend     = __webpack_require__(124)

	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}

	inherits(DestroyableTransform, Transform)

	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}

	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}


	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }

	    if (typeof transform != 'function')
	      transform = noop

	    if (typeof flush != 'function')
	      flush = null

	    return construct(options, transform, flush)
	  }
	}


	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)

	    this.options = xtend(options, override)

	    DestroyableTransform.call(this, this.options)
	  }

	  inherits(Through2, DestroyableTransform)

	  Through2.prototype._transform = transform

	  if (flush)
	    Through2.prototype._flush = flush

	  return Through2
	})


	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
	// original notice:

	/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
	 * @license  MIT
	 */
	function compare(a, b) {
	  if (a === b) {
	    return 0;
	  }

	  var x = a.length;
	  var y = b.length;

	  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
	    if (a[i] !== b[i]) {
	      x = a[i];
	      y = b[i];
	      break;
	    }
	  }

	  if (x < y) {
	    return -1;
	  }
	  if (y < x) {
	    return 1;
	  }
	  return 0;
	}
	function isBuffer(b) {
	  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
	    return global.Buffer.isBuffer(b);
	  }
	  return !!(b != null && b._isBuffer);
	}

	// based on node assert, original notice:

	// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
	//
	// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
	//
	// Originally from narwhal.js (http://narwhaljs.org)
	// Copyright (c) 2009 Thomas Robinson <280north.com>
	//
	// Permission is hereby granted, free of charge, to any person obtaining a copy
	// of this software and associated documentation files (the 'Software'), to
	// deal in the Software without restriction, including without limitation the
	// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	// sell copies of the Software, and to permit persons to whom the Software is
	// furnished to do so, subject to the following conditions:
	//
	// The above copyright notice and this permission notice shall be included in
	// all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	var util = __webpack_require__(9);
	var hasOwn = Object.prototype.hasOwnProperty;
	var pSlice = Array.prototype.slice;
	var functionsHaveNames = (function () {
	  return function foo() {}.name === 'foo';
	}());
	function pToString (obj) {
	  return Object.prototype.toString.call(obj);
	}
	function isView(arrbuf) {
	  if (isBuffer(arrbuf)) {
	    return false;
	  }
	  if (typeof global.ArrayBuffer !== 'function') {
	    return false;
	  }
	  if (typeof ArrayBuffer.isView === 'function') {
	    return ArrayBuffer.isView(arrbuf);
	  }
	  if (!arrbuf) {
	    return false;
	  }
	  if (arrbuf instanceof DataView) {
	    return true;
	  }
	  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
	    return true;
	  }
	  return false;
	}
	// 1. The assert module provides functions that throw
	// AssertionError's when particular conditions are not met. The
	// assert module must conform to the following interface.

	var assert = module.exports = ok;

	// 2. The AssertionError is defined in assert.
	// new assert.AssertionError({ message: message,
	//                             actual: actual,
	//                             expected: expected })

	var regex = /\s*function\s+([^\(\s]*)\s*/;
	// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
	function getName(func) {
	  if (!util.isFunction(func)) {
	    return;
	  }
	  if (functionsHaveNames) {
	    return func.name;
	  }
	  var str = func.toString();
	  var match = str.match(regex);
	  return match && match[1];
	}
	assert.AssertionError = function AssertionError(options) {
	  this.name = 'AssertionError';
	  this.actual = options.actual;
	  this.expected = options.expected;
	  this.operator = options.operator;
	  if (options.message) {
	    this.message = options.message;
	    this.generatedMessage = false;
	  } else {
	    this.message = getMessage(this);
	    this.generatedMessage = true;
	  }
	  var stackStartFunction = options.stackStartFunction || fail;
	  if (Error.captureStackTrace) {
	    Error.captureStackTrace(this, stackStartFunction);
	  } else {
	    // non v8 browsers so we can have a stacktrace
	    var err = new Error();
	    if (err.stack) {
	      var out = err.stack;

	      // try to strip useless frames
	      var fn_name = getName(stackStartFunction);
	      var idx = out.indexOf('\n' + fn_name);
	      if (idx >= 0) {
	        // once we have located the function frame
	        // we need to strip out everything before it (and its line)
	        var next_line = out.indexOf('\n', idx + 1);
	        out = out.substring(next_line + 1);
	      }

	      this.stack = out;
	    }
	  }
	};

	// assert.AssertionError instanceof Error
	util.inherits(assert.AssertionError, Error);

	function truncate(s, n) {
	  if (typeof s === 'string') {
	    return s.length < n ? s : s.slice(0, n);
	  } else {
	    return s;
	  }
	}
	function inspect(something) {
	  if (functionsHaveNames || !util.isFunction(something)) {
	    return util.inspect(something);
	  }
	  var rawname = getName(something);
	  var name = rawname ? ': ' + rawname : '';
	  return '[Function' +  name + ']';
	}
	function getMessage(self) {
	  return truncate(inspect(self.actual), 128) + ' ' +
	         self.operator + ' ' +
	         truncate(inspect(self.expected), 128);
	}

	// At present only the three keys mentioned above are used and
	// understood by the spec. Implementations or sub modules can pass
	// other keys to the AssertionError's constructor - they will be
	// ignored.

	// 3. All of the following functions must throw an AssertionError
	// when a corresponding condition is not met, with a message that
	// may be undefined if not provided.  All assertion methods provide
	// both the actual and expected values to the assertion error for
	// display purposes.

	function fail(actual, expected, message, operator, stackStartFunction) {
	  throw new assert.AssertionError({
	    message: message,
	    actual: actual,
	    expected: expected,
	    operator: operator,
	    stackStartFunction: stackStartFunction
	  });
	}

	// EXTENSION! allows for well behaved errors defined elsewhere.
	assert.fail = fail;

	// 4. Pure assertion tests whether a value is truthy, as determined
	// by !!guard.
	// assert.ok(guard, message_opt);
	// This statement is equivalent to assert.equal(true, !!guard,
	// message_opt);. To test strictly for the value true, use
	// assert.strictEqual(true, guard, message_opt);.

	function ok(value, message) {
	  if (!value) fail(value, true, message, '==', assert.ok);
	}
	assert.ok = ok;

	// 5. The equality assertion tests shallow, coercive equality with
	// ==.
	// assert.equal(actual, expected, message_opt);

	assert.equal = function equal(actual, expected, message) {
	  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
	};

	// 6. The non-equality assertion tests for whether two objects are not equal
	// with != assert.notEqual(actual, expected, message_opt);

	assert.notEqual = function notEqual(actual, expected, message) {
	  if (actual == expected) {
	    fail(actual, expected, message, '!=', assert.notEqual);
	  }
	};

	// 7. The equivalence assertion tests a deep equality relation.
	// assert.deepEqual(actual, expected, message_opt);

	assert.deepEqual = function deepEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
	  }
	};

	assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
	  if (!_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
	  }
	};

	function _deepEqual(actual, expected, strict, memos) {
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (isBuffer(actual) && isBuffer(expected)) {
	    return compare(actual, expected) === 0;

	  // 7.2. If the expected value is a Date object, the actual value is
	  // equivalent if it is also a Date object that refers to the same time.
	  } else if (util.isDate(actual) && util.isDate(expected)) {
	    return actual.getTime() === expected.getTime();

	  // 7.3 If the expected value is a RegExp object, the actual value is
	  // equivalent if it is also a RegExp object with the same source and
	  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
	  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
	    return actual.source === expected.source &&
	           actual.global === expected.global &&
	           actual.multiline === expected.multiline &&
	           actual.lastIndex === expected.lastIndex &&
	           actual.ignoreCase === expected.ignoreCase;

	  // 7.4. Other pairs that do not both pass typeof value == 'object',
	  // equivalence is determined by ==.
	  } else if ((actual === null || typeof actual !== 'object') &&
	             (expected === null || typeof expected !== 'object')) {
	    return strict ? actual === expected : actual == expected;

	  // If both values are instances of typed arrays, wrap their underlying
	  // ArrayBuffers in a Buffer each to increase performance
	  // This optimization requires the arrays to have the same type as checked by
	  // Object.prototype.toString (aka pToString). Never perform binary
	  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
	  // bit patterns are not identical.
	  } else if (isView(actual) && isView(expected) &&
	             pToString(actual) === pToString(expected) &&
	             !(actual instanceof Float32Array ||
	               actual instanceof Float64Array)) {
	    return compare(new Uint8Array(actual.buffer),
	                   new Uint8Array(expected.buffer)) === 0;

	  // 7.5 For all other Object pairs, including Array objects, equivalence is
	  // determined by having the same number of owned properties (as verified
	  // with Object.prototype.hasOwnProperty.call), the same set of keys
	  // (although not necessarily the same order), equivalent values for every
	  // corresponding key, and an identical 'prototype' property. Note: this
	  // accounts for both named and indexed properties on Arrays.
	  } else if (isBuffer(actual) !== isBuffer(expected)) {
	    return false;
	  } else {
	    memos = memos || {actual: [], expected: []};

	    var actualIndex = memos.actual.indexOf(actual);
	    if (actualIndex !== -1) {
	      if (actualIndex === memos.expected.indexOf(expected)) {
	        return true;
	      }
	    }

	    memos.actual.push(actual);
	    memos.expected.push(expected);

	    return objEquiv(actual, expected, strict, memos);
	  }
	}

	function isArguments(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	}

	function objEquiv(a, b, strict, actualVisitedObjects) {
	  if (a === null || a === undefined || b === null || b === undefined)
	    return false;
	  // if one is a primitive, the other must be same
	  if (util.isPrimitive(a) || util.isPrimitive(b))
	    return a === b;
	  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
	    return false;
	  var aIsArgs = isArguments(a);
	  var bIsArgs = isArguments(b);
	  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
	    return false;
	  if (aIsArgs) {
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return _deepEqual(a, b, strict);
	  }
	  var ka = objectKeys(a);
	  var kb = objectKeys(b);
	  var key, i;
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length !== kb.length)
	    return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] !== kb[i])
	      return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
	      return false;
	  }
	  return true;
	}

	// 8. The non-equivalence assertion tests for any deep inequality.
	// assert.notDeepEqual(actual, expected, message_opt);

	assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, false)) {
	    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
	  }
	};

	assert.notDeepStrictEqual = notDeepStrictEqual;
	function notDeepStrictEqual(actual, expected, message) {
	  if (_deepEqual(actual, expected, true)) {
	    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
	  }
	}


	// 9. The strict equality assertion tests strict equality, as determined by ===.
	// assert.strictEqual(actual, expected, message_opt);

	assert.strictEqual = function strictEqual(actual, expected, message) {
	  if (actual !== expected) {
	    fail(actual, expected, message, '===', assert.strictEqual);
	  }
	};

	// 10. The strict non-equality assertion tests for strict inequality, as
	// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);

	assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
	  if (actual === expected) {
	    fail(actual, expected, message, '!==', assert.notStrictEqual);
	  }
	};

	function expectedException(actual, expected) {
	  if (!actual || !expected) {
	    return false;
	  }

	  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
	    return expected.test(actual);
	  }

	  try {
	    if (actual instanceof expected) {
	      return true;
	    }
	  } catch (e) {
	    // Ignore.  The instanceof check doesn't work for arrow functions.
	  }

	  if (Error.isPrototypeOf(expected)) {
	    return false;
	  }

	  return expected.call({}, actual) === true;
	}

	function _tryBlock(block) {
	  var error;
	  try {
	    block();
	  } catch (e) {
	    error = e;
	  }
	  return error;
	}

	function _throws(shouldThrow, block, expected, message) {
	  var actual;

	  if (typeof block !== 'function') {
	    throw new TypeError('"block" argument must be a function');
	  }

	  if (typeof expected === 'string') {
	    message = expected;
	    expected = null;
	  }

	  actual = _tryBlock(block);

	  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
	            (message ? ' ' + message : '.');

	  if (shouldThrow && !actual) {
	    fail(actual, expected, 'Missing expected exception' + message);
	  }

	  var userProvidedMessage = typeof message === 'string';
	  var isUnwantedException = !shouldThrow && util.isError(actual);
	  var isUnexpectedException = !shouldThrow && actual && !expected;

	  if ((isUnwantedException &&
	      userProvidedMessage &&
	      expectedException(actual, expected)) ||
	      isUnexpectedException) {
	    fail(actual, expected, 'Got unwanted exception' + message);
	  }

	  if ((shouldThrow && actual && expected &&
	      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
	    throw actual;
	  }
	}

	// 11. Expected to throw an error:
	// assert.throws(block, Error_opt, message_opt);

	assert.throws = function(block, /*optional*/error, /*optional*/message) {
	  _throws(true, block, error, message);
	};

	// EXTENSION! This is annoying to write outside this module.
	assert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {
	  _throws(false, block, error, message);
	};

	assert.ifError = function(err) { if (err) throw err; };

	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    if (hasOwn.call(obj, key)) keys.push(key);
	  }
	  return keys;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 31 */
/***/ function(module, exports) {

	function packNumber(value) {
	    // 100 -> '100'
	    // 00100 -> '100'
	    // +100 -> '100'
	    // -100 -> '-100'
	    // 0.123 -> '.123'
	    // 0.12300 -> '.123'
	    // 0.0 -> ''
	    // 0 -> ''
	    value = String(value).replace(/^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/, '$1$2$3');

	    if (value.length === 0 || value === '-') {
	        value = '0';
	    }

	    return value;
	};

	module.exports = function(node) {
	    node.value = packNumber(node.value);
	};
	module.exports.pack = packNumber;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	// JS-YAML's default schema for `load` function.
	// It is not described in the YAML specification.
	//
	// This schema is based on JS-YAML's default safe schema and includes
	// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
	//
	// Also this schema is used as default base schema at `Schema.create` function.


	'use strict';


	var Schema = __webpack_require__(21);


	module.exports = Schema.DEFAULT = new Schema({
	  include: [
	    __webpack_require__(27)
	  ],
	  explicit: [
	    __webpack_require__(239),
	    __webpack_require__(238),
	    __webpack_require__(237)
	  ]
	});


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = minimatch
	minimatch.Minimatch = Minimatch

	var path = { sep: '/' }
	try {
	  path = __webpack_require__(6)
	} catch (er) {}

	var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
	var expand = __webpack_require__(137)

	// any single thing other than /
	// don't need to escape / when using new RegExp()
	var qmark = '[^/]'

	// * => any number of characters
	var star = qmark + '*?'

	// ** when dots are allowed.  Anything goes, except .. and .
	// not (^ or / followed by one or two dots followed by $ or /),
	// followed by anything, any number of times.
	var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

	// not a ^ or / followed by a dot,
	// followed by anything, any number of times.
	var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

	// characters that need to be escaped in RegExp.
	var reSpecials = charSet('().*{}+?[]^$\\!')

	// "abc" -> { a:true, b:true, c:true }
	function charSet (s) {
	  return s.split('').reduce(function (set, c) {
	    set[c] = true
	    return set
	  }, {})
	}

	// normalizes slashes.
	var slashSplit = /\/+/

	minimatch.filter = filter
	function filter (pattern, options) {
	  options = options || {}
	  return function (p, i, list) {
	    return minimatch(p, pattern, options)
	  }
	}

	function ext (a, b) {
	  a = a || {}
	  b = b || {}
	  var t = {}
	  Object.keys(b).forEach(function (k) {
	    t[k] = b[k]
	  })
	  Object.keys(a).forEach(function (k) {
	    t[k] = a[k]
	  })
	  return t
	}

	minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return minimatch

	  var orig = minimatch

	  var m = function minimatch (p, pattern, options) {
	    return orig.minimatch(p, pattern, ext(def, options))
	  }

	  m.Minimatch = function Minimatch (pattern, options) {
	    return new orig.Minimatch(pattern, ext(def, options))
	  }

	  return m
	}

	Minimatch.defaults = function (def) {
	  if (!def || !Object.keys(def).length) return Minimatch
	  return minimatch.defaults(def).Minimatch
	}

	function minimatch (p, pattern, options) {
	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}

	  // shortcut: comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    return false
	  }

	  // "" only matches ""
	  if (pattern.trim() === '') return p === ''

	  return new Minimatch(pattern, options).match(p)
	}

	function Minimatch (pattern, options) {
	  if (!(this instanceof Minimatch)) {
	    return new Minimatch(pattern, options)
	  }

	  if (typeof pattern !== 'string') {
	    throw new TypeError('glob pattern string required')
	  }

	  if (!options) options = {}
	  pattern = pattern.trim()

	  // windows support: need to use /, not \
	  if (path.sep !== '/') {
	    pattern = pattern.split(path.sep).join('/')
	  }

	  this.options = options
	  this.set = []
	  this.pattern = pattern
	  this.regexp = null
	  this.negate = false
	  this.comment = false
	  this.empty = false

	  // make the set of regexps etc.
	  this.make()
	}

	Minimatch.prototype.debug = function () {}

	Minimatch.prototype.make = make
	function make () {
	  // don't do it more than once.
	  if (this._made) return

	  var pattern = this.pattern
	  var options = this.options

	  // empty patterns and comments match nothing.
	  if (!options.nocomment && pattern.charAt(0) === '#') {
	    this.comment = true
	    return
	  }
	  if (!pattern) {
	    this.empty = true
	    return
	  }

	  // step 1: figure out negation, etc.
	  this.parseNegate()

	  // step 2: expand braces
	  var set = this.globSet = this.braceExpand()

	  if (options.debug) this.debug = console.error

	  this.debug(this.pattern, set)

	  // step 3: now we have a set, so turn each one into a series of path-portion
	  // matching patterns.
	  // These will be regexps, except in the case of "**", which is
	  // set to the GLOBSTAR object for globstar behavior,
	  // and will not contain any / characters
	  set = this.globParts = set.map(function (s) {
	    return s.split(slashSplit)
	  })

	  this.debug(this.pattern, set)

	  // glob --> regexps
	  set = set.map(function (s, si, set) {
	    return s.map(this.parse, this)
	  }, this)

	  this.debug(this.pattern, set)

	  // filter out everything that didn't compile properly.
	  set = set.filter(function (s) {
	    return s.indexOf(false) === -1
	  })

	  this.debug(this.pattern, set)

	  this.set = set
	}

	Minimatch.prototype.parseNegate = parseNegate
	function parseNegate () {
	  var pattern = this.pattern
	  var negate = false
	  var options = this.options
	  var negateOffset = 0

	  if (options.nonegate) return

	  for (var i = 0, l = pattern.length
	    ; i < l && pattern.charAt(i) === '!'
	    ; i++) {
	    negate = !negate
	    negateOffset++
	  }

	  if (negateOffset) this.pattern = pattern.substr(negateOffset)
	  this.negate = negate
	}

	// Brace expansion:
	// a{b,c}d -> abd acd
	// a{b,}c -> abc ac
	// a{0..3}d -> a0d a1d a2d a3d
	// a{b,c{d,e}f}g -> abg acdfg acefg
	// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
	//
	// Invalid sets are not expanded.
	// a{2..}b -> a{2..}b
	// a{b}c -> a{b}c
	minimatch.braceExpand = function (pattern, options) {
	  return braceExpand(pattern, options)
	}

	Minimatch.prototype.braceExpand = braceExpand

	function braceExpand (pattern, options) {
	  if (!options) {
	    if (this instanceof Minimatch) {
	      options = this.options
	    } else {
	      options = {}
	    }
	  }

	  pattern = typeof pattern === 'undefined'
	    ? this.pattern : pattern

	  if (typeof pattern === 'undefined') {
	    throw new Error('undefined pattern')
	  }

	  if (options.nobrace ||
	    !pattern.match(/\{.*\}/)) {
	    // shortcut. no need to expand.
	    return [pattern]
	  }

	  return expand(pattern)
	}

	// parse a component of the expanded set.
	// At this point, no pattern may contain "/" in it
	// so we're going to return a 2d array, where each entry is the full
	// pattern, split on '/', and then turned into a regular expression.
	// A regexp is made at the end which joins each array with an
	// escaped /, and another full one which joins each regexp with |.
	//
	// Following the lead of Bash 4.1, note that "**" only has special meaning
	// when it is the *only* thing in a path portion.  Otherwise, any series
	// of * is equivalent to a single *.  Globstar behavior is enabled by
	// default, and can be disabled by setting options.noglobstar.
	Minimatch.prototype.parse = parse
	var SUBPARSE = {}
	function parse (pattern, isSub) {
	  var options = this.options

	  // shortcuts
	  if (!options.noglobstar && pattern === '**') return GLOBSTAR
	  if (pattern === '') return ''

	  var re = ''
	  var hasMagic = !!options.nocase
	  var escaping = false
	  // ? => one single character
	  var patternListStack = []
	  var negativeLists = []
	  var plType
	  var stateChar
	  var inClass = false
	  var reClassStart = -1
	  var classStart = -1
	  // . and .. never match anything that doesn't start with .,
	  // even when options.dot is set.
	  var patternStart = pattern.charAt(0) === '.' ? '' // anything
	  // not (start or / followed by . or .. followed by / or end)
	  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
	  : '(?!\\.)'
	  var self = this

	  function clearStateChar () {
	    if (stateChar) {
	      // we had some state-tracking character
	      // that wasn't consumed by this pass.
	      switch (stateChar) {
	        case '*':
	          re += star
	          hasMagic = true
	        break
	        case '?':
	          re += qmark
	          hasMagic = true
	        break
	        default:
	          re += '\\' + stateChar
	        break
	      }
	      self.debug('clearStateChar %j %j', stateChar, re)
	      stateChar = false
	    }
	  }

	  for (var i = 0, len = pattern.length, c
	    ; (i < len) && (c = pattern.charAt(i))
	    ; i++) {
	    this.debug('%s\t%s %s %j', pattern, i, re, c)

	    // skip over any that are escaped.
	    if (escaping && reSpecials[c]) {
	      re += '\\' + c
	      escaping = false
	      continue
	    }

	    switch (c) {
	      case '/':
	        // completely not allowed, even escaped.
	        // Should already be path-split by now.
	        return false

	      case '\\':
	        clearStateChar()
	        escaping = true
	      continue

	      // the various stateChar values
	      // for the "extglob" stuff.
	      case '?':
	      case '*':
	      case '+':
	      case '@':
	      case '!':
	        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

	        // all of those are literals inside a class, except that
	        // the glob [!a] means [^a] in regexp
	        if (inClass) {
	          this.debug('  in class')
	          if (c === '!' && i === classStart + 1) c = '^'
	          re += c
	          continue
	        }

	        // if we already have a stateChar, then it means
	        // that there was something like ** or +? in there.
	        // Handle the stateChar, then proceed with this one.
	        self.debug('call clearStateChar %j', stateChar)
	        clearStateChar()
	        stateChar = c
	        // if extglob is disabled, then +(asdf|foo) isn't a thing.
	        // just clear the statechar *now*, rather than even diving into
	        // the patternList stuff.
	        if (options.noext) clearStateChar()
	      continue

	      case '(':
	        if (inClass) {
	          re += '('
	          continue
	        }

	        if (!stateChar) {
	          re += '\\('
	          continue
	        }

	        plType = stateChar
	        patternListStack.push({
	          type: plType,
	          start: i - 1,
	          reStart: re.length
	        })
	        // negation is (?:(?!js)[^/]*)
	        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
	        this.debug('plType %j %j', stateChar, re)
	        stateChar = false
	      continue

	      case ')':
	        if (inClass || !patternListStack.length) {
	          re += '\\)'
	          continue
	        }

	        clearStateChar()
	        hasMagic = true
	        re += ')'
	        var pl = patternListStack.pop()
	        plType = pl.type
	        // negation is (?:(?!js)[^/]*)
	        // The others are (?:<pattern>)<type>
	        switch (plType) {
	          case '!':
	            negativeLists.push(pl)
	            re += ')[^/]*?)'
	            pl.reEnd = re.length
	            break
	          case '?':
	          case '+':
	          case '*':
	            re += plType
	            break
	          case '@': break // the default anyway
	        }
	      continue

	      case '|':
	        if (inClass || !patternListStack.length || escaping) {
	          re += '\\|'
	          escaping = false
	          continue
	        }

	        clearStateChar()
	        re += '|'
	      continue

	      // these are mostly the same in regexp and glob
	      case '[':
	        // swallow any state-tracking char before the [
	        clearStateChar()

	        if (inClass) {
	          re += '\\' + c
	          continue
	        }

	        inClass = true
	        classStart = i
	        reClassStart = re.length
	        re += c
	      continue

	      case ']':
	        //  a right bracket shall lose its special
	        //  meaning and represent itself in
	        //  a bracket expression if it occurs
	        //  first in the list.  -- POSIX.2 2.8.3.2
	        if (i === classStart + 1 || !inClass) {
	          re += '\\' + c
	          escaping = false
	          continue
	        }

	        // handle the case where we left a class open.
	        // "[z-a]" is valid, equivalent to "\[z-a\]"
	        if (inClass) {
	          // split where the last [ was, make sure we don't have
	          // an invalid re. if so, re-walk the contents of the
	          // would-be class to re-translate any characters that
	          // were passed through as-is
	          // TODO: It would probably be faster to determine this
	          // without a try/catch and a new RegExp, but it's tricky
	          // to do safely.  For now, this is safe and works.
	          var cs = pattern.substring(classStart + 1, i)
	          try {
	            RegExp('[' + cs + ']')
	          } catch (er) {
	            // not a valid class!
	            var sp = this.parse(cs, SUBPARSE)
	            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
	            hasMagic = hasMagic || sp[1]
	            inClass = false
	            continue
	          }
	        }

	        // finish up the class.
	        hasMagic = true
	        inClass = false
	        re += c
	      continue

	      default:
	        // swallow any state char that wasn't consumed
	        clearStateChar()

	        if (escaping) {
	          // no need
	          escaping = false
	        } else if (reSpecials[c]
	          && !(c === '^' && inClass)) {
	          re += '\\'
	        }

	        re += c

	    } // switch
	  } // for

	  // handle the case where we left a class open.
	  // "[abc" is valid, equivalent to "\[abc"
	  if (inClass) {
	    // split where the last [ was, and escape it
	    // this is a huge pita.  We now have to re-walk
	    // the contents of the would-be class to re-translate
	    // any characters that were passed through as-is
	    cs = pattern.substr(classStart + 1)
	    sp = this.parse(cs, SUBPARSE)
	    re = re.substr(0, reClassStart) + '\\[' + sp[0]
	    hasMagic = hasMagic || sp[1]
	  }

	  // handle the case where we had a +( thing at the *end*
	  // of the pattern.
	  // each pattern list stack adds 3 chars, and we need to go through
	  // and escape any | chars that were passed through as-is for the regexp.
	  // Go through and escape them, taking care not to double-escape any
	  // | chars that were already escaped.
	  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
	    var tail = re.slice(pl.reStart + 3)
	    // maybe some even number of \, then maybe 1 \, followed by a |
	    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
	      if (!$2) {
	        // the | isn't already escaped, so escape it.
	        $2 = '\\'
	      }

	      // need to escape all those slashes *again*, without escaping the
	      // one that we need for escaping the | character.  As it works out,
	      // escaping an even number of slashes can be done by simply repeating
	      // it exactly after itself.  That's why this trick works.
	      //
	      // I am sorry that you have to see this.
	      return $1 + $1 + $2 + '|'
	    })

	    this.debug('tail=%j\n   %s', tail, tail)
	    var t = pl.type === '*' ? star
	      : pl.type === '?' ? qmark
	      : '\\' + pl.type

	    hasMagic = true
	    re = re.slice(0, pl.reStart) + t + '\\(' + tail
	  }

	  // handle trailing things that only matter at the very end.
	  clearStateChar()
	  if (escaping) {
	    // trailing \\
	    re += '\\\\'
	  }

	  // only need to apply the nodot start if the re starts with
	  // something that could conceivably capture a dot
	  var addPatternStart = false
	  switch (re.charAt(0)) {
	    case '.':
	    case '[':
	    case '(': addPatternStart = true
	  }

	  // Hack to work around lack of negative lookbehind in JS
	  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
	  // like 'a.xyz.yz' doesn't match.  So, the first negative
	  // lookahead, has to look ALL the way ahead, to the end of
	  // the pattern.
	  for (var n = negativeLists.length - 1; n > -1; n--) {
	    var nl = negativeLists[n]

	    var nlBefore = re.slice(0, nl.reStart)
	    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
	    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
	    var nlAfter = re.slice(nl.reEnd)

	    nlLast += nlAfter

	    // Handle nested stuff like *(*.js|!(*.json)), where open parens
	    // mean that we should *not* include the ) in the bit that is considered
	    // "after" the negated section.
	    var openParensBefore = nlBefore.split('(').length - 1
	    var cleanAfter = nlAfter
	    for (i = 0; i < openParensBefore; i++) {
	      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
	    }
	    nlAfter = cleanAfter

	    var dollar = ''
	    if (nlAfter === '' && isSub !== SUBPARSE) {
	      dollar = '$'
	    }
	    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
	    re = newRe
	  }

	  // if the re is not "" at this point, then we need to make sure
	  // it doesn't match against an empty path part.
	  // Otherwise a/* will match a/, which it should not.
	  if (re !== '' && hasMagic) {
	    re = '(?=.)' + re
	  }

	  if (addPatternStart) {
	    re = patternStart + re
	  }

	  // parsing just a piece of a larger pattern.
	  if (isSub === SUBPARSE) {
	    return [re, hasMagic]
	  }

	  // skip the regexp for non-magical patterns
	  // unescape anything in it, though, so that it'll be
	  // an exact match against a file etc.
	  if (!hasMagic) {
	    return globUnescape(pattern)
	  }

	  var flags = options.nocase ? 'i' : ''
	  var regExp = new RegExp('^' + re + '$', flags)

	  regExp._glob = pattern
	  regExp._src = re

	  return regExp
	}

	minimatch.makeRe = function (pattern, options) {
	  return new Minimatch(pattern, options || {}).makeRe()
	}

	Minimatch.prototype.makeRe = makeRe
	function makeRe () {
	  if (this.regexp || this.regexp === false) return this.regexp

	  // at this point, this.set is a 2d array of partial
	  // pattern strings, or "**".
	  //
	  // It's better to use .match().  This function shouldn't
	  // be used, really, but it's pretty convenient sometimes,
	  // when you just want to work with a regex.
	  var set = this.set

	  if (!set.length) {
	    this.regexp = false
	    return this.regexp
	  }
	  var options = this.options

	  var twoStar = options.noglobstar ? star
	    : options.dot ? twoStarDot
	    : twoStarNoDot
	  var flags = options.nocase ? 'i' : ''

	  var re = set.map(function (pattern) {
	    return pattern.map(function (p) {
	      return (p === GLOBSTAR) ? twoStar
	      : (typeof p === 'string') ? regExpEscape(p)
	      : p._src
	    }).join('\\\/')
	  }).join('|')

	  // must match entire pattern
	  // ending in a * or ** will make it less strict.
	  re = '^(?:' + re + ')$'

	  // can match anything, as long as it's not this.
	  if (this.negate) re = '^(?!' + re + ').*$'

	  try {
	    this.regexp = new RegExp(re, flags)
	  } catch (ex) {
	    this.regexp = false
	  }
	  return this.regexp
	}

	minimatch.match = function (list, pattern, options) {
	  options = options || {}
	  var mm = new Minimatch(pattern, options)
	  list = list.filter(function (f) {
	    return mm.match(f)
	  })
	  if (mm.options.nonull && !list.length) {
	    list.push(pattern)
	  }
	  return list
	}

	Minimatch.prototype.match = match
	function match (f, partial) {
	  this.debug('match', f, this.pattern)
	  // short-circuit in the case of busted things.
	  // comments, etc.
	  if (this.comment) return false
	  if (this.empty) return f === ''

	  if (f === '/' && partial) return true

	  var options = this.options

	  // windows: need to use /, not \
	  if (path.sep !== '/') {
	    f = f.split(path.sep).join('/')
	  }

	  // treat the test path as a set of pathparts.
	  f = f.split(slashSplit)
	  this.debug(this.pattern, 'split', f)

	  // just ONE of the pattern sets in this.set needs to match
	  // in order for it to be valid.  If negating, then just one
	  // match means that we have failed.
	  // Either way, return on the first hit.

	  var set = this.set
	  this.debug(this.pattern, 'set', set)

	  // Find the basename of the path by looking for the last non-empty segment
	  var filename
	  var i
	  for (i = f.length - 1; i >= 0; i--) {
	    filename = f[i]
	    if (filename) break
	  }

	  for (i = 0; i < set.length; i++) {
	    var pattern = set[i]
	    var file = f
	    if (options.matchBase && pattern.length === 1) {
	      file = [filename]
	    }
	    var hit = this.matchOne(file, pattern, partial)
	    if (hit) {
	      if (options.flipNegate) return true
	      return !this.negate
	    }
	  }

	  // didn't get any hits.  this is success if it's a negative
	  // pattern, failure otherwise.
	  if (options.flipNegate) return false
	  return this.negate
	}

	// set partial to true to test if, for example,
	// "/a/b" matches the start of "/*/b/*/d"
	// Partial means, if you run out of file before you run
	// out of pattern, then that's fine, as long as all
	// the parts match.
	Minimatch.prototype.matchOne = function (file, pattern, partial) {
	  var options = this.options

	  this.debug('matchOne',
	    { 'this': this, file: file, pattern: pattern })

	  this.debug('matchOne', file.length, pattern.length)

	  for (var fi = 0,
	      pi = 0,
	      fl = file.length,
	      pl = pattern.length
	      ; (fi < fl) && (pi < pl)
	      ; fi++, pi++) {
	    this.debug('matchOne loop')
	    var p = pattern[pi]
	    var f = file[fi]

	    this.debug(pattern, p, f)

	    // should be impossible.
	    // some invalid regexp stuff in the set.
	    if (p === false) return false

	    if (p === GLOBSTAR) {
	      this.debug('GLOBSTAR', [pattern, p, f])

	      // "**"
	      // a/**/b/**/c would match the following:
	      // a/b/x/y/z/c
	      // a/x/y/z/b/c
	      // a/b/x/b/x/c
	      // a/b/c
	      // To do this, take the rest of the pattern after
	      // the **, and see if it would match the file remainder.
	      // If so, return success.
	      // If not, the ** "swallows" a segment, and try again.
	      // This is recursively awful.
	      //
	      // a/**/b/**/c matching a/b/x/y/z/c
	      // - a matches a
	      // - doublestar
	      //   - matchOne(b/x/y/z/c, b/**/c)
	      //     - b matches b
	      //     - doublestar
	      //       - matchOne(x/y/z/c, c) -> no
	      //       - matchOne(y/z/c, c) -> no
	      //       - matchOne(z/c, c) -> no
	      //       - matchOne(c, c) yes, hit
	      var fr = fi
	      var pr = pi + 1
	      if (pr === pl) {
	        this.debug('** at the end')
	        // a ** at the end will just swallow the rest.
	        // We have found a match.
	        // however, it will not swallow /.x, unless
	        // options.dot is set.
	        // . and .. are *never* matched by **, for explosively
	        // exponential reasons.
	        for (; fi < fl; fi++) {
	          if (file[fi] === '.' || file[fi] === '..' ||
	            (!options.dot && file[fi].charAt(0) === '.')) return false
	        }
	        return true
	      }

	      // ok, let's see if we can swallow whatever we can.
	      while (fr < fl) {
	        var swallowee = file[fr]

	        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

	        // XXX remove this slice.  Just pass the start index.
	        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
	          this.debug('globstar found match!', fr, fl, swallowee)
	          // found a match.
	          return true
	        } else {
	          // can't swallow "." or ".." ever.
	          // can only swallow ".foo" when explicitly asked.
	          if (swallowee === '.' || swallowee === '..' ||
	            (!options.dot && swallowee.charAt(0) === '.')) {
	            this.debug('dot detected!', file, fr, pattern, pr)
	            break
	          }

	          // ** swallows a segment, and continue.
	          this.debug('globstar swallow a segment, and continue')
	          fr++
	        }
	      }

	      // no match was found.
	      // However, in partial mode, we can't say this is necessarily over.
	      // If there's more *pattern* left, then
	      if (partial) {
	        // ran out of file
	        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
	        if (fr === fl) return true
	      }
	      return false
	    }

	    // something other than **
	    // non-magic patterns just have to match exactly
	    // patterns with magic have been turned into regexps.
	    var hit
	    if (typeof p === 'string') {
	      if (options.nocase) {
	        hit = f.toLowerCase() === p.toLowerCase()
	      } else {
	        hit = f === p
	      }
	      this.debug('string match', p, f, hit)
	    } else {
	      hit = f.match(p)
	      this.debug('pattern match', p, f, hit)
	    }

	    if (!hit) return false
	  }

	  // Note: ending in / means that we'll get a final ""
	  // at the end of the pattern.  This can only match a
	  // corresponding "" at the end of the file.
	  // If the file ends in /, then it can only match a
	  // a pattern that ends in /, unless the pattern just
	  // doesn't have any more for it. But, a/b/ should *not*
	  // match "a/b/*", even though "" matches against the
	  // [^/]*? pattern, except in partial mode, where it might
	  // simply not be reached yet.
	  // However, a/b/ should still satisfy a/*

	  // now either we fell off the end of the pattern, or we're done.
	  if (fi === fl && pi === pl) {
	    // ran out of pattern and filename at the same time.
	    // an exact hit!
	    return true
	  } else if (fi === fl) {
	    // ran out of file, but still had pattern left.
	    // this is ok if we're doing the match as part of
	    // a glob fs traversal.
	    return partial
	  } else if (pi === pl) {
	    // ran out of pattern, still have file left.
	    // this is only acceptable if we're on the very last
	    // empty segment of a file with a trailing slash.
	    // a/* should match a/b/
	    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
	    return emptyFileEnd
	  }

	  // should be unreachable.
	  throw new Error('wtf?')
	}

	// replace stuff like \* with *
	function globUnescape (s) {
	  return s.replace(/\\(.)/g, '$1')
	}

	function regExpEscape (s) {
	  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
	}


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var apply = Function.prototype.apply;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
	  if (timeout) {
	    timeout.close();
	  }
	};

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// setimmediate attaches itself to the global object
	__webpack_require__(278);
	exports.setImmediate = setImmediate;
	exports.clearImmediate = clearImmediate;


/***/ },
/* 35 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var buffer = __webpack_require__(2);
	var Buffer = buffer.Buffer;
	var SlowBuffer = buffer.SlowBuffer;
	var MAX_LEN = buffer.kMaxLength || 2147483647;
	exports.alloc = function alloc(size, fill, encoding) {
	  if (typeof Buffer.alloc === 'function') {
	    return Buffer.alloc(size, fill, encoding);
	  }
	  if (typeof encoding === 'number') {
	    throw new TypeError('encoding must not be number');
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  var enc = encoding;
	  var _fill = fill;
	  if (_fill === undefined) {
	    enc = undefined;
	    _fill = 0;
	  }
	  var buf = new Buffer(size);
	  if (typeof _fill === 'string') {
	    var fillBuf = new Buffer(_fill, enc);
	    var flen = fillBuf.length;
	    var i = -1;
	    while (++i < size) {
	      buf[i] = fillBuf[i % flen];
	    }
	  } else {
	    buf.fill(_fill);
	  }
	  return buf;
	}
	exports.allocUnsafe = function allocUnsafe(size) {
	  if (typeof Buffer.allocUnsafe === 'function') {
	    return Buffer.allocUnsafe(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size > MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new Buffer(size);
	}
	exports.from = function from(value, encodingOrOffset, length) {
	  if (typeof Buffer.from === 'function' && (!global.Uint8Array || Uint8Array.from !== Buffer.from)) {
	    return Buffer.from(value, encodingOrOffset, length);
	  }
	  if (typeof value === 'number') {
	    throw new TypeError('"value" argument must not be a number');
	  }
	  if (typeof value === 'string') {
	    return new Buffer(value, encodingOrOffset);
	  }
	  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
	    var offset = encodingOrOffset;
	    if (arguments.length === 1) {
	      return new Buffer(value);
	    }
	    if (typeof offset === 'undefined') {
	      offset = 0;
	    }
	    var len = length;
	    if (typeof len === 'undefined') {
	      len = value.byteLength - offset;
	    }
	    if (offset >= value.byteLength) {
	      throw new RangeError('\'offset\' is out of bounds');
	    }
	    if (len > value.byteLength - offset) {
	      throw new RangeError('\'length\' is out of bounds');
	    }
	    return new Buffer(value.slice(offset, offset + len));
	  }
	  if (Buffer.isBuffer(value)) {
	    var out = new Buffer(value.length);
	    value.copy(out, 0, 0, value.length);
	    return out;
	  }
	  if (value) {
	    if (Array.isArray(value) || (typeof ArrayBuffer !== 'undefined' && value.buffer instanceof ArrayBuffer) || 'length' in value) {
	      return new Buffer(value);
	    }
	    if (value.type === 'Buffer' && Array.isArray(value.data)) {
	      return new Buffer(value.data);
	    }
	  }

	  throw new TypeError('First argument must be a string, Buffer, ' + 'ArrayBuffer, Array, or array-like object.');
	}
	exports.allocUnsafeSlow = function allocUnsafeSlow(size) {
	  if (typeof Buffer.allocUnsafeSlow === 'function') {
	    return Buffer.allocUnsafeSlow(size);
	  }
	  if (typeof size !== 'number') {
	    throw new TypeError('size must be a number');
	  }
	  if (size >= MAX_LEN) {
	    throw new RangeError('size is too large');
	  }
	  return new SlowBuffer(size);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var escapeStringRegexp = __webpack_require__(184);
	var ansiStyles = __webpack_require__(125);
	var stripAnsi = __webpack_require__(286);
	var hasAnsi = __webpack_require__(221);
	var supportsColor = __webpack_require__(138);
	var defineProps = Object.defineProperties;
	var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

	function Chalk(options) {
		// detect mode if not set manually
		this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
	}

	// use bright blue on Windows as the normal blue color is illegible
	if (isSimpleWindowsTerm) {
		ansiStyles.blue.open = '\u001b[94m';
	}

	var styles = (function () {
		var ret = {};

		Object.keys(ansiStyles).forEach(function (key) {
			ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

			ret[key] = {
				get: function () {
					return build.call(this, this._styles.concat(key));
				}
			};
		});

		return ret;
	})();

	var proto = defineProps(function chalk() {}, styles);

	function build(_styles) {
		var builder = function () {
			return applyStyle.apply(builder, arguments);
		};

		builder._styles = _styles;
		builder.enabled = this.enabled;
		// __proto__ is used because we must return a function, but there is
		// no way to create a function with a different prototype.
		/* eslint-disable no-proto */
		builder.__proto__ = proto;

		return builder;
	}

	function applyStyle() {
		// support varags, but simply cast to string in case there's only one arg
		var args = arguments;
		var argsLen = args.length;
		var str = argsLen !== 0 && String(arguments[0]);

		if (argsLen > 1) {
			// don't slice `arguments`, it prevents v8 optimizations
			for (var a = 1; a < argsLen; a++) {
				str += ' ' + args[a];
			}
		}

		if (!this.enabled || !str) {
			return str;
		}

		var nestedStyles = this._styles;
		var i = nestedStyles.length;

		// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
		// see https://github.com/chalk/chalk/issues/58
		// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
		var originalDim = ansiStyles.dim.open;
		if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
			ansiStyles.dim.open = '';
		}

		while (i--) {
			var code = ansiStyles[nestedStyles[i]];

			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			str = code.open + str.replace(code.closeRe, code.open) + code.close;
		}

		// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
		ansiStyles.dim.open = originalDim;

		return str;
	}

	function init() {
		var ret = {};

		Object.keys(styles).forEach(function (name) {
			ret[name] = {
				get: function () {
					return build.call(this, [name]);
				}
			};
		});

		return ret;
	}

	defineProps(Chalk.prototype, init());

	module.exports = new Chalk();
	module.exports.styles = ansiStyles;
	module.exports.hasColor = hasAnsi;
	module.exports.stripColor = stripAnsi;
	module.exports.supportsColor = supportsColor;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);
	var packNumber = __webpack_require__(31).pack;

	// http://www.w3.org/TR/css3-color/#svg-color
	var NAME_TO_HEX = {
	    'aliceblue': 'f0f8ff',
	    'antiquewhite': 'faebd7',
	    'aqua': '0ff',
	    'aquamarine': '7fffd4',
	    'azure': 'f0ffff',
	    'beige': 'f5f5dc',
	    'bisque': 'ffe4c4',
	    'black': '000',
	    'blanchedalmond': 'ffebcd',
	    'blue': '00f',
	    'blueviolet': '8a2be2',
	    'brown': 'a52a2a',
	    'burlywood': 'deb887',
	    'cadetblue': '5f9ea0',
	    'chartreuse': '7fff00',
	    'chocolate': 'd2691e',
	    'coral': 'ff7f50',
	    'cornflowerblue': '6495ed',
	    'cornsilk': 'fff8dc',
	    'crimson': 'dc143c',
	    'cyan': '0ff',
	    'darkblue': '00008b',
	    'darkcyan': '008b8b',
	    'darkgoldenrod': 'b8860b',
	    'darkgray': 'a9a9a9',
	    'darkgrey': 'a9a9a9',
	    'darkgreen': '006400',
	    'darkkhaki': 'bdb76b',
	    'darkmagenta': '8b008b',
	    'darkolivegreen': '556b2f',
	    'darkorange': 'ff8c00',
	    'darkorchid': '9932cc',
	    'darkred': '8b0000',
	    'darksalmon': 'e9967a',
	    'darkseagreen': '8fbc8f',
	    'darkslateblue': '483d8b',
	    'darkslategray': '2f4f4f',
	    'darkslategrey': '2f4f4f',
	    'darkturquoise': '00ced1',
	    'darkviolet': '9400d3',
	    'deeppink': 'ff1493',
	    'deepskyblue': '00bfff',
	    'dimgray': '696969',
	    'dimgrey': '696969',
	    'dodgerblue': '1e90ff',
	    'firebrick': 'b22222',
	    'floralwhite': 'fffaf0',
	    'forestgreen': '228b22',
	    'fuchsia': 'f0f',
	    'gainsboro': 'dcdcdc',
	    'ghostwhite': 'f8f8ff',
	    'gold': 'ffd700',
	    'goldenrod': 'daa520',
	    'gray': '808080',
	    'grey': '808080',
	    'green': '008000',
	    'greenyellow': 'adff2f',
	    'honeydew': 'f0fff0',
	    'hotpink': 'ff69b4',
	    'indianred': 'cd5c5c',
	    'indigo': '4b0082',
	    'ivory': 'fffff0',
	    'khaki': 'f0e68c',
	    'lavender': 'e6e6fa',
	    'lavenderblush': 'fff0f5',
	    'lawngreen': '7cfc00',
	    'lemonchiffon': 'fffacd',
	    'lightblue': 'add8e6',
	    'lightcoral': 'f08080',
	    'lightcyan': 'e0ffff',
	    'lightgoldenrodyellow': 'fafad2',
	    'lightgray': 'd3d3d3',
	    'lightgrey': 'd3d3d3',
	    'lightgreen': '90ee90',
	    'lightpink': 'ffb6c1',
	    'lightsalmon': 'ffa07a',
	    'lightseagreen': '20b2aa',
	    'lightskyblue': '87cefa',
	    'lightslategray': '789',
	    'lightslategrey': '789',
	    'lightsteelblue': 'b0c4de',
	    'lightyellow': 'ffffe0',
	    'lime': '0f0',
	    'limegreen': '32cd32',
	    'linen': 'faf0e6',
	    'magenta': 'f0f',
	    'maroon': '800000',
	    'mediumaquamarine': '66cdaa',
	    'mediumblue': '0000cd',
	    'mediumorchid': 'ba55d3',
	    'mediumpurple': '9370db',
	    'mediumseagreen': '3cb371',
	    'mediumslateblue': '7b68ee',
	    'mediumspringgreen': '00fa9a',
	    'mediumturquoise': '48d1cc',
	    'mediumvioletred': 'c71585',
	    'midnightblue': '191970',
	    'mintcream': 'f5fffa',
	    'mistyrose': 'ffe4e1',
	    'moccasin': 'ffe4b5',
	    'navajowhite': 'ffdead',
	    'navy': '000080',
	    'oldlace': 'fdf5e6',
	    'olive': '808000',
	    'olivedrab': '6b8e23',
	    'orange': 'ffa500',
	    'orangered': 'ff4500',
	    'orchid': 'da70d6',
	    'palegoldenrod': 'eee8aa',
	    'palegreen': '98fb98',
	    'paleturquoise': 'afeeee',
	    'palevioletred': 'db7093',
	    'papayawhip': 'ffefd5',
	    'peachpuff': 'ffdab9',
	    'peru': 'cd853f',
	    'pink': 'ffc0cb',
	    'plum': 'dda0dd',
	    'powderblue': 'b0e0e6',
	    'purple': '800080',
	    'rebeccapurple': '639',
	    'red': 'f00',
	    'rosybrown': 'bc8f8f',
	    'royalblue': '4169e1',
	    'saddlebrown': '8b4513',
	    'salmon': 'fa8072',
	    'sandybrown': 'f4a460',
	    'seagreen': '2e8b57',
	    'seashell': 'fff5ee',
	    'sienna': 'a0522d',
	    'silver': 'c0c0c0',
	    'skyblue': '87ceeb',
	    'slateblue': '6a5acd',
	    'slategray': '708090',
	    'slategrey': '708090',
	    'snow': 'fffafa',
	    'springgreen': '00ff7f',
	    'steelblue': '4682b4',
	    'tan': 'd2b48c',
	    'teal': '008080',
	    'thistle': 'd8bfd8',
	    'tomato': 'ff6347',
	    'turquoise': '40e0d0',
	    'violet': 'ee82ee',
	    'wheat': 'f5deb3',
	    'white': 'fff',
	    'whitesmoke': 'f5f5f5',
	    'yellow': 'ff0',
	    'yellowgreen': '9acd32'
	};

	var HEX_TO_NAME = {
	    '800000': 'maroon',
	    '800080': 'purple',
	    '808000': 'olive',
	    '808080': 'gray',
	    '00ffff': 'cyan',
	    'f0ffff': 'azure',
	    'f5f5dc': 'beige',
	    'ffe4c4': 'bisque',
	    '000000': 'black',
	    '0000ff': 'blue',
	    'a52a2a': 'brown',
	    'ff7f50': 'coral',
	    'ffd700': 'gold',
	    '008000': 'green',
	    '4b0082': 'indigo',
	    'fffff0': 'ivory',
	    'f0e68c': 'khaki',
	    '00ff00': 'lime',
	    'faf0e6': 'linen',
	    '000080': 'navy',
	    'ffa500': 'orange',
	    'da70d6': 'orchid',
	    'cd853f': 'peru',
	    'ffc0cb': 'pink',
	    'dda0dd': 'plum',
	    'f00': 'red',
	    'ff0000': 'red',
	    'fa8072': 'salmon',
	    'a0522d': 'sienna',
	    'c0c0c0': 'silver',
	    'fffafa': 'snow',
	    'd2b48c': 'tan',
	    '008080': 'teal',
	    'ff6347': 'tomato',
	    'ee82ee': 'violet',
	    'f5deb3': 'wheat',
	    'ffffff': 'white',
	    'ffff00': 'yellow'
	};

	function hueToRgb(p, q, t) {
	    if (t < 0) {
	        t += 1;
	    }
	    if (t > 1) {
	        t -= 1;
	    }
	    if (t < 1 / 6) {
	        return p + (q - p) * 6 * t;
	    }
	    if (t < 1 / 2) {
	        return q;
	    }
	    if (t < 2 / 3) {
	        return p + (q - p) * (2 / 3 - t) * 6;
	    }
	    return p;
	}

	function hslToRgb(h, s, l, a) {
	    var r;
	    var g;
	    var b;

	    if (s == 0) {
	        r = g = b = l; // achromatic
	    } else {
	        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
	        var p = 2 * l - q;

	        r = hueToRgb(p, q, h + 1 / 3);
	        g = hueToRgb(p, q, h);
	        b = hueToRgb(p, q, h - 1 / 3);
	    }

	    return [
	        Math.round(r * 255),
	        Math.round(g * 255),
	        Math.round(b * 255),
	        a
	    ];
	}

	function toHex(value) {
	    value = value.toString(16);
	    return value.length === 1 ? '0' + value : value;
	}

	function parseFunctionArgs(functionArgs, count, rgb) {
	    var argument = functionArgs.head;
	    var args = [];

	    while (argument !== null) {
	        var argumentPart = argument.data.sequence.head;
	        var wasValue = false;

	        while (argumentPart !== null) {
	            var value = argumentPart.data;
	            var type = value.type;

	            switch (type) {
	                case 'Number':
	                case 'Percentage':
	                    if (wasValue) {
	                        return;
	                    }

	                    wasValue = true;
	                    args.push({
	                        type: type,
	                        value: Number(value.value)
	                    });
	                    break;

	                case 'Operator':
	                    if (wasValue || value.value !== '+') {
	                        return;
	                    }
	                    break;

	                default:
	                    // something we couldn't understand
	                    return;
	            }

	            argumentPart = argumentPart.next;
	        }

	        argument = argument.next;
	    }

	    if (args.length !== count) {
	        // invalid arguments count
	        // TODO: remove those tokens
	        return;
	    }

	    if (args.length === 4) {
	        if (args[3].type !== 'Number') {
	            // 4th argument should be a number
	            // TODO: remove those tokens
	            return;
	        }

	        args[3].type = 'Alpha';
	    }

	    if (rgb) {
	        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
	            // invalid color, numbers and percentage shouldn't be mixed
	            // TODO: remove those tokens
	            return;
	        }
	    } else {
	        if (args[0].type !== 'Number' ||
	            args[1].type !== 'Percentage' ||
	            args[2].type !== 'Percentage') {
	            // invalid color, for hsl values should be: number, percentage, percentage
	            // TODO: remove those tokens
	            return;
	        }

	        args[0].type = 'Angle';
	    }

	    return args.map(function(arg) {
	        var value = Math.max(0, arg.value);

	        switch (arg.type) {
	            case 'Number':
	                // fit value to [0..255] range
	                value = Math.min(value, 255);
	                break;

	            case 'Percentage':
	                // convert 0..100% to value in [0..255] range
	                value = Math.min(value, 100) / 100;

	                if (!rgb) {
	                    return value;
	                }

	                value = 255 * value;
	                break;

	            case 'Angle':
	                // fit value to (-360..360) range
	                return (((value % 360) + 360) % 360) / 360;

	            case 'Alpha':
	                // fit value to [0..1] range
	                return Math.min(value, 1);
	        }

	        return Math.round(value);
	    });
	}

	function compressFunction(node, item, list) {
	    var functionName = node.name;
	    var args;

	    if (functionName === 'rgba' || functionName === 'hsla') {
	        args = parseFunctionArgs(node.arguments, 4, functionName === 'rgba');

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        if (functionName === 'hsla') {
	            args = hslToRgb.apply(null, args);
	            node.name = 'rgba';
	        }

	        if (args[3] !== 1) {
	            // replace argument values for normalized/interpolated
	            node.arguments.each(function(argument) {
	                var item = argument.sequence.head;

	                if (item.data.type === 'Operator') {
	                    item = item.next;
	                }

	                argument.sequence = new List([{
	                    type: 'Number',
	                    info: item.data.info,
	                    value: packNumber(args.shift())
	                }]);
	            });

	            return;
	        }

	        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
	        functionName = 'rgb';
	    }

	    if (functionName === 'hsl') {
	        args = args || parseFunctionArgs(node.arguments, 3, false);

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        // convert to rgb
	        args = hslToRgb.apply(null, args);
	        functionName = 'rgb';
	    }

	    if (functionName === 'rgb') {
	        args = args || parseFunctionArgs(node.arguments, 3, true);

	        if (!args) {
	            // something went wrong
	            return;
	        }

	        // check if color is not at the end and not followed by space
	        var next = item.next;
	        if (next && next.data.type !== 'Space') {
	            list.insert(list.createItem({
	                type: 'Space'
	            }), next);
	        }

	        item.data = {
	            type: 'Hash',
	            info: node.info,
	            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
	        };

	        compressHex(item.data, item);
	    }
	}

	function compressIdent(node, item) {
	    if (this.declaration === null) {
	        return;
	    }

	    var color = node.name.toLowerCase();

	    if (NAME_TO_HEX.hasOwnProperty(color)) {
	        var hex = NAME_TO_HEX[color];

	        if (hex.length + 1 <= color.length) {
	            // replace for shorter hex value
	            item.data = {
	                type: 'Hash',
	                info: node.info,
	                value: hex
	            };
	        } else {
	            // special case for consistent colors
	            if (color === 'grey') {
	                color = 'gray';
	            }

	            // just replace value for lower cased name
	            node.name = color;
	        }
	    }
	}

	function compressHex(node, item) {
	    var color = node.value.toLowerCase();

	    // #112233 -> #123
	    if (color.length === 6 &&
	        color[0] === color[1] &&
	        color[2] === color[3] &&
	        color[4] === color[5]) {
	        color = color[0] + color[2] + color[4];
	    }

	    if (HEX_TO_NAME[color]) {
	        item.data = {
	            type: 'Identifier',
	            info: node.info,
	            name: HEX_TO_NAME[color]
	        };
	    } else {
	        node.value = color;
	    }
	}

	module.exports = {
	    compressFunction: compressFunction,
	    compressIdent: compressIdent,
	    compressHex: compressHex
	};


/***/ },
/* 39 */
/***/ function(module, exports) {

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function isEqualLists(a, b) {
	    var cursor1 = a.head;
	    var cursor2 = b.head;

	    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	        cursor1 = cursor1.next;
	        cursor2 = cursor2.next;
	    }

	    return cursor1 === null && cursor2 === null;
	}

	function isEqualDeclarations(a, b) {
	    var cursor1 = a.head;
	    var cursor2 = b.head;

	    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
	        cursor1 = cursor1.next;
	        cursor2 = cursor2.next;
	    }

	    return cursor1 === null && cursor2 === null;
	}

	function compareDeclarations(declarations1, declarations2) {
	    var result = {
	        eq: [],
	        ne1: [],
	        ne2: [],
	        ne2overrided: []
	    };

	    var fingerprints = Object.create(null);
	    var declarations2hash = Object.create(null);

	    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
	        declarations2hash[cursor.data.id] = true;
	    }

	    for (var cursor = declarations1.head; cursor; cursor = cursor.next)  {
	        var data = cursor.data;

	        if (data.fingerprint) {
	            fingerprints[data.fingerprint] = data.value.important;
	        }

	        if (declarations2hash[data.id]) {
	            declarations2hash[data.id] = false;
	            result.eq.push(data);
	        } else {
	            result.ne1.push(data);
	        }
	    }

	    for (var cursor = declarations2.head; cursor; cursor = cursor.next)  {
	        var data = cursor.data;

	        if (declarations2hash[data.id]) {
	            // if declarations1 has overriding declaration, this is not a difference
	            // but take in account !important - prev should be equal or greater than follow
	            if (hasOwnProperty.call(fingerprints, data.fingerprint) &&
	                Number(fingerprints[data.fingerprint]) >= Number(data.value.important)) {
	                result.ne2overrided.push(data);
	            } else {
	                result.ne2.push(data);
	            }
	        }
	    }

	    return result;
	}

	function addSelectors(dest, source) {
	    source.each(function(sourceData) {
	        var newStr = sourceData.id;
	        var cursor = dest.head;

	        while (cursor) {
	            var nextStr = cursor.data.id;

	            if (nextStr === newStr) {
	                return;
	            }

	            if (nextStr > newStr) {
	                break;
	            }

	            cursor = cursor.next;
	        }

	        dest.insert(dest.createItem(sourceData), cursor);
	    });

	    return dest;
	}

	// check if simpleselectors has no equal specificity and element selector
	function hasSimilarSelectors(selectors1, selectors2) {
	    return selectors1.some(function(a) {
	        return selectors2.some(function(b) {
	            return a.compareMarker === b.compareMarker;
	        });
	    });
	}

	// test node can't to be skipped
	function unsafeToSkipNode(node) {
	    switch (node.type) {
	        case 'Ruleset':
	            // unsafe skip ruleset with selector similarities
	            return hasSimilarSelectors(node.selector.selectors, this);

	        case 'Atrule':
	            // can skip at-rules with blocks
	            if (node.block) {
	                // non-stylesheet blocks are safe to skip since have no selectors
	                if (node.block.type !== 'StyleSheet') {
	                    return false;
	                }

	                // unsafe skip at-rule if block contains something unsafe to skip
	                return node.block.rules.some(unsafeToSkipNode, this);
	            }
	            break;
	    }

	    // unsafe by default
	    return true;
	}

	module.exports = {
	    isEqualLists: isEqualLists,
	    isEqualDeclarations: isEqualDeclarations,
	    compareDeclarations: compareDeclarations,
	    addSelectors: addSelectors,
	    hasSimilarSelectors: hasSimilarSelectors,
	    unsafeToSkipNode: unsafeToSkipNode
	};


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's Failsafe schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2802346


	'use strict';


	var Schema = __webpack_require__(21);


	module.exports = new Schema({
	  explicit: [
	    __webpack_require__(247),
	    __webpack_require__(245),
	    __webpack_require__(240)
	  ]
	});


/***/ },
/* 41 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to match template delimiters. */
	var reInterpolate = /<%=([\s\S]+?)%>/g;

	module.exports = reInterpolate;


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process) {var natives = process.binding('natives')
	var module = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"module\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var normalRequire = require
	exports.source = src
	exports.require = req
	var vm = __webpack_require__(321)

	// fallback for 0.x support
	var runInThisContext, ContextifyScript, Script
	/*istanbul ignore next*/
	try {
	  ContextifyScript = process.binding('contextify').ContextifyScript;
	  runInThisContext = function runInThisContext(code, options) {
	    var script = new ContextifyScript(code, options);
	    return script.runInThisContext();
	  }
	} catch (er) {
	  Script = process.binding('evals').NodeScript;
	  runInThisContext = Script.runInThisContext;
	}

	var wrap = [
	  '(function (exports, require, module, __filename, __dirname) { ',
	  '\n});'
	];


	// Basically the same functionality as node's (buried deep)
	// NativeModule class, but without caching, or internal/ blocking,
	// or a class, since that's not really necessary.  I assume that if
	// you're loading something with this module, it's because you WANT
	// a separate copy.  However, to preserve semantics, any require()
	// calls made throughout the internal module load IS cached.
	function req (id, whitelist) {
	  var cache = Object.create(null)

	  if (Array.isArray(whitelist)) {
	    // a whitelist of things to pull from the "actual" native modules
	    whitelist.forEach(function (id) {
	      cache[id] = {
	        loading: false,
	        loaded: true,
	        filename: id + '.js',
	        exports: __webpack_require__(266)(id)
	      }
	    })
	  }

	  return req_(id, cache)
	}

	function req_ (id, cache) {
	  // Buffer is special, because it's a type rather than a "normal"
	  // class, and many things depend on `Buffer.isBuffer` working.
	  if (id === 'buffer') {
	    return __webpack_require__(2)
	  }

	  // native_module isn't actually a natives binding.
	  // weird, right?
	  if (id === 'native_module') {
	    return {
	      getSource: src,
	      wrap: function (script) {
	        return wrap[0] + script + wrap[1]
	      },
	      wrapper: wrap,
	      _cache: cache
	    }
	  }

	  var source = src(id)
	  if (!source) {
	    return undefined
	  }
	  source = wrap[0] + source + wrap[1]

	  var cachingRequire = function require (id) {
	    if (cache[id]) {
	      return cache[id].exports
	    }
	    return req_(id, cache)
	  }

	  var nm = {
	    exports: {},
	    loading: true,
	    loaded: false,
	    filename: id + '.js'
	  }
	  cache[id] = nm
	  var fn
	  try {
	    /* istanbul ignore else */
	    if (ContextifyScript) {
	      fn = runInThisContext(source, {
	        filename: nm.filename,
	        lineOffset: 0,
	        displayErrors: true
	      });
	    } else {
	      fn = runInThisContext(source, nm.filename, true);
	    }
	    fn(nm.exports, cachingRequire, nm, nm.filename)
	    nm.loaded = true
	  } finally {
	    nm.loading = false
	  }

	  return nm.exports
	}

	function src (id) {
	  return natives[id]
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	if (!process.version ||
	    process.version.indexOf('v0.') === 0 ||
	    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
	  module.exports = nextTick;
	} else {
	  module.exports = process.nextTick;
	}

	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process.nextTick(fn);
	  case 2:
	    return process.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	'use strict';

	module.exports = Transform;

	var Duplex = __webpack_require__(16);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function TransformState(stream) {
	  this.afterTransform = function (er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	  this.writeencoding = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined) stream.push(data);

	  cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(this);

	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.once('prefinish', function () {
	    if (typeof this._flush === 'function') this._flush(function (er, data) {
	      done(stream, er, data);
	    });else done(stream);
	  });
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);

	  if (data !== null && data !== undefined) stream.push(data);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

	  if (ts.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.

	'use strict';

	module.exports = Writable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(43);
	/*</replacement>*/

	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: __webpack_require__(300)
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(3);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(11).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(36);
	/*</replacement>*/

	util.inherits(Writable, Stream);

	function nop() {}

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	  this.next = null;
	}

	function WritableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(16);

	  options = options || {};

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;

	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}

	function Writable(options) {
	  Duplex = Duplex || __webpack_require__(16);

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  processNextTick(cb, er);
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;
	  // Always throw error if a null is written
	  // if we are not in object mode then throw
	  // if it is not a buffer, string, or undefined.
	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    processNextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = bufferShim.from(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);

	  if (Buffer.isBuffer(chunk)) encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = new WriteReq(chunk, encoding, cb);
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) processNextTick(cb, er);else cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	        afterWrite(stream, state, finished, cb);
	      }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    while (entry) {
	      buffer[count] = entry;
	      entry = entry.next;
	      count += 1;
	    }

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequestCount = 0;
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else {
	      prefinish(stream, state);
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;

	  this.finish = function (err) {
	    var entry = _this.entry;
	    _this.entry = null;
	    while (entry) {
	      var cb = entry.callback;
	      state.pendingcb--;
	      cb(err);
	      entry = entry.next;
	    }
	    if (state.corkedRequestsFree) {
	      state.corkedRequestsFree.next = _this;
	    } else {
	      state.corkedRequestsFree = _this;
	    }
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(34).setImmediate))

/***/ },
/* 46 */
/***/ function(module, exports) {

	// Returns a wrapper function that returns a wrapped callback
	// The wrapper function should do some stuff, and return a
	// presumably different callback function.
	// This makes sure that own properties are retained, so that
	// decorations and such are not lost along the way.
	module.exports = wrappy
	function wrappy (fn, cb) {
	  if (fn && cb) return wrappy(fn)(cb)

	  if (typeof fn !== 'function')
	    throw new TypeError('need wrapper function')

	  Object.keys(fn).forEach(function (k) {
	    wrapper[k] = fn[k]
	  })

	  return wrapper

	  function wrapper() {
	    var args = new Array(arguments.length)
	    for (var i = 0; i < args.length; i++) {
	      args[i] = arguments[i]
	    }
	    var ret = fn.apply(this, args)
	    var cb = args[args.length-1]
	    if (typeof ret === 'function' && ret !== cb) {
	      Object.keys(cb).forEach(function (k) {
	        ret[k] = cb[k]
	      })
	    }
	    return ret
	  }
	}


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var Stat = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).Stats

	module.exports = cloneStats

	function cloneStats(stats) {
	  var replacement = new Stat

	  Object.keys(stats).forEach(function(key) {
	    replacement[key] = stats[key]
	  })

	  return replacement
	}


/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {
	'use strict';

	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	*/
	function clone(parent, circular, depth, prototype) {
	  var filter;
	  if (typeof circular === 'object') {
	    depth = circular.depth;
	    prototype = circular.prototype;
	    filter = circular.filter;
	    circular = circular.circular
	  }
	  // maintain two arrays for circular references, where corresponding parents
	  // and children have the same index
	  var allParents = [];
	  var allChildren = [];

	  var useBuffer = typeof Buffer != 'undefined';

	  if (typeof circular == 'undefined')
	    circular = true;

	  if (typeof depth == 'undefined')
	    depth = Infinity;

	  // recurse this function so we don't reset allParents and allChildren
	  function _clone(parent, depth) {
	    // cloning null always returns null
	    if (parent === null)
	      return null;

	    if (depth == 0)
	      return parent;

	    var child;
	    var proto;
	    if (typeof parent != 'object') {
	      return parent;
	    }

	    if (clone.__isArray(parent)) {
	      child = [];
	    } else if (clone.__isRegExp(parent)) {
	      child = new RegExp(parent.source, __getRegExpFlags(parent));
	      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	    } else if (clone.__isDate(parent)) {
	      child = new Date(parent.getTime());
	    } else if (useBuffer && Buffer.isBuffer(parent)) {
	      child = new Buffer(parent.length);
	      parent.copy(child);
	      return child;
	    } else {
	      if (typeof prototype == 'undefined') {
	        proto = Object.getPrototypeOf(parent);
	        child = Object.create(proto);
	      }
	      else {
	        child = Object.create(prototype);
	        proto = prototype;
	      }
	    }

	    if (circular) {
	      var index = allParents.indexOf(parent);

	      if (index != -1) {
	        return allChildren[index];
	      }
	      allParents.push(parent);
	      allChildren.push(child);
	    }

	    for (var i in parent) {
	      var attrs;
	      if (proto) {
	        attrs = Object.getOwnPropertyDescriptor(proto, i);
	      }

	      if (attrs && attrs.set == null) {
	        continue;
	      }
	      child[i] = _clone(parent[i], depth - 1);
	    }

	    return child;
	  }

	  return _clone(parent, depth);
	}

	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function clonePrototype(parent) {
	  if (parent === null)
	    return null;

	  var c = function () {};
	  c.prototype = parent;
	  return new c();
	};

	// private utility functions

	function __objToStr(o) {
	  return Object.prototype.toString.call(o);
	};
	clone.__objToStr = __objToStr;

	function __isDate(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Date]';
	};
	clone.__isDate = __isDate;

	function __isArray(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object Array]';
	};
	clone.__isArray = __isArray;

	function __isRegExp(o) {
	  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
	};
	clone.__isRegExp = __isRegExp;

	function __getRegExpFlags(re) {
	  var flags = '';
	  if (re.global) flags += 'g';
	  if (re.ignoreCase) flags += 'i';
	  if (re.multiline) flags += 'm';
	  return flags;
	};
	clone.__getRegExpFlags = __getRegExpFlags;

	return clone;
	})();

	if (typeof module === 'object' && module.exports) {
	  module.exports = clone;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 49 */,
/* 50 */
/***/ function(module, exports) {

	exports.TokenType = {
	    String: 'String',
	    Comment: 'Comment',
	    Unknown: 'Unknown',
	    Newline: 'Newline',
	    Space: 'Space',
	    Tab: 'Tab',
	    ExclamationMark: 'ExclamationMark',         // !
	    QuotationMark: 'QuotationMark',             // "
	    NumberSign: 'NumberSign',                   // #
	    DollarSign: 'DollarSign',                   // $
	    PercentSign: 'PercentSign',                 // %
	    Ampersand: 'Ampersand',                     // &
	    Apostrophe: 'Apostrophe',                   // '
	    LeftParenthesis: 'LeftParenthesis',         // (
	    RightParenthesis: 'RightParenthesis',       // )
	    Asterisk: 'Asterisk',                       // *
	    PlusSign: 'PlusSign',                       // +
	    Comma: 'Comma',                             // ,
	    HyphenMinus: 'HyphenMinus',                 // -
	    FullStop: 'FullStop',                       // .
	    Solidus: 'Solidus',                         // /
	    Colon: 'Colon',                             // :
	    Semicolon: 'Semicolon',                     // ;
	    LessThanSign: 'LessThanSign',               // <
	    EqualsSign: 'EqualsSign',                   // =
	    GreaterThanSign: 'GreaterThanSign',         // >
	    QuestionMark: 'QuestionMark',               // ?
	    CommercialAt: 'CommercialAt',               // @
	    LeftSquareBracket: 'LeftSquareBracket',     // [
	    ReverseSolidus: 'ReverseSolidus',           // \
	    RightSquareBracket: 'RightSquareBracket',   // ]
	    CircumflexAccent: 'CircumflexAccent',       // ^
	    LowLine: 'LowLine',                         // _
	    LeftCurlyBracket: 'LeftCurlyBracket',       // {
	    VerticalLine: 'VerticalLine',               // |
	    RightCurlyBracket: 'RightCurlyBracket',     // }
	    Tilde: 'Tilde',                             // ~
	    Identifier: 'Identifier',
	    DecimalNumber: 'DecimalNumber'
	};

	// var i = 1;
	// for (var key in exports.TokenType) {
	//     exports.TokenType[key] = i++;
	// }


/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	var clone = __webpack_require__(48);

	module.exports = function(options, defaults) {
	  options = options || {};

	  Object.keys(defaults).forEach(function(key) {
	    if (typeof options[key] === 'undefined') {
	      options[key] = clone(defaults[key]);
	    }
	  });

	  return options;
	};

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(179);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(11).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = __webpack_require__(323);
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = __webpack_require__(19);

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(17).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  var Duplex = __webpack_require__(19);

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(17).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(19);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = __webpack_require__(19);

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(19);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports.alphasort = alphasort
	exports.alphasorti = alphasorti
	exports.isAbsolute = process.platform === "win32" ? absWin : absUnix
	exports.setopts = setopts
	exports.ownProp = ownProp
	exports.makeAbs = makeAbs
	exports.finish = finish
	exports.mark = mark
	exports.isIgnored = isIgnored
	exports.childrenIgnored = childrenIgnored

	function ownProp (obj, field) {
	  return Object.prototype.hasOwnProperty.call(obj, field)
	}

	var path = __webpack_require__(6)
	var minimatch = __webpack_require__(33)
	var Minimatch = minimatch.Minimatch

	function absWin (p) {
	  if (absUnix(p)) return true
	  // pull off the device/UNC bit from a windows path.
	  // from node's lib/path.js
	  var splitDeviceRe =
	      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
	  var result = splitDeviceRe.exec(p)
	  var device = result[1] || ''
	  var isUnc = device && device.charAt(1) !== ':'
	  var isAbsolute = !!result[2] || isUnc // UNC paths are always absolute

	  return isAbsolute
	}

	function absUnix (p) {
	  return p.charAt(0) === "/" || p === ""
	}

	function alphasorti (a, b) {
	  return a.toLowerCase().localeCompare(b.toLowerCase())
	}

	function alphasort (a, b) {
	  return a.localeCompare(b)
	}

	function setupIgnores (self, options) {
	  self.ignore = options.ignore || []

	  if (!Array.isArray(self.ignore))
	    self.ignore = [self.ignore]

	  if (self.ignore.length) {
	    self.ignore = self.ignore.map(ignoreMap)
	  }
	}

	function ignoreMap (pattern) {
	  var gmatcher = null
	  if (pattern.slice(-3) === '/**') {
	    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
	    gmatcher = new Minimatch(gpattern, { nonegate: true })
	  }

	  return {
	    matcher: new Minimatch(pattern, { nonegate: true }),
	    gmatcher: gmatcher
	  }
	}

	function setopts (self, pattern, options) {
	  if (!options)
	    options = {}

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  self.pattern = pattern
	  self.strict = options.strict !== false
	  self.realpath = !!options.realpath
	  self.realpathCache = options.realpathCache || Object.create(null)
	  self.follow = !!options.follow
	  self.dot = !!options.dot
	  self.mark = !!options.mark
	  self.nodir = !!options.nodir
	  if (self.nodir)
	    self.mark = true
	  self.sync = !!options.sync
	  self.nounique = !!options.nounique
	  self.nonull = !!options.nonull
	  self.nosort = !!options.nosort
	  self.nocase = !!options.nocase
	  self.stat = !!options.stat
	  self.noprocess = !!options.noprocess

	  self.maxLength = options.maxLength || Infinity
	  self.cache = options.cache || Object.create(null)
	  self.statCache = options.statCache || Object.create(null)
	  self.symlinks = options.symlinks || Object.create(null)

	  setupIgnores(self, options)

	  self.changedCwd = false
	  var cwd = process.cwd()
	  if (!ownProp(options, "cwd"))
	    self.cwd = cwd
	  else {
	    self.cwd = options.cwd
	    self.changedCwd = path.resolve(options.cwd) !== cwd
	  }

	  self.root = options.root || path.resolve(self.cwd, "/")
	  self.root = path.resolve(self.root)
	  if (process.platform === "win32")
	    self.root = self.root.replace(/\\/g, "/")

	  self.nomount = !!options.nomount

	  self.minimatch = new Minimatch(pattern, options)
	  self.options = self.minimatch.options
	}

	function finish (self) {
	  var nou = self.nounique
	  var all = nou ? [] : Object.create(null)

	  for (var i = 0, l = self.matches.length; i < l; i ++) {
	    var matches = self.matches[i]
	    if (!matches || Object.keys(matches).length === 0) {
	      if (self.nonull) {
	        // do like the shell, and spit out the literal glob
	        var literal = self.minimatch.globSet[i]
	        if (nou)
	          all.push(literal)
	        else
	          all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou)
	        all.push.apply(all, m)
	      else
	        m.forEach(function (m) {
	          all[m] = true
	        })
	    }
	  }

	  if (!nou)
	    all = Object.keys(all)

	  if (!self.nosort)
	    all = all.sort(self.nocase ? alphasorti : alphasort)

	  // at *some* point we statted all of these
	  if (self.mark) {
	    for (var i = 0; i < all.length; i++) {
	      all[i] = self._mark(all[i])
	    }
	    if (self.nodir) {
	      all = all.filter(function (e) {
	        return !(/\/$/.test(e))
	      })
	    }
	  }

	  if (self.ignore.length)
	    all = all.filter(function(m) {
	      return !isIgnored(self, m)
	    })

	  self.found = all
	}

	function mark (self, p) {
	  var abs = makeAbs(self, p)
	  var c = self.cache[abs]
	  var m = p
	  if (c) {
	    var isDir = c === 'DIR' || Array.isArray(c)
	    var slash = p.slice(-1) === '/'

	    if (isDir && !slash)
	      m += '/'
	    else if (!isDir && slash)
	      m = m.slice(0, -1)

	    if (m !== p) {
	      var mabs = makeAbs(self, m)
	      self.statCache[mabs] = self.statCache[abs]
	      self.cache[mabs] = self.cache[abs]
	    }
	  }

	  return m
	}

	// lotta situps...
	function makeAbs (self, f) {
	  var abs = f
	  if (f.charAt(0) === '/') {
	    abs = path.join(self.root, f)
	  } else if (exports.isAbsolute(f)) {
	    abs = f
	  } else if (self.changedCwd) {
	    abs = path.resolve(self.cwd, f)
	  } else if (self.realpath) {
	    abs = path.resolve(f)
	  }
	  return abs
	}


	// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
	// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
	function isIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	function childrenIgnored (self, path) {
	  if (!self.ignore.length)
	    return false

	  return self.ignore.some(function(item) {
	    return !!(item.gmatcher && item.gmatcher.match(path))
	  })
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern, false)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern, inGlobStar)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	//
	// If inGlobStar and PREFIX is symlink and points to dir
	//   set ENTRIES = []
	// else readdir(PREFIX) as ENTRIES
	//   If fail, END
	//
	// with ENTRIES
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       // Mark that this entry is a globstar match
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.

	module.exports = glob

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var minimatch = __webpack_require__(33)
	var Minimatch = minimatch.Minimatch
	var inherits = __webpack_require__(7)
	var EE = __webpack_require__(11).EventEmitter
	var path = __webpack_require__(6)
	var assert = __webpack_require__(30)
	var globSync = __webpack_require__(192)
	var common = __webpack_require__(55)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var isAbsolute = common.isAbsolute
	var setopts = common.setopts
	var ownProp = common.ownProp
	var inflight = __webpack_require__(226)
	var util = __webpack_require__(9)
	var childrenIgnored = common.childrenIgnored

	var once = __webpack_require__(68)

	function glob (pattern, options, cb) {
	  if (typeof options === 'function') cb = options, options = {}
	  if (!options) options = {}

	  if (options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return globSync(pattern, options)
	  }

	  return new Glob(pattern, options, cb)
	}

	glob.sync = globSync
	var GlobSync = glob.GlobSync = globSync.GlobSync

	// old api surface
	glob.glob = glob

	glob.hasMagic = function (pattern, options_) {
	  var options = util._extend({}, options_)
	  options.noprocess = true

	  var g = new Glob(pattern, options)
	  var set = g.minimatch.set
	  if (set.length > 1)
	    return true

	  for (var j = 0; j < set[0].length; j++) {
	    if (typeof set[0][j] !== 'string')
	      return true
	  }

	  return false
	}

	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (typeof options === 'function') {
	    cb = options
	    options = null
	  }

	  if (options && options.sync) {
	    if (cb)
	      throw new TypeError('callback provided to sync glob')
	    return new GlobSync(pattern, options)
	  }

	  if (!(this instanceof Glob))
	    return new Glob(pattern, options, cb)

	  setopts(this, pattern, options)
	  this._didRealPath = false

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  if (typeof cb === 'function') {
	    cb = once(cb)
	    this.on('error', cb)
	    this.on('end', function (matches) {
	      cb(null, matches)
	    })
	  }

	  var self = this
	  var n = this.minimatch.set.length
	  this._processing = 0
	  this.matches = new Array(n)

	  this._emitQueue = []
	  this._processQueue = []
	  this.paused = false

	  if (this.noprocess)
	    return this

	  if (n === 0)
	    return done()

	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false, done)
	  }

	  function done () {
	    --self._processing
	    if (self._processing <= 0)
	      self._finish()
	  }
	}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)
	  if (this.aborted)
	    return

	  if (this.realpath && !this._didRealpath)
	    return this._realpath()

	  common.finish(this)
	  this.emit('end', this.found)
	}

	Glob.prototype._realpath = function () {
	  if (this._didRealpath)
	    return

	  this._didRealpath = true

	  var n = this.matches.length
	  if (n === 0)
	    return this._finish()

	  var self = this
	  for (var i = 0; i < this.matches.length; i++)
	    this._realpathSet(i, next)

	  function next () {
	    if (--n === 0)
	      self._finish()
	  }
	}

	Glob.prototype._realpathSet = function (index, cb) {
	  var matchset = this.matches[index]
	  if (!matchset)
	    return cb()

	  var found = Object.keys(matchset)
	  var self = this
	  var n = found.length

	  if (n === 0)
	    return cb()

	  var set = this.matches[index] = Object.create(null)
	  found.forEach(function (p, i) {
	    // If there's a problem with the stat, then it means that
	    // one or more of the links in the realpath couldn't be
	    // resolved.  just return the abs value in that case.
	    p = self._makeAbs(p)
	    fs.realpath(p, self.realpathCache, function (er, real) {
	      if (!er)
	        set[real] = true
	      else if (er.syscall === 'stat')
	        set[p] = true
	      else
	        self.emit('error', er) // srsly wtf right here

	      if (--n === 0) {
	        self.matches[index] = set
	        cb()
	      }
	    })
	  })
	}

	Glob.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	Glob.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit('abort')
	}

	Glob.prototype.pause = function () {
	  if (!this.paused) {
	    this.paused = true
	    this.emit('pause')
	  }
	}

	Glob.prototype.resume = function () {
	  if (this.paused) {
	    this.emit('resume')
	    this.paused = false
	    if (this._emitQueue.length) {
	      var eq = this._emitQueue.slice(0)
	      this._emitQueue.length = 0
	      for (var i = 0; i < eq.length; i ++) {
	        var e = eq[i]
	        this._emitMatch(e[0], e[1])
	      }
	    }
	    if (this._processQueue.length) {
	      var pq = this._processQueue.slice(0)
	      this._processQueue.length = 0
	      for (var i = 0; i < pq.length; i ++) {
	        var p = pq[i]
	        this._processing--
	        this._process(p[0], p[1], p[2], p[3])
	      }
	    }
	  }
	}

	Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
	  assert(this instanceof Glob)
	  assert(typeof cb === 'function')

	  if (this.aborted)
	    return

	  this._processing++
	  if (this.paused) {
	    this._processQueue.push([pattern, index, inGlobStar, cb])
	    return
	  }

	  //console.error('PROCESS %d', this._processing, pattern)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index, cb)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip _processing
	  if (childrenIgnored(this, read))
	    return cb()

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
	}

	Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}

	Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return cb()

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return cb()

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this._emitMatch(index, e)
	    }
	    // This was the last one, and no stats were needed
	    return cb()
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix) {
	      if (prefix !== '/')
	        e = prefix + '/' + e
	      else
	        e = prefix + e
	    }
	    this._process([e].concat(remain), index, inGlobStar, cb)
	  }
	  cb()
	}

	Glob.prototype._emitMatch = function (index, e) {
	  if (this.aborted)
	    return

	  if (this.matches[index][e])
	    return

	  if (this.paused) {
	    this._emitQueue.push([index, e])
	    return
	  }

	  var abs = this._makeAbs(e)

	  if (this.nodir) {
	    var c = this.cache[abs]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  if (this.mark)
	    e = this._mark(e)

	  this.matches[index][e] = true

	  var st = this.statCache[abs]
	  if (st)
	    this.emit('stat', e, st)

	  this.emit('match', e)
	}

	Glob.prototype._readdirInGlobStar = function (abs, cb) {
	  if (this.aborted)
	    return

	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false, cb)

	  var lstatkey = 'lstat\0' + abs
	  var self = this
	  var lstatcb = inflight(lstatkey, lstatcb_)

	  if (lstatcb)
	    fs.lstat(abs, lstatcb)

	  function lstatcb_ (er, lstat) {
	    if (er)
	      return cb()

	    var isSym = lstat.isSymbolicLink()
	    self.symlinks[abs] = isSym

	    // If it's not a symlink or a dir, then it's definitely a regular file.
	    // don't bother doing a readdir in that case.
	    if (!isSym && !lstat.isDirectory()) {
	      self.cache[abs] = 'FILE'
	      cb()
	    } else
	      self._readdir(abs, false, cb)
	  }
	}

	Glob.prototype._readdir = function (abs, inGlobStar, cb) {
	  if (this.aborted)
	    return

	  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
	  if (!cb)
	    return

	  //console.error('RD %j %j', +inGlobStar, abs)
	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs, cb)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return cb()

	    if (Array.isArray(c))
	      return cb(null, c)
	  }

	  var self = this
	  fs.readdir(abs, readdirCb(this, abs, cb))
	}

	function readdirCb (self, abs, cb) {
	  return function (er, entries) {
	    if (er)
	      self._readdirError(abs, er, cb)
	    else
	      self._readdirEntries(abs, entries, cb)
	  }
	}

	Glob.prototype._readdirEntries = function (abs, entries, cb) {
	  if (this.aborted)
	    return

	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries
	  return cb(null, entries)
	}

	Glob.prototype._readdirError = function (f, er, cb) {
	  if (this.aborted)
	    return

	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) return this.emit('error', er)
	      if (!this.silent) console.error('glob error', er)
	      break
	  }
	  return cb()
	}

	Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
	  var self = this
	  this._readdir(abs, inGlobStar, function (er, entries) {
	    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
	  })
	}


	Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
	  //console.error('pgs2', prefix, remain[0], entries)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return cb()

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false, cb)

	  var isSym = this.symlinks[abs]
	  var len = entries.length

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return cb()

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true, cb)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true, cb)
	  }

	  cb()
	}

	Glob.prototype._processSimple = function (prefix, index, cb) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var self = this
	  this._stat(prefix, function (er, exists) {
	    self._processSimple2(prefix, index, er, exists, cb)
	  })
	}
	Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

	  //console.error('ps2', prefix, exists)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return cb()

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this._emitMatch(index, prefix)
	  cb()
	}

	// Returns either 'DIR', 'FILE', or false
	Glob.prototype._stat = function (f, cb) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return cb()

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return cb(null, c)

	    if (needDir && c === 'FILE')
	      return cb()

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (stat !== undefined) {
	    if (stat === false)
	      return cb(null, stat)
	    else {
	      var type = stat.isDirectory() ? 'DIR' : 'FILE'
	      if (needDir && type === 'FILE')
	        return cb()
	      else
	        return cb(null, type, stat)
	    }
	  }

	  var self = this
	  var statcb = inflight('stat\0' + abs, lstatcb_)
	  if (statcb)
	    fs.lstat(abs, statcb)

	  function lstatcb_ (er, lstat) {
	    if (lstat && lstat.isSymbolicLink()) {
	      // If it's a symlink, then treat it as the target, unless
	      // the target does not exist, then treat it as a file.
	      return fs.stat(abs, function (er, stat) {
	        if (er)
	          self._stat2(f, abs, null, lstat, cb)
	        else
	          self._stat2(f, abs, er, stat, cb)
	      })
	    } else {
	      self._stat2(f, abs, er, lstat, cb)
	    }
	  }
	}

	Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
	  if (er) {
	    this.statCache[abs] = false
	    return cb()
	  }

	  var needDir = f.slice(-1) === '/'
	  this.statCache[abs] = stat

	  if (abs.slice(-1) === '/' && !stat.isDirectory())
	    return cb(null, false, stat)

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return cb()

	  return cb(null, c, stat)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(12)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])


	var patterns =
	  [ "http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test"
	  , ["a*", ["a", "abc", "abd", "abe"]]
	  , ["X*", ["X*"], {nonull: true}]

	  // allow null glob expansion
	  , ["X*", []]

	  // isaacs: Slightly different than bash/sh/ksh
	  // \\* is not un-escaped to literal "*" in a failed match,
	  // but it does make it get treated as a literal star
	  , ["\\*", ["\\*"], {nonull: true}]
	  , ["\\**", ["\\**"], {nonull: true}]
	  , ["\\*\\*", ["\\*\\*"], {nonull: true}]

	  , ["b*/", ["bdir/"]]
	  , ["c*", ["c", "ca", "cb"]]
	  , ["**", files]

	  , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	  , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]

	  , "legendary larry crashes bashes"
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	  , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]

	  , "character classes"
	  , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	  , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	     "bdir/", "ca", "cb", "dd", "de"]]
	  , ["a*[^c]", ["abd", "abe"]]
	  , function () { files.push("a-b", "aXb") }
	  , ["a[X-]b", ["a-b", "aXb"]]
	  , function () { files.push(".x", ".y") }
	  , ["[^a-c]*", ["d", "dd", "de"]]
	  , function () { files.push("a*b/", "a*b/ooo") }
	  , ["a\\*b/*", ["a*b/ooo"]]
	  , ["a\\*?/*", ["a*b/ooo"]]
	  , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	  , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	  , ["*.\\*", ["r.*"], null, ["r.*"]]
	  , ["a[b]c", ["abc"]]
	  , ["a[\\b]c", ["abc"]]
	  , ["a?c", ["abc"]]
	  , ["a\\*c", [], {null: true}, ["abc"]]
	  , ["", [""], { null: true }, [""]]

	  , "http://www.opensource.apple.com/source/bash/bash-23/" +
	    "bash/tests/glob-test"
	  , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	  , ["*/man*/bash.*", ["man/man1/bash.1"]]
	  , ["man/man1/bash.1", ["man/man1/bash.1"]]
	  , ["a***c", ["abc"], null, ["abc"]]
	  , ["a*****?c", ["abc"], null, ["abc"]]
	  , ["?*****??", ["abc"], null, ["abc"]]
	  , ["*****??", ["abc"], null, ["abc"]]
	  , ["?*****?c", ["abc"], null, ["abc"]]
	  , ["?***?****c", ["abc"], null, ["abc"]]
	  , ["?***?****?", ["abc"], null, ["abc"]]
	  , ["?***?****", ["abc"], null, ["abc"]]
	  , ["*******c", ["abc"], null, ["abc"]]
	  , ["*******?", ["abc"], null, ["abc"]]
	  , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	  , ["[-abc]", ["-"], null, ["-"]]
	  , ["[abc-]", ["-"], null, ["-"]]
	  , ["\\", ["\\"], null, ["\\"]]
	  , ["[\\\\]", ["\\"], null, ["\\"]]
	  , ["[[]", ["["], null, ["["]]
	  , ["[", ["["], null, ["["]]
	  , ["[*", ["[abc"], null, ["[abc"]]
	  , "a right bracket shall lose its special meaning and\n" +
	    "represent itself in a bracket expression if it occurs\n" +
	    "first in the list.  -- POSIX.2 2.8.3.2"
	  , ["[]]", ["]"], null, ["]"]]
	  , ["[]-]", ["]"], null, ["]"]]
	  , ["[a-\z]", ["p"], null, ["p"]]
	  , ["??**********?****?", [], { null: true }, ["abc"]]
	  , ["??**********?****c", [], { null: true }, ["abc"]]
	  , ["?************c****?****", [], { null: true }, ["abc"]]
	  , ["*c*?**", [], { null: true }, ["abc"]]
	  , ["a*****c*?**", [], { null: true }, ["abc"]]
	  , ["a********???*******", [], { null: true }, ["abc"]]
	  , ["[]", [], { null: true }, ["a"]]
	  , ["[abc", [], { null: true }, ["["]]

	  , "nocase tests"
	  , ["XYZ", ["xYz"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["ab*", ["ABC"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]
	  , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	    , ["xYz", "ABC", "IjK"]]

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  , "onestar/twostar"
	  , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	  , ["{/?,*}", ["/a", "bb"], {null: true}
	    , ["/a", "/b/b", "/a/b/c", "bb"]]

	  , "dots should not match unless requested"
	  , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]

	  // .. and . can only match patterns starting with .,
	  // even when options.dot is set.
	  , function () {
	      files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	    }
	  , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	  , ["a/*/b", ["a/c/b"], {dot:false}]
	  , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]


	  // this also tests that changing the options needs
	  // to change the cache key, even if the pattern is
	  // the same!
	  , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	    , [ ".a/.d", "a/.d", "a/b"]]

	  , "paren sets cannot contain slashes"
	  , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]

	  // brace sets trump all else.
	  //
	  // invalid glob pattern.  fails on bash4 and bsdglob.
	  // however, in this implementation, it's easier just
	  // to do the intuitive thing, and let brace-expansion
	  // actually come before parsing any extglob patterns,
	  // like the documentation seems to say.
	  //
	  // XXX: if anyone complains about this, either fix it
	  // or tell them to grow up and stop complaining.
	  //
	  // bash/bsdglob says this:
	  // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	  // but we do this instead:
	  , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]

	  // test partial parsing in the presence of comment/negation chars
	  , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	  , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]

	  // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	  , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	    , {}
	    , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]


	  // crazy nested {,,} and *(||) tests.
	  , function () {
	      files = [ "a", "b", "c", "d"
	              , "ab", "ac", "ad"
	              , "bc", "cb"
	              , "bc,d", "c,db", "c,d"
	              , "d)", "(b|c", "*(b|c"
	              , "b|c", "b|cc", "cb|c"
	              , "x(a|b|c)", "x(a|c)"
	              , "(a|b|c)", "(a|c)"]
	    }
	  , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	  , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	  // a
	  // *(b|c)
	  // *(b|d)
	  , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	  , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]


	  // test various flag settings.
	  , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	    , { noext: true } ]
	  , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	    , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	  , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]


	  // begin channelling Boole and deMorgan...
	  , "negation tests"
	  , function () {
	      files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	    }

	  // anything that is NOT a* matches.
	  , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]

	  // anything that IS !a* matches.
	  , ["!a*", ["!ab", "!abc"], {nonegate: true}]

	  // anything that IS a* matches
	  , ["!!a*", ["a!b"]]

	  // anything that is NOT !a* matches
	  , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]

	  // negation nestled within a pattern
	  , function () {
	      files = [ "foo.js"
	              , "foo.bar"
	              // can't match this one without negative lookbehind.
	              , "foo.js.js"
	              , "blar.js"
	              , "foo."
	              , "boo.js.boo" ]
	    }
	  , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]

	  // https://github.com/isaacs/minimatch/issues/5
	  , function () {
	      files = [ 'a/b/.x/c'
	              , 'a/b/.x/c/d'
	              , 'a/b/.x/c/d/e'
	              , 'a/b/.x'
	              , 'a/b/.x/'
	              , 'a/.x/b'
	              , '.x'
	              , '.x/'
	              , '.x/a'
	              , '.x/a/b'
	              , 'a/.x/b/.x/c'
	              , '.x/.x' ]
	  }
	  , ["**/.x/**", [ '.x/'
	                 , '.x/a'
	                 , '.x/a/b'
	                 , 'a/.x/b'
	                 , 'a/b/.x/'
	                 , 'a/b/.x/c'
	                 , 'a/b/.x/c/d'
	                 , 'a/b/.x/c/d/e' ] ]

	  ]

	var regexps =
	  [ '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:(?=.)X[^/]*?)$/',
	    '/^(?:\\*)$/',
	    '/^(?:(?=.)\\*[^/]*?)$/',
	    '/^(?:\\*\\*)$/',
	    '/^(?:(?=.)b[^/]*?\\/)$/',
	    '/^(?:(?=.)c[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:\\.\\.\\/(?!\\.)(?=.)[^/]*?\\/)$/',
	    '/^(?:s\\/(?=.)\\.\\.[^/]*?\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/1\\/)$/',
	    '/^(?:\\/\\^root:\\/\\{s\\/(?=.)\\^[^:][^/]*?:[^:][^/]*?:\\([^:]\\)[^/]*?\\.[^/]*?\\$\\/\u0001\\/)$/',
	    '/^(?:(?!\\.)(?=.)[a-c]b[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[a-y][^/]*?[^c])$/',
	    '/^(?:(?=.)a[^/]*?[^c])$/',
	    '/^(?:(?=.)a[X-]b)$/',
	    '/^(?:(?!\\.)(?=.)[^a-c][^/]*?)$/',
	    '/^(?:a\\*b\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?=.)a\\*[^/]\\/(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\\\\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\![^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.\\*)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[b]c)$/',
	    '/^(?:(?=.)a[^/]c)$/',
	    '/^(?:a\\*c)$/',
	    'false',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\/(?=.)man[^/]*?\\/(?=.)bash\\.[^/]*?)$/',
	    '/^(?:man\\/man1\\/bash\\.1)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?=.)a[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/]k[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/][^/]*?[^/]*?cd[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?k[^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[-abc])$/',
	    '/^(?:(?!\\.)(?=.)[abc-])$/',
	    '/^(?:\\\\)$/',
	    '/^(?:(?!\\.)(?=.)[\\\\])$/',
	    '/^(?:(?!\\.)(?=.)[\\[])$/',
	    '/^(?:\\[)$/',
	    '/^(?:(?=.)\\[(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[\\]])$/',
	    '/^(?:(?!\\.)(?=.)[\\]-])$/',
	    '/^(?:(?!\\.)(?=.)[a-z])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/])$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?c)$/',
	    '/^(?:(?!\\.)(?=.)[^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?c[^/]*?[^/][^/]*?[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/][^/][^/][^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?[^/]*?)$/',
	    '/^(?:\\[\\])$/',
	    '/^(?:\\[abc)$/',
	    '/^(?:(?=.)XYZ)$/i',
	    '/^(?:(?=.)ab[^/]*?)$/i',
	    '/^(?:(?!\\.)(?=.)[ia][^/][ck])$/i',
	    '/^(?:\\/(?!\\.)(?=.)[^/]*?|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:\\/(?!\\.)(?=.)[^/]|(?!\\.)(?=.)[^/]*?)$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?)$/',
	    '/^(?:a\\/(?!(?:^|\\/)\\.{1,2}(?:$|\\/))(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:a\\/(?!\\.)(?=.)[^/]*?\\/b)$/',
	    '/^(?:a\\/(?=.)\\.[^/]*?\\/b)$/',
	    '/^(?:(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\/b\\))$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?=.)\\[(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)\\[(?=.)#a[^/]*?)$/',
	    '/^(?:(?=.)\\+\\(a\\|[^/]*?\\|c\\\\\\\\\\|d\\\\\\\\\\|e\\\\\\\\\\\\\\\\\\|f\\\\\\\\\\\\\\\\\\|g)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:a|(?!\\.)(?=.)[^/]*?\\(b\\|c|d\\))$/',
	    '/^(?:a|(?!\\.)(?=.)(?:b|c)*|(?!\\.)(?=.)(?:b|d)*)$/',
	    '/^(?:(?!\\.)(?=.)(?:a|b|c)*|(?!\\.)(?=.)(?:a|c)*)$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\(a\\|b\\|c\\)|(?!\\.)(?=.)[^/]*?\\(a\\|c\\))$/',
	    '/^(?:(?=.)a[^/]b)$/',
	    '/^(?:(?=.)#[^/]*?)$/',
	    '/^(?!^(?:(?=.)a[^/]*?)$).*$/',
	    '/^(?:(?=.)\\!a[^/]*?)$/',
	    '/^(?:(?=.)a[^/]*?)$/',
	    '/^(?!^(?:(?=.)\\!a[^/]*?)$).*$/',
	    '/^(?:(?!\\.)(?=.)[^/]*?\\.(?:(?!js)[^/]*?))$/',
	    '/^(?:(?:(?!(?:\\/|^)\\.).)*?\\/\\.x\\/(?:(?!(?:\\/|^)\\.).)*?)$/' ]
	var re = 0;

	tap.test("basic tests", function (t) {
	  var start = Date.now()

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  patterns.forEach(function (c) {
	    if (typeof c === "function") return c()
	    if (typeof c === "string") return t.comment(c)

	    var pattern = c[0]
	      , expect = c[1].sort(alpha)
	      , options = c[2] || {}
	      , f = c[3] || files
	      , tapOpts = c[4] || {}

	    // options.debug = true
	    var m = new mm.Minimatch(pattern, options)
	    var r = m.makeRe()
	    var expectRe = regexps[re++]
	    tapOpts.re = String(r) || JSON.stringify(r)
	    tapOpts.files = JSON.stringify(f)
	    tapOpts.pattern = pattern
	    tapOpts.set = m.set
	    tapOpts.negated = m.negate

	    var actual = mm.match(f, pattern, options)
	    actual.sort(alpha)

	    t.equivalent( actual, expect
	                , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                , tapOpts )

	    t.equal(tapOpts.re, expectRe, tapOpts)
	  })

	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})

	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})

	function alpha (a, b) {
	  return a > b ? 1 : -1
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , minimatch = __webpack_require__(12)

	tap.test("brace expansion", function (t) {
	  // [ pattern, [expanded] ]
	  ; [ [ "a{b,c{d,e},{f,g}h}x{y,z}"
	      , [ "abxy"
	        , "abxz"
	        , "acdxy"
	        , "acdxz"
	        , "acexy"
	        , "acexz"
	        , "afhxy"
	        , "afhxz"
	        , "aghxy"
	        , "aghxz" ] ]
	    , [ "a{1..5}b"
	      , [ "a1b"
	        , "a2b"
	        , "a3b"
	        , "a4b"
	        , "a5b" ] ]
	    , [ "a{b}c", ["a{b}c"] ]
	  ].forEach(function (tc) {
	    var p = tc[0]
	      , expect = tc[1]
	    t.equivalent(minimatch.braceExpand(p), expect, p)
	  })
	  console.error("ending")
	  t.end()
	})




/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	var Minimatch = __webpack_require__(12).Minimatch
	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	tap.test("cache test", function (t) {
	  var mm1 = new Minimatch("a?b")
	  var mm2 = new Minimatch("a?b")
	  t.equal(mm1, mm2, "should get the same object")
	  // the lru should drop it after 100 entries
	  for (var i = 0; i < 100; i ++) {
	    new Minimatch("a"+i)
	  }
	  mm2 = new Minimatch("a?b")
	  t.notEqual(mm1, mm2, "cache should have dropped")
	  t.end()
	})


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {// http://www.bashcookbook.com/bashinfo/source/bash-1.14.7/tests/glob-test
	//
	// TODO: Some of these tests do very bad things with backslashes, and will
	// most likely fail badly on windows.  They should probably be skipped.

	var tap = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	  , globalBefore = Object.keys(global)
	  , mm = __webpack_require__(12)
	  , files = [ "a", "b", "c", "d", "abc"
	            , "abd", "abe", "bb", "bcd"
	            , "ca", "cb", "dd", "de"
	            , "bdir/", "bdir/cfile"]
	  , next = files.concat([ "a-b", "aXb"
	                        , ".x", ".y" ])

	tap.test("basic tests", function (t) {
	  var start = Date.now()

	  // [ pattern, [matches], MM opts, files, TAP opts]
	  ; [ "http://www.bashcookbook.com/bashinfo" +
	      "/source/bash-1.14.7/tests/glob-test"
	    , ["a*", ["a", "abc", "abd", "abe"]]
	    , ["X*", ["X*"], {nonull: true}]

	    // allow null glob expansion
	    , ["X*", []]

	    // isaacs: Slightly different than bash/sh/ksh
	    // \\* is not un-escaped to literal "*" in a failed match,
	    // but it does make it get treated as a literal star
	    , ["\\*", ["\\*"], {nonull: true}]
	    , ["\\**", ["\\**"], {nonull: true}]
	    , ["\\*\\*", ["\\*\\*"], {nonull: true}]

	    , ["b*/", ["bdir/"]]
	    , ["c*", ["c", "ca", "cb"]]
	    , ["**", files]

	    , ["\\.\\./*/", ["\\.\\./*/"], {nonull: true}]
	    , ["s/\\..*//", ["s/\\..*//"], {nonull: true}]

	    , "legendary larry crashes bashes"
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\\1/"], {nonull: true}]
	    , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"
	      , ["/^root:/{s/^[^:]*:[^:]*:\([^:]*\).*$/\1/"], {nonull: true}]

	    , "character classes"
	    , ["[a-c]b*", ["abc", "abd", "abe", "bb", "cb"]]
	    , ["[a-y]*[^c]", ["abd", "abe", "bb", "bcd",
	       "bdir/", "ca", "cb", "dd", "de"]]
	    , ["a*[^c]", ["abd", "abe"]]
	    , function () { files.push("a-b", "aXb") }
	    , ["a[X-]b", ["a-b", "aXb"]]
	    , function () { files.push(".x", ".y") }
	    , ["[^a-c]*", ["d", "dd", "de"]]
	    , function () { files.push("a*b/", "a*b/ooo") }
	    , ["a\\*b/*", ["a*b/ooo"]]
	    , ["a\\*?/*", ["a*b/ooo"]]
	    , ["*\\\\!*", [], {null: true}, ["echo !7"]]
	    , ["*\\!*", ["echo !7"], null, ["echo !7"]]
	    , ["*.\\*", ["r.*"], null, ["r.*"]]
	    , ["a[b]c", ["abc"]]
	    , ["a[\\b]c", ["abc"]]
	    , ["a?c", ["abc"]]
	    , ["a\\*c", [], {null: true}, ["abc"]]
	    , ["", [""], { null: true }, [""]]

	    , "http://www.opensource.apple.com/source/bash/bash-23/" +
	      "bash/tests/glob-test"
	    , function () { files.push("man/", "man/man1/", "man/man1/bash.1") }
	    , ["*/man*/bash.*", ["man/man1/bash.1"]]
	    , ["man/man1/bash.1", ["man/man1/bash.1"]]
	    , ["a***c", ["abc"], null, ["abc"]]
	    , ["a*****?c", ["abc"], null, ["abc"]]
	    , ["?*****??", ["abc"], null, ["abc"]]
	    , ["*****??", ["abc"], null, ["abc"]]
	    , ["?*****?c", ["abc"], null, ["abc"]]
	    , ["?***?****c", ["abc"], null, ["abc"]]
	    , ["?***?****?", ["abc"], null, ["abc"]]
	    , ["?***?****", ["abc"], null, ["abc"]]
	    , ["*******c", ["abc"], null, ["abc"]]
	    , ["*******?", ["abc"], null, ["abc"]]
	    , ["a*cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??k***", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a**?**cd**?**??***k**", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["a****c**?**??*****", ["abcdecdhjk"], null, ["abcdecdhjk"]]
	    , ["[-abc]", ["-"], null, ["-"]]
	    , ["[abc-]", ["-"], null, ["-"]]
	    , ["\\", ["\\"], null, ["\\"]]
	    , ["[\\\\]", ["\\"], null, ["\\"]]
	    , ["[[]", ["["], null, ["["]]
	    , ["[", ["["], null, ["["]]
	    , ["[*", ["[abc"], null, ["[abc"]]
	    , "a right bracket shall lose its special meaning and\n" +
	      "represent itself in a bracket expression if it occurs\n" +
	      "first in the list.  -- POSIX.2 2.8.3.2"
	    , ["[]]", ["]"], null, ["]"]]
	    , ["[]-]", ["]"], null, ["]"]]
	    , ["[a-\z]", ["p"], null, ["p"]]
	    , ["??**********?****?", [], { null: true }, ["abc"]]
	    , ["??**********?****c", [], { null: true }, ["abc"]]
	    , ["?************c****?****", [], { null: true }, ["abc"]]
	    , ["*c*?**", [], { null: true }, ["abc"]]
	    , ["a*****c*?**", [], { null: true }, ["abc"]]
	    , ["a********???*******", [], { null: true }, ["abc"]]
	    , ["[]", [], { null: true }, ["a"]]
	    , ["[abc", [], { null: true }, ["["]]

	    , "nocase tests"
	    , ["XYZ", ["xYz"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["ab*", ["ABC"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]
	    , ["[ia]?[ck]", ["ABC", "IjK"], { nocase: true, null: true }
	      , ["xYz", "ABC", "IjK"]]

	    // [ pattern, [matches], MM opts, files, TAP opts]
	    , "onestar/twostar"
	    , ["{/*,*}", [], {null: true}, ["/asdf/asdf/asdf"]]
	    , ["{/?,*}", ["/a", "bb"], {null: true}
	      , ["/a", "/b/b", "/a/b/c", "bb"]]

	    , "dots should not match unless requested"
	    , ["**", ["a/b"], {}, ["a/b", "a/.d", ".a/.d"]]

	    // .. and . can only match patterns starting with .,
	    // even when options.dot is set.
	    , function () {
	        files = ["a/./b", "a/../b", "a/c/b", "a/.d/b"]
	      }
	    , ["a/*/b", ["a/c/b", "a/.d/b"], {dot: true}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: true}]
	    , ["a/*/b", ["a/c/b"], {dot:false}]
	    , ["a/.*/b", ["a/./b", "a/../b", "a/.d/b"], {dot: false}]


	    // this also tests that changing the options needs
	    // to change the cache key, even if the pattern is
	    // the same!
	    , ["**", ["a/b","a/.d",".a/.d"], { dot: true }
	      , [ ".a/.d", "a/.d", "a/b"]]

	    , "paren sets cannot contain slashes"
	    , ["*(a/b)", ["*(a/b)"], {nonull: true}, ["a/b"]]

	    // brace sets trump all else.
	    //
	    // invalid glob pattern.  fails on bash4 and bsdglob.
	    // however, in this implementation, it's easier just
	    // to do the intuitive thing, and let brace-expansion
	    // actually come before parsing any extglob patterns,
	    // like the documentation seems to say.
	    //
	    // XXX: if anyone complains about this, either fix it
	    // or tell them to grow up and stop complaining.
	    //
	    // bash/bsdglob says this:
	    // , ["*(a|{b),c)}", ["*(a|{b),c)}"], {}, ["a", "ab", "ac", "ad"]]
	    // but we do this instead:
	    , ["*(a|{b),c)}", ["a", "ab", "ac"], {}, ["a", "ab", "ac", "ad"]]

	    // test partial parsing in the presence of comment/negation chars
	    , ["[!a*", ["[!ab"], {}, ["[!ab", "[ab"]]
	    , ["[#a*", ["[#ab"], {}, ["[#ab", "[ab"]]

	    // like: {a,b|c\\,d\\\|e} except it's unclosed, so it has to be escaped.
	    , ["+(a|*\\|c\\\\|d\\\\\\|e\\\\\\\\|f\\\\\\\\\\|g"
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g"]
	      , {}
	      , ["+(a|b\\|c\\\\|d\\\\|e\\\\\\\\|f\\\\\\\\|g", "a", "b\\c"]]


	    // crazy nested {,,} and *(||) tests.
	    , function () {
	        files = [ "a", "b", "c", "d"
	                , "ab", "ac", "ad"
	                , "bc", "cb"
	                , "bc,d", "c,db", "c,d"
	                , "d)", "(b|c", "*(b|c"
	                , "b|c", "b|cc", "cb|c"
	                , "x(a|b|c)", "x(a|c)"
	                , "(a|b|c)", "(a|c)"]
	      }
	    , ["*(a|{b,c})", ["a", "b", "c", "ab", "ac"]]
	    , ["{a,*(b|c,d)}", ["a","(b|c", "*(b|c", "d)"]]
	    // a
	    // *(b|c)
	    // *(b|d)
	    , ["{a,*(b|{c,d})}", ["a","b", "bc", "cb", "c", "d"]]
	    , ["*(a|{b|c,c})", ["a", "b", "c", "ab", "ac", "bc", "cb"]]


	    // test various flag settings.
	    , [ "*(a|{b|c,c})", ["x(a|b|c)", "x(a|c)", "(a|b|c)", "(a|c)"]
	      , { noext: true } ]
	    , ["a?b", ["x/y/acb", "acb/"], {matchBase: true}
	      , ["x/y/acb", "acb/", "acb/d/e", "x/y/acb/d"] ]
	    , ["#*", ["#a", "#b"], {nocomment: true}, ["#a", "#b", "c#d"]]


	    // begin channelling Boole and deMorgan...
	    , "negation tests"
	    , function () {
	        files = ["d", "e", "!ab", "!abc", "a!b", "\\!a"]
	      }

	    // anything that is NOT a* matches.
	    , ["!a*", ["\\!a", "d", "e", "!ab", "!abc"]]

	    // anything that IS !a* matches.
	    , ["!a*", ["!ab", "!abc"], {nonegate: true}]

	    // anything that IS a* matches
	    , ["!!a*", ["a!b"]]

	    // anything that is NOT !a* matches
	    , ["!\\!a*", ["a!b", "d", "e", "\\!a"]]

	    // negation nestled within a pattern
	    , function () {
	        files = [ "foo.js"
	                , "foo.bar"
	                // can't match this one without negative lookbehind.
	                , "foo.js.js"
	                , "blar.js"
	                , "foo."
	                , "boo.js.boo" ]
	      }
	    , ["*.!(js)", ["foo.bar", "foo.", "boo.js.boo"] ]

	    ].forEach(function (c) {
	      if (typeof c === "function") return c()
	      if (typeof c === "string") return t.comment(c)

	      var pattern = c[0]
	        , expect = c[1].sort(alpha)
	        , options = c[2] || {}
	        , f = c[3] || files
	        , tapOpts = c[4] || {}

	      // options.debug = true
	      var Class = mm.defaults(options).Minimatch
	      var m = new Class(pattern, {})
	      var r = m.makeRe()
	      tapOpts.re = String(r) || JSON.stringify(r)
	      tapOpts.files = JSON.stringify(f)
	      tapOpts.pattern = pattern
	      tapOpts.set = m.set
	      tapOpts.negated = m.negate

	      var actual = mm.match(f, pattern, options)
	      actual.sort(alpha)

	      t.equivalent( actual, expect
	                  , JSON.stringify(pattern) + " " + JSON.stringify(expect)
	                  , tapOpts )
	    })

	  t.comment("time=" + (Date.now() - start) + "ms")
	  t.end()
	})

	tap.test("global leak test", function (t) {
	  var globalAfter = Object.keys(global)
	  t.equivalent(globalAfter, globalBefore, "no new globals, please")
	  t.end()
	})

	function alpha (a, b) {
	  return a > b ? 1 : -1
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	var test = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"tap\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).test
	var minimatch = __webpack_require__(12)

	test('extglob ending with statechar', function(t) {
	  t.notOk(minimatch('ax', 'a?(b*)'))
	  t.ok(minimatch('ax', '?(a*|b)'))
	  t.end()
	})


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Transform = __webpack_require__(71)
	  , inherits  = __webpack_require__(9).inherits
	  , xtend     = __webpack_require__(124)

	function DestroyableTransform(opts) {
	  Transform.call(this, opts)
	  this._destroyed = false
	}

	inherits(DestroyableTransform, Transform)

	DestroyableTransform.prototype.destroy = function(err) {
	  if (this._destroyed) return
	  this._destroyed = true
	  
	  var self = this
	  process.nextTick(function() {
	    if (err)
	      self.emit('error', err)
	    self.emit('close')
	  })
	}

	// a noop _transform function
	function noop (chunk, enc, callback) {
	  callback(null, chunk)
	}


	// create a new export function, used by both the main export and
	// the .ctor export, contains common logic for dealing with arguments
	function through2 (construct) {
	  return function (options, transform, flush) {
	    if (typeof options == 'function') {
	      flush     = transform
	      transform = options
	      options   = {}
	    }

	    if (typeof transform != 'function')
	      transform = noop

	    if (typeof flush != 'function')
	      flush = null

	    return construct(options, transform, flush)
	  }
	}


	// main export, just make me a transform stream!
	module.exports = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(options)

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})


	// make me a reusable prototype that I can `new`, or implicitly `new`
	// with a constructor call
	module.exports.ctor = through2(function (options, transform, flush) {
	  function Through2 (override) {
	    if (!(this instanceof Through2))
	      return new Through2(override)

	    this.options = xtend(options, override)

	    DestroyableTransform.call(this, this.options)
	  }

	  inherits(Through2, DestroyableTransform)

	  Through2.prototype._transform = transform

	  if (flush)
	    Through2.prototype._flush = flush

	  return Through2
	})


	module.exports.obj = through2(function (options, transform, flush) {
	  var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options))

	  t2._transform = transform

	  if (flush)
	    t2._flush = flush

	  return t2
	})

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(3).Stream;

	module.exports = function(o) {
	  return !!o && o instanceof Stream;
	};

/***/ },
/* 64 */
/***/ function(module, exports) {

	var toString = {}.toString;

	module.exports = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's Core schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2804923
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, Core schema has no distinctions from JSON schema is JS-YAML.


	'use strict';


	var Schema = __webpack_require__(21);


	module.exports = new Schema({
	  include: [
	    __webpack_require__(66)
	  ]
	});


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	// Standard YAML's JSON schema.
	// http://www.yaml.org/spec/1.2/spec.html#id2803231
	//
	// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
	// So, this schema is not such strict as defined in the YAML specification.
	// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.


	'use strict';


	var Schema = __webpack_require__(21);


	module.exports = new Schema({
	  include: [
	    __webpack_require__(40)
	  ],
	  implicit: [
	    __webpack_require__(242),
	    __webpack_require__(234),
	    __webpack_require__(236),
	    __webpack_require__(235)
	  ]
	});


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(6);
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var _0777 = parseInt('0777', 8);

	module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;

	function mkdirP (p, opts, f, made) {
	    if (typeof opts === 'function') {
	        f = opts;
	        opts = {};
	    }
	    else if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;
	    
	    var cb = f || function () {};
	    p = path.resolve(p);
	    
	    xfs.mkdir(p, mode, function (er) {
	        if (!er) {
	            made = made || p;
	            return cb(null, made);
	        }
	        switch (er.code) {
	            case 'ENOENT':
	                mkdirP(path.dirname(p), opts, function (er, made) {
	                    if (er) cb(er, made);
	                    else mkdirP(p, opts, cb, made);
	                });
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                xfs.stat(p, function (er2, stat) {
	                    // if the stat fails, then that's super weird.
	                    // let the original error be the failure reason.
	                    if (er2 || !stat.isDirectory()) cb(er, made)
	                    else cb(null, made);
	                });
	                break;
	        }
	    });
	}

	mkdirP.sync = function sync (p, opts, made) {
	    if (!opts || typeof opts !== 'object') {
	        opts = { mode: opts };
	    }
	    
	    var mode = opts.mode;
	    var xfs = opts.fs || fs;
	    
	    if (mode === undefined) {
	        mode = _0777 & (~process.umask());
	    }
	    if (!made) made = null;

	    p = path.resolve(p);

	    try {
	        xfs.mkdirSync(p, mode);
	        made = made || p;
	    }
	    catch (err0) {
	        switch (err0.code) {
	            case 'ENOENT' :
	                made = sync(path.dirname(p), opts, made);
	                sync(p, opts, made);
	                break;

	            // In the case of any other error, just see if there's a dir
	            // there already.  If so, then hooray!  If not, then something
	            // is borked.
	            default:
	                var stat;
	                try {
	                    stat = xfs.statSync(p);
	                }
	                catch (err1) {
	                    throw err0;
	                }
	                if (!stat.isDirectory()) throw err0;
	                break;
	        }
	    }

	    return made;
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(46)
	module.exports = wrappy(once)
	module.exports.strict = wrappy(onceStrict)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })

	  Object.defineProperty(Function.prototype, 'onceStrict', {
	    value: function () {
	      return onceStrict(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}

	function onceStrict (fn) {
	  var f = function () {
	    if (f.called)
	      throw new Error(f.onceError)
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  var name = fn.name || 'Function wrapped with `once`'
	  f.onceError = name + " shouldn't be called more than once"
	  f.called = false
	  return f
	}


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	'use strict';

	module.exports = PassThrough;

	var Transform = __webpack_require__(44);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	module.exports = Readable;

	/*<replacement>*/
	var processNextTick = __webpack_require__(43);
	/*</replacement>*/

	/*<replacement>*/
	var isArray = __webpack_require__(64);
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	var EE = __webpack_require__(11).EventEmitter;

	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream;
	(function () {
	  try {
	    Stream = __webpack_require__(3);
	  } catch (_) {} finally {
	    if (!Stream) Stream = __webpack_require__(11).EventEmitter;
	  }
	})();
	/*</replacement>*/

	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(36);
	/*</replacement>*/

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = __webpack_require__(324);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var BufferList = __webpack_require__(272);
	var StringDecoder;

	util.inherits(Readable, Stream);

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') {
	    return emitter.prependListener(event, fn);
	  } else {
	    // This is a hack to make sure that our error handler is attached before any
	    // userland ones.  NEVER DO THIS. This is here only because this code needs
	    // to continue to work with older versions of Node.js that do not include
	    // the prependListener() method. The goal is to eventually remove this hack.
	    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	  }
	}

	function ReadableState(options, stream) {
	  Duplex = Duplex || __webpack_require__(16);

	  options = options || {};

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~ ~this.highWaterMark;

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = __webpack_require__(17).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  Duplex = Duplex || __webpack_require__(16);

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options && typeof options.read === 'function') this._read = options.read;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;

	  if (!state.objectMode && typeof chunk === 'string') {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = bufferShim.from(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var _e = new Error('stream.unshift() after end event');
	      stream.emit('error', _e);
	    } else {
	      var skipAdd;
	      if (state.decoder && !addToFront && !encoding) {
	        chunk = state.decoder.write(chunk);
	        skipAdd = !state.objectMode && chunk.length === 0;
	      }

	      if (!addToFront) state.reading = false;

	      // Don't add to the buffer if we've decoded to an empty string chunk and
	      // we're not in object mode
	      if (!skipAdd) {
	        // if we want the data now, just emit it.
	        if (state.flowing && state.length === 0 && !state.sync) {
	          stream.emit('data', chunk);
	          stream.read(0);
	        } else {
	          // update the buffer info.
	          state.length += state.objectMode ? 1 : chunk.length;
	          if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	          if (state.needReadable) emitReadable(stream);
	        }
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = __webpack_require__(17).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) && typeof chunk !== 'string' && chunk !== null && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    processNextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', src._readableState.awaitDrain);
	        src._readableState.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this);
	    }return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;

	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        processNextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    processNextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function (ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = bufferShim.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    processNextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function forEach(xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(44)


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	var path = __webpack_require__(6);

	module.exports = function(npath, ext) {
	  if (typeof npath !== 'string') return npath;
	  if (npath.length === 0) return npath;

	  var nFileName = path.basename(npath, path.extname(npath))+ext;
	  return path.join(path.dirname(npath), nFileName);
	};

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = __webpack_require__(28);
	var has = Object.prototype.hasOwnProperty;

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = util.toSetString(aStr);
	  var isDuplicate = has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    this._set[sStr] = idx;
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  var sStr = util.toSetString(aStr);
	  return has.call(this._set, sStr);
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  var sStr = util.toSetString(aStr);
	  if (has.call(this._set, sStr)) {
	    return this._set[sStr];
	  }
	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	exports.ArraySet = ArraySet;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */

	var base64 = __webpack_require__(279);

	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	exports.encode = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var base64VLQ = __webpack_require__(74);
	var util = __webpack_require__(28);
	var ArraySet = __webpack_require__(73).ArraySet;
	var MappingList = __webpack_require__(281).MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet();
	  this._names = new ArraySet();
	  this._mappings = new MappingList();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet();
	    var newNames = new ArraySet();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source)
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = ''

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64VLQ.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64VLQ.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64VLQ.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64VLQ.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64VLQ.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	exports.SourceMapGenerator = SourceMapGenerator;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * Copyright 2009-2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE.txt or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */
	exports.SourceMapGenerator = __webpack_require__(75).SourceMapGenerator;
	exports.SourceMapConsumer = __webpack_require__(283).SourceMapConsumer;
	exports.SourceNode = __webpack_require__(284).SourceNode;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	var EventEmitter = __webpack_require__(11).EventEmitter;

	var sparklesNamespace = 'store@sparkles';
	var defaultNamespace = 'default';

	function getStore(){
	  var store = global[sparklesNamespace];

	  if(!store){
	    store = global[sparklesNamespace] = {};
	  }

	  return store;
	}

	function getEmitter(namespace){

	  var store = getStore();

	  namespace = namespace || defaultNamespace;

	  var ee = store[namespace];

	  if(!ee){
	    ee = store[namespace] = new EventEmitter();
	    ee.setMaxListeners(0);
	    ee.remove = function remove(){
	      ee.removeAllListeners();
	      delete store[namespace];
	    };
	  }

	  return ee;
	}

	function exists(namespace){
	  var store = getStore();

	  return !!(store[namespace]);
	}

	module.exports = getEmitter;
	module.exports.exists = exists;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	var isUtf8 = __webpack_require__(227);

	var stripBom = module.exports = function (arg) {
		if (typeof arg === 'string') {
			return arg.replace(/^\ufeff/g, '');
		}

		if (Buffer.isBuffer(arg) && isUtf8(arg) &&
			arg[0] === 0xef && arg[1] === 0xbb && arg[2] === 0xbf) {
			return arg.slice(3);
		}

		return arg;
	};

	stripBom.stream = function () {
		var firstChunk = __webpack_require__(188);

		return firstChunk({minSize: 3}, function (chunk, enc, cb) {
			this.push(stripBom(chunk));
			cb();
		});
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EXTEND = __webpack_require__(24);

	var JSAPI = module.exports = function(data, parentNode) {
	    EXTEND(this, data);
	    if (parentNode) {
	        Object.defineProperty(this, 'parentNode', {
	            writable: true,
	            value: parentNode
	        });
	    }
	};

	/**
	 * Perform a deep clone of this node.
	 *
	 * @return {Object} element
	 */
	JSAPI.prototype.clone = function() {
	    var node = this;
	    var nodeData = {};

	    Object.keys(node).forEach(function(key) {
	        if (key !== 'content') {
	            nodeData[key] = node[key];
	        }
	    });

	    // Deep-clone node data
	    // This is still faster than using EXTEND(true…)
	    nodeData = JSON.parse(JSON.stringify(nodeData));

	    // parentNode gets set to a proper object by the parent clone,
	    // but it needs to be true/false now to do the right thing
	    // in the constructor.
	    var clonedNode = new JSAPI(nodeData, !!node.parentNode);

	    if (node.content) {
	        clonedNode.content = node.content.map(function(childNode) {
	            var clonedChild = childNode.clone();
	            clonedChild.parentNode = clonedNode;
	            return clonedChild;
	        });
	    }

	    return clonedNode;
	};

	/**
	 * Determine if item is an element
	 * (any, with a specific name or in a names array).
	 *
	 * @param {String|Array} [param] element name or names arrays
	 * @return {Boolean}
	 */
	JSAPI.prototype.isElem = function(param) {

	    if (!param) return !!this.elem;

	    if (Array.isArray(param)) return !!this.elem && (param.indexOf(this.elem) > -1);

	    return !!this.elem && this.elem === param;

	};

	/**
	 * Renames an element
	 *
	 * @param {String} name new element name
	 * @return {Object} element
	 */
	JSAPI.prototype.renameElem = function(name) {

	    if (name && typeof name === 'string')
	        this.elem = this.local = name;

	    return this;

	};

	/**
	 * Determine if element is empty.
	 *
	 * @return {Boolean}
	 */
	 JSAPI.prototype.isEmpty = function() {

	    return !this.content || !this.content.length;

	};

	/**
	 * Changes content by removing elements and/or adding new elements.
	 *
	 * @param {Number} start Index at which to start changing the content.
	 * @param {Number} n Number of elements to remove.
	 * @param {Array|Object} [insertion] Elements to add to the content.
	 * @return {Array} Removed elements.
	 */
	 JSAPI.prototype.spliceContent = function(start, n, insertion) {

	    if (arguments.length < 2) return [];

	    if (!Array.isArray(insertion))
	        insertion = Array.apply(null, arguments).slice(2);

	    insertion.forEach(function(inner) { inner.parentNode = this }, this);

	    return this.content.splice.apply(this.content, [start, n].concat(insertion));


	};

	/**
	 * Determine if element has an attribute
	 * (any, or by name or by name + value).
	 *
	 * @param {String} [name] attribute name
	 * @param {String} [val] attribute value (will be toString()'ed)
	 * @return {Boolean}
	 */
	 JSAPI.prototype.hasAttr = function(name, val) {

	    if (!this.attrs || !Object.keys(this.attrs).length) return false;

	    if (!arguments.length) return !!this.attrs;

	    if (val !== undefined) return !!this.attrs[name] && this.attrs[name].value === val.toString();

	    return !!this.attrs[name];

	};

	/**
	 * Determine if element has an attribute by local name
	 * (any, or by name or by name + value).
	 *
	 * @param {String} [localName] local attribute name
	 * @param {Number|String|RegExp|Function} [val] attribute value (will be toString()'ed or executed, otherwise ignored)
	 * @return {Boolean}
	 */
	 JSAPI.prototype.hasAttrLocal = function(localName, val) {

	    if (!this.attrs || !Object.keys(this.attrs).length) return false;

	    if (!arguments.length) return !!this.attrs;

	    var callback;

	    switch (val != null && val.constructor && val.constructor.name) {
	        case 'Number':   // same as String
	        case 'String':   callback = stringValueTest; break;
	        case 'RegExp':   callback = regexpValueTest; break;
	        case 'Function': callback = funcValueTest; break;
	        default:         callback = nameTest;
	    }
	    return this.someAttr(callback);

	    function nameTest(attr) {
	        return attr.local === localName;
	    }

	    function stringValueTest(attr) {
	        return attr.local === localName && val == attr.value;
	    }

	    function regexpValueTest(attr) {
	        return attr.local === localName && val.test(attr.value);
	    }

	    function funcValueTest(attr) {
	        return attr.local === localName && val(attr.value);
	    }

	};

	/**
	 * Get a specific attribute from an element
	 * (by name or name + value).
	 *
	 * @param {String} name attribute name
	 * @param {String} [val] attribute value (will be toString()'ed)
	 * @return {Object|Undefined}
	 */
	 JSAPI.prototype.attr = function(name, val) {

	    if (!this.hasAttr() || !arguments.length) return undefined;

	    if (val !== undefined) return this.hasAttr(name, val) ? this.attrs[name] : undefined;

	    return this.attrs[name];

	};

	/**
	 * Get computed attribute value from an element
	 *
	 * @param {String} name attribute name
	 * @return {Object|Undefined}
	 */
	 JSAPI.prototype.computedAttr = function(name, val) {
	    /* jshint eqnull: true */
	    if (!arguments.length) return;

	    for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attr(name).value); elem = elem.parentNode);

	    if (val != null) {
	        return elem ? elem.hasAttr(name, val) : false;
	    } else if (elem && elem.hasAttr(name)) {
	        return elem.attrs[name].value;
	    }

	};

	/**
	 * Remove a specific attribute.
	 *
	 * @param {String|Array} name attribute name
	 * @param {String} [val] attribute value
	 * @return {Boolean}
	 */
	 JSAPI.prototype.removeAttr = function(name, val, recursive) {

	    if (!arguments.length) return false;

	    if (Array.isArray(name)) name.forEach(this.removeAttr, this);

	    if (!this.hasAttr(name)) return false;

	    if (!recursive && val && this.attrs[name].value !== val) return false;

	    delete this.attrs[name];

	    if (!Object.keys(this.attrs).length) delete this.attrs;

	    return true;

	};

	/**
	 * Add attribute.
	 *
	 * @param {Object} [attr={}] attribute object
	 * @return {Object|Boolean} created attribute or false if no attr was passed in
	 */
	 JSAPI.prototype.addAttr = function(attr) {
	    attr = attr || {};

	    if (attr.name === undefined ||
	        attr.value === undefined ||
	        attr.prefix === undefined ||
	        attr.local === undefined
	    ) return false;

	    this.attrs = this.attrs || {};
	    this.attrs[attr.name] = attr;

	    return this.attrs[attr.name];

	};

	/**
	 * Iterates over all attributes.
	 *
	 * @param {Function} callback callback
	 * @param {Object} [context] callback context
	 * @return {Boolean} false if there are no any attributes
	 */
	 JSAPI.prototype.eachAttr = function(callback, context) {

	    if (!this.hasAttr()) return false;

	    for (var name in this.attrs) {
	        callback.call(context, this.attrs[name]);
	    }

	    return true;

	};

	/**
	 * Tests whether some attribute passes the test.
	 *
	 * @param {Function} callback callback
	 * @param {Object} [context] callback context
	 * @return {Boolean} false if there are no any attributes
	 */
	 JSAPI.prototype.someAttr = function(callback, context) {

	    if (!this.hasAttr()) return false;

	    for (var name in this.attrs) {
	        if (callback.call(context, this.attrs[name])) return true;
	    }

	    return false;

	};


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./_collections": 4,
		"./_collections.js": 4,
		"./_path": 13,
		"./_path.js": 13,
		"./_transforms": 14,
		"./_transforms.js": 14,
		"./addClassesToSVGElement": 81,
		"./addClassesToSVGElement.js": 81,
		"./cleanupAttrs": 82,
		"./cleanupAttrs.js": 82,
		"./cleanupEnableBackground": 83,
		"./cleanupEnableBackground.js": 83,
		"./cleanupIDs": 84,
		"./cleanupIDs.js": 84,
		"./cleanupListOfValues": 85,
		"./cleanupListOfValues.js": 85,
		"./cleanupNumericValues": 86,
		"./cleanupNumericValues.js": 86,
		"./collapseGroups": 87,
		"./collapseGroups.js": 87,
		"./convertColors": 88,
		"./convertColors.js": 88,
		"./convertPathData": 89,
		"./convertPathData.js": 89,
		"./convertShapeToPath": 90,
		"./convertShapeToPath.js": 90,
		"./convertStyleToAttrs": 91,
		"./convertStyleToAttrs.js": 91,
		"./convertTransform": 92,
		"./convertTransform.js": 92,
		"./mergePaths": 93,
		"./mergePaths.js": 93,
		"./minifyStyles": 94,
		"./minifyStyles.js": 94,
		"./moveElemsAttrsToGroup": 95,
		"./moveElemsAttrsToGroup.js": 95,
		"./moveGroupAttrsToElems": 96,
		"./moveGroupAttrsToElems.js": 96,
		"./removeAttrs": 97,
		"./removeAttrs.js": 97,
		"./removeComments": 98,
		"./removeComments.js": 98,
		"./removeDesc": 99,
		"./removeDesc.js": 99,
		"./removeDimensions": 100,
		"./removeDimensions.js": 100,
		"./removeDoctype": 101,
		"./removeDoctype.js": 101,
		"./removeEditorsNSData": 102,
		"./removeEditorsNSData.js": 102,
		"./removeEmptyAttrs": 103,
		"./removeEmptyAttrs.js": 103,
		"./removeEmptyContainers": 104,
		"./removeEmptyContainers.js": 104,
		"./removeEmptyText": 105,
		"./removeEmptyText.js": 105,
		"./removeHiddenElems": 106,
		"./removeHiddenElems.js": 106,
		"./removeMetadata": 107,
		"./removeMetadata.js": 107,
		"./removeNonInheritableGroupAttrs": 108,
		"./removeNonInheritableGroupAttrs.js": 108,
		"./removeRasterImages": 109,
		"./removeRasterImages.js": 109,
		"./removeStyleElement": 110,
		"./removeStyleElement.js": 110,
		"./removeTitle": 111,
		"./removeTitle.js": 111,
		"./removeUnknownsAndDefaults": 112,
		"./removeUnknownsAndDefaults.js": 112,
		"./removeUnusedNS": 113,
		"./removeUnusedNS.js": 113,
		"./removeUselessDefs": 114,
		"./removeUselessDefs.js": 114,
		"./removeUselessStrokeAndFill": 115,
		"./removeUselessStrokeAndFill.js": 115,
		"./removeViewBox": 116,
		"./removeViewBox.js": 116,
		"./removeXMLProcInst": 117,
		"./removeXMLProcInst.js": 117,
		"./sortAttrs": 118,
		"./sortAttrs.js": 118,
		"./transformsWithOnePath": 119,
		"./transformsWithOnePath.js": 119
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 80;


/***/ },
/* 81 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'full';

	exports.active = false;

	exports.description = 'adds classnames to an outer <svg> element';

	var ENOCLS = 'Error in plugin "addClassesToSVGElement": absent parameters.\n\
	It should have a list of classes in "classNames" or one "className".\n\
	Config example:\n\n\
	\
	plugins:\n\
	- addClassesToSVGElement:\n\
	    className: "mySvg"\n\n\
	\
	plugins:\n\
	- addClassesToSVGElement:\n\
	    classNames: ["mySvg", "size-big"]\n';

	/**
	 * Add classnames to an outer <svg> element. Example config:
	 *
	 * plugins:
	 * - addClassesToSVGElement:
	 *     className: 'mySvg'
	 *
	 * plugins:
	 * - addClassesToSVGElement:
	 *     classNames: ['mySvg', 'size-big']
	 *
	 * @author April Arcus
	 */
	exports.fn = function(data, params) {
	    if (!params || !(Array.isArray(params.classNames) && params.classNames.some(String) || params.className)) {
	        console.error(ENOCLS);
	        return data;
	    }

	    var classNames = params.classNames || [ params.className ],
	        svg = data.content[0];

	    if (svg.isElem('svg')) {
	        if (svg.hasAttr('class')) {
	            svg.attr('class').value =
	                svg.attr('class').value
	                    .split(' ')
	                    .concat(classNames)
	                    .join(' ');
	        } else {
	            svg.addAttr({
	                name: 'class',
	                value: classNames.join(' '),
	                prefix: '',
	                local: 'class'
	            });
	        }
	    }

	    return data;

	};


/***/ },
/* 82 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'cleanups attributes from newlines, trailing and repeating spaces';

	exports.params = {
	    newlines: true,
	    trim: true,
	    spaces: true
	};

	var regNewlinesNeedSpace = /(\S)\n(\S)/g,
	    regNewlines = /\n/g,
	    regSpaces = /\s{2,}/g;

	/**
	 * Cleanup attributes values from newlines, trailing and repeating spaces.
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.isElem()) {

	        item.eachAttr(function(attr) {

	            if (params.newlines) {
	                // new line which requires a space instead of themselve
	                attr.value = attr.value.replace(regNewlinesNeedSpace, function(match, p1, p2) {
	                    return p1 + ' ' + p2;
	                });

	                // simple new line
	                attr.value = attr.value.replace(regNewlines, '');
	            }

	            if (params.trim) {
	                attr.value = attr.value.trim();
	            }

	            if (params.spaces) {
	                attr.value = attr.value.replace(regSpaces, ' ');
	            }

	        });

	    }

	};


/***/ },
/* 83 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'full';

	exports.active = true;

	exports.description = 'remove or cleanup enable-background attribute when possible';

	/**
	 * Remove or cleanup enable-background attr which coincides with a width/height box.
	 *
	 * @see http://www.w3.org/TR/SVG/filters.html#EnableBackgroundProperty
	 *
	 * @example
	 * <svg width="100" height="50" enable-background="new 0 0 100 50">
	 *             ⬇
	 * <svg width="100" height="50">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(data) {

	    var regEnableBackground = /^new\s0\s0\s([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)\s([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)$/,
	        hasFilter = false,
	        elems = ['svg', 'mask', 'pattern'];

	    function checkEnableBackground(item) {
	        if (
	            item.isElem(elems) &&
	            item.hasAttr('enable-background') &&
	            item.hasAttr('width') &&
	            item.hasAttr('height')
	        ) {

	            var match = item.attr('enable-background').value.match(regEnableBackground);

	            if (match) {
	                if (
	                    item.attr('width').value === match[1] &&
	                    item.attr('height').value === match[3]
	                ) {
	                    if (item.isElem('svg')) {
	                        item.removeAttr('enable-background');
	                    } else {
	                        item.attr('enable-background').value = 'new';
	                    }
	                }
	            }

	        }
	    }

	    function checkForFilter(item) {
	        if (item.isElem('filter')) {
	            hasFilter = true;
	        }
	    }

	    function monkeys(items, fn) {
	        items.content.forEach(function(item) {
	            fn(item);

	            if (item.content) {
	                monkeys(item, fn);
	            }
	        });
	        return items;
	    }

	    var firstStep = monkeys(data, function(item) {
	        checkEnableBackground(item);
	        if (!hasFilter) {
	            checkForFilter(item);
	        }
	    });

	    return hasFilter ? firstStep : monkeys(firstStep, function(item) {
	            //we don't need 'enable-background' if we have no filters
	            item.removeAttr('enable-background');
	        });
	};


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'full';

	exports.active = true;

	exports.description = 'removes unused IDs and minifies used';

	exports.params = {
	    remove: true,
	    minify: true,
	    prefix: ''
	};

	var referencesProps = __webpack_require__(4).referencesProps,
	    regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/,
	    regReferencesHref = /^#(.+?)$/,
	    regReferencesBegin = /^(\w+?)\./,
	    styleOrScript = ['style', 'script'],
	    generateIDchars = [
	        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
	        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
	    ],
	    maxIDindex = generateIDchars.length - 1;

	/**
	 * Remove unused and minify used IDs
	 * (only if there are no any <style> or <script>).
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(data, params) {

	    var currentID,
	        currentIDstring,
	        IDs = Object.create(null),
	        referencesIDs = Object.create(null),
	        idPrefix = 'id-', // prefix IDs so that values like '__proto__' don't break the work
	        hasStyleOrScript = false;

	    /**
	     * Bananas!
	     *
	     * @param {Array} items input items
	     * @return {Array} output items
	     */
	    function monkeys(items) {

	        for (var i = 0; i < items.content.length && !hasStyleOrScript; i++) {

	            var item = items.content[i],
	                match;

	            // check if <style> of <script> presents
	            if (item.isElem(styleOrScript)) {
	                hasStyleOrScript = true;
	                continue;
	            }

	            // …and don't remove any ID if yes
	            if (item.isElem()) {

	                item.eachAttr(function(attr) {
	                    var key;
	                    // save IDs
	                    if (attr.name === 'id') {
	                        key = idPrefix + attr.value;
	                        if (key in IDs) {
	                            item.removeAttr('id');
	                        } else {
	                            IDs[key] = item;
	                        }
	                    }

	                    // save IDs url() references
	                    else if (referencesProps.indexOf(attr.name) > -1) {
	                        match = attr.value.match(regReferencesUrl);

	                        if (match) {
	                            key = idPrefix + match[2];
	                            if (referencesIDs[key]) {
	                                referencesIDs[key].push(attr);
	                            } else {
	                                referencesIDs[key] = [attr];
	                            }
	                        }
	                    }

	                    // save IDs href references
	                    else if (
	                        attr.local === 'href' && (match = attr.value.match(regReferencesHref)) ||
	                        attr.name === 'begin' && (match = attr.value.match(regReferencesBegin))
	                    ) {
	                        key = idPrefix + match[1];
	                        if (referencesIDs[key]) {
	                            referencesIDs[key].push(attr);
	                        } else {
	                            referencesIDs[key] = [attr];
	                        }
	                    }
	                });

	            }

	            // go deeper
	            if (item.content) {
	                monkeys(item);
	            }
	        }

	        return items;

	    }

	    data = monkeys(data);

	    if (hasStyleOrScript) {
	        return data;
	    }

	    for (var k in referencesIDs) {
	        if (IDs[k]) {

	            // replace referenced IDs with the minified ones
	            if (params.minify) {

	                currentIDstring = getIDstring(currentID = generateID(currentID), params);
	                IDs[k].attr('id').value = currentIDstring;

	                referencesIDs[k].forEach(function(attr) {
	                    k = k.replace(idPrefix, '');
	                    attr.value = attr.value
	                        .replace('#' + k, '#' + currentIDstring)
	                        .replace(k + '.', currentIDstring + '.');
	                });

	            }

	            // don't remove referenced IDs
	            delete IDs[idPrefix + k];

	        }
	    }

	    // remove non-referenced IDs attributes from elements
	    if (params.remove) {

	        for(var ID in IDs) {
	            IDs[ID].removeAttr('id');
	        }

	    }

	    return data;

	};

	/**
	 * Generate unique minimal ID.
	 *
	 * @param {Array} [currentID] current ID
	 * @return {Array} generated ID array
	 */
	function generateID(currentID) {

	    if (!currentID) return [0];

	    currentID[currentID.length - 1]++;

	    for(var i = currentID.length - 1; i > 0; i--) {
	        if (currentID[i] > maxIDindex) {
	            currentID[i] = 0;

	            if (currentID[i - 1] !== undefined) {
	                currentID[i - 1]++;
	            }
	        }
	    }

	    if (currentID[0] > maxIDindex) {
	        currentID[0] = 0;
	        currentID.unshift(0);
	    }

	    return currentID;

	}

	/**
	 * Get string from generated ID array.
	 *
	 * @param {Array} arr input ID array
	 * @return {String} output ID string
	 */
	function getIDstring(arr, params) {

	    var str = params.prefix;

	    arr.forEach(function(i) {
	        str += generateIDchars[i];
	    });

	    return str;

	}


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'rounds list of values to the fixed precision';

	exports.params = {
	    floatPrecision: 3,
	    leadingZero: true,
	    defaultPx: true,
	    convertToPx: true
	};

	var regNumericValues = /^([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/,
	    regSeparator = /\s+,?\s*|,\s*/,
	    removeLeadingZero = __webpack_require__(22).removeLeadingZero,
	    absoluteLengths = { // relative to px
	        cm: 96/2.54,
	        mm: 96/25.4,
	        in: 96,
	        pt: 4/3,
	        pc: 16
	    };

	/**
	 * Round list of values to the fixed precision.
	 *
	 * @example
	 * <svg viewBox="0 0 200.28423 200.28423" enable-background="new 0 0 200.28423 200.28423">
	 *         ⬇
	 * <svg viewBox="0 0 200.284 200.284" enable-background="new 0 0 200.284 200.284">
	 *
	 *
	 * <polygon points="208.250977 77.1308594 223.069336 ... "/>
	 *         ⬇
	 * <polygon points="208.251 77.131 223.069 ... "/>
	 *
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author kiyopikko
	 */
	exports.fn = function(item, params) {


	    if ( item.hasAttr('points') ) {
	        roundValues(item.attrs.points);
	    }

	    if ( item.hasAttr('enable-background') ) {
	        roundValues(item.attrs['enable-background']);
	    }

	    if ( item.hasAttr('viewBox') ) {
	        roundValues(item.attrs.viewBox);
	    }

	    if ( item.hasAttr('stroke-dasharray') ) {
	        roundValues(item.attrs['stroke-dasharray']);
	    }

	    if ( item.hasAttr('dx') ) {
	        roundValues(item.attrs.dx);
	    }

	    if ( item.hasAttr('dy') ) {
	        roundValues(item.attrs.dy);
	    }

	    if ( item.hasAttr('x') ) {
	        roundValues(item.attrs.x);
	    }

	    if ( item.hasAttr('y') ) {
	        roundValues(item.attrs.y);
	    }


	    function roundValues($prop){

	        var num, units,
	            match,
	            matchNew,
	            lists = $prop.value,
	            listsArr = lists.split(regSeparator),
	            roundedListArr = [],
	            roundedList;

	        listsArr.forEach(function(elem){

	            match = elem.match(regNumericValues);
	            matchNew = elem.match(/new/);

	             // if attribute value matches regNumericValues
	            if(match){

	                // round it to the fixed precision
	                num = +(+match[1]).toFixed(params.floatPrecision),
	                units = match[3] || '';

	                // convert absolute values to pixels
	                if (params.convertToPx && units && (units in absoluteLengths)) {
	                    var pxNum = +(absoluteLengths[units] * match[1]).toFixed(params.floatPrecision);

	                    if (String(pxNum).length < match[0].length)
	                        num = pxNum,
	                        units = 'px';
	                }

	                 // and remove leading zero
	                if (params.leadingZero) {
	                    num = removeLeadingZero(num);
	                }

	                // remove default 'px' units
	                if (params.defaultPx && units === 'px') {
	                    units = '';
	                }

	                roundedListArr.push(num+units);

	            }
	            // if attribute value is "new"(only enable-background).
	            else if(matchNew){

	                roundedListArr.push('new');

	            }

	        });

	        roundedList = roundedListArr.join(' ');
	        $prop.value = roundedList;

	    }

	};


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'rounds numeric values to the fixed precision, removes default ‘px’ units';

	exports.params = {
	    floatPrecision: 3,
	    leadingZero: true,
	    defaultPx: true,
	    convertToPx: true
	};

	var regNumericValues = /^([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/,
	    removeLeadingZero = __webpack_require__(22).removeLeadingZero,
	    absoluteLengths = { // relative to px
	        cm: 96/2.54,
	        mm: 96/25.4,
	        in: 96,
	        pt: 4/3,
	        pc: 16
	    };

	/**
	 * Round numeric values to the fixed precision,
	 * remove default 'px' units.
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.isElem()) {

	        var match;

	        item.eachAttr(function(attr) {
	            match = attr.value.match(regNumericValues);

	            // if attribute value matches regNumericValues
	            if (match) {
	                // round it to the fixed precision
	                var num = +(+match[1]).toFixed(params.floatPrecision),
	                    units = match[3] || '';

	                // convert absolute values to pixels
	                if (params.convertToPx && units && (units in absoluteLengths)) {
	                    var pxNum = +(absoluteLengths[units] * match[1]).toFixed(params.floatPrecision);

	                    if (String(pxNum).length < match[0].length)
	                        num = pxNum,
	                        units = 'px';
	                }

	                // and remove leading zero
	                if (params.leadingZero) {
	                    num = removeLeadingZero(num);
	                }

	                // remove default 'px' units
	                if (params.defaultPx && units === 'px') {
	                    units = '';
	                }

	                attr.value = num + units;
	            }
	        });

	    }

	};


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItemReverse';

	exports.active = true;

	exports.description = 'collapses useless groups';

	var animationElems = __webpack_require__(4).elemsGroups.animation;

	function hasAnimatedAttr(item) {
	    return item.isElem(animationElems) && item.hasAttr('attributeName', this) ||
	        !item.isEmpty() && item.content.some(hasAnimatedAttr, this);
	}

	/*
	 * Collapse useless groups.
	 *
	 * @example
	 * <g>
	 *     <g attr1="val1">
	 *         <path d="..."/>
	 *     </g>
	 * </g>
	 *         ⬇
	 * <g>
	 *     <g>
	 *         <path attr1="val1" d="..."/>
	 *     </g>
	 * </g>
	 *         ⬇
	 * <path attr1="val1" d="..."/>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    // non-empty elements
	    if (item.isElem() && !item.isElem('switch') && !item.isEmpty()) {

	        item.content.forEach(function(g, i) {

	            // non-empty groups
	            if (g.isElem('g') && !g.isEmpty()) {

	                // move group attibutes to the single content element
	                if (g.hasAttr() && g.content.length === 1) {
	                    var inner = g.content[0];

	                    if (inner.isElem() && !inner.hasAttr('id') && (
	                        !g.hasAttr('clip-path') ||
	                        inner.isElem('g') && !g.hasAttr('transform') && !inner.hasAttr('transform')
	                    )) {
	                        g.eachAttr(function(attr) {
	                            if (g.content.some(hasAnimatedAttr, attr.name)) return;

	                            if (!inner.hasAttr(attr.name)) {
	                                inner.addAttr(attr);
	                            } else if (attr.name == 'transform' || attr.name == 'class') {
	                                inner.attr(attr.name).value = attr.value + ' ' + inner.attr(attr.name).value;
	                            }
	                            g.removeAttr(attr.name);
	                        });
	                    }
	                }

	                // collapse groups without attributes
	                if (!g.hasAttr() && !g.content.some(function(item) { return item.isElem(animationElems) })) {
	                    item.spliceContent(i, 1, g.content);
	                }
	            }

	        });

	    }

	};


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'converts colors: rgb() to #rrggbb and #rrggbb to #rgb';

	exports.params = {
	    currentColor: false,
	    names2hex: true,
	    rgb2hex: true,
	    shorthex: true,
	    shortname: true
	};

	var collections = __webpack_require__(4),
	    rNumber = '([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)',
	    rComma = '\\s*,\\s*',
	    regRGB = new RegExp('^rgb\\(\\s*' + rNumber + rComma + rNumber + rComma + rNumber + '\\s*\\)$'),
	    regHEX = /^\#(([a-fA-F0-9])\2){3}$/,
	    none = /\bnone\b/i;

	/**
	 * Convert different colors formats in element attributes to hex.
	 *
	 * @see http://www.w3.org/TR/SVG/types.html#DataTypeColor
	 * @see http://www.w3.org/TR/SVG/single-page.html#types-ColorKeywords
	 *
	 * @example
	 * Convert color name keyword to long hex:
	 * fuchsia ➡ #ff00ff
	 *
	 * Convert rgb() to long hex:
	 * rgb(255, 0, 255) ➡ #ff00ff
	 * rgb(50%, 100, 100%) ➡ #7f64ff
	 *
	 * Convert long hex to short hex:
	 * #aabbcc ➡ #abc
	 *
	 * Convert hex to short name
	 * #000080 ➡ navy
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.elem) {

	        item.eachAttr(function(attr) {

	            if (collections.colorsProps.indexOf(attr.name) > -1) {

	                var val = attr.value,
	                    match;

	                // Convert colors to currentColor
	                if (params.currentColor && (match = !val.match(none))) {
	                    val = 'currentColor';
	                }

	                // Convert color name keyword to long hex
	                if (params.names2hex && val.toLowerCase() in collections.colorsNames) {
	                    val = collections.colorsNames[val.toLowerCase()];
	                }

	                // Convert rgb() to long hex
	                if (params.rgb2hex && (match = val.match(regRGB))) {
	                    match = match.slice(1, 4).map(function(m) {
	                        if (m.indexOf('%') > -1)
	                            m = Math.round(parseFloat(m) * 2.55);

	                        return Math.max(0, Math.min(m, 255));
	                    });

	                    val = rgb2hex(match);
	                }

	                // Convert long hex to short hex
	                if (params.shorthex && (match = val.match(regHEX))) {
	                    val = '#' + match[0][1] + match[0][3] + match[0][5];
	                }

	                // Convert hex to short name
	                if (params.shortname && val in collections.colorsShortNames) {
	                    val = collections.colorsShortNames[val];
	                }

	                attr.value = val;

	            }

	        });

	    }

	};

	/**
	 * Convert [r, g, b] to #rrggbb.
	 *
	 * @see https://gist.github.com/983535
	 *
	 * @example
	 * rgb2hex([255, 255, 255]) // '#ffffff'
	 *
	 * @param {Array} rgb [r, g, b]
	 * @return {String} #rrggbb
	 *
	 * @author Jed Schmidt
	 */
	function rgb2hex(rgb) {
	    return '#' + ('00000' + (rgb[0] << 16 | rgb[1] << 8 | rgb[2]).toString(16)).slice(-6).toUpperCase();
	}


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'optimizes path data: writes in shorter form, applies transformations';

	exports.params = {
	    applyTransforms: true,
	    applyTransformsStroked: true,
	    makeArcs: {
	        threshold: 2.5, // coefficient of rounding error
	        tolerance: 0.5  // percentage of radius
	    },
	    straightCurves: true,
	    lineShorthands: true,
	    curveSmoothShorthands: true,
	    floatPrecision: 3,
	    transformPrecision: 5,
	    removeUseless: true,
	    collapseRepeated: true,
	    utilizeAbsolute: true,
	    leadingZero: true,
	    negativeExtraSpace: true
	};

	var pathElems = __webpack_require__(4).pathElems,
	    path2js = __webpack_require__(13).path2js,
	    js2path = __webpack_require__(13).js2path,
	    applyTransforms = __webpack_require__(13).applyTransforms,
	    cleanupOutData = __webpack_require__(22).cleanupOutData,
	    roundData,
	    precision,
	    error,
	    arcThreshold,
	    arcTolerance,
	    hasMarkerMid;

	/**
	 * Convert absolute Path to relative,
	 * collapse repeated instructions,
	 * detect and convert Lineto shorthands,
	 * remove useless instructions like "l0,0",
	 * trim useless delimiters and leading zeros,
	 * decrease accuracy of floating-point numbers.
	 *
	 * @see http://www.w3.org/TR/SVG/paths.html#PathData
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.isElem(pathElems) && item.hasAttr('d')) {

	        precision = params.floatPrecision;
	        error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;
	        roundData = precision > 0 && precision < 20 ? strongRound : round;
	        if (params.makeArcs) {
	            arcThreshold = params.makeArcs.threshold;
	            arcTolerance = params.makeArcs.tolerance;
	        }
	        hasMarkerMid = item.hasAttr('marker-mid');

	        var data = path2js(item);

	        // TODO: get rid of functions returns
	        if (data.length) {
	            convertToRelative(data);

	            if (params.applyTransforms) {
	                data = applyTransforms(item, data, params);
	            }

	            data = filters(data, params);

	            if (params.utilizeAbsolute) {
	                data = convertToMixed(data, params);
	            }

	            js2path(item, data, params);
	        }

	    }

	};

	/**
	 * Convert absolute path data coordinates to relative.
	 *
	 * @param {Array} path input path data
	 * @param {Object} params plugin params
	 * @return {Array} output path data
	 */
	function convertToRelative(path) {

	    var point = [0, 0],
	        subpathPoint = [0, 0],
	        baseItem;

	    path.forEach(function(item, index) {

	        var instruction = item.instruction,
	            data = item.data;

	        // data !== !z
	        if (data) {

	            // already relative
	            // recalculate current point
	            if ('mcslqta'.indexOf(instruction) > -1) {

	                point[0] += data[data.length - 2];
	                point[1] += data[data.length - 1];

	                if (instruction === 'm') {
	                    subpathPoint[0] = point[0];
	                    subpathPoint[1] = point[1];
	                    baseItem = item;
	                }

	            } else if (instruction === 'h') {

	                point[0] += data[0];

	            } else if (instruction === 'v') {

	                point[1] += data[0];

	            }

	            // convert absolute path data coordinates to relative
	            // if "M" was not transformed from "m"
	            // M → m
	            if (instruction === 'M') {

	                if (index > 0) instruction = 'm';

	                data[0] -= point[0];
	                data[1] -= point[1];

	                subpathPoint[0] = point[0] += data[0];
	                subpathPoint[1] = point[1] += data[1];

	                baseItem = item;

	            }

	            // L → l
	            // T → t
	            else if ('LT'.indexOf(instruction) > -1) {

	                instruction = instruction.toLowerCase();

	                // x y
	                // 0 1
	                data[0] -= point[0];
	                data[1] -= point[1];

	                point[0] += data[0];
	                point[1] += data[1];

	            // C → c
	            } else if (instruction === 'C') {

	                instruction = 'c';

	                // x1 y1 x2 y2 x y
	                // 0  1  2  3  4 5
	                data[0] -= point[0];
	                data[1] -= point[1];
	                data[2] -= point[0];
	                data[3] -= point[1];
	                data[4] -= point[0];
	                data[5] -= point[1];

	                point[0] += data[4];
	                point[1] += data[5];

	            // S → s
	            // Q → q
	            } else if ('SQ'.indexOf(instruction) > -1) {

	                instruction = instruction.toLowerCase();

	                // x1 y1 x y
	                // 0  1  2 3
	                data[0] -= point[0];
	                data[1] -= point[1];
	                data[2] -= point[0];
	                data[3] -= point[1];

	                point[0] += data[2];
	                point[1] += data[3];

	            // A → a
	            } else if (instruction === 'A') {

	                instruction = 'a';

	                // rx ry x-axis-rotation large-arc-flag sweep-flag x y
	                // 0  1  2               3              4          5 6
	                data[5] -= point[0];
	                data[6] -= point[1];

	                point[0] += data[5];
	                point[1] += data[6];

	            // H → h
	            } else if (instruction === 'H') {

	                instruction = 'h';

	                data[0] -= point[0];

	                point[0] += data[0];

	            // V → v
	            } else if (instruction === 'V') {

	                instruction = 'v';

	                data[0] -= point[1];

	                point[1] += data[0];

	            }

	            item.instruction = instruction;
	            item.data = data;

	            // store absolute coordinates for later use
	            item.coords = point.slice(-2);

	        }

	        // !data === z, reset current point
	        else if (instruction == 'z') {
	            if (baseItem) {
	                item.coords = baseItem.coords;
	            }
	            point[0] = subpathPoint[0];
	            point[1] = subpathPoint[1];
	        }

	        item.base = index > 0 ? path[index - 1].coords : [0, 0];

	    });

	    return path;

	}

	/**
	 * Main filters loop.
	 *
	 * @param {Array} path input path data
	 * @param {Object} params plugin params
	 * @return {Array} output path data
	 */
	function filters(path, params) {

	    var stringify = data2Path.bind(null, params),
	        relSubpoint = [0, 0],
	        pathBase = [0, 0],
	        prev = {};

	    path = path.filter(function(item, index, path) {

	        var instruction = item.instruction,
	            data = item.data,
	            next = path[index + 1];

	        if (data) {

	            var sdata = data,
	                circle;

	            if (instruction === 's') {
	                sdata = [0, 0].concat(data);

	                if ('cs'.indexOf(prev.instruction) > -1) {
	                    var pdata = prev.data,
	                        n = pdata.length;

	                    // (-x, -y) of the prev tangent point relative to the current point
	                    sdata[0] = pdata[n - 2] - pdata[n - 4];
	                    sdata[1] = pdata[n - 1] - pdata[n - 3];
	                }

	            }

	            // convert curves to arcs if possible
	            if (
	                params.makeArcs &&
	                (instruction == 'c' || instruction == 's') &&
	                isConvex(sdata) &&
	                (circle = findCircle(sdata))
	            ) {
	                var r = roundData([circle.radius])[0],
	                    angle = findArcAngle(sdata, circle),
	                    sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0,
	                    arc = {
	                        instruction: 'a',
	                        data: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
	                        coords: item.coords.slice(),
	                        base: item.base
	                    },
	                    output = [arc],
	                    // relative coordinates to adjust the found circle
	                    relCenter = [circle.center[0] - sdata[4], circle.center[1] - sdata[5]],
	                    relCircle = { center: relCenter, radius: circle.radius },
	                    arcCurves = [item],
	                    hasPrev = 0,
	                    suffix = '',
	                    nextLonghand;

	                if (
	                    prev.instruction == 'c' && isConvex(prev.data) && isArcPrev(prev.data, circle) ||
	                    prev.instruction == 'a' && prev.sdata && isArcPrev(prev.sdata, circle)
	                ) {
	                    arcCurves.unshift(prev);
	                    arc.base = prev.base;
	                    arc.data[5] = arc.coords[0] - arc.base[0];
	                    arc.data[6] = arc.coords[1] - arc.base[1];
	                    var prevData = prev.instruction == 'a' ? prev.sdata : prev.data;
	                    angle += findArcAngle(prevData,
	                        {
	                            center: [prevData[4] + relCenter[0], prevData[5] + relCenter[1]],
	                            radius: circle.radius
	                        }
	                    );
	                    if (angle > Math.PI) arc.data[3] = 1;
	                    hasPrev = 1;
	                }

	                // check if next curves are fitting the arc
	                for (var j = index; (next = path[++j]) && ~'cs'.indexOf(next.instruction);) {
	                    var nextData = next.data;
	                    if (next.instruction == 's') {
	                        nextLonghand = makeLonghand({instruction: 's', data: next.data.slice() },
	                            path[j - 1].data);
	                        nextData = nextLonghand.data;
	                        nextLonghand.data = nextData.slice(0, 2);
	                        suffix = stringify([nextLonghand]);
	                    }
	                    if (isConvex(nextData) && isArc(nextData, relCircle)) {
	                        angle += findArcAngle(nextData, relCircle);
	                        if (angle - 2 * Math.PI > 1e-3) break; // more than 360°
	                        if (angle > Math.PI) arc.data[3] = 1;
	                        arcCurves.push(next);
	                        if (2 * Math.PI - angle > 1e-3) { // less than 360°
	                            arc.coords = next.coords;
	                            arc.data[5] = arc.coords[0] - arc.base[0];
	                            arc.data[6] = arc.coords[1] - arc.base[1];
	                        } else {
	                            // full circle, make a half-circle arc and add a second one
	                            arc.data[5] = 2 * (relCircle.center[0] - nextData[4]);
	                            arc.data[6] = 2 * (relCircle.center[1] - nextData[5]);
	                            arc.coords = [arc.base[0] + arc.data[5], arc.base[1] + arc.data[6]];
	                            arc = {
	                                instruction: 'a',
	                                data: [r, r, 0, 0, sweep,
	                                    next.coords[0] - arc.coords[0], next.coords[1] - arc.coords[1]],
	                                coords: next.coords,
	                                base: arc.coords
	                            };
	                            output.push(arc);
	                            j++;
	                            break;
	                        }
	                        relCenter[0] -= nextData[4];
	                        relCenter[1] -= nextData[5];
	                    } else break;
	                }

	                if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
	                    if (path[j] && path[j].instruction == 's') {
	                        makeLonghand(path[j], path[j - 1].data);
	                    }
	                    if (hasPrev) {
	                        var prevArc = output.shift();
	                        roundData(prevArc.data);
	                        relSubpoint[0] += prevArc.data[5] - prev.data[prev.data.length - 2];
	                        relSubpoint[1] += prevArc.data[6] - prev.data[prev.data.length - 1];
	                        prev.instruction = 'a';
	                        prev.data = prevArc.data;
	                        item.base = prev.coords = prevArc.coords;
	                    }
	                    arc = output.shift();
	                    if (arcCurves.length == 1) {
	                        item.sdata = sdata.slice(); // preserve curve data for future checks
	                    } else if (arcCurves.length - 1 - hasPrev > 0) {
	                        // filter out consumed next items
	                        path.splice.apply(path, [index + 1, arcCurves.length - 1 - hasPrev].concat(output));
	                    }
	                    if (!arc) return false;
	                    instruction = 'a';
	                    data = arc.data;
	                    item.coords = arc.coords;
	                }
	            }

	            // Rounding relative coordinates, taking in account accummulating error
	            // to get closer to absolute coordinates. Sum of rounded value remains same:
	            // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2
	            if (precision !== false) {
	                if ('mltqsc'.indexOf(instruction) > -1) {
	                    for (var i = data.length; i--;) {
	                        data[i] += item.base[i % 2] - relSubpoint[i % 2];
	                    }
	                } else if (instruction == 'h') {
	                    data[0] += item.base[0] - relSubpoint[0];
	                } else if (instruction == 'v') {
	                    data[0] += item.base[1] - relSubpoint[1];
	                } else if (instruction == 'a') {
	                    data[5] += item.base[0] - relSubpoint[0];
	                    data[6] += item.base[1] - relSubpoint[1];
	                }
	                roundData(data);

	                if      (instruction == 'h') relSubpoint[0] += data[0];
	                else if (instruction == 'v') relSubpoint[1] += data[0];
	                else {
	                    relSubpoint[0] += data[data.length - 2];
	                    relSubpoint[1] += data[data.length - 1];
	                }
	                roundData(relSubpoint);

	                if (instruction.toLowerCase() == 'm') {
	                    pathBase[0] = relSubpoint[0];
	                    pathBase[1] = relSubpoint[1];
	                }
	            }

	            // convert straight curves into lines segments
	            if (params.straightCurves) {

	                if (
	                    instruction === 'c' &&
	                    isCurveStraightLine(data) ||
	                    instruction === 's' &&
	                    isCurveStraightLine(sdata)
	                ) {
	                    if (next && next.instruction == 's')
	                        makeLonghand(next, data); // fix up next curve
	                    instruction = 'l';
	                    data = data.slice(-2);
	                }

	                else if (
	                    instruction === 'q' &&
	                    isCurveStraightLine(data)
	                ) {
	                    if (next && next.instruction == 't')
	                        makeLonghand(next, data); // fix up next curve
	                    instruction = 'l';
	                    data = data.slice(-2);
	                }

	                else if (
	                    instruction === 't' &&
	                    prev.instruction !== 'q' &&
	                    prev.instruction !== 't'
	                ) {
	                    instruction = 'l';
	                    data = data.slice(-2);
	                }

	                else if (
	                    instruction === 'a' &&
	                    (data[0] === 0 || data[1] === 0)
	                ) {
	                    instruction = 'l';
	                    data = data.slice(-2);
	                }
	            }

	            // horizontal and vertical line shorthands
	            // l 50 0 → h 50
	            // l 0 50 → v 50
	            if (
	                params.lineShorthands &&
	                instruction === 'l'
	            ) {
	                if (data[1] === 0) {
	                    instruction = 'h';
	                    data.pop();
	                } else if (data[0] === 0) {
	                    instruction = 'v';
	                    data.shift();
	                }
	            }

	            // collapse repeated commands
	            // h 20 h 30 -> h 50
	            if (
	                params.collapseRepeated &&
	                !hasMarkerMid &&
	                ('mhv'.indexOf(instruction) > -1) &&
	                prev.instruction &&
	                instruction == prev.instruction.toLowerCase() &&
	                (
	                    (instruction != 'h' && instruction != 'v') ||
	                    (prev.data[0] >= 0) == (item.data[0] >= 0)
	            )) {
	                prev.data[0] += data[0];
	                if (instruction != 'h' && instruction != 'v') {
	                    prev.data[1] += data[1];
	                }
	                prev.coords = item.coords;
	                path[index] = prev;
	                return false;
	            }

	            // convert curves into smooth shorthands
	            if (params.curveSmoothShorthands && prev.instruction) {

	                // curveto
	                if (instruction === 'c') {

	                    // c + c → c + s
	                    if (
	                        prev.instruction === 'c' &&
	                        data[0] === -(prev.data[2] - prev.data[4]) &&
	                        data[1] === -(prev.data[3] - prev.data[5])
	                    ) {
	                        instruction = 's';
	                        data = data.slice(2);
	                    }

	                    // s + c → s + s
	                    else if (
	                        prev.instruction === 's' &&
	                        data[0] === -(prev.data[0] - prev.data[2]) &&
	                        data[1] === -(prev.data[1] - prev.data[3])
	                    ) {
	                        instruction = 's';
	                        data = data.slice(2);
	                    }

	                    // [^cs] + c → [^cs] + s
	                    else if (
	                        'cs'.indexOf(prev.instruction) === -1 &&
	                        data[0] === 0 &&
	                        data[1] === 0
	                    ) {
	                        instruction = 's';
	                        data = data.slice(2);
	                    }

	                }

	                // quadratic Bézier curveto
	                else if (instruction === 'q') {

	                    // q + q → q + t
	                    if (
	                        prev.instruction === 'q' &&
	                        data[0] === (prev.data[2] - prev.data[0]) &&
	                        data[1] === (prev.data[3] - prev.data[1])
	                    ) {
	                        instruction = 't';
	                        data = data.slice(2);
	                    }

	                    // t + q → t + t
	                    else if (
	                        prev.instruction === 't' &&
	                        data[2] === prev.data[0] &&
	                        data[3] === prev.data[1]
	                    ) {
	                        instruction = 't';
	                        data = data.slice(2);
	                    }

	                }

	            }

	            // remove useless non-first path segments
	            if (params.removeUseless) {

	                // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0
	                if (
	                    (
	                     'lhvqtcs'.indexOf(instruction) > -1
	                    ) &&
	                    data.every(function(i) { return i === 0; })
	                ) {
	                    path[index] = prev;
	                    return false;
	                }

	                // a 25,25 -30 0,1 0,0
	                if (
	                    instruction === 'a' &&
	                    data[5] === 0 &&
	                    data[6] === 0
	                ) {
	                    path[index] = prev;
	                    return false;
	                }

	            }

	            item.instruction = instruction;
	            item.data = data;

	            prev = item;

	        } else {

	            // z resets coordinates
	            relSubpoint[0] = pathBase[0];
	            relSubpoint[1] = pathBase[1];
	            if (prev.instruction == 'z') return false;
	            prev = item;

	        }

	        return true;

	    });

	    return path;

	}

	/**
	 * Writes data in shortest form using absolute or relative coordinates.
	 *
	 * @param {Array} data input path data
	 * @return {Boolean} output
	 */
	function convertToMixed(path, params) {

	    var prev = path[0];

	    path = path.filter(function(item, index) {

	        if (index == 0) return true;
	        if (!item.data) {
	            prev = item;
	            return true;
	        }

	        var instruction = item.instruction,
	            data = item.data,
	            adata = data && data.slice(0);

	        if ('mltqsc'.indexOf(instruction) > -1) {
	            for (var i = adata.length; i--;) {
	                adata[i] += item.base[i % 2];
	            }
	        } else if (instruction == 'h') {
	                adata[0] += item.base[0];
	        } else if (instruction == 'v') {
	                adata[0] += item.base[1];
	        } else if (instruction == 'a') {
	                adata[5] += item.base[0];
	                adata[6] += item.base[1];
	        }

	        roundData(adata);

	        var absoluteDataStr = cleanupOutData(adata, params),
	            relativeDataStr = cleanupOutData(data, params);

	        // Convert to absolute coordinates if it's shorter.
	        // v-20 -> V0
	        // Don't convert if it fits following previous instruction.
	        // l20 30-10-50 instead of l20 30L20 30
	        if (
	            absoluteDataStr.length < relativeDataStr.length &&
	            !(
	                params.negativeExtraSpace &&
	                instruction == prev.instruction &&
	                prev.instruction.charCodeAt(0) > 96 &&
	                absoluteDataStr.length == relativeDataStr.length - 1 &&
	                (data[0] < 0 || /^0\./.test(data[0]) && prev.data[prev.data.length - 1] % 1)
	            )
	        ) {
	            item.instruction = instruction.toUpperCase();
	            item.data = adata;
	        }

	        prev = item;

	        return true;

	    });

	    return path;

	}

	/**
	 * Checks if curve is convex. Control points of such a curve must form
	 * a convex quadrilateral with diagonals crosspoint inside of it.
	 *
	 * @param {Array} data input path data
	 * @return {Boolean} output
	 */
	function isConvex(data) {

	    var center = getIntersection([0, 0, data[2], data[3], data[0], data[1], data[4], data[5]]);

	    return center &&
	        (data[2] < center[0] == center[0] < 0) &&
	        (data[3] < center[1] == center[1] < 0) &&
	        (data[4] < center[0] == center[0] < data[0]) &&
	        (data[5] < center[1] == center[1] < data[1]);

	}

	/**
	 * Computes lines equations by two points and returns their intersection point.
	 *
	 * @param {Array} coords 8 numbers for 4 pairs of coordinates (x,y)
	 * @return {Array|undefined} output coordinate of lines' crosspoint
	 */
	function getIntersection(coords) {

	        // Prev line equation parameters.
	    var a1 = coords[1] - coords[3], // y1 - y2
	        b1 = coords[2] - coords[0], // x2 - x1
	        c1 = coords[0] * coords[3] - coords[2] * coords[1], // x1 * y2 - x2 * y1

	        // Next line equation parameters
	        a2 = coords[5] - coords[7], // y1 - y2
	        b2 = coords[6] - coords[4], // x2 - x1
	        c2 = coords[4] * coords[7] - coords[5] * coords[6], // x1 * y2 - x2 * y1
	        denom = (a1 * b2 - a2 * b1);

	    if (!denom) return; // parallel lines havn't an intersection

	    var cross = [
	            (b1 * c2 - b2 * c1) / denom,
	            (a1 * c2 - a2 * c1) / -denom
	        ];
	    if (
	        !isNaN(cross[0]) && !isNaN(cross[1]) &&
	        isFinite(cross[0]) && isFinite(cross[1])
	    ) {
	        return cross;
	    }

	}

	/**
	 * Decrease accuracy of floating-point numbers
	 * in path data keeping a specified number of decimals.
	 * Smart rounds values like 2.3491 to 2.35 instead of 2.349.
	 * Doesn't apply "smartness" if the number precision fits already.
	 *
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function strongRound(data) {
	    for (var i = data.length; i-- > 0;) {
	        if (data[i].toFixed(precision) != data[i]) {
	            var rounded = +data[i].toFixed(precision - 1);
	            data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ?
	                +data[i].toFixed(precision) :
	                rounded;
	        }
	    }
	    return data;
	}

	/**
	 * Simple rounding function if precision is 0.
	 *
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function round(data) {
	    for (var i = data.length; i-- > 0;) {
	        data[i] = Math.round(data[i]);
	    }
	    return data;
	}

	/**
	 * Checks if a curve is a straight line by measuring distance
	 * from middle points to the line formed by end points.
	 *
	 * @param {Array} xs array of curve points x-coordinates
	 * @param {Array} ys array of curve points y-coordinates
	 * @return {Boolean}
	 */

	function isCurveStraightLine(data) {

	    // Get line equation a·x + b·y + c = 0 coefficients a, b (c = 0) by start and end points.
	    var i = data.length - 2,
	        a = -data[i + 1], // y1 − y2 (y1 = 0)
	        b = data[i],      // x2 − x1 (x1 = 0)
	        d = 1 / (a * a + b * b); // same part for all points

	    if (i <= 1 || !isFinite(d)) return false; // curve that ends at start point isn't the case

	    // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))
	    while ((i -= 2) >= 0) {
	        if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
	            return false;
	    }

	    return true;

	}

	/**
	 * Converts next curve from shorthand to full form using the current curve data.
	 *
	 * @param {Object} item curve to convert
	 * @param {Array} data current curve data
	 */

	function makeLonghand(item, data) {
	    switch (item.instruction) {
	        case 's': item.instruction = 'c'; break;
	        case 't': item.instruction = 'q'; break;
	    }
	    item.data.unshift(data[data.length - 2] - data[data.length - 4], data[data.length - 1] - data[data.length - 3]);
	    return item;
	}

	/**
	 * Returns distance between two points
	 *
	 * @param {Array} point1 first point coordinates
	 * @param {Array} point2 second point coordinates
	 * @return {Number} distance
	 */

	function getDistance(point1, point2) {
	    return Math.sqrt(Math.pow(point1[0] - point2[0], 2) + Math.pow(point1[1] - point2[1], 2));
	}

	/**
	 * Returns coordinates of the curve point corresponding to the certain t
	 * a·(1 - t)³·p1 + b·(1 - t)²·t·p2 + c·(1 - t)·t²·p3 + d·t³·p4,
	 * where pN are control points and p1 is zero due to relative coordinates.
	 *
	 * @param {Array} curve array of curve points coordinates
	 * @param {Number} t parametric position from 0 to 1
	 * @return {Array} Point coordinates
	 */

	function getCubicBezierPoint(curve, t) {
	    var sqrT = t * t,
	        cubT = sqrT * t,
	        mt = 1 - t,
	        sqrMt = mt * mt;

	    return [
	        3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
	        3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
	    ];
	}

	/**
	 * Finds circle by 3 points of the curve and checks if the curve fits the found circle.
	 *
	 * @param {Array} curve
	 * @return {Object|undefined} circle
	 */

	function findCircle(curve) {
	    var midPoint = getCubicBezierPoint(curve, 1/2),
	        m1 = [midPoint[0] / 2, midPoint[1] / 2],
	        m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2],
	        center = getIntersection([
	            m1[0], m1[1],
	            m1[0] + m1[1], m1[1] - m1[0],
	            m2[0], m2[1],
	            m2[0] + (m2[1] - midPoint[1]), m2[1] - (m2[0] - midPoint[0])
	        ]),
	        radius = center && getDistance([0, 0], center),
	        tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);

	    if (center && [1/4, 3/4].every(function(point) {
	        return Math.abs(getDistance(getCubicBezierPoint(curve, point), center) - radius) <= tolerance;
	    }))
	        return { center: center, radius: radius};
	}

	/**
	 * Checks if a curve fits the given circe.
	 *
	 * @param {Object} circle
	 * @param {Array} curve
	 * @return {Boolean}
	 */

	function isArc(curve,  circle) {
	    var tolerance = Math.min(arcThreshold * error, arcTolerance * circle.radius / 100);

	    return [0, 1/4, 1/2, 3/4, 1].every(function(point) {
	        return Math.abs(getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius) <= tolerance;
	    });
	}

	/**
	 * Checks if a previos curve fits the given circe.
	 *
	 * @param {Object} circle
	 * @param {Array} curve
	 * @return {Boolean}
	 */

	function isArcPrev(curve,  circle) {
	    return isArc(curve, {
	        center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
	        radius: circle.radius
	    });
	}

	/**
	 * Finds angle of a curve fitting the given arc.

	 * @param {Array} curve
	 * @param {Object} relCircle
	 * @return {Number} angle
	 */

	function findArcAngle(curve, relCircle) {
	    var x1 = -relCircle.center[0],
	        y1 = -relCircle.center[1],
	        x2 = curve[4] - relCircle.center[0],
	        y2 = curve[5] - relCircle.center[1];

	    return Math.acos(
	            (x1 * x2 + y1 * y2) /
	            Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
	        );
	}

	/**
	 * Converts given path data to string.
	 *
	 * @param {Object} params
	 * @param {Array} pathData
	 * @return {String}
	 */

	function data2Path(params, pathData) {
	    return pathData.reduce(function(pathString, item) {
	        return pathString += item.instruction + (item.data ? cleanupOutData(roundData(item.data.slice()), params) : '');
	    }, '');
	}


/***/ },
/* 90 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'converts basic shapes to more compact path form';

	var none = { value: 0 },
	    regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;

	/**
	 * Converts basic shape to more compact path.
	 * It also allows further optimizations like
	 * combining paths with similar attributes.
	 *
	 * @see http://www.w3.org/TR/SVG/shapes.html
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Lev Solntsev
	 */
	exports.fn = function(item) {

	    if (
	        item.isElem('rect') &&
	        item.hasAttr('width') &&
	        item.hasAttr('height') &&
	        !item.hasAttr('rx') &&
	        !item.hasAttr('ry')
	    ) {

	        var x = +(item.attr('x') || none).value,
	            y = +(item.attr('y') || none).value,
	            width  = +item.attr('width').value,
	            height = +item.attr('height').value;

	            // Values like '100%' compute to NaN, thus running after
	            // cleanupNumericValues when 'px' units has already been removed.
	            // TODO: Calculate sizes from % and non-px units if possible.
	        if (isNaN(x - y + width - height)) return;

	        var pathData =
	            'M' + x + ' ' + y +
	            'H' + (x + width) +
	            'V' + (y + height) +
	            'H' + x +
	            'z';

	        item.addAttr({
	                name: 'd',
	                value: pathData,
	                prefix: '',
	                local: 'd'
	            });

	        item.renameElem('path')
	            .removeAttr(['x', 'y', 'width', 'height']);

	    } else if (item.isElem('line')) {

	        var x1 = +(item.attr('x1') || none).value,
	            y1 = +(item.attr('y1') || none).value,
	            x2 = +(item.attr('x2') || none).value,
	            y2 = +(item.attr('y2') || none).value;
	        if (isNaN(x1 - y1 + x2 - y2)) return;

	        item.addAttr({
	                name: 'd',
	                value: 'M' + x1 + ' ' + y1 + 'L' + x2 + ' ' + y2,
	                prefix: '',
	                local: 'd'
	            });

	        item.renameElem('path')
	            .removeAttr(['x1', 'y1', 'x2', 'y2']);

	    } else if ((
	            item.isElem('polyline') ||
	            item.isElem('polygon')
	        ) &&
	        item.hasAttr('points')
	    ) {

	        var coords = (item.attr('points').value.match(regNumber) || []).map(Number);
	        if (coords.length < 4) return false;

	        item.addAttr({
	                name: 'd',
	                value: 'M' + coords.slice(0,2).join(' ') +
	                       'L' + coords.slice(2).join(' ') +
	                       (item.isElem('polygon') ? 'z' : ''),
	                prefix: '',
	                local: 'd'
	            });

	        item.renameElem('path')
	            .removeAttr('points');
	    }

	};


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/* jshint quotmark: false */
	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'converts style to attributes';

	var EXTEND = __webpack_require__(24),
	    stylingProps = __webpack_require__(4).attrsGroups.presentation,
	    rEscape = '\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)',                 // Like \" or \2051. Code points consume one space.
	    rAttr = '\\s*(' + g('[^:;\\\\]', rEscape) + '*?)\\s*',          // attribute name like ‘fill’
	    rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)", // string in single quotes: 'smth'
	    rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)',       // string in double quotes: "smth"
	    rQuotedString = new RegExp('^' + g(rSingleQuotes, rQuotes) + '$'),

	    // Parentheses, E.g.: url(data:image/png;base64,iVBO...).
	    // ':' and ';' inside of it should be threated as is. (Just like in strings.)
	    rParenthesis = '\\(' + g('[^\'"()\\\\]+', rEscape, rSingleQuotes, rQuotes) + '*?' + '\\)',

	    // The value. It can have strings and parentheses (see above). Fallbacks to anything in case of unexpected input.
	    rValue = '\\s*(' + g('[^\'"();\\\\]+?', rEscape, rSingleQuotes, rQuotes, rParenthesis, '[^;]*?') + '*?' + ')',

	    // End of declaration. Spaces outside of capturing groups help to do natural trimming.
	    rDeclEnd = '\\s*(?:;\\s*|$)',

	    // Final RegExp to parse CSS declarations.
	    regDeclarationBlock = new RegExp(rAttr + ':' + rValue + rDeclEnd, 'ig'),

	    // Comments expression. Honors escape sequences and strings.
	    regStripComments = new RegExp(g(rEscape, rSingleQuotes, rQuotes, '/\\*[^]*?\\*/'), 'ig');

	/**
	 * Convert style in attributes. Cleanups comments and illegal declarations (without colon) as a side effect.
	 *
	 * @example
	 * <g style="fill:#000; color: #fff;">
	 *             ⬇
	 * <g fill="#000" color="#fff">
	 *
	 * @example
	 * <g style="fill:#000; color: #fff; -webkit-blah: blah">
	 *             ⬇
	 * <g fill="#000" color="#fff" style="-webkit-blah: blah">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {
	    /* jshint boss: true */

	    if (item.elem && item.hasAttr('style')) {
	            // ['opacity: 1', 'color: #000']
	        var styleValue = item.attr('style').value,
	            styles = [],
	            attrs = {};

	        // Strip CSS comments preserving escape sequences and strings.
	        styleValue = styleValue.replace(regStripComments, function(match) {
	            return match[0] == '/' ? '' :
	                match[0] == '\\' && /[-g-z]/i.test(match[1]) ? match[1] : match;
	        });

	        regDeclarationBlock.lastIndex = 0;
	        for (var rule; rule = regDeclarationBlock.exec(styleValue);) {
	            styles.push([rule[1], rule[2]]);
	        }

	        if (styles.length) {

	            styles = styles.filter(function(style) {
	                if (style[0]) {
	                    var prop = style[0].toLowerCase(),
	                        val = style[1];

	                    if (rQuotedString.test(val)) {
	                        val = val.slice(1, -1);
	                    }

	                    if (stylingProps.indexOf(prop) > -1) {

	                        attrs[prop] = {
	                            name: prop,
	                            value: val,
	                            local: prop,
	                            prefix: ''
	                        };

	                        return false;
	                    }
	                }

	                return true;
	            });

	            EXTEND(item.attrs, attrs);

	            if (styles.length) {
	                item.attr('style').value = styles
	                    .map(function(declaration) { return declaration.join(':') })
	                    .join(';');
	            } else {
	                item.removeAttr('style');
	            }

	        }

	    }

	};

	function g() {
	    return '(?:' + Array.prototype.join.call(arguments, '|') + ')';
	}


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'collapses multiple transformations and optimizes it';

	exports.params = {
	    convertToShorts: true,
	    // degPrecision: 3, // transformPrecision (or matrix precision) - 2 by default
	    floatPrecision: 3,
	    transformPrecision: 5,
	    matrixToTransform: true,
	    shortTranslate: true,
	    shortScale: true,
	    shortRotate: true,
	    removeUseless: true,
	    collapseIntoOne: true,
	    leadingZero: true,
	    negativeExtraSpace: false
	};

	var cleanupOutData = __webpack_require__(22).cleanupOutData,
	    EXTEND = __webpack_require__(24),
	    transform2js = __webpack_require__(14).transform2js,
	    transformsMultiply = __webpack_require__(14).transformsMultiply,
	    matrixToTransform = __webpack_require__(14).matrixToTransform,
	    degRound,
	    floatRound,
	    transformRound;

	/**
	 * Convert matrices to the short aliases,
	 * convert long translate, scale or rotate transform notations to the shorts ones,
	 * convert transforms to the matrices and multiply them all into one,
	 * remove useless transforms.
	 *
	 * @see http://www.w3.org/TR/SVG/coords.html#TransformMatrixDefined
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.elem) {

	        // transform
	        if (item.hasAttr('transform')) {
	            convertTransform(item, 'transform', params);
	        }

	        // gradientTransform
	        if (item.hasAttr('gradientTransform')) {
	            convertTransform(item, 'gradientTransform', params);
	        }

	        // patternTransform
	        if (item.hasAttr('patternTransform')) {
	            convertTransform(item, 'patternTransform', params);
	        }

	    }

	};

	/**
	 * Main function.
	 *
	 * @param {Object} item input item
	 * @param {String} attrName attribute name
	 * @param {Object} params plugin params
	 */
	function convertTransform(item, attrName, params) {
	    var data = transform2js(item.attr(attrName).value);
	    params = definePrecision(data, params);

	    if (params.collapseIntoOne && data.length > 1) {
	        data = [transformsMultiply(data)];
	    }

	    if (params.convertToShorts) {
	        data = convertToShorts(data, params);
	    } else {
	        data.forEach(roundTransform);
	    }

	    if (params.removeUseless) {
	        data = removeUseless(data);
	    }

	    if (data.length) {
	        item.attr(attrName).value = js2transform(data, params);
	    } else {
	        item.removeAttr(attrName);
	    }
	}

	/**
	 * Defines precision to work with certain parts.
	 * transformPrecision - for scale and four first matrix parameters (needs a better precision due to multiplying),
	 * floatPrecision - for translate including two last matrix and rotate parameters,
	 * degPrecision - for rotate and skew. By default it's equal to (rougly)
	 * transformPrecision - 2 or floatPrecision whichever is lower. Can be set in params.
	 *
	 * @param {Array} transforms input array
	 * @param {Object} params plugin params
	 * @return {Array} output array
	 */
	function definePrecision(data, params) {
	    /* jshint validthis: true */
	    var matrixData = data.reduce(getMatrixData, []),
	        significantDigits = params.transformPrecision;

	    // Clone params so it don't affect other elements transformations.
	    params = EXTEND({}, params);

	    // Limit transform precision with matrix one. Calculating with larger precision doesn't add any value.
	    if (matrixData.length) {
	        params.transformPrecision = Math.min(params.transformPrecision,
	            Math.max.apply(Math, matrixData.map(floatDigits)) || params.transformPrecision);

	        significantDigits = Math.max.apply(Math, matrixData.map(function(n) {
	            return String(n).replace(/\D+/g, '').length; // Number of digits in a number. 123.45 → 5
	        }));
	    }
	    // No sense in angle precision more then number of significant digits in matrix.
	    if (!('degPrecision' in params)) {
	        params.degPrecision = Math.max(0, Math.min(params.floatPrecision, significantDigits - 2));
	    }

	    floatRound = params.floatPrecision >= 1 && params.floatPrecision < 20 ?
	        smartRound.bind(this, params.floatPrecision) :
	        round;
	    degRound = params.degPrecision >= 1 && params.floatPrecision < 20 ?
	        smartRound.bind(this, params.degPrecision) :
	        round;
	    transformRound = params.transformPrecision >= 1 && params.floatPrecision < 20 ?
	        smartRound.bind(this, params.transformPrecision) :
	        round;

	    return params;
	}

	/**
	 * Gathers four first matrix parameters.
	 *
	 * @param {Array} a array of data
	 * @param {Object} transform
	 * @return {Array} output array
	 */
	function getMatrixData(a, b) {
	    return b.name == 'matrix' ? a.concat(b.data.slice(0, 4)) : a;
	}

	/**
	 * Returns number of digits after the point. 0.125 → 3
	 */
	function floatDigits(n) {
	    return (n = String(n)).slice(n.indexOf('.')).length - 1;
	}

	/**
	 * Convert transforms to the shorthand alternatives.
	 *
	 * @param {Array} transforms input array
	 * @param {Object} params plugin params
	 * @return {Array} output array
	 */
	function convertToShorts(transforms, params) {

	    for(var i = 0; i < transforms.length; i++) {

	        var transform = transforms[i];

	        // convert matrix to the short aliases
	        if (
	            params.matrixToTransform &&
	            transform.name === 'matrix'
	        ) {
	            var decomposed = matrixToTransform(transform, params);
	            if (decomposed != transform &&
	                js2transform(decomposed, params).length <= js2transform([transform], params).length) {

	                transforms.splice.apply(transforms, [i, 1].concat(decomposed));
	            }
	            transform = transforms[i];
	        }

	        // fixed-point numbers
	        // 12.754997 → 12.755
	        roundTransform(transform);

	        // convert long translate transform notation to the shorts one
	        // translate(10 0) → translate(10)
	        if (
	            params.shortTranslate &&
	            transform.name === 'translate' &&
	            transform.data.length === 2 &&
	            !transform.data[1]
	        ) {
	            transform.data.pop();
	        }

	        // convert long scale transform notation to the shorts one
	        // scale(2 2) → scale(2)
	        if (
	            params.shortScale &&
	            transform.name === 'scale' &&
	            transform.data.length === 2 &&
	            transform.data[0] === transform.data[1]
	        ) {
	            transform.data.pop();
	        }

	        // convert long rotate transform notation to the short one
	        // translate(cx cy) rotate(a) translate(-cx -cy) → rotate(a cx cy)
	        if (
	            params.shortRotate &&
	            transforms[i - 2] &&
	            transforms[i - 2].name === 'translate' &&
	            transforms[i - 1].name === 'rotate' &&
	            transforms[i].name === 'translate' &&
	            transforms[i - 2].data[0] === -transforms[i].data[0] &&
	            transforms[i - 2].data[1] === -transforms[i].data[1]
	        ) {
	            transforms.splice(i - 2, 3, {
	                name: 'rotate',
	                data: [
	                    transforms[i - 1].data[0],
	                    transforms[i - 2].data[0],
	                    transforms[i - 2].data[1]
	                ]
	            });

	            // splice compensation
	            i -= 2;

	            transform = transforms[i];
	        }

	    }

	    return transforms;

	}

	/**
	 * Remove useless transforms.
	 *
	 * @param {Array} transforms input array
	 * @return {Array} output array
	 */
	function removeUseless(transforms) {

	    return transforms.filter(function(transform) {

	        // translate(0), rotate(0[, cx, cy]), skewX(0), skewY(0)
	        if (
	            ['translate', 'rotate', 'skewX', 'skewY'].indexOf(transform.name) > -1 &&
	            (transform.data.length == 1 || transform.name == 'rotate') &&
	            !transform.data[0] ||

	            // translate(0, 0)
	            transform.name == 'translate' &&
	            !transform.data[0] &&
	            !transform.data[1] ||

	            // scale(1)
	            transform.name == 'scale' &&
	            transform.data[0] == 1 &&
	            (transform.data.length < 2 || transform.data[1] == 1) ||

	            // matrix(1 0 0 1 0 0)
	            transform.name == 'matrix' &&
	            transform.data[0] == 1 &&
	            transform.data[3] == 1 &&
	            !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])
	        ) {
	            return false;
	        }

	        return true;

	    });

	}

	/**
	 * Convert transforms JS representation to string.
	 *
	 * @param {Array} transformJS JS representation array
	 * @param {Object} params plugin params
	 * @return {String} output string
	 */
	function js2transform(transformJS, params) {

	    var transformString = '';

	    // collect output value string
	    transformJS.forEach(function(transform) {
	        roundTransform(transform);
	        transformString += (transformString && ' ') + transform.name + '(' + cleanupOutData(transform.data, params) + ')';
	    });

	    return transformString;

	}

	function roundTransform(transform) {
	    switch (transform.name) {
	        case 'translate':
	            transform.data = floatRound(transform.data);
	            break;
	        case 'rotate':
	            transform.data = degRound(transform.data.slice(0, 1)).concat(floatRound(transform.data.slice(1)));
	            break;
	        case 'skewX':
	        case 'skewY':
	            transform.data = degRound(transform.data);
	            break;
	        case 'scale':
	            transform.data = transformRound(transform.data);
	            break;
	        case 'matrix':
	            transform.data = transformRound(transform.data.slice(0, 4)).concat(floatRound(transform.data.slice(4)));
	            break;
	    }
	    return transform;
	}

	/**
	 * Rounds numbers in array.
	 *
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function round(data) {
	    return data.map(Math.round);
	}

	/**
	 * Decrease accuracy of floating-point numbers
	 * in transforms keeping a specified number of decimals.
	 * Smart rounds values like 2.349 to 2.35.
	 *
	 * @param {Number} fixed number of decimals
	 * @param {Array} data input data array
	 * @return {Array} output data array
	 */
	function smartRound(precision, data) {
	    for (var i = data.length, tolerance = +Math.pow(.1, precision).toFixed(precision); i--;) {
	        if (data[i].toFixed(precision) != data[i]) {
	            var rounded = +data[i].toFixed(precision - 1);
	            data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ?
	                +data[i].toFixed(precision) :
	                rounded;
	        }
	    }
	    return data;
	}


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'merges multiple paths in one if possible';

	exports.params = {
	    collapseRepeated: true,
	    leadingZero: true,
	    negativeExtraSpace: true
	};

	var path2js = __webpack_require__(13).path2js,
	    js2path = __webpack_require__(13).js2path,
	    intersects = __webpack_require__(13).intersects;

	/**
	 * Merge multiple Paths into one.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich, Lev Solntsev
	 */
	exports.fn = function(item, params) {

	    if (!item.isElem() || item.isEmpty()) return;

	    var prevContentItem = null,
	        prevContentItemKeys = null;

	    item.content = item.content.filter(function(contentItem) {

	        if (prevContentItem &&
	            prevContentItem.isElem('path') &&
	            prevContentItem.isEmpty() &&
	            prevContentItem.hasAttr('d') &&
	            contentItem.isElem('path') &&
	            contentItem.isEmpty() &&
	            contentItem.hasAttr('d')
	        ) {

	            if (!prevContentItemKeys) {
	                prevContentItemKeys = Object.keys(prevContentItem.attrs);
	            }

	            var contentItemAttrs = Object.keys(contentItem.attrs),
	                equalData = prevContentItemKeys.length == contentItemAttrs.length &&
	                    contentItemAttrs.every(function(key) {
	                        return key == 'd' ||
	                            prevContentItem.hasAttr(key) &&
	                            prevContentItem.attr(key).value == contentItem.attr(key).value;
	                    }),
	                prevPathJS = path2js(prevContentItem),
	                curPathJS = path2js(contentItem);

	            if (equalData && !intersects(prevPathJS, curPathJS)) {
	                js2path(prevContentItem, prevPathJS.concat(curPathJS), params);
	                return false;
	            }
	        }

	        prevContentItem = contentItem;
	        prevContentItemKeys = null;
	        return true;

	    });

	};


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.params = {
	    svgo: {}
	};

	exports.description = 'minifies existing styles in svg';

	var csso = __webpack_require__(172);

	/**
	 * Minifies styles (<style> element + style attribute) using svgo
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author strarsis <strarsis@gmail.com>
	 */
	exports.fn = function(item, svgoOptions) {

	    if(item.elem) {
	        if(item.isElem('style') && !item.isEmpty()) {
	            var styleCss = item.content[0].text || item.content[0].cdata || [],
	                DATA = styleCss.indexOf('>') >= 0 || styleCss.indexOf('<') >= 0 ? 'cdata' : 'text';
	            if(styleCss.length > 0) {
	                var styleCssMinified = csso.minify(styleCss, svgoOptions);
	                item.content[0][DATA] = styleCssMinified.css;
	            }
	      }

	      if(item.hasAttr('style')) {
	          var itemCss = item.attr('style').value;
	          if(itemCss.length > 0) {
	              var itemCssMinified = csso.minifyBlock(itemCss, svgoOptions);
	              item.attr('style').value = itemCssMinified.css;
	          }
	      }
	    }

	    return item;
	};


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItemReverse';

	exports.active = true;

	exports.description = 'moves elements attributes to the existing group wrapper';

	var inheritableAttrs = __webpack_require__(4).inheritableAttrs,
	    pathElems = __webpack_require__(4).pathElems;

	/**
	 * Collapse content's intersected and inheritable
	 * attributes to the existing group wrapper.
	 *
	 * @example
	 * <g attr1="val1">
	 *     <g attr2="val2">
	 *         text
	 *     </g>
	 *     <circle attr2="val2" attr3="val3"/>
	 * </g>
	 *              ⬇
	 * <g attr1="val1" attr2="val2">
	 *     <g>
	 *         text
	 *     </g>
	 *    <circle attr3="val3"/>
	 * </g>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (item.isElem('g') && !item.isEmpty() && item.content.length > 1) {

	        var intersection = {},
	            hasTransform = false,
	            hasClip = item.hasAttr('clip-path') || item.hasAttr('mask'),
	            intersected = item.content.every(function(inner) {
	                if (inner.isElem() && inner.hasAttr()) {
	                    // don't mess with possible styles (hack until CSS parsing is implemented)
	                    if (inner.hasAttr('class')) return false;
	                    if (!Object.keys(intersection).length) {
	                        intersection = inner.attrs;
	                    } else {
	                        intersection = intersectInheritableAttrs(intersection, inner.attrs);

	                        if (!intersection) return false;
	                    }

	                    return true;
	                }
	            }),
	            allPath = item.content.every(function(inner) {
	                return inner.isElem(pathElems);
	            });

	        if (intersected) {

	            item.content.forEach(function(g) {

	                for (var name in intersection) {

	                    if (!allPath && !hasClip || name !== 'transform') {

	                        g.removeAttr(name);

	                        if (name === 'transform') {
	                            if (!hasTransform) {
	                                if (item.hasAttr('transform')) {
	                                    item.attr('transform').value += ' ' + intersection[name].value;
	                                } else {
	                                    item.addAttr(intersection[name]);
	                                }

	                                hasTransform = true;
	                            }
	                        } else {
	                            item.addAttr(intersection[name]);
	                        }

	                    }
	                }

	            });

	        }

	    }

	};

	/**
	 * Intersect inheritable attributes.
	 *
	 * @param {Object} a first attrs object
	 * @param {Object} b second attrs object
	 *
	 * @return {Object} intersected attrs object
	 */
	function intersectInheritableAttrs(a, b) {

	    var c = {};

	    for (var n in a) {
	        if (
	            b.hasOwnProperty(n) &&
	            inheritableAttrs.indexOf(n) > -1 &&
	            a[n].name === b[n].name &&
	            a[n].value === b[n].value &&
	            a[n].prefix === b[n].prefix &&
	            a[n].local === b[n].local
	        ) {
	            c[n] = a[n];
	        }
	    }

	    if (!Object.keys(c).length) return false;

	    return c;

	}


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'moves some group attributes to the content elements';

	var collections = __webpack_require__(4),
	    pathElems = collections.pathElems.concat(['g', 'text']),
	    referencesProps = collections.referencesProps;

	/**
	 * Move group attrs to the content elements.
	 *
	 * @example
	 * <g transform="scale(2)">
	 *     <path transform="rotate(45)" d="M0,0 L10,20"/>
	 *     <path transform="translate(10, 20)" d="M0,10 L20,30"/>
	 * </g>
	 *                          ⬇
	 * <g>
	 *     <path transform="scale(2) rotate(45)" d="M0,0 L10,20"/>
	 *     <path transform="scale(2) translate(10, 20)" d="M0,10 L20,30"/>
	 * </g>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    // move group transform attr to content's pathElems
	    if (
	        item.isElem('g') &&
	        item.hasAttr('transform') &&
	        !item.isEmpty() &&
	        !item.someAttr(function(attr) {
	            return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');
	        }) &&
	        item.content.every(function(inner) {
	            return inner.isElem(pathElems) && !inner.hasAttr('id');
	        })
	    ) {
	        item.content.forEach(function(inner) {
	            if (inner.hasAttr('transform')) {
	                inner.attr('transform').value = item.attr('transform').value + ' ' + inner.attr('transform').value;
	            } else {
	                inner.addAttr(item.attr('transform'));
	            }
	        });

	        item.removeAttr('transform');
	    }

	};


/***/ },
/* 97 */
/***/ function(module, exports) {

	'use strict';

	var ELEM_SEP = ':';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes specified attributes';

	exports.params = {
	    attrs: []
	};

	/**
	 * Remove attributes
	 *
	 * @param attrs:
	 *
	 *   format: [ element* : attribute* ]
	 *
	 *   element   : regexp (wrapped into ^...$), single * or omitted > all elements
	 *   attribute : regexp (wrapped into ^...$)
	 *
	 *   examples:
	 *
	 *     > basic: remove fill attribute
	 *     ---
	 *     removeAttrs:
	 *       attrs: 'fill'
	 *
	 *     > remove fill attribute on path element
	 *     ---
	 *       attrs: 'path:fill'
	 *
	 *
	 *     > remove all fill and stroke attribute
	 *     ---
	 *       attrs:
	 *         - 'fill'
	 *         - 'stroke'
	 *
	 *     [is same as]
	 *
	 *       attrs: '(fill|stroke)'
	 *
	 *     [is same as]
	 *
	 *       attrs: '*:(fill|stroke)'
	 *
	 *     [is same as]
	 *
	 *       attrs: '.*:(fill|stroke)'
	 *
	 *
	 *     > remove all stroke related attributes
	 *     ----
	 *     attrs: 'stroke.*'
	 *
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Benny Schudel
	 */
	exports.fn = function(item, params) {

	        // wrap into an array if params is not
	    if (!Array.isArray(params.attrs)) {
	        params.attrs = [params.attrs];
	    }

	    if (item.isElem()) {

	            // prepare patterns
	        var patterns = params.attrs.map(function(pattern) {

	                // apply to all elements if specifc element is omitted
	            if (pattern.indexOf(ELEM_SEP) === -1) {
	                pattern = ['.*', ELEM_SEP, pattern].join('');
	            }

	                // create regexps for element and attribute name
	            return pattern.split(ELEM_SEP)
	                .map(function(value) {

	                        // adjust single * to match anything
	                    if (value === '*') { value = '.*'; }

	                    return new RegExp(['^', value, '$'].join(''), 'i');
	                });

	        });

	            // loop patterns
	        patterns.forEach(function(pattern) {

	                // matches element
	            if (pattern[0].test(item.elem)) {

	                    // loop attributes
	                item.eachAttr(function(attr) {
	                    var name = attr.name;

	                        // matches attribute name
	                    if (pattern[1].test(name)) {
	                        item.removeAttr(name);
	                    }

	                });

	            }

	        });

	    }

	};


/***/ },
/* 98 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes comments';

	/**
	 * Remove comments.
	 *
	 * @example
	 * <!-- Generator: Adobe Illustrator 15.0.0, SVG Export
	 * Plug-In . SVG Version: 6.00 Build 0)  -->
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (item.comment && item.comment.charAt(0) !== '!') {
	        return false;
	    }

	};


/***/ },
/* 99 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.params = {
	    removeAny: false
	};

	exports.description = 'removes <desc> (only non-meaningful by default)';

	var standardDescs = /^Created with/;

	/**
	 * Removes <desc>.
	 * Removes only standard editors content or empty elements 'cause it can be used for accessibility.
	 * Enable parameter 'removeAny' to remove any description.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/desc
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Daniel Wabyick
	 */
	exports.fn = function(item, params) {

	    return !item.isElem('desc') || !(params.removeAny || item.isEmpty() ||
	            standardDescs.test(item.content[0].text));

	};


/***/ },
/* 100 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes width and height in presence of viewBox';

	/**
	 * Remove width/height attributes when a viewBox attribute is present.
	 *
	 * @example
	 * <svg width="100" height="50" viewBox="0 0 100 50">
	 *   ↓
	 * <svg viewBox="0 0 100 50">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if true, with and height will be filtered out
	 *
	 * @author Benny Schudel
	 */
	exports.fn = function(item) {

	    if (
	        item.isElem('svg') &&
	        item.hasAttr('viewBox')
	    ) {
	        item.removeAttr('width');
	        item.removeAttr('height');
	    }

	};


/***/ },
/* 101 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes doctype declaration';

	/**
	 * Remove DOCTYPE declaration.
	 *
	 * "Unfortunately the SVG DTDs are a source of so many
	 * issues that the SVG WG has decided not to write one
	 * for the upcoming SVG 1.2 standard. In fact SVG WG
	 * members are even telling people not to use a DOCTYPE
	 * declaration in SVG 1.0 and 1.1 documents"
	 * https://jwatt.org/svg/authoring/#doctype-declaration
	 *
	 * @example
	 * <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
	 * q"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
	 *
	 * @example
	 * <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	 * "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd" [
	 *     <!-- an internal subset can be embedded here -->
	 * ]>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (item.doctype) {
	        return false;
	    }

	};


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes editors namespaces, elements and attributes';

	var editorNamespaces = __webpack_require__(4).editorNamespaces,
	    prefixes = [];

	exports.params = {
	    additionalNamespaces: []
	};

	/**
	 * Remove editors namespaces, elements and attributes.
	 *
	 * @example
	 * <svg xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd">
	 * <sodipodi:namedview/>
	 * <path sodipodi:nodetypes="cccc"/>
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (Array.isArray(params.additionalNamespaces)) {
	        editorNamespaces = editorNamespaces.concat(params.additionalNamespaces);
	    }

	    if (item.elem) {

	        if (item.isElem('svg')) {

	            item.eachAttr(function(attr) {
	                if (attr.prefix === 'xmlns' && editorNamespaces.indexOf(attr.value) > -1) {
	                    prefixes.push(attr.local);

	                    // <svg xmlns:sodipodi="">
	                    item.removeAttr(attr.name);
	                }
	            });

	        }

	        // <* sodipodi:*="">
	        item.eachAttr(function(attr) {
	            if (prefixes.indexOf(attr.prefix) > -1) {
	                item.removeAttr(attr.name);
	            }
	        });

	        // <sodipodi:*>
	        if (prefixes.indexOf(item.prefix) > -1) {
	            return false;
	        }

	    }

	};


/***/ },
/* 103 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes empty attributes';

	/**
	 * Remove attributes with empty values.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (item.elem) {

	        item.eachAttr(function(attr) {
	            if (attr.value === '') {
	                item.removeAttr(attr.name);
	            }
	        });

	    }

	};


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItemReverse';

	exports.active = true;

	exports.description = 'removes empty container elements';

	var container = __webpack_require__(4).elemsGroups.container;

	/**
	 * Remove empty containers.
	 *
	 * @see http://www.w3.org/TR/SVG/intro.html#TermContainerElement
	 *
	 * @example
	 * <defs/>
	 *
	 * @example
	 * <g><marker><a/></marker></g>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    return !(item.isElem(container) && !item.isElem('svg') && item.isEmpty() &&
	        (!item.isElem('pattern') || !item.hasAttrLocal('href')));

	};


/***/ },
/* 105 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes empty <text> elements';

	exports.params = {
	    text: true,
	    tspan: true,
	    tref: true
	};

	/**
	 * Remove empty Text elements.
	 *
	 * @see http://www.w3.org/TR/SVG/text.html
	 *
	 * @example
	 * Remove empty text element:
	 * <text/>
	 *
	 * Remove empty tspan element:
	 * <tspan/>
	 *
	 * Remove tref with empty xlink:href attribute:
	 * <tref xlink:href=""/>
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    // Remove empty text element
	    if (
	        params.text &&
	        item.isElem('text') &&
	        item.isEmpty()
	    ) return false;

	    // Remove empty tspan element
	    if (
	        params.tspan &&
	        item.isElem('tspan') &&
	        item.isEmpty()
	    ) return false;

	    // Remove tref with empty xlink:href attribute
	    if (
	        params.tref &&
	        item.isElem('tref') &&
	        !item.hasAttrLocal('href')
	    ) return false;

	};


/***/ },
/* 106 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes hidden elements (zero sized, with absent attributes)';

	exports.params = {
	    displayNone: true,
	    opacity0: true,
	    circleR0: true,
	    ellipseRX0: true,
	    ellipseRY0: true,
	    rectWidth0: true,
	    rectHeight0: true,
	    patternWidth0: true,
	    patternHeight0: true,
	    imageWidth0: true,
	    imageHeight0: true,
	    pathEmptyD: true,
	    polylineEmptyPoints: true,
	    polygonEmptyPoints: true
	};

	var regValidPath = /M\s*(?:[-+]?(?:\d*\.\d+|\d+(?:\.|(?!\.)))([eE][-+]?\d+)?(?!\d)\s*,?\s*){2}\D*\d/i;

	/**
	 * Remove hidden elements with disabled rendering:
	 * - display="none"
	 * - opacity="0"
	 * - circle with zero radius
	 * - ellipse with zero x-axis or y-axis radius
	 * - rectangle with zero width or height
	 * - pattern with zero width or height
	 * - image with zero width or height
	 * - path with empty data
	 * - polyline with empty points
	 * - polygon with empty points
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.elem) {

	        // display="none"
	        //
	        // http://www.w3.org/TR/SVG/painting.html#DisplayProperty
	        // "A value of display: none indicates that the given element
	        // and its children shall not be rendered directly"
	        if (
	            params.displayNone &&
	            item.hasAttr('display', 'none')
	        ) return false;

	        // opacity="0"
	        //
	        // http://www.w3.org/TR/SVG/masking.html#ObjectAndGroupOpacityProperties
	        if (
	            params.opacity0 &&
	            item.hasAttr('opacity', '0')
	        ) return false;

	        // Circles with zero radius
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#CircleElementRAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <circle r="0">
	        if (
	            params.circleR0 &&
	            item.isElem('circle') &&
	            item.isEmpty() &&
	            item.hasAttr('r', '0')
	        ) return false;

	        // Ellipse with zero x-axis radius
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#EllipseElementRXAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <ellipse rx="0">
	        if (
	            params.ellipseRX0 &&
	            item.isElem('ellipse') &&
	            item.isEmpty() &&
	            item.hasAttr('rx', '0')
	        ) return false;

	        // Ellipse with zero y-axis radius
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#EllipseElementRYAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <ellipse ry="0">
	        if (
	            params.ellipseRY0 &&
	            item.isElem('ellipse') &&
	            item.isEmpty() &&
	            item.hasAttr('ry', '0')
	        ) return false;

	        // Rectangle with zero width
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#RectElementWidthAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <rect width="0">
	        if (
	            params.rectWidth0 &&
	            item.isElem('rect') &&
	            item.isEmpty() &&
	            item.hasAttr('width', '0')
	        ) return false;

	        // Rectangle with zero height
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#RectElementHeightAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <rect height="0">
	        if (
	            params.rectHeight0 &&
	            params.rectWidth0 &&
	            item.isElem('rect') &&
	            item.isEmpty() &&
	            item.hasAttr('height', '0')
	        ) return false;

	        // Pattern with zero width
	        //
	        // http://www.w3.org/TR/SVG/pservers.html#PatternElementWidthAttribute
	        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
	        //
	        // <pattern width="0">
	        if (
	            params.patternWidth0 &&
	            item.isElem('pattern') &&
	            item.hasAttr('width', '0')
	        ) return false;

	        // Pattern with zero height
	        //
	        // http://www.w3.org/TR/SVG/pservers.html#PatternElementHeightAttribute
	        // "A value of zero disables rendering of the element (i.e., no paint is applied)"
	        //
	        // <pattern height="0">
	        if (
	            params.patternHeight0 &&
	            item.isElem('pattern') &&
	            item.hasAttr('height', '0')
	        ) return false;

	        // Image with zero width
	        //
	        // http://www.w3.org/TR/SVG/struct.html#ImageElementWidthAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <image width="0">
	        if (
	            params.imageWidth0 &&
	            item.isElem('image') &&
	            item.hasAttr('width', '0')
	        ) return false;

	        // Image with zero height
	        //
	        // http://www.w3.org/TR/SVG/struct.html#ImageElementHeightAttribute
	        // "A value of zero disables rendering of the element"
	        //
	        // <image height="0">
	        if (
	            params.imageHeight0 &&
	            item.isElem('image') &&
	            item.hasAttr('height', '0')
	        ) return false;

	        // Path with empty data
	        //
	        // http://www.w3.org/TR/SVG/paths.html#DAttribute
	        //
	        // <path d=""/>
	        if (
	            params.pathEmptyD &&
	            item.isElem('path') &&
	            (!item.hasAttr('d') || !regValidPath.test(item.attr('d').value))
	        ) return false;

	        // Polyline with empty points
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#PolylineElementPointsAttribute
	        //
	        // <polyline points="">
	        if (
	            params.polylineEmptyPoints &&
	            item.isElem('polyline') &&
	            !item.hasAttr('points')
	        ) return false;

	        // Polygon with empty points
	        //
	        // http://www.w3.org/TR/SVG/shapes.html#PolygonElementPointsAttribute
	        //
	        // <polygon points="">
	        if (
	            params.polygonEmptyPoints &&
	            item.isElem('polygon') &&
	            !item.hasAttr('points')
	        ) return false;

	    }

	};


/***/ },
/* 107 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes <metadata>';

	/**
	 * Remove <metadata>.
	 *
	 * http://www.w3.org/TR/SVG/metadata.html
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    return !item.isElem('metadata');

	};


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes non-inheritable group’s presentational attributes';

	var inheritableAttrs = __webpack_require__(4).inheritableAttrs,
	    attrsGroups = __webpack_require__(4).attrsGroups,
	    excludedAttrs = ['display', 'opacity'];

	/**
	 * Remove non-inheritable group's "presentation" attributes.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (item.isElem('g')) {

	        item.eachAttr(function(attr) {
	            if (
	                ~attrsGroups.presentation.indexOf(attr.name) &&
	                ~attrsGroups.graphicalEvent.indexOf(attr.name) &&
	                ~attrsGroups.core.indexOf(attr.name) &&
	                ~attrsGroups.conditionalProcessing.indexOf(attr.name) &&
	                !~excludedAttrs.indexOf(attr.name) &&
	                !~inheritableAttrs.indexOf(attr.name)
	            ) {
	                item.removeAttr(attr.name);
	            }
	        });

	    }

	};


/***/ },
/* 109 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes raster images (disabled by default)';

	/**
	 * Remove raster images references in <image>.
	 *
	 * @see https://bugs.webkit.org/show_bug.cgi?id=63548
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (
	        item.isElem('image') &&
	        item.hasAttrLocal('href', /(\.|image\/)(jpg|png|gif)/)
	    ) {
	        return false;
	    }

	};


/***/ },
/* 110 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes <style> element (disabled by default)';

	/**
	 * Remove <style>.
	 *
	 * http://www.w3.org/TR/SVG/styling.html#StyleElement
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Betsy Dupuis
	 */
	exports.fn = function(item) {

	    return !item.isElem('style');

	};


/***/ },
/* 111 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes <title> (disabled by default)';

	/**
	 * Remove <title>.
	 * Disabled by default cause it may be used for accessibility.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/SVG/Element/title
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Igor Kalashnikov
	 */
	exports.fn = function(item) {

	    return !item.isElem('title');

	};


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes unknown elements content and attributes, removes attrs with default values';

	exports.params = {
	    unknownContent: true,
	    unknownAttrs: true,
	    defaultAttrs: true,
	    uselessOverrides: true,
	    keepDataAttrs: true
	};

	var collections = __webpack_require__(4),
	    elems = collections.elems,
	    attrsGroups = collections.attrsGroups,
	    elemsGroups = collections.elemsGroups,
	    attrsGroupsDefaults = collections.attrsGroupsDefaults,
	    attrsInheritable = collections.inheritableAttrs;

	// collect and extend all references
	for (var elem in elems) {
	    elem = elems[elem];

	    if (elem.attrsGroups) {
	        elem.attrs = elem.attrs || [];

	        elem.attrsGroups.forEach(function(attrsGroupName) {
	            elem.attrs = elem.attrs.concat(attrsGroups[attrsGroupName]);

	            var groupDefaults = attrsGroupsDefaults[attrsGroupName];

	            if (groupDefaults) {
	                elem.defaults = elem.defaults || {};

	                for (var attrName in groupDefaults) {
	                    elem.defaults[attrName] = groupDefaults[attrName];
	                }
	            }
	        });

	    }

	    if (elem.contentGroups) {
	        elem.content = elem.content || [];

	        elem.contentGroups.forEach(function(contentGroupName) {
	            elem.content = elem.content.concat(elemsGroups[contentGroupName]);
	        });
	    }
	}

	/**
	 * Remove unknown elements content and attributes,
	 * remove attributes with default values.
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    // elems w/o namespace prefix
	    if (item.isElem() && !item.prefix) {

	        var elem = item.elem;

	        // remove unknown element's content
	        if (
	            params.unknownContent &&
	            !item.isEmpty() &&
	            elems[elem] && // make sure we know of this element before checking its children
	            elem !== 'foreignObject' // Don't check foreignObject
	        ) {
	            item.content.forEach(function(content, i) {
	                if (
	                    content.isElem() &&
	                    !content.prefix &&
	                    (
	                        (
	                            elems[elem].content && // Do we have a record of its permitted content?
	                            elems[elem].content.indexOf(content.elem) === -1
	                        ) ||
	                        (
	                            !elems[elem].content && // we dont know about its permitted content
	                            !elems[content.elem] // check that we know about the element at all
	                        )
	                    )
	                ) {
	                    item.content.splice(i, 1);
	                }
	            });
	        }

	        // remove element's unknown attrs and attrs with default values
	        if (elems[elem] && elems[elem].attrs) {

	            item.eachAttr(function(attr) {

	                if (
	                    attr.name !== 'xmlns' &&
	                    (attr.prefix === 'xml' || !attr.prefix) &&
	                    (!params.keepDataAttrs || attr.name.indexOf('data-') != 0)
	                ) {
	                    if (
	                        // unknown attrs
	                        (
	                            params.unknownAttrs &&
	                            elems[elem].attrs.indexOf(attr.name) === -1
	                        ) ||
	                        // attrs with default values
	                        (
	                            params.defaultAttrs &&
	                            elems[elem].defaults &&
	                            elems[elem].defaults[attr.name] === attr.value && (
	                                attrsInheritable.indexOf(attr.name) < 0 ||
	                                !item.parentNode.computedAttr(attr.name)
	                            )
	                        ) ||
	                        // useless overrides
	                        (
	                            params.uselessOverrides &&
	                            attrsInheritable.indexOf(attr.name) > -1 &&
	                            item.parentNode.computedAttr(attr.name, attr.value)
	                        )
	                    ) {
	                        item.removeAttr(attr.name);
	                    }
	                }

	            });

	        }

	    }

	};


/***/ },
/* 113 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'full';

	exports.active = true;

	exports.description = 'removes unused namespaces declaration';

	/**
	 * Remove unused namespaces declaration.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(data) {

	    var svgElem,
	        xmlnsCollection = [];

	    /**
	     * Remove namespace from collection.
	     *
	     * @param {String} ns namescape name
	     */
	    function removeNSfromCollection(ns) {

	        var pos = xmlnsCollection.indexOf(ns);

	        // if found - remove ns from the namespaces collection
	        if (pos > -1) {
	            xmlnsCollection.splice(pos, 1);
	        }

	    }

	    /**
	     * Bananas!
	     *
	     * @param {Array} items input items
	     *
	     * @return {Array} output items
	     */
	    function monkeys(items) {

	        var i = 0,
	            length = items.content.length;

	        while(i < length) {

	            var item = items.content[i];

	            if (item.isElem('svg')) {

	                item.eachAttr(function(attr) {
	                    // collect namespaces
	                    if (attr.prefix === 'xmlns' && attr.local) {
	                        xmlnsCollection.push(attr.local);
	                    }
	                });

	                // if svg element has ns-attr
	                if (xmlnsCollection.length) {
	                    // save svg element
	                    svgElem = item;
	                }

	            } else if (xmlnsCollection.length) {

	                // check item for the ns-attrs
	                if (item.prefix) {
	                    removeNSfromCollection(item.prefix);
	                }

	                // check each attr for the ns-attrs
	                item.eachAttr(function(attr) {
	                    removeNSfromCollection(attr.prefix);
	                });

	            }

	            // if nothing is found - go deeper
	            if (xmlnsCollection.length && item.content) {
	                monkeys(item);
	            }

	            i++;

	        }

	        return items;

	    }

	    data = monkeys(data);

	    // remove svg element ns-attributes if they are not used even once
	    if (xmlnsCollection.length) {
	        xmlnsCollection.forEach(function(name) {
	            svgElem.removeAttr('xmlns:' + name);
	        });
	    }

	    return data;

	};


/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes elements in <defs> without id';

	var nonRendering = __webpack_require__(4).elemsGroups.nonRendering,
	    defs;

	/**
	 * Removes content of defs and properties that aren't rendered directly without ids.
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Lev Solntsev
	 */
	exports.fn = function(item) {

	    if (item.isElem('defs')) {

	        defs = item;
	        item.content = (item.content || []).reduce(getUsefulItems, []);

	        if (item.isEmpty()) return false;

	    } else if (item.isElem(nonRendering) && !item.hasAttr('id')) {

	        return false;

	    }

	};

	function getUsefulItems(usefulItems, item) {

	    if (item.hasAttr('id') || item.isElem('style')) {

	        usefulItems.push(item);
	        item.parentNode = defs;

	    } else if (!item.isEmpty()) {

	        item.content.reduce(getUsefulItems, usefulItems);

	    }

	    return usefulItems;
	}


/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes useless stroke and fill attributes';

	exports.params = {
	    stroke: true,
	    fill: true
	};

	var shape = __webpack_require__(4).elemsGroups.shape,
	    regStrokeProps = /^stroke/,
	    regFillProps = /^fill-/,
	    styleOrScript = ['style', 'script'],
	    hasStyleOrScript = false;

	/**
	 * Remove useless stroke and fill attrs.
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item, params) {

	    if (item.isElem(styleOrScript)) {
	        hasStyleOrScript = true;
	    }

	    if (!hasStyleOrScript && item.isElem(shape) && !item.computedAttr('id')) {

	        var stroke = params.stroke && item.computedAttr('stroke'),
	            fill = params.fill && !item.computedAttr('fill', 'none');

	        // remove stroke*
	        if (
	            params.stroke &&
	            (!stroke ||
	                stroke == 'none' ||
	                item.computedAttr('stroke-opacity', '0') ||
	                item.computedAttr('stroke-width', '0')
	            )
	        ) {
	            var parentStroke = item.parentNode.computedAttr('stroke'),
	                declineStroke = parentStroke && parentStroke != 'none';

	            item.eachAttr(function(attr) {
	                if (regStrokeProps.test(attr.name)) {
	                    item.removeAttr(attr.name);
	                }
	            });

	            if (declineStroke) item.addAttr({
	                name: 'stroke',
	                value: 'none',
	                prefix: '',
	                local: 'stroke'
	            });
	        }

	        // remove fill*
	        if (
	            params.fill &&
	            (!fill || item.computedAttr('fill-opacity', '0'))
	        ) {
	            item.eachAttr(function(attr) {
	                if (regFillProps.test(attr.name)) {
	                    item.removeAttr(attr.name);
	                }
	            });

	            if (fill) {
	                if (item.hasAttr('fill'))
	                    item.attr('fill').value = 'none';
	                else
	                    item.addAttr({
	                        name: 'fill',
	                        value: 'none',
	                        prefix: '',
	                        local: 'fill'
	                    });
	            }
	        }

	    }

	};


/***/ },
/* 116 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'removes viewBox attribute when possible (disabled by default)';

	var regViewBox = /^0\s0\s([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)\s([\-+]?\d*\.?\d+([eE][\-+]?\d+)?)$/,
	    viewBoxElems = ['svg', 'pattern'];

	/**
	 * Remove viewBox attr which coincides with a width/height box.
	 *
	 * @see http://www.w3.org/TR/SVG/coords.html#ViewBoxAttribute
	 *
	 * @example
	 * <svg width="100" height="50" viewBox="0 0 100 50">
	 *             ⬇
	 * <svg width="100" height="50">
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    if (
	        item.isElem(viewBoxElems) &&
	        item.hasAttr('viewBox') &&
	        item.hasAttr('width') &&
	        item.hasAttr('height')
	    ) {

	        var match = item.attr('viewBox').value.match(regViewBox);

	        if (match) {
	            if (
	                item.attr('width').value === match[1] &&
	                item.attr('height').value === match[3]
	            ) {
	                item.removeAttr('viewBox');
	            }
	        }

	    }

	};


/***/ },
/* 117 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = true;

	exports.description = 'removes XML processing instructions';

	/**
	 * Remove XML Processing Instruction.
	 *
	 * @example
	 * <?xml version="1.0" encoding="utf-8"?>
	 *
	 * @param {Object} item current iteration item
	 * @return {Boolean} if false, item will be filtered out
	 *
	 * @author Kir Belevich
	 */
	exports.fn = function(item) {

	    return !(item.processinginstruction && item.processinginstruction.name === 'xml');

	};


/***/ },
/* 118 */
/***/ function(module, exports) {

	'use strict';

	exports.type = 'perItem';

	exports.active = false;

	exports.description = 'sorts element attributes (disabled by default)';

	exports.params = {
		order: [
			'xmlns',
			'id',
			'width', 'height',
			'x', 'x1', 'x2',
			'y', 'y1', 'y2',
			'cx', 'cy', 'r',
			'fill', 'fill-opacity', 'fill-rule',
			'stroke', 'stroke-opacity', 'stroke-width', 'stroke-miterlimit', 'stroke-dashoffset',
			'd', 'points'
		]
	};

	/**
	 * Sort element attributes for epic readability.
	 *
	 * @param {Object} item current iteration item
	 * @param {Object} params plugin params
	 *
	 * @author Nikolay Frantsev
	 */
	exports.fn = function(item, params) {

		var attrs = [],
			sorted = {},
			orderlen = params.order.length + 1;

		if (item.elem) {

			item.eachAttr(function(attr) {
				attrs.push(attr);
			});

			attrs.sort(function(a, b) {
				return ((a = params.order.indexOf(a.name)) > -1 ? a : orderlen) -
					((b = params.order.indexOf(b.name)) > -1 ? b : orderlen);
			});

			attrs.forEach(function (attr) {
				sorted[attr.name] = attr;
			});

			item.attrs = sorted;

		}

	};


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*
	 * Thanks to http://fontello.com project for sponsoring this plugin
	 */

	exports.type = 'full';

	exports.active = false;

	exports.description = 'performs a set of operations on SVG with one path inside (disabled by default)';

	exports.params = {
	    // width and height to resize SVG and rescale inner Path
	    width: false,
	    height: false,

	    // scale inner Path without resizing SVG
	    scale: false,

	    // shiftX/Y inner Path
	    shiftX: false,
	    shiftY: false,

	    // crop SVG width along the real width of inner Path
	    hcrop: false,

	    // vertical center inner Path inside SVG height
	    vcenter: false,

	    // stringify params
	    floatPrecision: 3,
	    leadingZero: true,
	    negativeExtraSpace: true
	};

	var _path = __webpack_require__(13),
	    relative2absolute = _path.relative2absolute,
	    computeCubicBoundingBox = _path.computeCubicBoundingBox,
	    computeQuadraticBoundingBox = _path.computeQuadraticBoundingBox,
	    applyTransforms = _path.applyTransforms,
	    js2path = _path.js2path,
	    path2js = _path.path2js,
	    EXTEND = __webpack_require__(24);

	exports.fn = function(data, params) {

	    data.content.forEach(function(item) {

	        // only for SVG with one Path inside
	        if (item.isElem('svg') &&
	            item.content.length === 1 &&
	            item.content[0].isElem('path')
	        ) {

	            var svgElem = item,
	                pathElem = svgElem.content[0],
	                // get absoluted Path data
	                path = relative2absolute(EXTEND(true, [], path2js(pathElem))),
	                xs = [],
	                ys = [],
	                cubicСontrolPoint = [0, 0],
	                quadraticСontrolPoint = [0, 0],
	                lastPoint = [0, 0],
	                cubicBoundingBox,
	                quadraticBoundingBox,
	                i,
	                segment;

	            path.forEach(function(pathItem) {

	                // ML
	                if ('ML'.indexOf(pathItem.instruction) > -1) {

	                    for (i = 0; i < pathItem.data.length; i++) {
	                        if (i % 2 === 0) {
	                            xs.push(pathItem.data[i]);
	                        } else {
	                            ys.push(pathItem.data[i]);
	                        }
	                    }

	                    lastPoint = cubicСontrolPoint = quadraticСontrolPoint = pathItem.data.slice(-2);

	                // H
	                } else if (pathItem.instruction === 'H') {

	                    pathItem.data.forEach(function(d) {
	                        xs.push(d);
	                    });

	                    lastPoint[0] = cubicСontrolPoint[0] = quadraticСontrolPoint[0] = pathItem.data[pathItem.data.length - 2];

	                // V
	                } else if (pathItem.instruction === 'V') {

	                    pathItem.data.forEach(function(d) {
	                        ys.push(d);
	                    });

	                    lastPoint[1] = cubicСontrolPoint[1] = quadraticСontrolPoint[1] = pathItem.data[pathItem.data.length - 1];

	                // C
	                } else if (pathItem.instruction === 'C') {

	                    for (i = 0; i < pathItem.data.length; i += 6) {

	                        segment = pathItem.data.slice(i, i + 6);

	                        cubicBoundingBox = computeCubicBoundingBox.apply(this, lastPoint.concat(segment));

	                        xs.push(cubicBoundingBox.minx);
	                        xs.push(cubicBoundingBox.maxx);

	                        ys.push(cubicBoundingBox.miny);
	                        ys.push(cubicBoundingBox.maxy);

	                        // reflected control point for the next possible S
	                        cubicСontrolPoint = [
	                            2 * segment[4] - segment[2],
	                            2 * segment[5] - segment[3]
	                        ];

	                        lastPoint = segment.slice(-2);

	                    }

	                // S
	                } else if (pathItem.instruction === 'S') {

	                    for (i = 0; i < pathItem.data.length; i += 4) {

	                        segment = pathItem.data.slice(i, i + 4);

	                        cubicBoundingBox = computeCubicBoundingBox.apply(this, lastPoint.concat(cubicСontrolPoint).concat(segment));

	                        xs.push(cubicBoundingBox.minx);
	                        xs.push(cubicBoundingBox.maxx);

	                        ys.push(cubicBoundingBox.miny);
	                        ys.push(cubicBoundingBox.maxy);

	                        // reflected control point for the next possible S
	                        cubicСontrolPoint = [
	                            2 * segment[2] - cubicСontrolPoint[0],
	                            2 * segment[3] - cubicСontrolPoint[1],
	                        ];

	                        lastPoint = segment.slice(-2);

	                    }

	                // Q
	                } else if (pathItem.instruction === 'Q') {

	                    for (i = 0; i < pathItem.data.length; i += 4) {

	                        segment = pathItem.data.slice(i, i + 4);

	                        quadraticBoundingBox = computeQuadraticBoundingBox.apply(this, lastPoint.concat(segment));

	                        xs.push(quadraticBoundingBox.minx);
	                        xs.push(quadraticBoundingBox.maxx);

	                        ys.push(quadraticBoundingBox.miny);
	                        ys.push(quadraticBoundingBox.maxy);

	                        // reflected control point for the next possible T
	                        quadraticСontrolPoint = [
	                            2 * segment[2] - segment[0],
	                            2 * segment[3] - segment[1]
	                        ];

	                        lastPoint = segment.slice(-2);

	                    }

	                // S
	                } else if (pathItem.instruction === 'T') {

	                    for (i = 0; i < pathItem.data.length; i += 2) {

	                        segment = pathItem.data.slice(i, i + 2);

	                        quadraticBoundingBox = computeQuadraticBoundingBox.apply(this, lastPoint.concat(quadraticСontrolPoint).concat(segment));

	                        xs.push(quadraticBoundingBox.minx);
	                        xs.push(quadraticBoundingBox.maxx);

	                        ys.push(quadraticBoundingBox.miny);
	                        ys.push(quadraticBoundingBox.maxy);

	                        // reflected control point for the next possible T
	                        quadraticСontrolPoint = [
	                            2 * segment[0] - quadraticСontrolPoint[0],
	                            2 * segment[1] - quadraticСontrolPoint[1]
	                        ];

	                        lastPoint = segment.slice(-2);

	                    }

	                }

	            });

	            var xmin = Math.min.apply(this, xs).toFixed(params.floatPrecision),
	                xmax = Math.max.apply(this, xs).toFixed(params.floatPrecision),
	                ymin = Math.min.apply(this, ys).toFixed(params.floatPrecision),
	                ymax = Math.max.apply(this, ys).toFixed(params.floatPrecision),
	                svgWidth = +svgElem.attr('width').value,
	                svgHeight = +svgElem.attr('height').value,
	                realWidth = Math.round(xmax - xmin),
	                realHeight = Math.round(ymax - ymin),
	                transform = '',
	                scale;

	            // width & height
	            if (params.width && params.height) {

	                scale = Math.min(params.width / svgWidth, params.height / svgHeight);

	                realWidth = realWidth * scale;
	                realHeight = realHeight * scale;

	                svgWidth = svgElem.attr('width').value = params.width;
	                svgHeight = svgElem.attr('height').value = params.height;

	                transform += ' scale(' + scale + ')';

	            // width
	            } else if (params.width && !params.height) {

	                scale = params.width / svgWidth;

	                realWidth = realWidth * scale;
	                realHeight = realHeight * scale;

	                svgWidth = svgElem.attr('width').value = params.width;
	                svgHeight = svgElem.attr('height').value = svgHeight * scale;

	                transform += ' scale(' + scale + ')';

	            // height
	            } else if (params.height && !params.width) {

	                scale = params.height / svgHeight;

	                realWidth = realWidth * scale;
	                realHeight = realHeight * scale;

	                svgWidth = svgElem.attr('width').value = svgWidth * scale;
	                svgHeight = svgElem.attr('height').value = params.height;

	                transform += ' scale(' + scale + ')';

	            }

	            // shiftX
	            if (params.shiftX) {
	                transform += ' translate(' + realWidth * params.shiftX + ', 0)';
	            }

	            // shiftY
	            if (params.shiftY) {
	                transform += ' translate(0, ' + realHeight * params.shiftY + ')';
	            }

	            // scale
	            if (params.scale) {
	                scale = params.scale;

	                var shiftX = svgWidth / 2,
	                    shiftY = svgHeight / 2;

	                realWidth = realWidth * scale;
	                realHeight = realHeight * scale;

	                if (params.shiftX || params.shiftY) {
	                    transform += ' scale(' + scale + ')';
	                } else {
	                    transform += ' translate(' + shiftX + ' ' + shiftY + ') scale(' + scale + ') translate(-' + shiftX + ' -' + shiftY + ')';
	                }
	            }

	            // hcrop
	            if (params.hcrop) {
	                transform += ' translate(' + (-xmin) + ' 0)';

	                svgElem.attr('width').value = realWidth;
	            }

	            // vcenter
	            if (params.vcenter) {
	                transform += ' translate(0 ' + (((svgHeight - realHeight) / 2) - ymin) + ')';
	            }

	            if (transform) {
	                pathElem.addAttr({
	                    name: 'transform',
	                    prefix: '',
	                    local: 'transform',
	                    value: transform
	                });

	                path = applyTransforms(pathElem, pathElem.pathJS, true, params.floatPrecision);

	                // transformed data rounding
	                path.forEach(function(pathItem) {
	                    if (pathItem.data) {
	                        pathItem.data = pathItem.data.map(function(num) {
	                            return +num.toFixed(params.floatPrecision);
	                        });
	                    }
	                });

	                // save new
	                js2path(pathElem, path, params);
	            }

	        }

	    });

	    return data;

	};


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	module.exports = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	}
	/*</replacement>*/


	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var Readable = __webpack_require__(294);
	var Writable = __webpack_require__(296);

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(23);
	var stripBom = __webpack_require__(78);

	function streamFile(file, cb) {
	  file.contents = fs.createReadStream(file.path)
	    .pipe(stripBom.stream());

	  cb(null, file);
	}

	module.exports = streamFile;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(42).require('fs', ['stream'])


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(3).Stream;

	module.exports = function(o) {
	  return !!o && o instanceof Stream;
	};

/***/ },
/* 124 */
/***/ function(module, exports) {

	module.exports = extend

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function extend() {
	    var target = {}

	    for (var i = 0; i < arguments.length; i++) {
	        var source = arguments[i]

	        for (var key in source) {
	            if (hasOwnProperty.call(source, key)) {
	                target[key] = source[key]
	            }
	        }
	    }

	    return target
	}


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module) {'use strict';

	function assembleStyles () {
		var styles = {
			modifiers: {
				reset: [0, 0],
				bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
				dim: [2, 22],
				italic: [3, 23],
				underline: [4, 24],
				inverse: [7, 27],
				hidden: [8, 28],
				strikethrough: [9, 29]
			},
			colors: {
				black: [30, 39],
				red: [31, 39],
				green: [32, 39],
				yellow: [33, 39],
				blue: [34, 39],
				magenta: [35, 39],
				cyan: [36, 39],
				white: [37, 39],
				gray: [90, 39]
			},
			bgColors: {
				bgBlack: [40, 49],
				bgRed: [41, 49],
				bgGreen: [42, 49],
				bgYellow: [43, 49],
				bgBlue: [44, 49],
				bgMagenta: [45, 49],
				bgCyan: [46, 49],
				bgWhite: [47, 49]
			}
		};

		// fix humans
		styles.colors.grey = styles.colors.gray;

		Object.keys(styles).forEach(function (groupName) {
			var group = styles[groupName];

			Object.keys(group).forEach(function (styleName) {
				var style = group[styleName];

				styles[styleName] = group[styleName] = {
					open: '\u001b[' + style[0] + 'm',
					close: '\u001b[' + style[1] + 'm'
				};
			});

			Object.defineProperty(styles, groupName, {
				value: group,
				enumerable: false
			});
		});

		return styles;
	}

	Object.defineProperty(module, 'exports', {
		enumerable: true,
		get: assembleStyles
	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module)))

/***/ },
/* 126 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function (arr) {
		var rest = [].concat.apply([], [].slice.call(arguments, 1));
		return arr.filter(function (el) {
			return rest.indexOf(el) === -1;
		});
	};


/***/ },
/* 127 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {'use strict';

	// there's 3 implementations written in increasing order of efficiency

	// 1 - no Set type is defined
	function uniqNoSet(arr) {
		var ret = [];

		for (var i = 0; i < arr.length; i++) {
			if (ret.indexOf(arr[i]) === -1) {
				ret.push(arr[i]);
			}
		}

		return ret;
	}

	// 2 - a simple Set type is defined
	function uniqSet(arr) {
		var seen = new Set();
		return arr.filter(function (el) {
			if (!seen.has(el)) {
				seen.add(el);
				return true;
			}

			return false;
		});
	}

	// 3 - a standard Set type is defined and it has a forEach method
	function uniqSetWithForEach(arr) {
		var ret = [];

		(new Set(arr)).forEach(function (el) {
			ret.push(el);
		});

		return ret;
	}

	// V8 currently has a broken implementation
	// https://github.com/joyent/node/issues/8449
	function doesForEachActuallyWork() {
		var ret = false;

		(new Set([true])).forEach(function (el) {
			ret = el;
		});

		return ret === true;
	}

	if ('Set' in global) {
		if (typeof Set.prototype.forEach === 'function' && doesForEachActuallyWork()) {
			module.exports = uniqSetWithForEach;
		} else {
			module.exports = uniqSet;
		}
	} else {
		module.exports = uniqNoSet;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname, process) {'use strict';

	exports.__esModule = true;
	exports['default'] = configureGenerator;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var _fs2 = _interopRequireDefault(_fs);

	var _helpersGetSvgsInDir = __webpack_require__(130);

	var _helpersGetSvgsInDir2 = _interopRequireDefault(_helpersGetSvgsInDir);

	var _helpersMinifySvg = __webpack_require__(131);

	var _helpersMinifySvg2 = _interopRequireDefault(_helpersMinifySvg);

	var _nunjucks = __webpack_require__(267);

	var _nunjucks2 = _interopRequireDefault(_nunjucks);

	var _path = __webpack_require__(6);

	var _path2 = _interopRequireDefault(_path);

	var _helpersCleanup = __webpack_require__(129);

	_nunjucks2['default'].configure({ autoescape: false });

	var defaultComment = 'Generated by gulp svg-icon - do not modify manually';
	var defaultComponentName = 'Icon';

	function configureGenerator(config) {
	  return function () {
	    var componentName = config.componentName || defaultComponentName;
	    var defaultTemplate = config.native ? _path2['default'].join(__dirname, '..', 'template', 'icon_native.nunjucks') : _path2['default'].join(__dirname, '..', 'template', 'icon.nunjucks');
	    var template = config.template || defaultTemplate;
	    var templateFile = _path2['default'].isAbsolute(template) ? template : _path2['default'].join(process.cwd(), template);
	    var templateContent = _fs2['default'].readFileSync(templateFile).toString();

	    var svgDir = _path2['default'].isAbsolute(config.svgDir) ? config.svgDir : _path2['default'].join(process.cwd(), config.svgDir);

	    console.log('Looking for SVGs in:', svgDir); // eslint-disable-line no-console

	    console.log('Using ' + componentName + ' template from:', templateFile); // eslint-disable-line no-console

	    var svgs = _helpersGetSvgsInDir2['default'](svgDir);

	    var iconDestination = config.destination || _path2['default'].join(process.cwd(), 'Icon.react.js');

	    var comment = config.comment || defaultComment;
	    var reactPureRender = config.reactPureRender;
	    var cleanupHelper = config.native ? _helpersCleanup.cleanupNativeSvg : _helpersCleanup.cleanupSvg;

	    var svgPromises = svgs.map(function (file) {
	      return _helpersMinifySvg2['default'](file, _fs2['default'].readFileSync(file).toString());
	    });
	    Promise.all(svgPromises).then(function (results) {
	      var icons = results.map(function (result) {
	        return {
	          name: _helpersCleanup.cleanupName(result.name),
	          svg: cleanupHelper(result.svg.data, config.keepFillColor)
	        };
	      }).sort(function (a, b) {
	        return a.name.localeCompare(b.name);
	      });

	      _fs2['default'].writeFileSync(iconDestination, _nunjucks2['default'].renderString(templateContent, {
	        icons: icons,
	        comment: comment,
	        reactPureRender: reactPureRender,
	        radium: config.radium,
	        useColorProp: !config.keepFillColor,
	        componentName: componentName
	      }));

	      console.log('Generated ' + componentName + ' component to:', iconDestination); // eslint-disable-line no-console
	      console.log(icons.map(function (icon) {
	        return '<' + componentName + ' kind="' + icon.name + '" />';
	      }).join('\n')); // eslint-disable-line no-console
	    })['catch'](function (error) {
	      return console.error(error);
	    }); // eslint-disable-line no-console
	  };
	}

	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, "/", __webpack_require__(1)))

/***/ },
/* 129 */
/***/ function(module, exports) {

	'use strict';

	exports.__esModule = true;
	exports.cleanupName = cleanupName;
	exports.cleanupSvg = cleanupSvg;
	exports.cleanupNativeSvg = cleanupNativeSvg;
	function _camelCase(string) {
	  return string.replace(/^.|-./g, function (letter, index) {
	    return index === 0 ? letter.toLowerCase() : letter.substr(1).toUpperCase();
	  }).replace('class', 'className');
	}

	function _basicCleanup(svg) {
	  return svg.replace(/width="\S+"/, '').replace(/height="\S+"/, '').replace(/xmlns="(\S*)"/, '').replace(/data-name="(.*?)"/, '').replace(/([\w-]+)="/g, function (match) {
	    return _camelCase(match);
	  }).replace(/\s{2,}/g, ' ');
	}

	function cleanupName(name) {
	  return name.replace(/u[A-Z0-9]{4}-/, '');
	}

	function cleanupSvg(svg, keepFillColor) {
	  var cleanedSvg = _basicCleanup(svg).replace(/viewBox/, 'height={height || size} width={width || size} onClick={onClick} style={style} className={className} viewBox');

	  return keepFillColor ? cleanedSvg : cleanedSvg.replace(/fill="#?\w+"/g, '').replace(/viewBox/, 'fill={color} viewBox').replace(/\s{2,}/g, ' ').replace(/ \>/g, '>');
	}

	function cleanupNativeSvg(svg, keepFillColor) {
	  var cleanedSvg = _basicCleanup(svg).replace(/viewBox/, 'height={height || size} width={width || size} style={style} viewBox').replace(/\<[a-z]|\<\/[a-z]/g, function (match) {
	    return match.toUpperCase();
	  });

	  return keepFillColor ? cleanedSvg : cleanedSvg.replace(/fill="#?\w+"/g, '').replace(/\<Path/g, '<Path fill={color}').replace(/\s{2,}/g, ' ').replace(/ \>/g, '>');
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = getSvgsInDir;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

	var _fs2 = _interopRequireDefault(_fs);

	var _path = __webpack_require__(6);

	var _path2 = _interopRequireDefault(_path);

	function getSvgsInDir(dir) {
	  if (!_fs2['default'].existsSync(dir)) {
	    return null;
	  }

	  return [].concat.apply([], _fs2['default'].readdirSync(dir).map(function (file) {
	    var absolutePath = _path2['default'].join(dir, file);

	    if (_fs2['default'].lstatSync(absolutePath).isDirectory()) {
	      return getSvgsInDir(dir, file);
	    }

	    if (!absolutePath.match(/\.svg$/)) {
	      return null;
	    }

	    return absolutePath;
	  })).filter(function (filePath) {
	    return filePath !== null;
	  });
	}

	module.exports = exports['default'];

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;
	exports['default'] = minifySvg;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _path = __webpack_require__(6);

	var _path2 = _interopRequireDefault(_path);

	var _bluebird = __webpack_require__(136);

	var _bluebird2 = _interopRequireDefault(_bluebird);

	var _svgo = __webpack_require__(132);

	var _svgo2 = _interopRequireDefault(_svgo);

	function minifySvg(file, content) {
	  return new _bluebird2['default'](function (resolve) {
	    return _svgo2['default'].optimize(content, function (result) {
	      return resolve({
	        name: _path2['default'].basename(file, '.svg'),
	        svg: result
	      });
	    });
	  });
	}

	module.exports = exports['default'];

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	exports.__esModule = true;

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

	var _svgo = __webpack_require__(288);

	var _svgo2 = _interopRequireDefault(_svgo);

	var svgo = new _svgo2['default']({
	  plugins: ['removeDoctype', 'removeXMLProcInst', 'removeComments', 'removeMetadata', 'removeEditorsNSData', 'cleanupAttrs', 'convertStyleToAttrs', 'cleanupIDs', 'removeRasterImages', 'removeUselessDefs', 'cleanupNumericValues', 'cleanupListOfValues', 'convertColors', 'removeUnknownsAndDefaults', 'removeNonInheritableGroupAttrs', 'removeUselessStrokeAndFill', 'removeViewBox', 'cleanupEnableBackground', 'removeHiddenElems', 'removeEmptyText', 'convertShapeToPath', 'moveElemsAttrsToGroup', 'moveGroupAttrsToElems', 'collapseGroups', 'convertPathData', 'convertTransform', 'removeEmptyAttrs', 'removeEmptyContainers', 'mergePaths', 'removeUnusedNS', 'transformsWithOnePath', 'sortAttrs', 'removeTitle', 'removeDesc', 'removeDimensions', 'addClassesToSVGElement', 'removeStyleElement']
	});

	exports['default'] = svgo;
	module.exports = exports['default'];

/***/ },
/* 133 */
/***/ function(module, exports) {

	module.exports = balanced;
	function balanced(a, b, str) {
	  if (a instanceof RegExp) a = maybeMatch(a, str);
	  if (b instanceof RegExp) b = maybeMatch(b, str);

	  var r = range(a, b, str);

	  return r && {
	    start: r[0],
	    end: r[1],
	    pre: str.slice(0, r[0]),
	    body: str.slice(r[0] + a.length, r[1]),
	    post: str.slice(r[1] + b.length)
	  };
	}

	function maybeMatch(reg, str) {
	  var m = str.match(reg);
	  return m ? m[0] : null;
	}

	balanced.range = range;
	function range(a, b, str) {
	  var begs, beg, left, right, result;
	  var ai = str.indexOf(a);
	  var bi = str.indexOf(b, ai + 1);
	  var i = ai;

	  if (ai >= 0 && bi > 0) {
	    begs = [];
	    left = str.length;

	    while (i >= 0 && !result) {
	      if (i == ai) {
	        begs.push(i);
	        ai = str.indexOf(a, i + 1);
	      } else if (begs.length == 1) {
	        result = [ begs.pop(), bi ];
	      } else {
	        beg = begs.pop();
	        if (beg < left) {
	          left = beg;
	          right = bi;
	        }

	        bi = str.indexOf(b, i + 1);
	      }

	      i = ai < bi && ai >= 0 ? ai : bi;
	    }

	    if (begs.length) {
	      result = [ left, right ];
	    }
	  }

	  return result;
	}


/***/ },
/* 134 */
/***/ function(module, exports) {

	'use strict'

	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray

	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
	  lookup[i] = code[i]
	  revLookup[code.charCodeAt(i)] = i
	}

	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63

	function placeHoldersCount (b64) {
	  var len = b64.length
	  if (len % 4 > 0) {
	    throw new Error('Invalid string. Length must be a multiple of 4')
	  }

	  // the number of equal signs (place holders)
	  // if there are two placeholders, than the two characters before it
	  // represent one byte
	  // if there is only one, then the three characters before it represent 2 bytes
	  // this is just a cheap hack to not do indexOf twice
	  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
	}

	function byteLength (b64) {
	  // base64 is 4/3 + up to two characters of the original data
	  return b64.length * 3 / 4 - placeHoldersCount(b64)
	}

	function toByteArray (b64) {
	  var i, j, l, tmp, placeHolders, arr
	  var len = b64.length
	  placeHolders = placeHoldersCount(b64)

	  arr = new Arr(len * 3 / 4 - placeHolders)

	  // if there are placeholders, only get up to the last complete 4 chars
	  l = placeHolders > 0 ? len - 4 : len

	  var L = 0

	  for (i = 0, j = 0; i < l; i += 4, j += 3) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
	    arr[L++] = (tmp >> 16) & 0xFF
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  if (placeHolders === 2) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
	    arr[L++] = tmp & 0xFF
	  } else if (placeHolders === 1) {
	    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
	    arr[L++] = (tmp >> 8) & 0xFF
	    arr[L++] = tmp & 0xFF
	  }

	  return arr
	}

	function tripletToBase64 (num) {
	  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
	}

	function encodeChunk (uint8, start, end) {
	  var tmp
	  var output = []
	  for (var i = start; i < end; i += 3) {
	    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
	    output.push(tripletToBase64(tmp))
	  }
	  return output.join('')
	}

	function fromByteArray (uint8) {
	  var tmp
	  var len = uint8.length
	  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
	  var output = ''
	  var parts = []
	  var maxChunkLength = 16383 // must be multiple of 3

	  // go through the array every three bytes, we'll deal with trailing stuff later
	  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
	    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
	  }

	  // pad the end with zeros, but make sure to not forget the extra bytes
	  if (extraBytes === 1) {
	    tmp = uint8[len - 1]
	    output += lookup[tmp >> 2]
	    output += lookup[(tmp << 4) & 0x3F]
	    output += '=='
	  } else if (extraBytes === 2) {
	    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
	    output += lookup[tmp >> 10]
	    output += lookup[(tmp >> 4) & 0x3F]
	    output += lookup[(tmp << 2) & 0x3F]
	    output += '='
	  }

	  parts.push(output)

	  return parts.join('')
	}


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var BEEP_DELAY = 500;

	function beep() {
		process.stdout.write('\u0007');
	}

	function melodicalBeep(val, cb) {
		if (val.length === 0) {
			cb();
			return;
		}

		setTimeout(function () {
			if (val.shift() === '*') {
				beep();
			}

			melodicalBeep(val, cb);
		}, BEEP_DELAY);
	}

	module.exports = function (val, cb) {
		if (!process.stdout.isTTY ||
			process.argv.indexOf('--no-beep') !== -1 ||
			process.argv.indexOf('--beep=false') !== -1) {
			return;
		}

		cb = cb || function () {};

		if (val === parseInt(val)) {
			if (val < 0) {
				throw new TypeError('Negative numbers are not accepted');
			}

			if (val === 0) {
				cb();
				return;
			}

			for (var i = 0; i < val; i++) {
				setTimeout(function (i) {
					beep();

					if (i === val - 1) {
						cb();
					}
				}, BEEP_DELAY * i, i);
			}
		} else if (!val) {
			beep();
			cb();
		} else if (typeof val === 'string') {
			melodicalBeep(val.split(''), cb);
		} else {
			throw new TypeError('Not an accepted type');
		}
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, global, setImmediate) {/* @preserve
	 * The MIT License (MIT)
	 * 
	 * Copyright (c) 2013-2015 Petka Antonov
	 * 
	 * Permission is hereby granted, free of charge, to any person obtaining a copy
	 * of this software and associated documentation files (the "Software"), to deal
	 * in the Software without restriction, including without limitation the rights
	 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 * copies of the Software, and to permit persons to whom the Software is
	 * furnished to do so, subject to the following conditions:
	 * 
	 * The above copyright notice and this permission notice shall be included in
	 * all copies or substantial portions of the Software.
	 * 
	 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
	 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 * THE SOFTWARE.
	 * 
	 */
	/**
	 * bluebird build version 3.4.7
	 * Features enabled: core, race, call_get, generators, map, nodeify, promisify, props, reduce, settle, some, using, timers, filter, any, each
	*/
	!function(e){if(true)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.Promise=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof _dereq_=="function"&&_dereq_;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof _dereq_=="function"&&_dereq_;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var SomePromiseArray = Promise._SomePromiseArray;
	function any(promises) {
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(1);
	    ret.setUnwrap();
	    ret.init();
	    return promise;
	}

	Promise.any = function (promises) {
	    return any(promises);
	};

	Promise.prototype.any = function () {
	    return any(this);
	};

	};

	},{}],2:[function(_dereq_,module,exports){
	"use strict";
	var firstLineError;
	try {throw new Error(); } catch (e) {firstLineError = e;}
	var schedule = _dereq_("./schedule");
	var Queue = _dereq_("./queue");
	var util = _dereq_("./util");

	function Async() {
	    this._customScheduler = false;
	    this._isTickUsed = false;
	    this._lateQueue = new Queue(16);
	    this._normalQueue = new Queue(16);
	    this._haveDrainedQueues = false;
	    this._trampolineEnabled = true;
	    var self = this;
	    this.drainQueues = function () {
	        self._drainQueues();
	    };
	    this._schedule = schedule;
	}

	Async.prototype.setScheduler = function(fn) {
	    var prev = this._schedule;
	    this._schedule = fn;
	    this._customScheduler = true;
	    return prev;
	};

	Async.prototype.hasCustomScheduler = function() {
	    return this._customScheduler;
	};

	Async.prototype.enableTrampoline = function() {
	    this._trampolineEnabled = true;
	};

	Async.prototype.disableTrampolineIfNecessary = function() {
	    if (util.hasDevTools) {
	        this._trampolineEnabled = false;
	    }
	};

	Async.prototype.haveItemsQueued = function () {
	    return this._isTickUsed || this._haveDrainedQueues;
	};


	Async.prototype.fatalError = function(e, isNode) {
	    if (isNode) {
	        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) +
	            "\n");
	        process.exit(2);
	    } else {
	        this.throwLater(e);
	    }
	};

	Async.prototype.throwLater = function(fn, arg) {
	    if (arguments.length === 1) {
	        arg = fn;
	        fn = function () { throw arg; };
	    }
	    if (typeof setTimeout !== "undefined") {
	        setTimeout(function() {
	            fn(arg);
	        }, 0);
	    } else try {
	        this._schedule(function() {
	            fn(arg);
	        });
	    } catch (e) {
	        throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	};

	function AsyncInvokeLater(fn, receiver, arg) {
	    this._lateQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncInvoke(fn, receiver, arg) {
	    this._normalQueue.push(fn, receiver, arg);
	    this._queueTick();
	}

	function AsyncSettlePromises(promise) {
	    this._normalQueue._pushOne(promise);
	    this._queueTick();
	}

	if (!util.hasDevTools) {
	    Async.prototype.invokeLater = AsyncInvokeLater;
	    Async.prototype.invoke = AsyncInvoke;
	    Async.prototype.settlePromises = AsyncSettlePromises;
	} else {
	    Async.prototype.invokeLater = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvokeLater.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                setTimeout(function() {
	                    fn.call(receiver, arg);
	                }, 100);
	            });
	        }
	    };

	    Async.prototype.invoke = function (fn, receiver, arg) {
	        if (this._trampolineEnabled) {
	            AsyncInvoke.call(this, fn, receiver, arg);
	        } else {
	            this._schedule(function() {
	                fn.call(receiver, arg);
	            });
	        }
	    };

	    Async.prototype.settlePromises = function(promise) {
	        if (this._trampolineEnabled) {
	            AsyncSettlePromises.call(this, promise);
	        } else {
	            this._schedule(function() {
	                promise._settlePromises();
	            });
	        }
	    };
	}

	Async.prototype._drainQueue = function(queue) {
	    while (queue.length() > 0) {
	        var fn = queue.shift();
	        if (typeof fn !== "function") {
	            fn._settlePromises();
	            continue;
	        }
	        var receiver = queue.shift();
	        var arg = queue.shift();
	        fn.call(receiver, arg);
	    }
	};

	Async.prototype._drainQueues = function () {
	    this._drainQueue(this._normalQueue);
	    this._reset();
	    this._haveDrainedQueues = true;
	    this._drainQueue(this._lateQueue);
	};

	Async.prototype._queueTick = function () {
	    if (!this._isTickUsed) {
	        this._isTickUsed = true;
	        this._schedule(this.drainQueues);
	    }
	};

	Async.prototype._reset = function () {
	    this._isTickUsed = false;
	};

	module.exports = Async;
	module.exports.firstLineError = firstLineError;

	},{"./queue":26,"./schedule":29,"./util":36}],3:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise, debug) {
	var calledBind = false;
	var rejectThis = function(_, e) {
	    this._reject(e);
	};

	var targetRejected = function(e, context) {
	    context.promiseRejectionQueued = true;
	    context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
	};

	var bindingResolved = function(thisArg, context) {
	    if (((this._bitField & 50397184) === 0)) {
	        this._resolveCallback(context.target);
	    }
	};

	var bindingRejected = function(e, context) {
	    if (!context.promiseRejectionQueued) this._reject(e);
	};

	Promise.prototype.bind = function (thisArg) {
	    if (!calledBind) {
	        calledBind = true;
	        Promise.prototype._propagateFrom = debug.propagateFromFunction();
	        Promise.prototype._boundValue = debug.boundValueFunction();
	    }
	    var maybePromise = tryConvertToPromise(thisArg);
	    var ret = new Promise(INTERNAL);
	    ret._propagateFrom(this, 1);
	    var target = this._target();
	    ret._setBoundTo(maybePromise);
	    if (maybePromise instanceof Promise) {
	        var context = {
	            promiseRejectionQueued: false,
	            promise: ret,
	            target: target,
	            bindingPromise: maybePromise
	        };
	        target._then(INTERNAL, targetRejected, undefined, ret, context);
	        maybePromise._then(
	            bindingResolved, bindingRejected, undefined, ret, context);
	        ret._setOnCancel(maybePromise);
	    } else {
	        ret._resolveCallback(target);
	    }
	    return ret;
	};

	Promise.prototype._setBoundTo = function (obj) {
	    if (obj !== undefined) {
	        this._bitField = this._bitField | 2097152;
	        this._boundTo = obj;
	    } else {
	        this._bitField = this._bitField & (~2097152);
	    }
	};

	Promise.prototype._isBound = function () {
	    return (this._bitField & 2097152) === 2097152;
	};

	Promise.bind = function (thisArg, value) {
	    return Promise.resolve(value).bind(thisArg);
	};
	};

	},{}],4:[function(_dereq_,module,exports){
	"use strict";
	var old;
	if (typeof Promise !== "undefined") old = Promise;
	function noConflict() {
	    try { if (Promise === bluebird) Promise = old; }
	    catch (e) {}
	    return bluebird;
	}
	var bluebird = _dereq_("./promise")();
	bluebird.noConflict = noConflict;
	module.exports = bluebird;

	},{"./promise":22}],5:[function(_dereq_,module,exports){
	"use strict";
	var cr = Object.create;
	if (cr) {
	    var callerCache = cr(null);
	    var getterCache = cr(null);
	    callerCache[" size"] = getterCache[" size"] = 0;
	}

	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var isIdentifier = util.isIdentifier;

	var getMethodCaller;
	var getGetter;
	if (false) {
	var makeMethodCaller = function (methodName) {
	    return new Function("ensureMethod", "                                    \n\
	        return function(obj) {                                               \n\
	            'use strict'                                                     \n\
	            var len = this.length;                                           \n\
	            ensureMethod(obj, 'methodName');                                 \n\
	            switch(len) {                                                    \n\
	                case 1: return obj.methodName(this[0]);                      \n\
	                case 2: return obj.methodName(this[0], this[1]);             \n\
	                case 3: return obj.methodName(this[0], this[1], this[2]);    \n\
	                case 0: return obj.methodName();                             \n\
	                default:                                                     \n\
	                    return obj.methodName.apply(obj, this);                  \n\
	            }                                                                \n\
	        };                                                                   \n\
	        ".replace(/methodName/g, methodName))(ensureMethod);
	};

	var makeGetter = function (propertyName) {
	    return new Function("obj", "                                             \n\
	        'use strict';                                                        \n\
	        return obj.propertyName;                                             \n\
	        ".replace("propertyName", propertyName));
	};

	var getCompiled = function(name, compiler, cache) {
	    var ret = cache[name];
	    if (typeof ret !== "function") {
	        if (!isIdentifier(name)) {
	            return null;
	        }
	        ret = compiler(name);
	        cache[name] = ret;
	        cache[" size"]++;
	        if (cache[" size"] > 512) {
	            var keys = Object.keys(cache);
	            for (var i = 0; i < 256; ++i) delete cache[keys[i]];
	            cache[" size"] = keys.length - 256;
	        }
	    }
	    return ret;
	};

	getMethodCaller = function(name) {
	    return getCompiled(name, makeMethodCaller, callerCache);
	};

	getGetter = function(name) {
	    return getCompiled(name, makeGetter, getterCache);
	};
	}

	function ensureMethod(obj, methodName) {
	    var fn;
	    if (obj != null) fn = obj[methodName];
	    if (typeof fn !== "function") {
	        var message = "Object " + util.classString(obj) + " has no method '" +
	            util.toString(methodName) + "'";
	        throw new Promise.TypeError(message);
	    }
	    return fn;
	}

	function caller(obj) {
	    var methodName = this.pop();
	    var fn = ensureMethod(obj, methodName);
	    return fn.apply(obj, this);
	}
	Promise.prototype.call = function (methodName) {
	    var args = [].slice.call(arguments, 1);;
	    if (false) {
	        if (canEvaluate) {
	            var maybeCaller = getMethodCaller(methodName);
	            if (maybeCaller !== null) {
	                return this._then(
	                    maybeCaller, undefined, undefined, args, undefined);
	            }
	        }
	    }
	    args.push(methodName);
	    return this._then(caller, undefined, undefined, args, undefined);
	};

	function namedGetter(obj) {
	    return obj[this];
	}
	function indexedGetter(obj) {
	    var index = +this;
	    if (index < 0) index = Math.max(0, index + obj.length);
	    return obj[index];
	}
	Promise.prototype.get = function (propertyName) {
	    var isIndex = (typeof propertyName === "number");
	    var getter;
	    if (!isIndex) {
	        if (canEvaluate) {
	            var maybeGetter = getGetter(propertyName);
	            getter = maybeGetter !== null ? maybeGetter : namedGetter;
	        } else {
	            getter = namedGetter;
	        }
	    } else {
	        getter = indexedGetter;
	    }
	    return this._then(getter, undefined, undefined, propertyName, undefined);
	};
	};

	},{"./util":36}],6:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, PromiseArray, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	Promise.prototype["break"] = Promise.prototype.cancel = function() {
	    if (!debug.cancellation()) return this._warn("cancellation is disabled");

	    var promise = this;
	    var child = promise;
	    while (promise._isCancellable()) {
	        if (!promise._cancelBy(child)) {
	            if (child._isFollowing()) {
	                child._followee().cancel();
	            } else {
	                child._cancelBranched();
	            }
	            break;
	        }

	        var parent = promise._cancellationParent;
	        if (parent == null || !parent._isCancellable()) {
	            if (promise._isFollowing()) {
	                promise._followee().cancel();
	            } else {
	                promise._cancelBranched();
	            }
	            break;
	        } else {
	            if (promise._isFollowing()) promise._followee().cancel();
	            promise._setWillBeCancelled();
	            child = promise;
	            promise = parent;
	        }
	    }
	};

	Promise.prototype._branchHasCancelled = function() {
	    this._branchesRemainingToCancel--;
	};

	Promise.prototype._enoughBranchesHaveCancelled = function() {
	    return this._branchesRemainingToCancel === undefined ||
	           this._branchesRemainingToCancel <= 0;
	};

	Promise.prototype._cancelBy = function(canceller) {
	    if (canceller === this) {
	        this._branchesRemainingToCancel = 0;
	        this._invokeOnCancel();
	        return true;
	    } else {
	        this._branchHasCancelled();
	        if (this._enoughBranchesHaveCancelled()) {
	            this._invokeOnCancel();
	            return true;
	        }
	    }
	    return false;
	};

	Promise.prototype._cancelBranched = function() {
	    if (this._enoughBranchesHaveCancelled()) {
	        this._cancel();
	    }
	};

	Promise.prototype._cancel = function() {
	    if (!this._isCancellable()) return;
	    this._setCancelled();
	    async.invoke(this._cancelPromises, this, undefined);
	};

	Promise.prototype._cancelPromises = function() {
	    if (this._length() > 0) this._settlePromises();
	};

	Promise.prototype._unsetOnCancel = function() {
	    this._onCancelField = undefined;
	};

	Promise.prototype._isCancellable = function() {
	    return this.isPending() && !this._isCancelled();
	};

	Promise.prototype.isCancellable = function() {
	    return this.isPending() && !this.isCancelled();
	};

	Promise.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
	    if (util.isArray(onCancelCallback)) {
	        for (var i = 0; i < onCancelCallback.length; ++i) {
	            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
	        }
	    } else if (onCancelCallback !== undefined) {
	        if (typeof onCancelCallback === "function") {
	            if (!internalOnly) {
	                var e = tryCatch(onCancelCallback).call(this._boundValue());
	                if (e === errorObj) {
	                    this._attachExtraTrace(e.e);
	                    async.throwLater(e.e);
	                }
	            }
	        } else {
	            onCancelCallback._resultCancelled(this);
	        }
	    }
	};

	Promise.prototype._invokeOnCancel = function() {
	    var onCancelCallback = this._onCancel();
	    this._unsetOnCancel();
	    async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
	};

	Promise.prototype._invokeInternalOnCancel = function() {
	    if (this._isCancellable()) {
	        this._doInvokeOnCancel(this._onCancel(), true);
	        this._unsetOnCancel();
	    }
	};

	Promise.prototype._resultCancelled = function() {
	    this.cancel();
	};

	};

	},{"./util":36}],7:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(NEXT_FILTER) {
	var util = _dereq_("./util");
	var getKeys = _dereq_("./es5").keys;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function catchFilter(instances, cb, promise) {
	    return function(e) {
	        var boundTo = promise._boundValue();
	        predicateLoop: for (var i = 0; i < instances.length; ++i) {
	            var item = instances[i];

	            if (item === Error ||
	                (item != null && item.prototype instanceof Error)) {
	                if (e instanceof item) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (typeof item === "function") {
	                var matchesPredicate = tryCatch(item).call(boundTo, e);
	                if (matchesPredicate === errorObj) {
	                    return matchesPredicate;
	                } else if (matchesPredicate) {
	                    return tryCatch(cb).call(boundTo, e);
	                }
	            } else if (util.isObject(e)) {
	                var keys = getKeys(item);
	                for (var j = 0; j < keys.length; ++j) {
	                    var key = keys[j];
	                    if (item[key] != e[key]) {
	                        continue predicateLoop;
	                    }
	                }
	                return tryCatch(cb).call(boundTo, e);
	            }
	        }
	        return NEXT_FILTER;
	    };
	}

	return catchFilter;
	};

	},{"./es5":13,"./util":36}],8:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var longStackTraces = false;
	var contextStack = [];

	Promise.prototype._promiseCreated = function() {};
	Promise.prototype._pushContext = function() {};
	Promise.prototype._popContext = function() {return null;};
	Promise._peekContext = Promise.prototype._peekContext = function() {};

	function Context() {
	    this._trace = new Context.CapturedTrace(peekContext());
	}
	Context.prototype._pushContext = function () {
	    if (this._trace !== undefined) {
	        this._trace._promiseCreated = null;
	        contextStack.push(this._trace);
	    }
	};

	Context.prototype._popContext = function () {
	    if (this._trace !== undefined) {
	        var trace = contextStack.pop();
	        var ret = trace._promiseCreated;
	        trace._promiseCreated = null;
	        return ret;
	    }
	    return null;
	};

	function createContext() {
	    if (longStackTraces) return new Context();
	}

	function peekContext() {
	    var lastIndex = contextStack.length - 1;
	    if (lastIndex >= 0) {
	        return contextStack[lastIndex];
	    }
	    return undefined;
	}
	Context.CapturedTrace = null;
	Context.create = createContext;
	Context.deactivateLongStackTraces = function() {};
	Context.activateLongStackTraces = function() {
	    var Promise_pushContext = Promise.prototype._pushContext;
	    var Promise_popContext = Promise.prototype._popContext;
	    var Promise_PeekContext = Promise._peekContext;
	    var Promise_peekContext = Promise.prototype._peekContext;
	    var Promise_promiseCreated = Promise.prototype._promiseCreated;
	    Context.deactivateLongStackTraces = function() {
	        Promise.prototype._pushContext = Promise_pushContext;
	        Promise.prototype._popContext = Promise_popContext;
	        Promise._peekContext = Promise_PeekContext;
	        Promise.prototype._peekContext = Promise_peekContext;
	        Promise.prototype._promiseCreated = Promise_promiseCreated;
	        longStackTraces = false;
	    };
	    longStackTraces = true;
	    Promise.prototype._pushContext = Context.prototype._pushContext;
	    Promise.prototype._popContext = Context.prototype._popContext;
	    Promise._peekContext = Promise.prototype._peekContext = peekContext;
	    Promise.prototype._promiseCreated = function() {
	        var ctx = this._peekContext();
	        if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
	    };
	};
	return Context;
	};

	},{}],9:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, Context) {
	var getDomain = Promise._getDomain;
	var async = Promise._async;
	var Warning = _dereq_("./errors").Warning;
	var util = _dereq_("./util");
	var canAttachTrace = util.canAttachTrace;
	var unhandledRejectionHandled;
	var possiblyUnhandledRejection;
	var bluebirdFramePattern =
	    /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
	var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
	var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
	var stackFramePattern = null;
	var formatStack = null;
	var indentStackFrames = false;
	var printWarning;
	var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 &&
	                        (true ||
	                         util.env("BLUEBIRD_DEBUG") ||
	                         util.env("NODE_ENV") === "development"));

	var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 &&
	    (debugging || util.env("BLUEBIRD_WARNINGS")));

	var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 &&
	    (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));

	var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 &&
	    (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));

	Promise.prototype.suppressUnhandledRejections = function() {
	    var target = this._target();
	    target._bitField = ((target._bitField & (~1048576)) |
	                      524288);
	};

	Promise.prototype._ensurePossibleRejectionHandled = function () {
	    if ((this._bitField & 524288) !== 0) return;
	    this._setRejectionIsUnhandled();
	    async.invokeLater(this._notifyUnhandledRejection, this, undefined);
	};

	Promise.prototype._notifyUnhandledRejectionIsHandled = function () {
	    fireRejectionEvent("rejectionHandled",
	                                  unhandledRejectionHandled, undefined, this);
	};

	Promise.prototype._setReturnedNonUndefined = function() {
	    this._bitField = this._bitField | 268435456;
	};

	Promise.prototype._returnedNonUndefined = function() {
	    return (this._bitField & 268435456) !== 0;
	};

	Promise.prototype._notifyUnhandledRejection = function () {
	    if (this._isRejectionUnhandled()) {
	        var reason = this._settledValue();
	        this._setUnhandledRejectionIsNotified();
	        fireRejectionEvent("unhandledRejection",
	                                      possiblyUnhandledRejection, reason, this);
	    }
	};

	Promise.prototype._setUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField | 262144;
	};

	Promise.prototype._unsetUnhandledRejectionIsNotified = function () {
	    this._bitField = this._bitField & (~262144);
	};

	Promise.prototype._isUnhandledRejectionNotified = function () {
	    return (this._bitField & 262144) > 0;
	};

	Promise.prototype._setRejectionIsUnhandled = function () {
	    this._bitField = this._bitField | 1048576;
	};

	Promise.prototype._unsetRejectionIsUnhandled = function () {
	    this._bitField = this._bitField & (~1048576);
	    if (this._isUnhandledRejectionNotified()) {
	        this._unsetUnhandledRejectionIsNotified();
	        this._notifyUnhandledRejectionIsHandled();
	    }
	};

	Promise.prototype._isRejectionUnhandled = function () {
	    return (this._bitField & 1048576) > 0;
	};

	Promise.prototype._warn = function(message, shouldUseOwnTrace, promise) {
	    return warn(message, shouldUseOwnTrace, promise || this);
	};

	Promise.onPossiblyUnhandledRejection = function (fn) {
	    var domain = getDomain();
	    possiblyUnhandledRejection =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	Promise.onUnhandledRejectionHandled = function (fn) {
	    var domain = getDomain();
	    unhandledRejectionHandled =
	        typeof fn === "function" ? (domain === null ?
	                                            fn : util.domainBind(domain, fn))
	                                 : undefined;
	};

	var disableLongStackTraces = function() {};
	Promise.longStackTraces = function () {
	    if (async.haveItemsQueued() && !config.longStackTraces) {
	        throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    if (!config.longStackTraces && longStackTracesIsSupported()) {
	        var Promise_captureStackTrace = Promise.prototype._captureStackTrace;
	        var Promise_attachExtraTrace = Promise.prototype._attachExtraTrace;
	        config.longStackTraces = true;
	        disableLongStackTraces = function() {
	            if (async.haveItemsQueued() && !config.longStackTraces) {
	                throw new Error("cannot enable long stack traces after promises have been created\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	            }
	            Promise.prototype._captureStackTrace = Promise_captureStackTrace;
	            Promise.prototype._attachExtraTrace = Promise_attachExtraTrace;
	            Context.deactivateLongStackTraces();
	            async.enableTrampoline();
	            config.longStackTraces = false;
	        };
	        Promise.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
	        Promise.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
	        Context.activateLongStackTraces();
	        async.disableTrampolineIfNecessary();
	    }
	};

	Promise.hasLongStackTraces = function () {
	    return config.longStackTraces && longStackTracesIsSupported();
	};

	var fireDomEvent = (function() {
	    try {
	        if (typeof CustomEvent === "function") {
	            var event = new CustomEvent("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new CustomEvent(name.toLowerCase(), {
	                    detail: event,
	                    cancelable: true
	                });
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else if (typeof Event === "function") {
	            var event = new Event("CustomEvent");
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = new Event(name.toLowerCase(), {
	                    cancelable: true
	                });
	                domEvent.detail = event;
	                return !util.global.dispatchEvent(domEvent);
	            };
	        } else {
	            var event = document.createEvent("CustomEvent");
	            event.initCustomEvent("testingtheevent", false, true, {});
	            util.global.dispatchEvent(event);
	            return function(name, event) {
	                var domEvent = document.createEvent("CustomEvent");
	                domEvent.initCustomEvent(name.toLowerCase(), false, true,
	                    event);
	                return !util.global.dispatchEvent(domEvent);
	            };
	        }
	    } catch (e) {}
	    return function() {
	        return false;
	    };
	})();

	var fireGlobalEvent = (function() {
	    if (util.isNode) {
	        return function() {
	            return process.emit.apply(process, arguments);
	        };
	    } else {
	        if (!util.global) {
	            return function() {
	                return false;
	            };
	        }
	        return function(name) {
	            var methodName = "on" + name.toLowerCase();
	            var method = util.global[methodName];
	            if (!method) return false;
	            method.apply(util.global, [].slice.call(arguments, 1));
	            return true;
	        };
	    }
	})();

	function generatePromiseLifecycleEventObject(name, promise) {
	    return {promise: promise};
	}

	var eventToObjectGenerator = {
	    promiseCreated: generatePromiseLifecycleEventObject,
	    promiseFulfilled: generatePromiseLifecycleEventObject,
	    promiseRejected: generatePromiseLifecycleEventObject,
	    promiseResolved: generatePromiseLifecycleEventObject,
	    promiseCancelled: generatePromiseLifecycleEventObject,
	    promiseChained: function(name, promise, child) {
	        return {promise: promise, child: child};
	    },
	    warning: function(name, warning) {
	        return {warning: warning};
	    },
	    unhandledRejection: function (name, reason, promise) {
	        return {reason: reason, promise: promise};
	    },
	    rejectionHandled: generatePromiseLifecycleEventObject
	};

	var activeFireEvent = function (name) {
	    var globalEventFired = false;
	    try {
	        globalEventFired = fireGlobalEvent.apply(null, arguments);
	    } catch (e) {
	        async.throwLater(e);
	        globalEventFired = true;
	    }

	    var domEventFired = false;
	    try {
	        domEventFired = fireDomEvent(name,
	                    eventToObjectGenerator[name].apply(null, arguments));
	    } catch (e) {
	        async.throwLater(e);
	        domEventFired = true;
	    }

	    return domEventFired || globalEventFired;
	};

	Promise.config = function(opts) {
	    opts = Object(opts);
	    if ("longStackTraces" in opts) {
	        if (opts.longStackTraces) {
	            Promise.longStackTraces();
	        } else if (!opts.longStackTraces && Promise.hasLongStackTraces()) {
	            disableLongStackTraces();
	        }
	    }
	    if ("warnings" in opts) {
	        var warningsOption = opts.warnings;
	        config.warnings = !!warningsOption;
	        wForgottenReturn = config.warnings;

	        if (util.isObject(warningsOption)) {
	            if ("wForgottenReturn" in warningsOption) {
	                wForgottenReturn = !!warningsOption.wForgottenReturn;
	            }
	        }
	    }
	    if ("cancellation" in opts && opts.cancellation && !config.cancellation) {
	        if (async.haveItemsQueued()) {
	            throw new Error(
	                "cannot enable cancellation after promises are in use");
	        }
	        Promise.prototype._clearCancellationData =
	            cancellationClearCancellationData;
	        Promise.prototype._propagateFrom = cancellationPropagateFrom;
	        Promise.prototype._onCancel = cancellationOnCancel;
	        Promise.prototype._setOnCancel = cancellationSetOnCancel;
	        Promise.prototype._attachCancellationCallback =
	            cancellationAttachCancellationCallback;
	        Promise.prototype._execute = cancellationExecute;
	        propagateFromFunction = cancellationPropagateFrom;
	        config.cancellation = true;
	    }
	    if ("monitoring" in opts) {
	        if (opts.monitoring && !config.monitoring) {
	            config.monitoring = true;
	            Promise.prototype._fireEvent = activeFireEvent;
	        } else if (!opts.monitoring && config.monitoring) {
	            config.monitoring = false;
	            Promise.prototype._fireEvent = defaultFireEvent;
	        }
	    }
	    return Promise;
	};

	function defaultFireEvent() { return false; }

	Promise.prototype._fireEvent = defaultFireEvent;
	Promise.prototype._execute = function(executor, resolve, reject) {
	    try {
	        executor(resolve, reject);
	    } catch (e) {
	        return e;
	    }
	};
	Promise.prototype._onCancel = function () {};
	Promise.prototype._setOnCancel = function (handler) { ; };
	Promise.prototype._attachCancellationCallback = function(onCancel) {
	    ;
	};
	Promise.prototype._captureStackTrace = function () {};
	Promise.prototype._attachExtraTrace = function () {};
	Promise.prototype._clearCancellationData = function() {};
	Promise.prototype._propagateFrom = function (parent, flags) {
	    ;
	    ;
	};

	function cancellationExecute(executor, resolve, reject) {
	    var promise = this;
	    try {
	        executor(resolve, reject, function(onCancel) {
	            if (typeof onCancel !== "function") {
	                throw new TypeError("onCancel must be a function, got: " +
	                                    util.toString(onCancel));
	            }
	            promise._attachCancellationCallback(onCancel);
	        });
	    } catch (e) {
	        return e;
	    }
	}

	function cancellationAttachCancellationCallback(onCancel) {
	    if (!this._isCancellable()) return this;

	    var previousOnCancel = this._onCancel();
	    if (previousOnCancel !== undefined) {
	        if (util.isArray(previousOnCancel)) {
	            previousOnCancel.push(onCancel);
	        } else {
	            this._setOnCancel([previousOnCancel, onCancel]);
	        }
	    } else {
	        this._setOnCancel(onCancel);
	    }
	}

	function cancellationOnCancel() {
	    return this._onCancelField;
	}

	function cancellationSetOnCancel(onCancel) {
	    this._onCancelField = onCancel;
	}

	function cancellationClearCancellationData() {
	    this._cancellationParent = undefined;
	    this._onCancelField = undefined;
	}

	function cancellationPropagateFrom(parent, flags) {
	    if ((flags & 1) !== 0) {
	        this._cancellationParent = parent;
	        var branchesRemainingToCancel = parent._branchesRemainingToCancel;
	        if (branchesRemainingToCancel === undefined) {
	            branchesRemainingToCancel = 0;
	        }
	        parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
	    }
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}

	function bindingPropagateFrom(parent, flags) {
	    if ((flags & 2) !== 0 && parent._isBound()) {
	        this._setBoundTo(parent._boundTo);
	    }
	}
	var propagateFromFunction = bindingPropagateFrom;

	function boundValueFunction() {
	    var ret = this._boundTo;
	    if (ret !== undefined) {
	        if (ret instanceof Promise) {
	            if (ret.isFulfilled()) {
	                return ret.value();
	            } else {
	                return undefined;
	            }
	        }
	    }
	    return ret;
	}

	function longStackTracesCaptureStackTrace() {
	    this._trace = new CapturedTrace(this._peekContext());
	}

	function longStackTracesAttachExtraTrace(error, ignoreSelf) {
	    if (canAttachTrace(error)) {
	        var trace = this._trace;
	        if (trace !== undefined) {
	            if (ignoreSelf) trace = trace._parent;
	        }
	        if (trace !== undefined) {
	            trace.attachExtraTrace(error);
	        } else if (!error.__stackCleaned__) {
	            var parsed = parseStackAndMessage(error);
	            util.notEnumerableProp(error, "stack",
	                parsed.message + "\n" + parsed.stack.join("\n"));
	            util.notEnumerableProp(error, "__stackCleaned__", true);
	        }
	    }
	}

	function checkForgottenReturns(returnValue, promiseCreated, name, promise,
	                               parent) {
	    if (returnValue === undefined && promiseCreated !== null &&
	        wForgottenReturn) {
	        if (parent !== undefined && parent._returnedNonUndefined()) return;
	        if ((promise._bitField & 65535) === 0) return;

	        if (name) name = name + " ";
	        var handlerLine = "";
	        var creatorLine = "";
	        if (promiseCreated._trace) {
	            var traceLines = promiseCreated._trace.stack.split("\n");
	            var stack = cleanStack(traceLines);
	            for (var i = stack.length - 1; i >= 0; --i) {
	                var line = stack[i];
	                if (!nodeFramePattern.test(line)) {
	                    var lineMatches = line.match(parseLinePattern);
	                    if (lineMatches) {
	                        handlerLine  = "at " + lineMatches[1] +
	                            ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
	                    }
	                    break;
	                }
	            }

	            if (stack.length > 0) {
	                var firstUserLine = stack[0];
	                for (var i = 0; i < traceLines.length; ++i) {

	                    if (traceLines[i] === firstUserLine) {
	                        if (i > 0) {
	                            creatorLine = "\n" + traceLines[i - 1];
	                        }
	                        break;
	                    }
	                }

	            }
	        }
	        var msg = "a promise was created in a " + name +
	            "handler " + handlerLine + "but was not returned from it, " +
	            "see http://goo.gl/rRqMUw" +
	            creatorLine;
	        promise._warn(msg, true, promiseCreated);
	    }
	}

	function deprecated(name, replacement) {
	    var message = name +
	        " is deprecated and will be removed in a future version.";
	    if (replacement) message += " Use " + replacement + " instead.";
	    return warn(message);
	}

	function warn(message, shouldUseOwnTrace, promise) {
	    if (!config.warnings) return;
	    var warning = new Warning(message);
	    var ctx;
	    if (shouldUseOwnTrace) {
	        promise._attachExtraTrace(warning);
	    } else if (config.longStackTraces && (ctx = Promise._peekContext())) {
	        ctx.attachExtraTrace(warning);
	    } else {
	        var parsed = parseStackAndMessage(warning);
	        warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
	    }

	    if (!activeFireEvent("warning", warning)) {
	        formatAndLogError(warning, "", true);
	    }
	}

	function reconstructStack(message, stacks) {
	    for (var i = 0; i < stacks.length - 1; ++i) {
	        stacks[i].push("From previous event:");
	        stacks[i] = stacks[i].join("\n");
	    }
	    if (i < stacks.length) {
	        stacks[i] = stacks[i].join("\n");
	    }
	    return message + "\n" + stacks.join("\n");
	}

	function removeDuplicateOrEmptyJumps(stacks) {
	    for (var i = 0; i < stacks.length; ++i) {
	        if (stacks[i].length === 0 ||
	            ((i + 1 < stacks.length) && stacks[i][0] === stacks[i+1][0])) {
	            stacks.splice(i, 1);
	            i--;
	        }
	    }
	}

	function removeCommonRoots(stacks) {
	    var current = stacks[0];
	    for (var i = 1; i < stacks.length; ++i) {
	        var prev = stacks[i];
	        var currentLastIndex = current.length - 1;
	        var currentLastLine = current[currentLastIndex];
	        var commonRootMeetPoint = -1;

	        for (var j = prev.length - 1; j >= 0; --j) {
	            if (prev[j] === currentLastLine) {
	                commonRootMeetPoint = j;
	                break;
	            }
	        }

	        for (var j = commonRootMeetPoint; j >= 0; --j) {
	            var line = prev[j];
	            if (current[currentLastIndex] === line) {
	                current.pop();
	                currentLastIndex--;
	            } else {
	                break;
	            }
	        }
	        current = prev;
	    }
	}

	function cleanStack(stack) {
	    var ret = [];
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        var isTraceLine = "    (No stack trace)" === line ||
	            stackFramePattern.test(line);
	        var isInternalFrame = isTraceLine && shouldIgnore(line);
	        if (isTraceLine && !isInternalFrame) {
	            if (indentStackFrames && line.charAt(0) !== " ") {
	                line = "    " + line;
	            }
	            ret.push(line);
	        }
	    }
	    return ret;
	}

	function stackFramesAsArray(error) {
	    var stack = error.stack.replace(/\s+$/g, "").split("\n");
	    for (var i = 0; i < stack.length; ++i) {
	        var line = stack[i];
	        if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
	            break;
	        }
	    }
	    if (i > 0 && error.name != "SyntaxError") {
	        stack = stack.slice(i);
	    }
	    return stack;
	}

	function parseStackAndMessage(error) {
	    var stack = error.stack;
	    var message = error.toString();
	    stack = typeof stack === "string" && stack.length > 0
	                ? stackFramesAsArray(error) : ["    (No stack trace)"];
	    return {
	        message: message,
	        stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
	    };
	}

	function formatAndLogError(error, title, isSoft) {
	    if (typeof console !== "undefined") {
	        var message;
	        if (util.isObject(error)) {
	            var stack = error.stack;
	            message = title + formatStack(stack, error);
	        } else {
	            message = title + String(error);
	        }
	        if (typeof printWarning === "function") {
	            printWarning(message, isSoft);
	        } else if (typeof console.log === "function" ||
	            typeof console.log === "object") {
	            console.log(message);
	        }
	    }
	}

	function fireRejectionEvent(name, localHandler, reason, promise) {
	    var localEventFired = false;
	    try {
	        if (typeof localHandler === "function") {
	            localEventFired = true;
	            if (name === "rejectionHandled") {
	                localHandler(promise);
	            } else {
	                localHandler(reason, promise);
	            }
	        }
	    } catch (e) {
	        async.throwLater(e);
	    }

	    if (name === "unhandledRejection") {
	        if (!activeFireEvent(name, reason, promise) && !localEventFired) {
	            formatAndLogError(reason, "Unhandled rejection ");
	        }
	    } else {
	        activeFireEvent(name, promise);
	    }
	}

	function formatNonError(obj) {
	    var str;
	    if (typeof obj === "function") {
	        str = "[function " +
	            (obj.name || "anonymous") +
	            "]";
	    } else {
	        str = obj && typeof obj.toString === "function"
	            ? obj.toString() : util.toString(obj);
	        var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
	        if (ruselessToString.test(str)) {
	            try {
	                var newStr = JSON.stringify(obj);
	                str = newStr;
	            }
	            catch(e) {

	            }
	        }
	        if (str.length === 0) {
	            str = "(empty array)";
	        }
	    }
	    return ("(<" + snip(str) + ">, no stack trace)");
	}

	function snip(str) {
	    var maxChars = 41;
	    if (str.length < maxChars) {
	        return str;
	    }
	    return str.substr(0, maxChars - 3) + "...";
	}

	function longStackTracesIsSupported() {
	    return typeof captureStackTrace === "function";
	}

	var shouldIgnore = function() { return false; };
	var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
	function parseLineInfo(line) {
	    var matches = line.match(parseLineInfoRegex);
	    if (matches) {
	        return {
	            fileName: matches[1],
	            line: parseInt(matches[2], 10)
	        };
	    }
	}

	function setBounds(firstLineError, lastLineError) {
	    if (!longStackTracesIsSupported()) return;
	    var firstStackLines = firstLineError.stack.split("\n");
	    var lastStackLines = lastLineError.stack.split("\n");
	    var firstIndex = -1;
	    var lastIndex = -1;
	    var firstFileName;
	    var lastFileName;
	    for (var i = 0; i < firstStackLines.length; ++i) {
	        var result = parseLineInfo(firstStackLines[i]);
	        if (result) {
	            firstFileName = result.fileName;
	            firstIndex = result.line;
	            break;
	        }
	    }
	    for (var i = 0; i < lastStackLines.length; ++i) {
	        var result = parseLineInfo(lastStackLines[i]);
	        if (result) {
	            lastFileName = result.fileName;
	            lastIndex = result.line;
	            break;
	        }
	    }
	    if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName ||
	        firstFileName !== lastFileName || firstIndex >= lastIndex) {
	        return;
	    }

	    shouldIgnore = function(line) {
	        if (bluebirdFramePattern.test(line)) return true;
	        var info = parseLineInfo(line);
	        if (info) {
	            if (info.fileName === firstFileName &&
	                (firstIndex <= info.line && info.line <= lastIndex)) {
	                return true;
	            }
	        }
	        return false;
	    };
	}

	function CapturedTrace(parent) {
	    this._parent = parent;
	    this._promisesCreated = 0;
	    var length = this._length = 1 + (parent === undefined ? 0 : parent._length);
	    captureStackTrace(this, CapturedTrace);
	    if (length > 32) this.uncycle();
	}
	util.inherits(CapturedTrace, Error);
	Context.CapturedTrace = CapturedTrace;

	CapturedTrace.prototype.uncycle = function() {
	    var length = this._length;
	    if (length < 2) return;
	    var nodes = [];
	    var stackToIndex = {};

	    for (var i = 0, node = this; node !== undefined; ++i) {
	        nodes.push(node);
	        node = node._parent;
	    }
	    length = this._length = i;
	    for (var i = length - 1; i >= 0; --i) {
	        var stack = nodes[i].stack;
	        if (stackToIndex[stack] === undefined) {
	            stackToIndex[stack] = i;
	        }
	    }
	    for (var i = 0; i < length; ++i) {
	        var currentStack = nodes[i].stack;
	        var index = stackToIndex[currentStack];
	        if (index !== undefined && index !== i) {
	            if (index > 0) {
	                nodes[index - 1]._parent = undefined;
	                nodes[index - 1]._length = 1;
	            }
	            nodes[i]._parent = undefined;
	            nodes[i]._length = 1;
	            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;

	            if (index < length - 1) {
	                cycleEdgeNode._parent = nodes[index + 1];
	                cycleEdgeNode._parent.uncycle();
	                cycleEdgeNode._length =
	                    cycleEdgeNode._parent._length + 1;
	            } else {
	                cycleEdgeNode._parent = undefined;
	                cycleEdgeNode._length = 1;
	            }
	            var currentChildLength = cycleEdgeNode._length + 1;
	            for (var j = i - 2; j >= 0; --j) {
	                nodes[j]._length = currentChildLength;
	                currentChildLength++;
	            }
	            return;
	        }
	    }
	};

	CapturedTrace.prototype.attachExtraTrace = function(error) {
	    if (error.__stackCleaned__) return;
	    this.uncycle();
	    var parsed = parseStackAndMessage(error);
	    var message = parsed.message;
	    var stacks = [parsed.stack];

	    var trace = this;
	    while (trace !== undefined) {
	        stacks.push(cleanStack(trace.stack.split("\n")));
	        trace = trace._parent;
	    }
	    removeCommonRoots(stacks);
	    removeDuplicateOrEmptyJumps(stacks);
	    util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
	    util.notEnumerableProp(error, "__stackCleaned__", true);
	};

	var captureStackTrace = (function stackDetection() {
	    var v8stackFramePattern = /^\s*at\s*/;
	    var v8stackFormatter = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if (error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    if (typeof Error.stackTraceLimit === "number" &&
	        typeof Error.captureStackTrace === "function") {
	        Error.stackTraceLimit += 6;
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        var captureStackTrace = Error.captureStackTrace;

	        shouldIgnore = function(line) {
	            return bluebirdFramePattern.test(line);
	        };
	        return function(receiver, ignoreUntil) {
	            Error.stackTraceLimit += 6;
	            captureStackTrace(receiver, ignoreUntil);
	            Error.stackTraceLimit -= 6;
	        };
	    }
	    var err = new Error();

	    if (typeof err.stack === "string" &&
	        err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
	        stackFramePattern = /@/;
	        formatStack = v8stackFormatter;
	        indentStackFrames = true;
	        return function captureStackTrace(o) {
	            o.stack = new Error().stack;
	        };
	    }

	    var hasStackAfterThrow;
	    try { throw new Error(); }
	    catch(e) {
	        hasStackAfterThrow = ("stack" in e);
	    }
	    if (!("stack" in err) && hasStackAfterThrow &&
	        typeof Error.stackTraceLimit === "number") {
	        stackFramePattern = v8stackFramePattern;
	        formatStack = v8stackFormatter;
	        return function captureStackTrace(o) {
	            Error.stackTraceLimit += 6;
	            try { throw new Error(); }
	            catch(e) { o.stack = e.stack; }
	            Error.stackTraceLimit -= 6;
	        };
	    }

	    formatStack = function(stack, error) {
	        if (typeof stack === "string") return stack;

	        if ((typeof error === "object" ||
	            typeof error === "function") &&
	            error.name !== undefined &&
	            error.message !== undefined) {
	            return error.toString();
	        }
	        return formatNonError(error);
	    };

	    return null;

	})([]);

	if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
	    printWarning = function (message) {
	        console.warn(message);
	    };
	    if (util.isNode && process.stderr.isTTY) {
	        printWarning = function(message, isSoft) {
	            var color = isSoft ? "\u001b[33m" : "\u001b[31m";
	            console.warn(color + message + "\u001b[0m\n");
	        };
	    } else if (!util.isNode && typeof (new Error().stack) === "string") {
	        printWarning = function(message, isSoft) {
	            console.warn("%c" + message,
	                        isSoft ? "color: darkorange" : "color: red");
	        };
	    }
	}

	var config = {
	    warnings: warnings,
	    longStackTraces: false,
	    cancellation: false,
	    monitoring: false
	};

	if (longStackTraces) Promise.longStackTraces();

	return {
	    longStackTraces: function() {
	        return config.longStackTraces;
	    },
	    warnings: function() {
	        return config.warnings;
	    },
	    cancellation: function() {
	        return config.cancellation;
	    },
	    monitoring: function() {
	        return config.monitoring;
	    },
	    propagateFromFunction: function() {
	        return propagateFromFunction;
	    },
	    boundValueFunction: function() {
	        return boundValueFunction;
	    },
	    checkForgottenReturns: checkForgottenReturns,
	    setBounds: setBounds,
	    warn: warn,
	    deprecated: deprecated,
	    CapturedTrace: CapturedTrace,
	    fireDomEvent: fireDomEvent,
	    fireGlobalEvent: fireGlobalEvent
	};
	};

	},{"./errors":12,"./util":36}],10:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function returner() {
	    return this.value;
	}
	function thrower() {
	    throw this.reason;
	}

	Promise.prototype["return"] =
	Promise.prototype.thenReturn = function (value) {
	    if (value instanceof Promise) value.suppressUnhandledRejections();
	    return this._then(
	        returner, undefined, undefined, {value: value}, undefined);
	};

	Promise.prototype["throw"] =
	Promise.prototype.thenThrow = function (reason) {
	    return this._then(
	        thrower, undefined, undefined, {reason: reason}, undefined);
	};

	Promise.prototype.catchThrow = function (reason) {
	    if (arguments.length <= 1) {
	        return this._then(
	            undefined, thrower, undefined, {reason: reason}, undefined);
	    } else {
	        var _reason = arguments[1];
	        var handler = function() {throw _reason;};
	        return this.caught(reason, handler);
	    }
	};

	Promise.prototype.catchReturn = function (value) {
	    if (arguments.length <= 1) {
	        if (value instanceof Promise) value.suppressUnhandledRejections();
	        return this._then(
	            undefined, returner, undefined, {value: value}, undefined);
	    } else {
	        var _value = arguments[1];
	        if (_value instanceof Promise) _value.suppressUnhandledRejections();
	        var handler = function() {return _value;};
	        return this.caught(value, handler);
	    }
	};
	};

	},{}],11:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseReduce = Promise.reduce;
	var PromiseAll = Promise.all;

	function promiseAllThis() {
	    return PromiseAll(this);
	}

	function PromiseMapSeries(promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, INTERNAL);
	}

	Promise.prototype.each = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, this, undefined);
	};

	Promise.prototype.mapSeries = function (fn) {
	    return PromiseReduce(this, fn, INTERNAL, INTERNAL);
	};

	Promise.each = function (promises, fn) {
	    return PromiseReduce(promises, fn, INTERNAL, 0)
	              ._then(promiseAllThis, undefined, undefined, promises, undefined);
	};

	Promise.mapSeries = PromiseMapSeries;
	};


	},{}],12:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var Objectfreeze = es5.freeze;
	var util = _dereq_("./util");
	var inherits = util.inherits;
	var notEnumerableProp = util.notEnumerableProp;

	function subError(nameProperty, defaultMessage) {
	    function SubError(message) {
	        if (!(this instanceof SubError)) return new SubError(message);
	        notEnumerableProp(this, "message",
	            typeof message === "string" ? message : defaultMessage);
	        notEnumerableProp(this, "name", nameProperty);
	        if (Error.captureStackTrace) {
	            Error.captureStackTrace(this, this.constructor);
	        } else {
	            Error.call(this);
	        }
	    }
	    inherits(SubError, Error);
	    return SubError;
	}

	var _TypeError, _RangeError;
	var Warning = subError("Warning", "warning");
	var CancellationError = subError("CancellationError", "cancellation error");
	var TimeoutError = subError("TimeoutError", "timeout error");
	var AggregateError = subError("AggregateError", "aggregate error");
	try {
	    _TypeError = TypeError;
	    _RangeError = RangeError;
	} catch(e) {
	    _TypeError = subError("TypeError", "type error");
	    _RangeError = subError("RangeError", "range error");
	}

	var methods = ("join pop push shift unshift slice filter forEach some " +
	    "every map indexOf lastIndexOf reduce reduceRight sort reverse").split(" ");

	for (var i = 0; i < methods.length; ++i) {
	    if (typeof Array.prototype[methods[i]] === "function") {
	        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
	    }
	}

	es5.defineProperty(AggregateError.prototype, "length", {
	    value: 0,
	    configurable: false,
	    writable: true,
	    enumerable: true
	});
	AggregateError.prototype["isOperational"] = true;
	var level = 0;
	AggregateError.prototype.toString = function() {
	    var indent = Array(level * 4 + 1).join(" ");
	    var ret = "\n" + indent + "AggregateError of:" + "\n";
	    level++;
	    indent = Array(level * 4 + 1).join(" ");
	    for (var i = 0; i < this.length; ++i) {
	        var str = this[i] === this ? "[Circular AggregateError]" : this[i] + "";
	        var lines = str.split("\n");
	        for (var j = 0; j < lines.length; ++j) {
	            lines[j] = indent + lines[j];
	        }
	        str = lines.join("\n");
	        ret += str + "\n";
	    }
	    level--;
	    return ret;
	};

	function OperationalError(message) {
	    if (!(this instanceof OperationalError))
	        return new OperationalError(message);
	    notEnumerableProp(this, "name", "OperationalError");
	    notEnumerableProp(this, "message", message);
	    this.cause = message;
	    this["isOperational"] = true;

	    if (message instanceof Error) {
	        notEnumerableProp(this, "message", message.message);
	        notEnumerableProp(this, "stack", message.stack);
	    } else if (Error.captureStackTrace) {
	        Error.captureStackTrace(this, this.constructor);
	    }

	}
	inherits(OperationalError, Error);

	var errorTypes = Error["__BluebirdErrorTypes__"];
	if (!errorTypes) {
	    errorTypes = Objectfreeze({
	        CancellationError: CancellationError,
	        TimeoutError: TimeoutError,
	        OperationalError: OperationalError,
	        RejectionError: OperationalError,
	        AggregateError: AggregateError
	    });
	    es5.defineProperty(Error, "__BluebirdErrorTypes__", {
	        value: errorTypes,
	        writable: false,
	        enumerable: false,
	        configurable: false
	    });
	}

	module.exports = {
	    Error: Error,
	    TypeError: _TypeError,
	    RangeError: _RangeError,
	    CancellationError: errorTypes.CancellationError,
	    OperationalError: errorTypes.OperationalError,
	    TimeoutError: errorTypes.TimeoutError,
	    AggregateError: errorTypes.AggregateError,
	    Warning: Warning
	};

	},{"./es5":13,"./util":36}],13:[function(_dereq_,module,exports){
	var isES5 = (function(){
	    "use strict";
	    return this === undefined;
	})();

	if (isES5) {
	    module.exports = {
	        freeze: Object.freeze,
	        defineProperty: Object.defineProperty,
	        getDescriptor: Object.getOwnPropertyDescriptor,
	        keys: Object.keys,
	        names: Object.getOwnPropertyNames,
	        getPrototypeOf: Object.getPrototypeOf,
	        isArray: Array.isArray,
	        isES5: isES5,
	        propertyIsWritable: function(obj, prop) {
	            var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
	            return !!(!descriptor || descriptor.writable || descriptor.set);
	        }
	    };
	} else {
	    var has = {}.hasOwnProperty;
	    var str = {}.toString;
	    var proto = {}.constructor.prototype;

	    var ObjectKeys = function (o) {
	        var ret = [];
	        for (var key in o) {
	            if (has.call(o, key)) {
	                ret.push(key);
	            }
	        }
	        return ret;
	    };

	    var ObjectGetDescriptor = function(o, key) {
	        return {value: o[key]};
	    };

	    var ObjectDefineProperty = function (o, key, desc) {
	        o[key] = desc.value;
	        return o;
	    };

	    var ObjectFreeze = function (obj) {
	        return obj;
	    };

	    var ObjectGetPrototypeOf = function (obj) {
	        try {
	            return Object(obj).constructor.prototype;
	        }
	        catch (e) {
	            return proto;
	        }
	    };

	    var ArrayIsArray = function (obj) {
	        try {
	            return str.call(obj) === "[object Array]";
	        }
	        catch(e) {
	            return false;
	        }
	    };

	    module.exports = {
	        isArray: ArrayIsArray,
	        keys: ObjectKeys,
	        names: ObjectKeys,
	        defineProperty: ObjectDefineProperty,
	        getDescriptor: ObjectGetDescriptor,
	        freeze: ObjectFreeze,
	        getPrototypeOf: ObjectGetPrototypeOf,
	        isES5: isES5,
	        propertyIsWritable: function() {
	            return true;
	        }
	    };
	}

	},{}],14:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var PromiseMap = Promise.map;

	Promise.prototype.filter = function (fn, options) {
	    return PromiseMap(this, fn, options, INTERNAL);
	};

	Promise.filter = function (promises, fn, options) {
	    return PromiseMap(promises, fn, options, INTERNAL);
	};
	};

	},{}],15:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, tryConvertToPromise) {
	var util = _dereq_("./util");
	var CancellationError = Promise.CancellationError;
	var errorObj = util.errorObj;

	function PassThroughHandlerContext(promise, type, handler) {
	    this.promise = promise;
	    this.type = type;
	    this.handler = handler;
	    this.called = false;
	    this.cancelPromise = null;
	}

	PassThroughHandlerContext.prototype.isFinallyHandler = function() {
	    return this.type === 0;
	};

	function FinallyHandlerCancelReaction(finallyHandler) {
	    this.finallyHandler = finallyHandler;
	}

	FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
	    checkCancel(this.finallyHandler);
	};

	function checkCancel(ctx, reason) {
	    if (ctx.cancelPromise != null) {
	        if (arguments.length > 1) {
	            ctx.cancelPromise._reject(reason);
	        } else {
	            ctx.cancelPromise._cancel();
	        }
	        ctx.cancelPromise = null;
	        return true;
	    }
	    return false;
	}

	function succeed() {
	    return finallyHandler.call(this, this.promise._target()._settledValue());
	}
	function fail(reason) {
	    if (checkCancel(this, reason)) return;
	    errorObj.e = reason;
	    return errorObj;
	}
	function finallyHandler(reasonOrValue) {
	    var promise = this.promise;
	    var handler = this.handler;

	    if (!this.called) {
	        this.called = true;
	        var ret = this.isFinallyHandler()
	            ? handler.call(promise._boundValue())
	            : handler.call(promise._boundValue(), reasonOrValue);
	        if (ret !== undefined) {
	            promise._setReturnedNonUndefined();
	            var maybePromise = tryConvertToPromise(ret, promise);
	            if (maybePromise instanceof Promise) {
	                if (this.cancelPromise != null) {
	                    if (maybePromise._isCancelled()) {
	                        var reason =
	                            new CancellationError("late cancellation observer");
	                        promise._attachExtraTrace(reason);
	                        errorObj.e = reason;
	                        return errorObj;
	                    } else if (maybePromise.isPending()) {
	                        maybePromise._attachCancellationCallback(
	                            new FinallyHandlerCancelReaction(this));
	                    }
	                }
	                return maybePromise._then(
	                    succeed, fail, undefined, this, undefined);
	            }
	        }
	    }

	    if (promise.isRejected()) {
	        checkCancel(this);
	        errorObj.e = reasonOrValue;
	        return errorObj;
	    } else {
	        checkCancel(this);
	        return reasonOrValue;
	    }
	}

	Promise.prototype._passThrough = function(handler, type, success, fail) {
	    if (typeof handler !== "function") return this.then();
	    return this._then(success,
	                      fail,
	                      undefined,
	                      new PassThroughHandlerContext(this, type, handler),
	                      undefined);
	};

	Promise.prototype.lastly =
	Promise.prototype["finally"] = function (handler) {
	    return this._passThrough(handler,
	                             0,
	                             finallyHandler,
	                             finallyHandler);
	};

	Promise.prototype.tap = function (handler) {
	    return this._passThrough(handler, 1, finallyHandler);
	};

	return PassThroughHandlerContext;
	};

	},{"./util":36}],16:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          apiRejection,
	                          INTERNAL,
	                          tryConvertToPromise,
	                          Proxyable,
	                          debug) {
	var errors = _dereq_("./errors");
	var TypeError = errors.TypeError;
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	var yieldHandlers = [];

	function promiseFromYieldHandler(value, yieldHandlers, traceParent) {
	    for (var i = 0; i < yieldHandlers.length; ++i) {
	        traceParent._pushContext();
	        var result = tryCatch(yieldHandlers[i])(value);
	        traceParent._popContext();
	        if (result === errorObj) {
	            traceParent._pushContext();
	            var ret = Promise.reject(errorObj.e);
	            traceParent._popContext();
	            return ret;
	        }
	        var maybePromise = tryConvertToPromise(result, traceParent);
	        if (maybePromise instanceof Promise) return maybePromise;
	    }
	    return null;
	}

	function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
	    if (debug.cancellation()) {
	        var internal = new Promise(INTERNAL);
	        var _finallyPromise = this._finallyPromise = new Promise(INTERNAL);
	        this._promise = internal.lastly(function() {
	            return _finallyPromise;
	        });
	        internal._captureStackTrace();
	        internal._setOnCancel(this);
	    } else {
	        var promise = this._promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	    }
	    this._stack = stack;
	    this._generatorFunction = generatorFunction;
	    this._receiver = receiver;
	    this._generator = undefined;
	    this._yieldHandlers = typeof yieldHandler === "function"
	        ? [yieldHandler].concat(yieldHandlers)
	        : yieldHandlers;
	    this._yieldedPromise = null;
	    this._cancellationPhase = false;
	}
	util.inherits(PromiseSpawn, Proxyable);

	PromiseSpawn.prototype._isResolved = function() {
	    return this._promise === null;
	};

	PromiseSpawn.prototype._cleanup = function() {
	    this._promise = this._generator = null;
	    if (debug.cancellation() && this._finallyPromise !== null) {
	        this._finallyPromise._fulfill();
	        this._finallyPromise = null;
	    }
	};

	PromiseSpawn.prototype._promiseCancelled = function() {
	    if (this._isResolved()) return;
	    var implementsReturn = typeof this._generator["return"] !== "undefined";

	    var result;
	    if (!implementsReturn) {
	        var reason = new Promise.CancellationError(
	            "generator .return() sentinel");
	        Promise.coroutine.returnSentinel = reason;
	        this._promise._attachExtraTrace(reason);
	        this._promise._pushContext();
	        result = tryCatch(this._generator["throw"]).call(this._generator,
	                                                         reason);
	        this._promise._popContext();
	    } else {
	        this._promise._pushContext();
	        result = tryCatch(this._generator["return"]).call(this._generator,
	                                                          undefined);
	        this._promise._popContext();
	    }
	    this._cancellationPhase = true;
	    this._yieldedPromise = null;
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseFulfilled = function(value) {
	    this._yieldedPromise = null;
	    this._promise._pushContext();
	    var result = tryCatch(this._generator.next).call(this._generator, value);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._promiseRejected = function(reason) {
	    this._yieldedPromise = null;
	    this._promise._attachExtraTrace(reason);
	    this._promise._pushContext();
	    var result = tryCatch(this._generator["throw"])
	        .call(this._generator, reason);
	    this._promise._popContext();
	    this._continue(result);
	};

	PromiseSpawn.prototype._resultCancelled = function() {
	    if (this._yieldedPromise instanceof Promise) {
	        var promise = this._yieldedPromise;
	        this._yieldedPromise = null;
	        promise.cancel();
	    }
	};

	PromiseSpawn.prototype.promise = function () {
	    return this._promise;
	};

	PromiseSpawn.prototype._run = function () {
	    this._generator = this._generatorFunction.call(this._receiver);
	    this._receiver =
	        this._generatorFunction = undefined;
	    this._promiseFulfilled(undefined);
	};

	PromiseSpawn.prototype._continue = function (result) {
	    var promise = this._promise;
	    if (result === errorObj) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._rejectCallback(result.e, false);
	        }
	    }

	    var value = result.value;
	    if (result.done === true) {
	        this._cleanup();
	        if (this._cancellationPhase) {
	            return promise.cancel();
	        } else {
	            return promise._resolveCallback(value);
	        }
	    } else {
	        var maybePromise = tryConvertToPromise(value, this._promise);
	        if (!(maybePromise instanceof Promise)) {
	            maybePromise =
	                promiseFromYieldHandler(maybePromise,
	                                        this._yieldHandlers,
	                                        this._promise);
	            if (maybePromise === null) {
	                this._promiseRejected(
	                    new TypeError(
	                        "A value %s was yielded that could not be treated as a promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a\u000a".replace("%s", value) +
	                        "From coroutine:\u000a" +
	                        this._stack.split("\n").slice(1, -7).join("\n")
	                    )
	                );
	                return;
	            }
	        }
	        maybePromise = maybePromise._target();
	        var bitField = maybePromise._bitField;
	        ;
	        if (((bitField & 50397184) === 0)) {
	            this._yieldedPromise = maybePromise;
	            maybePromise._proxy(this, null);
	        } else if (((bitField & 33554432) !== 0)) {
	            Promise._async.invoke(
	                this._promiseFulfilled, this, maybePromise._value()
	            );
	        } else if (((bitField & 16777216) !== 0)) {
	            Promise._async.invoke(
	                this._promiseRejected, this, maybePromise._reason()
	            );
	        } else {
	            this._promiseCancelled();
	        }
	    }
	};

	Promise.coroutine = function (generatorFunction, options) {
	    if (typeof generatorFunction !== "function") {
	        throw new TypeError("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var yieldHandler = Object(options).yieldHandler;
	    var PromiseSpawn$ = PromiseSpawn;
	    var stack = new Error().stack;
	    return function () {
	        var generator = generatorFunction.apply(this, arguments);
	        var spawn = new PromiseSpawn$(undefined, undefined, yieldHandler,
	                                      stack);
	        var ret = spawn.promise();
	        spawn._generator = generator;
	        spawn._promiseFulfilled(undefined);
	        return ret;
	    };
	};

	Promise.coroutine.addYieldHandler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    yieldHandlers.push(fn);
	};

	Promise.spawn = function (generatorFunction) {
	    debug.deprecated("Promise.spawn()", "Promise.coroutine()");
	    if (typeof generatorFunction !== "function") {
	        return apiRejection("generatorFunction must be a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var spawn = new PromiseSpawn(generatorFunction, this);
	    var ret = spawn.promise();
	    spawn._run(Promise.spawn);
	    return ret;
	};
	};

	},{"./errors":12,"./util":36}],17:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, tryConvertToPromise, INTERNAL, async,
	         getDomain) {
	var util = _dereq_("./util");
	var canEvaluate = util.canEvaluate;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var reject;

	if (false) {
	if (canEvaluate) {
	    var thenCallback = function(i) {
	        return new Function("value", "holder", "                             \n\
	            'use strict';                                                    \n\
	            holder.pIndex = value;                                           \n\
	            holder.checkFulfillment(this);                                   \n\
	            ".replace(/Index/g, i));
	    };

	    var promiseSetter = function(i) {
	        return new Function("promise", "holder", "                           \n\
	            'use strict';                                                    \n\
	            holder.pIndex = promise;                                         \n\
	            ".replace(/Index/g, i));
	    };

	    var generateHolderClass = function(total) {
	        var props = new Array(total);
	        for (var i = 0; i < props.length; ++i) {
	            props[i] = "this.p" + (i+1);
	        }
	        var assignment = props.join(" = ") + " = null;";
	        var cancellationCode= "var promise;\n" + props.map(function(prop) {
	            return "                                                         \n\
	                promise = " + prop + ";                                      \n\
	                if (promise instanceof Promise) {                            \n\
	                    promise.cancel();                                        \n\
	                }                                                            \n\
	            ";
	        }).join("\n");
	        var passedArguments = props.join(", ");
	        var name = "Holder$" + total;


	        var code = "return function(tryCatch, errorObj, Promise, async) {    \n\
	            'use strict';                                                    \n\
	            function [TheName](fn) {                                         \n\
	                [TheProperties]                                              \n\
	                this.fn = fn;                                                \n\
	                this.asyncNeeded = true;                                     \n\
	                this.now = 0;                                                \n\
	            }                                                                \n\
	                                                                             \n\
	            [TheName].prototype._callFunction = function(promise) {          \n\
	                promise._pushContext();                                      \n\
	                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n\
	                promise._popContext();                                       \n\
	                if (ret === errorObj) {                                      \n\
	                    promise._rejectCallback(ret.e, false);                   \n\
	                } else {                                                     \n\
	                    promise._resolveCallback(ret);                           \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype.checkFulfillment = function(promise) {       \n\
	                var now = ++this.now;                                        \n\
	                if (now === [TheTotal]) {                                    \n\
	                    if (this.asyncNeeded) {                                  \n\
	                        async.invoke(this._callFunction, this, promise);     \n\
	                    } else {                                                 \n\
	                        this._callFunction(promise);                         \n\
	                    }                                                        \n\
	                                                                             \n\
	                }                                                            \n\
	            };                                                               \n\
	                                                                             \n\
	            [TheName].prototype._resultCancelled = function() {              \n\
	                [CancellationCode]                                           \n\
	            };                                                               \n\
	                                                                             \n\
	            return [TheName];                                                \n\
	        }(tryCatch, errorObj, Promise, async);                               \n\
	        ";

	        code = code.replace(/\[TheName\]/g, name)
	            .replace(/\[TheTotal\]/g, total)
	            .replace(/\[ThePassedArguments\]/g, passedArguments)
	            .replace(/\[TheProperties\]/g, assignment)
	            .replace(/\[CancellationCode\]/g, cancellationCode);

	        return new Function("tryCatch", "errorObj", "Promise", "async", code)
	                           (tryCatch, errorObj, Promise, async);
	    };

	    var holderClasses = [];
	    var thenCallbacks = [];
	    var promiseSetters = [];

	    for (var i = 0; i < 8; ++i) {
	        holderClasses.push(generateHolderClass(i + 1));
	        thenCallbacks.push(thenCallback(i + 1));
	        promiseSetters.push(promiseSetter(i + 1));
	    }

	    reject = function (reason) {
	        this._reject(reason);
	    };
	}}

	Promise.join = function () {
	    var last = arguments.length - 1;
	    var fn;
	    if (last > 0 && typeof arguments[last] === "function") {
	        fn = arguments[last];
	        if (false) {
	            if (last <= 8 && canEvaluate) {
	                var ret = new Promise(INTERNAL);
	                ret._captureStackTrace();
	                var HolderClass = holderClasses[last - 1];
	                var holder = new HolderClass(fn);
	                var callbacks = thenCallbacks;

	                for (var i = 0; i < last; ++i) {
	                    var maybePromise = tryConvertToPromise(arguments[i], ret);
	                    if (maybePromise instanceof Promise) {
	                        maybePromise = maybePromise._target();
	                        var bitField = maybePromise._bitField;
	                        ;
	                        if (((bitField & 50397184) === 0)) {
	                            maybePromise._then(callbacks[i], reject,
	                                               undefined, ret, holder);
	                            promiseSetters[i](maybePromise, holder);
	                            holder.asyncNeeded = false;
	                        } else if (((bitField & 33554432) !== 0)) {
	                            callbacks[i].call(ret,
	                                              maybePromise._value(), holder);
	                        } else if (((bitField & 16777216) !== 0)) {
	                            ret._reject(maybePromise._reason());
	                        } else {
	                            ret._cancel();
	                        }
	                    } else {
	                        callbacks[i].call(ret, maybePromise, holder);
	                    }
	                }

	                if (!ret._isFateSealed()) {
	                    if (holder.asyncNeeded) {
	                        var domain = getDomain();
	                        if (domain !== null) {
	                            holder.fn = util.domainBind(domain, holder.fn);
	                        }
	                    }
	                    ret._setAsyncGuaranteed();
	                    ret._setOnCancel(holder);
	                }
	                return ret;
	            }
	        }
	    }
	    var args = [].slice.call(arguments);;
	    if (fn) args.pop();
	    var ret = new PromiseArray(args).promise();
	    return fn !== undefined ? ret.spread(fn) : ret;
	};

	};

	},{"./util":36}],18:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;
	var async = Promise._async;

	function MappingPromiseArray(promises, fn, limit, _filter) {
	    this.constructor$(promises);
	    this._promise._captureStackTrace();
	    var domain = getDomain();
	    this._callback = domain === null ? fn : util.domainBind(domain, fn);
	    this._preservedValues = _filter === INTERNAL
	        ? new Array(this.length())
	        : null;
	    this._limit = limit;
	    this._inFlight = 0;
	    this._queue = [];
	    async.invoke(this._asyncInit, this, undefined);
	}
	util.inherits(MappingPromiseArray, PromiseArray);

	MappingPromiseArray.prototype._asyncInit = function() {
	    this._init$(undefined, -2);
	};

	MappingPromiseArray.prototype._init = function () {};

	MappingPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var values = this._values;
	    var length = this.length();
	    var preservedValues = this._preservedValues;
	    var limit = this._limit;

	    if (index < 0) {
	        index = (index * -1) - 1;
	        values[index] = value;
	        if (limit >= 1) {
	            this._inFlight--;
	            this._drainQueue();
	            if (this._isResolved()) return true;
	        }
	    } else {
	        if (limit >= 1 && this._inFlight >= limit) {
	            values[index] = value;
	            this._queue.push(index);
	            return false;
	        }
	        if (preservedValues !== null) preservedValues[index] = value;

	        var promise = this._promise;
	        var callback = this._callback;
	        var receiver = promise._boundValue();
	        promise._pushContext();
	        var ret = tryCatch(callback).call(receiver, value, index, length);
	        var promiseCreated = promise._popContext();
	        debug.checkForgottenReturns(
	            ret,
	            promiseCreated,
	            preservedValues !== null ? "Promise.filter" : "Promise.map",
	            promise
	        );
	        if (ret === errorObj) {
	            this._reject(ret.e);
	            return true;
	        }

	        var maybePromise = tryConvertToPromise(ret, this._promise);
	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            var bitField = maybePromise._bitField;
	            ;
	            if (((bitField & 50397184) === 0)) {
	                if (limit >= 1) this._inFlight++;
	                values[index] = maybePromise;
	                maybePromise._proxy(this, (index + 1) * -1);
	                return false;
	            } else if (((bitField & 33554432) !== 0)) {
	                ret = maybePromise._value();
	            } else if (((bitField & 16777216) !== 0)) {
	                this._reject(maybePromise._reason());
	                return true;
	            } else {
	                this._cancel();
	                return true;
	            }
	        }
	        values[index] = ret;
	    }
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= length) {
	        if (preservedValues !== null) {
	            this._filter(values, preservedValues);
	        } else {
	            this._resolve(values);
	        }
	        return true;
	    }
	    return false;
	};

	MappingPromiseArray.prototype._drainQueue = function () {
	    var queue = this._queue;
	    var limit = this._limit;
	    var values = this._values;
	    while (queue.length > 0 && this._inFlight < limit) {
	        if (this._isResolved()) return;
	        var index = queue.pop();
	        this._promiseFulfilled(values[index], index);
	    }
	};

	MappingPromiseArray.prototype._filter = function (booleans, values) {
	    var len = values.length;
	    var ret = new Array(len);
	    var j = 0;
	    for (var i = 0; i < len; ++i) {
	        if (booleans[i]) ret[j++] = values[i];
	    }
	    ret.length = j;
	    this._resolve(ret);
	};

	MappingPromiseArray.prototype.preservedValues = function () {
	    return this._preservedValues;
	};

	function map(promises, fn, options, _filter) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }

	    var limit = 0;
	    if (options !== undefined) {
	        if (typeof options === "object" && options !== null) {
	            if (typeof options.concurrency !== "number") {
	                return Promise.reject(
	                    new TypeError("'concurrency' must be a number but it is " +
	                                    util.classString(options.concurrency)));
	            }
	            limit = options.concurrency;
	        } else {
	            return Promise.reject(new TypeError(
	                            "options argument must be an object but it is " +
	                             util.classString(options)));
	        }
	    }
	    limit = typeof limit === "number" &&
	        isFinite(limit) && limit >= 1 ? limit : 0;
	    return new MappingPromiseArray(promises, fn, limit, _filter).promise();
	}

	Promise.prototype.map = function (fn, options) {
	    return map(this, fn, options, null);
	};

	Promise.map = function (promises, fn, options, _filter) {
	    return map(promises, fn, options, _filter);
	};


	};

	},{"./util":36}],19:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, INTERNAL, tryConvertToPromise, apiRejection, debug) {
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;

	Promise.method = function (fn) {
	    if (typeof fn !== "function") {
	        throw new Promise.TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return function () {
	        var ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._pushContext();
	        var value = tryCatch(fn).apply(this, arguments);
	        var promiseCreated = ret._popContext();
	        debug.checkForgottenReturns(
	            value, promiseCreated, "Promise.method", ret);
	        ret._resolveFromSyncValue(value);
	        return ret;
	    };
	};

	Promise.attempt = Promise["try"] = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._pushContext();
	    var value;
	    if (arguments.length > 1) {
	        debug.deprecated("calling Promise.try with more than 1 argument");
	        var arg = arguments[1];
	        var ctx = arguments[2];
	        value = util.isArray(arg) ? tryCatch(fn).apply(ctx, arg)
	                                  : tryCatch(fn).call(ctx, arg);
	    } else {
	        value = tryCatch(fn)();
	    }
	    var promiseCreated = ret._popContext();
	    debug.checkForgottenReturns(
	        value, promiseCreated, "Promise.try", ret);
	    ret._resolveFromSyncValue(value);
	    return ret;
	};

	Promise.prototype._resolveFromSyncValue = function (value) {
	    if (value === util.errorObj) {
	        this._rejectCallback(value.e, false);
	    } else {
	        this._resolveCallback(value, true);
	    }
	};
	};

	},{"./util":36}],20:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var maybeWrapAsError = util.maybeWrapAsError;
	var errors = _dereq_("./errors");
	var OperationalError = errors.OperationalError;
	var es5 = _dereq_("./es5");

	function isUntypedError(obj) {
	    return obj instanceof Error &&
	        es5.getPrototypeOf(obj) === Error.prototype;
	}

	var rErrorKey = /^(?:name|message|stack|cause)$/;
	function wrapAsOperationalError(obj) {
	    var ret;
	    if (isUntypedError(obj)) {
	        ret = new OperationalError(obj);
	        ret.name = obj.name;
	        ret.message = obj.message;
	        ret.stack = obj.stack;
	        var keys = es5.keys(obj);
	        for (var i = 0; i < keys.length; ++i) {
	            var key = keys[i];
	            if (!rErrorKey.test(key)) {
	                ret[key] = obj[key];
	            }
	        }
	        return ret;
	    }
	    util.markAsOriginatingFromRejection(obj);
	    return obj;
	}

	function nodebackForPromise(promise, multiArgs) {
	    return function(err, value) {
	        if (promise === null) return;
	        if (err) {
	            var wrapped = wrapAsOperationalError(maybeWrapAsError(err));
	            promise._attachExtraTrace(wrapped);
	            promise._reject(wrapped);
	        } else if (!multiArgs) {
	            promise._fulfill(value);
	        } else {
	            var args = [].slice.call(arguments, 1);;
	            promise._fulfill(args);
	        }
	        promise = null;
	    };
	}

	module.exports = nodebackForPromise;

	},{"./errors":12,"./es5":13,"./util":36}],21:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	var util = _dereq_("./util");
	var async = Promise._async;
	var tryCatch = util.tryCatch;
	var errorObj = util.errorObj;

	function spreadAdapter(val, nodeback) {
	    var promise = this;
	    if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
	    var ret =
	        tryCatch(nodeback).apply(promise._boundValue(), [null].concat(val));
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	function successAdapter(val, nodeback) {
	    var promise = this;
	    var receiver = promise._boundValue();
	    var ret = val === undefined
	        ? tryCatch(nodeback).call(receiver, null)
	        : tryCatch(nodeback).call(receiver, null, val);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}
	function errorAdapter(reason, nodeback) {
	    var promise = this;
	    if (!reason) {
	        var newReason = new Error(reason + "");
	        newReason.cause = reason;
	        reason = newReason;
	    }
	    var ret = tryCatch(nodeback).call(promise._boundValue(), reason);
	    if (ret === errorObj) {
	        async.throwLater(ret.e);
	    }
	}

	Promise.prototype.asCallback = Promise.prototype.nodeify = function (nodeback,
	                                                                     options) {
	    if (typeof nodeback == "function") {
	        var adapter = successAdapter;
	        if (options !== undefined && Object(options).spread) {
	            adapter = spreadAdapter;
	        }
	        this._then(
	            adapter,
	            errorAdapter,
	            undefined,
	            this,
	            nodeback
	        );
	    }
	    return this;
	};
	};

	},{"./util":36}],22:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function() {
	var makeSelfResolutionError = function () {
	    return new TypeError("circular promise resolution chain\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var reflectHandler = function() {
	    return new Promise.PromiseInspection(this._target());
	};
	var apiRejection = function(msg) {
	    return Promise.reject(new TypeError(msg));
	};
	function Proxyable() {}
	var UNDEFINED_BINDING = {};
	var util = _dereq_("./util");

	var getDomain;
	if (util.isNode) {
	    getDomain = function() {
	        var ret = process.domain;
	        if (ret === undefined) ret = null;
	        return ret;
	    };
	} else {
	    getDomain = function() {
	        return null;
	    };
	}
	util.notEnumerableProp(Promise, "_getDomain", getDomain);

	var es5 = _dereq_("./es5");
	var Async = _dereq_("./async");
	var async = new Async();
	es5.defineProperty(Promise, "_async", {value: async});
	var errors = _dereq_("./errors");
	var TypeError = Promise.TypeError = errors.TypeError;
	Promise.RangeError = errors.RangeError;
	var CancellationError = Promise.CancellationError = errors.CancellationError;
	Promise.TimeoutError = errors.TimeoutError;
	Promise.OperationalError = errors.OperationalError;
	Promise.RejectionError = errors.OperationalError;
	Promise.AggregateError = errors.AggregateError;
	var INTERNAL = function(){};
	var APPLY = {};
	var NEXT_FILTER = {};
	var tryConvertToPromise = _dereq_("./thenables")(Promise, INTERNAL);
	var PromiseArray =
	    _dereq_("./promise_array")(Promise, INTERNAL,
	                               tryConvertToPromise, apiRejection, Proxyable);
	var Context = _dereq_("./context")(Promise);
	 /*jshint unused:false*/
	var createContext = Context.create;
	var debug = _dereq_("./debuggability")(Promise, Context);
	var CapturedTrace = debug.CapturedTrace;
	var PassThroughHandlerContext =
	    _dereq_("./finally")(Promise, tryConvertToPromise);
	var catchFilter = _dereq_("./catch_filter")(NEXT_FILTER);
	var nodebackForPromise = _dereq_("./nodeback");
	var errorObj = util.errorObj;
	var tryCatch = util.tryCatch;
	function check(self, executor) {
	    if (typeof executor !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(executor));
	    }
	    if (self.constructor !== Promise) {
	        throw new TypeError("the promise constructor cannot be invoked directly\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	}

	function Promise(executor) {
	    this._bitField = 0;
	    this._fulfillmentHandler0 = undefined;
	    this._rejectionHandler0 = undefined;
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    if (executor !== INTERNAL) {
	        check(this, executor);
	        this._resolveFromExecutor(executor);
	    }
	    this._promiseCreated();
	    this._fireEvent("promiseCreated", this);
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.caught = Promise.prototype["catch"] = function (fn) {
	    var len = arguments.length;
	    if (len > 1) {
	        var catchInstances = new Array(len - 1),
	            j = 0, i;
	        for (i = 0; i < len - 1; ++i) {
	            var item = arguments[i];
	            if (util.isObject(item)) {
	                catchInstances[j++] = item;
	            } else {
	                return apiRejection("expecting an object but got " +
	                    "A catch statement predicate " + util.classString(item));
	            }
	        }
	        catchInstances.length = j;
	        fn = arguments[i];
	        return this.then(undefined, catchFilter(catchInstances, fn, this));
	    }
	    return this.then(undefined, fn);
	};

	Promise.prototype.reflect = function () {
	    return this._then(reflectHandler,
	        reflectHandler, undefined, this, undefined);
	};

	Promise.prototype.then = function (didFulfill, didReject) {
	    if (debug.warnings() && arguments.length > 0 &&
	        typeof didFulfill !== "function" &&
	        typeof didReject !== "function") {
	        var msg = ".then() only accepts functions but was passed: " +
	                util.classString(didFulfill);
	        if (arguments.length > 1) {
	            msg += ", " + util.classString(didReject);
	        }
	        this._warn(msg);
	    }
	    return this._then(didFulfill, didReject, undefined, undefined, undefined);
	};

	Promise.prototype.done = function (didFulfill, didReject) {
	    var promise =
	        this._then(didFulfill, didReject, undefined, undefined, undefined);
	    promise._setIsFinal();
	};

	Promise.prototype.spread = function (fn) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    return this.all()._then(fn, undefined, undefined, APPLY, undefined);
	};

	Promise.prototype.toJSON = function () {
	    var ret = {
	        isFulfilled: false,
	        isRejected: false,
	        fulfillmentValue: undefined,
	        rejectionReason: undefined
	    };
	    if (this.isFulfilled()) {
	        ret.fulfillmentValue = this.value();
	        ret.isFulfilled = true;
	    } else if (this.isRejected()) {
	        ret.rejectionReason = this.reason();
	        ret.isRejected = true;
	    }
	    return ret;
	};

	Promise.prototype.all = function () {
	    if (arguments.length > 0) {
	        this._warn(".all() was passed arguments but it does not take any");
	    }
	    return new PromiseArray(this).promise();
	};

	Promise.prototype.error = function (fn) {
	    return this.caught(util.originatesFromRejection, fn);
	};

	Promise.getNewLibraryCopy = module.exports;

	Promise.is = function (val) {
	    return val instanceof Promise;
	};

	Promise.fromNode = Promise.fromCallback = function(fn) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs
	                                         : false;
	    var result = tryCatch(fn)(nodebackForPromise(ret, multiArgs));
	    if (result === errorObj) {
	        ret._rejectCallback(result.e, true);
	    }
	    if (!ret._isFateSealed()) ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.all = function (promises) {
	    return new PromiseArray(promises).promise();
	};

	Promise.cast = function (obj) {
	    var ret = tryConvertToPromise(obj);
	    if (!(ret instanceof Promise)) {
	        ret = new Promise(INTERNAL);
	        ret._captureStackTrace();
	        ret._setFulfilled();
	        ret._rejectionHandler0 = obj;
	    }
	    return ret;
	};

	Promise.resolve = Promise.fulfilled = Promise.cast;

	Promise.reject = Promise.rejected = function (reason) {
	    var ret = new Promise(INTERNAL);
	    ret._captureStackTrace();
	    ret._rejectCallback(reason, true);
	    return ret;
	};

	Promise.setScheduler = function(fn) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    return async.setScheduler(fn);
	};

	Promise.prototype._then = function (
	    didFulfill,
	    didReject,
	    _,    receiver,
	    internalData
	) {
	    var haveInternalData = internalData !== undefined;
	    var promise = haveInternalData ? internalData : new Promise(INTERNAL);
	    var target = this._target();
	    var bitField = target._bitField;

	    if (!haveInternalData) {
	        promise._propagateFrom(this, 3);
	        promise._captureStackTrace();
	        if (receiver === undefined &&
	            ((this._bitField & 2097152) !== 0)) {
	            if (!((bitField & 50397184) === 0)) {
	                receiver = this._boundValue();
	            } else {
	                receiver = target === this ? undefined : this._boundTo;
	            }
	        }
	        this._fireEvent("promiseChained", this, promise);
	    }

	    var domain = getDomain();
	    if (!((bitField & 50397184) === 0)) {
	        var handler, value, settler = target._settlePromiseCtx;
	        if (((bitField & 33554432) !== 0)) {
	            value = target._rejectionHandler0;
	            handler = didFulfill;
	        } else if (((bitField & 16777216) !== 0)) {
	            value = target._fulfillmentHandler0;
	            handler = didReject;
	            target._unsetRejectionIsUnhandled();
	        } else {
	            settler = target._settlePromiseLateCancellationObserver;
	            value = new CancellationError("late cancellation observer");
	            target._attachExtraTrace(value);
	            handler = didReject;
	        }

	        async.invoke(settler, target, {
	            handler: domain === null ? handler
	                : (typeof handler === "function" &&
	                    util.domainBind(domain, handler)),
	            promise: promise,
	            receiver: receiver,
	            value: value
	        });
	    } else {
	        target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
	    }

	    return promise;
	};

	Promise.prototype._length = function () {
	    return this._bitField & 65535;
	};

	Promise.prototype._isFateSealed = function () {
	    return (this._bitField & 117506048) !== 0;
	};

	Promise.prototype._isFollowing = function () {
	    return (this._bitField & 67108864) === 67108864;
	};

	Promise.prototype._setLength = function (len) {
	    this._bitField = (this._bitField & -65536) |
	        (len & 65535);
	};

	Promise.prototype._setFulfilled = function () {
	    this._bitField = this._bitField | 33554432;
	    this._fireEvent("promiseFulfilled", this);
	};

	Promise.prototype._setRejected = function () {
	    this._bitField = this._bitField | 16777216;
	    this._fireEvent("promiseRejected", this);
	};

	Promise.prototype._setFollowing = function () {
	    this._bitField = this._bitField | 67108864;
	    this._fireEvent("promiseResolved", this);
	};

	Promise.prototype._setIsFinal = function () {
	    this._bitField = this._bitField | 4194304;
	};

	Promise.prototype._isFinal = function () {
	    return (this._bitField & 4194304) > 0;
	};

	Promise.prototype._unsetCancelled = function() {
	    this._bitField = this._bitField & (~65536);
	};

	Promise.prototype._setCancelled = function() {
	    this._bitField = this._bitField | 65536;
	    this._fireEvent("promiseCancelled", this);
	};

	Promise.prototype._setWillBeCancelled = function() {
	    this._bitField = this._bitField | 8388608;
	};

	Promise.prototype._setAsyncGuaranteed = function() {
	    if (async.hasCustomScheduler()) return;
	    this._bitField = this._bitField | 134217728;
	};

	Promise.prototype._receiverAt = function (index) {
	    var ret = index === 0 ? this._receiver0 : this[
	            index * 4 - 4 + 3];
	    if (ret === UNDEFINED_BINDING) {
	        return undefined;
	    } else if (ret === undefined && this._isBound()) {
	        return this._boundValue();
	    }
	    return ret;
	};

	Promise.prototype._promiseAt = function (index) {
	    return this[
	            index * 4 - 4 + 2];
	};

	Promise.prototype._fulfillmentHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 0];
	};

	Promise.prototype._rejectionHandlerAt = function (index) {
	    return this[
	            index * 4 - 4 + 1];
	};

	Promise.prototype._boundValue = function() {};

	Promise.prototype._migrateCallback0 = function (follower) {
	    var bitField = follower._bitField;
	    var fulfill = follower._fulfillmentHandler0;
	    var reject = follower._rejectionHandler0;
	    var promise = follower._promise0;
	    var receiver = follower._receiverAt(0);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._migrateCallbackAt = function (follower, index) {
	    var fulfill = follower._fulfillmentHandlerAt(index);
	    var reject = follower._rejectionHandlerAt(index);
	    var promise = follower._promiseAt(index);
	    var receiver = follower._receiverAt(index);
	    if (receiver === undefined) receiver = UNDEFINED_BINDING;
	    this._addCallbacks(fulfill, reject, promise, receiver, null);
	};

	Promise.prototype._addCallbacks = function (
	    fulfill,
	    reject,
	    promise,
	    receiver,
	    domain
	) {
	    var index = this._length();

	    if (index >= 65535 - 4) {
	        index = 0;
	        this._setLength(0);
	    }

	    if (index === 0) {
	        this._promise0 = promise;
	        this._receiver0 = receiver;
	        if (typeof fulfill === "function") {
	            this._fulfillmentHandler0 =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this._rejectionHandler0 =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    } else {
	        var base = index * 4 - 4;
	        this[base + 2] = promise;
	        this[base + 3] = receiver;
	        if (typeof fulfill === "function") {
	            this[base + 0] =
	                domain === null ? fulfill : util.domainBind(domain, fulfill);
	        }
	        if (typeof reject === "function") {
	            this[base + 1] =
	                domain === null ? reject : util.domainBind(domain, reject);
	        }
	    }
	    this._setLength(index + 1);
	    return index;
	};

	Promise.prototype._proxy = function (proxyable, arg) {
	    this._addCallbacks(undefined, undefined, arg, proxyable, null);
	};

	Promise.prototype._resolveCallback = function(value, shouldBind) {
	    if (((this._bitField & 117506048) !== 0)) return;
	    if (value === this)
	        return this._rejectCallback(makeSelfResolutionError(), false);
	    var maybePromise = tryConvertToPromise(value, this);
	    if (!(maybePromise instanceof Promise)) return this._fulfill(value);

	    if (shouldBind) this._propagateFrom(maybePromise, 2);

	    var promise = maybePromise._target();

	    if (promise === this) {
	        this._reject(makeSelfResolutionError());
	        return;
	    }

	    var bitField = promise._bitField;
	    if (((bitField & 50397184) === 0)) {
	        var len = this._length();
	        if (len > 0) promise._migrateCallback0(this);
	        for (var i = 1; i < len; ++i) {
	            promise._migrateCallbackAt(this, i);
	        }
	        this._setFollowing();
	        this._setLength(0);
	        this._setFollowee(promise);
	    } else if (((bitField & 33554432) !== 0)) {
	        this._fulfill(promise._value());
	    } else if (((bitField & 16777216) !== 0)) {
	        this._reject(promise._reason());
	    } else {
	        var reason = new CancellationError("late cancellation observer");
	        promise._attachExtraTrace(reason);
	        this._reject(reason);
	    }
	};

	Promise.prototype._rejectCallback =
	function(reason, synchronous, ignoreNonErrorWarnings) {
	    var trace = util.ensureErrorObject(reason);
	    var hasStack = trace === reason;
	    if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
	        var message = "a promise was rejected with a non-error: " +
	            util.classString(reason);
	        this._warn(message, true);
	    }
	    this._attachExtraTrace(trace, synchronous ? hasStack : false);
	    this._reject(reason);
	};

	Promise.prototype._resolveFromExecutor = function (executor) {
	    var promise = this;
	    this._captureStackTrace();
	    this._pushContext();
	    var synchronous = true;
	    var r = this._execute(executor, function(value) {
	        promise._resolveCallback(value);
	    }, function (reason) {
	        promise._rejectCallback(reason, synchronous);
	    });
	    synchronous = false;
	    this._popContext();

	    if (r !== undefined) {
	        promise._rejectCallback(r, true);
	    }
	};

	Promise.prototype._settlePromiseFromHandler = function (
	    handler, receiver, value, promise
	) {
	    var bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;
	    promise._pushContext();
	    var x;
	    if (receiver === APPLY) {
	        if (!value || typeof value.length !== "number") {
	            x = errorObj;
	            x.e = new TypeError("cannot .spread() a non-array: " +
	                                    util.classString(value));
	        } else {
	            x = tryCatch(handler).apply(this._boundValue(), value);
	        }
	    } else {
	        x = tryCatch(handler).call(receiver, value);
	    }
	    var promiseCreated = promise._popContext();
	    bitField = promise._bitField;
	    if (((bitField & 65536) !== 0)) return;

	    if (x === NEXT_FILTER) {
	        promise._reject(value);
	    } else if (x === errorObj) {
	        promise._rejectCallback(x.e, false);
	    } else {
	        debug.checkForgottenReturns(x, promiseCreated, "",  promise, this);
	        promise._resolveCallback(x);
	    }
	};

	Promise.prototype._target = function() {
	    var ret = this;
	    while (ret._isFollowing()) ret = ret._followee();
	    return ret;
	};

	Promise.prototype._followee = function() {
	    return this._rejectionHandler0;
	};

	Promise.prototype._setFollowee = function(promise) {
	    this._rejectionHandler0 = promise;
	};

	Promise.prototype._settlePromise = function(promise, handler, receiver, value) {
	    var isPromise = promise instanceof Promise;
	    var bitField = this._bitField;
	    var asyncGuaranteed = ((bitField & 134217728) !== 0);
	    if (((bitField & 65536) !== 0)) {
	        if (isPromise) promise._invokeInternalOnCancel();

	        if (receiver instanceof PassThroughHandlerContext &&
	            receiver.isFinallyHandler()) {
	            receiver.cancelPromise = promise;
	            if (tryCatch(handler).call(receiver, value) === errorObj) {
	                promise._reject(errorObj.e);
	            }
	        } else if (handler === reflectHandler) {
	            promise._fulfill(reflectHandler.call(receiver));
	        } else if (receiver instanceof Proxyable) {
	            receiver._promiseCancelled(promise);
	        } else if (isPromise || promise instanceof PromiseArray) {
	            promise._cancel();
	        } else {
	            receiver.cancel();
	        }
	    } else if (typeof handler === "function") {
	        if (!isPromise) {
	            handler.call(receiver, value, promise);
	        } else {
	            if (asyncGuaranteed) promise._setAsyncGuaranteed();
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (receiver instanceof Proxyable) {
	        if (!receiver._isResolved()) {
	            if (((bitField & 33554432) !== 0)) {
	                receiver._promiseFulfilled(value, promise);
	            } else {
	                receiver._promiseRejected(value, promise);
	            }
	        }
	    } else if (isPromise) {
	        if (asyncGuaranteed) promise._setAsyncGuaranteed();
	        if (((bitField & 33554432) !== 0)) {
	            promise._fulfill(value);
	        } else {
	            promise._reject(value);
	        }
	    }
	};

	Promise.prototype._settlePromiseLateCancellationObserver = function(ctx) {
	    var handler = ctx.handler;
	    var promise = ctx.promise;
	    var receiver = ctx.receiver;
	    var value = ctx.value;
	    if (typeof handler === "function") {
	        if (!(promise instanceof Promise)) {
	            handler.call(receiver, value, promise);
	        } else {
	            this._settlePromiseFromHandler(handler, receiver, value, promise);
	        }
	    } else if (promise instanceof Promise) {
	        promise._reject(value);
	    }
	};

	Promise.prototype._settlePromiseCtx = function(ctx) {
	    this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
	};

	Promise.prototype._settlePromise0 = function(handler, value, bitField) {
	    var promise = this._promise0;
	    var receiver = this._receiverAt(0);
	    this._promise0 = undefined;
	    this._receiver0 = undefined;
	    this._settlePromise(promise, handler, receiver, value);
	};

	Promise.prototype._clearCallbackDataAtIndex = function(index) {
	    var base = index * 4 - 4;
	    this[base + 2] =
	    this[base + 3] =
	    this[base + 0] =
	    this[base + 1] = undefined;
	};

	Promise.prototype._fulfill = function (value) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    if (value === this) {
	        var err = makeSelfResolutionError();
	        this._attachExtraTrace(err);
	        return this._reject(err);
	    }
	    this._setFulfilled();
	    this._rejectionHandler0 = value;

	    if ((bitField & 65535) > 0) {
	        if (((bitField & 134217728) !== 0)) {
	            this._settlePromises();
	        } else {
	            async.settlePromises(this);
	        }
	    }
	};

	Promise.prototype._reject = function (reason) {
	    var bitField = this._bitField;
	    if (((bitField & 117506048) >>> 16)) return;
	    this._setRejected();
	    this._fulfillmentHandler0 = reason;

	    if (this._isFinal()) {
	        return async.fatalError(reason, util.isNode);
	    }

	    if ((bitField & 65535) > 0) {
	        async.settlePromises(this);
	    } else {
	        this._ensurePossibleRejectionHandled();
	    }
	};

	Promise.prototype._fulfillPromises = function (len, value) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._fulfillmentHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, value);
	    }
	};

	Promise.prototype._rejectPromises = function (len, reason) {
	    for (var i = 1; i < len; i++) {
	        var handler = this._rejectionHandlerAt(i);
	        var promise = this._promiseAt(i);
	        var receiver = this._receiverAt(i);
	        this._clearCallbackDataAtIndex(i);
	        this._settlePromise(promise, handler, receiver, reason);
	    }
	};

	Promise.prototype._settlePromises = function () {
	    var bitField = this._bitField;
	    var len = (bitField & 65535);

	    if (len > 0) {
	        if (((bitField & 16842752) !== 0)) {
	            var reason = this._fulfillmentHandler0;
	            this._settlePromise0(this._rejectionHandler0, reason, bitField);
	            this._rejectPromises(len, reason);
	        } else {
	            var value = this._rejectionHandler0;
	            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
	            this._fulfillPromises(len, value);
	        }
	        this._setLength(0);
	    }
	    this._clearCancellationData();
	};

	Promise.prototype._settledValue = function() {
	    var bitField = this._bitField;
	    if (((bitField & 33554432) !== 0)) {
	        return this._rejectionHandler0;
	    } else if (((bitField & 16777216) !== 0)) {
	        return this._fulfillmentHandler0;
	    }
	};

	function deferResolve(v) {this.promise._resolveCallback(v);}
	function deferReject(v) {this.promise._rejectCallback(v, false);}

	Promise.defer = Promise.pending = function() {
	    debug.deprecated("Promise.defer", "new Promise");
	    var promise = new Promise(INTERNAL);
	    return {
	        promise: promise,
	        resolve: deferResolve,
	        reject: deferReject
	    };
	};

	util.notEnumerableProp(Promise,
	                       "_makeSelfResolutionError",
	                       makeSelfResolutionError);

	_dereq_("./method")(Promise, INTERNAL, tryConvertToPromise, apiRejection,
	    debug);
	_dereq_("./bind")(Promise, INTERNAL, tryConvertToPromise, debug);
	_dereq_("./cancel")(Promise, PromiseArray, apiRejection, debug);
	_dereq_("./direct_resolve")(Promise);
	_dereq_("./synchronous_inspection")(Promise);
	_dereq_("./join")(
	    Promise, PromiseArray, tryConvertToPromise, INTERNAL, async, getDomain);
	Promise.Promise = Promise;
	Promise.version = "3.4.7";
	_dereq_('./map.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./call_get.js')(Promise);
	_dereq_('./using.js')(Promise, apiRejection, tryConvertToPromise, createContext, INTERNAL, debug);
	_dereq_('./timers.js')(Promise, INTERNAL, debug);
	_dereq_('./generators.js')(Promise, apiRejection, INTERNAL, tryConvertToPromise, Proxyable, debug);
	_dereq_('./nodeify.js')(Promise);
	_dereq_('./promisify.js')(Promise, INTERNAL);
	_dereq_('./props.js')(Promise, PromiseArray, tryConvertToPromise, apiRejection);
	_dereq_('./race.js')(Promise, INTERNAL, tryConvertToPromise, apiRejection);
	_dereq_('./reduce.js')(Promise, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL, debug);
	_dereq_('./settle.js')(Promise, PromiseArray, debug);
	_dereq_('./some.js')(Promise, PromiseArray, apiRejection);
	_dereq_('./filter.js')(Promise, INTERNAL);
	_dereq_('./each.js')(Promise, INTERNAL);
	_dereq_('./any.js')(Promise);
	                                                         
	    util.toFastProperties(Promise);                                          
	    util.toFastProperties(Promise.prototype);                                
	    function fillTypes(value) {                                              
	        var p = new Promise(INTERNAL);                                       
	        p._fulfillmentHandler0 = value;                                      
	        p._rejectionHandler0 = value;                                        
	        p._promise0 = value;                                                 
	        p._receiver0 = value;                                                
	    }                                                                        
	    // Complete slack tracking, opt out of field-type tracking and           
	    // stabilize map                                                         
	    fillTypes({a: 1});                                                       
	    fillTypes({b: 2});                                                       
	    fillTypes({c: 3});                                                       
	    fillTypes(1);                                                            
	    fillTypes(function(){});                                                 
	    fillTypes(undefined);                                                    
	    fillTypes(false);                                                        
	    fillTypes(new Promise(INTERNAL));                                        
	    debug.setBounds(Async.firstLineError, util.lastLineError);               
	    return Promise;                                                          

	};

	},{"./any.js":1,"./async":2,"./bind":3,"./call_get.js":5,"./cancel":6,"./catch_filter":7,"./context":8,"./debuggability":9,"./direct_resolve":10,"./each.js":11,"./errors":12,"./es5":13,"./filter.js":14,"./finally":15,"./generators.js":16,"./join":17,"./map.js":18,"./method":19,"./nodeback":20,"./nodeify.js":21,"./promise_array":23,"./promisify.js":24,"./props.js":25,"./race.js":27,"./reduce.js":28,"./settle.js":30,"./some.js":31,"./synchronous_inspection":32,"./thenables":33,"./timers.js":34,"./using.js":35,"./util":36}],23:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, tryConvertToPromise,
	    apiRejection, Proxyable) {
	var util = _dereq_("./util");
	var isArray = util.isArray;

	function toResolutionValue(val) {
	    switch(val) {
	    case -2: return [];
	    case -3: return {};
	    }
	}

	function PromiseArray(values) {
	    var promise = this._promise = new Promise(INTERNAL);
	    if (values instanceof Promise) {
	        promise._propagateFrom(values, 3);
	    }
	    promise._setOnCancel(this);
	    this._values = values;
	    this._length = 0;
	    this._totalResolved = 0;
	    this._init(undefined, -2);
	}
	util.inherits(PromiseArray, Proxyable);

	PromiseArray.prototype.length = function () {
	    return this._length;
	};

	PromiseArray.prototype.promise = function () {
	    return this._promise;
	};

	PromiseArray.prototype._init = function init(_, resolveValueIfEmpty) {
	    var values = tryConvertToPromise(this._values, this._promise);
	    if (values instanceof Promise) {
	        values = values._target();
	        var bitField = values._bitField;
	        ;
	        this._values = values;

	        if (((bitField & 50397184) === 0)) {
	            this._promise._setAsyncGuaranteed();
	            return values._then(
	                init,
	                this._reject,
	                undefined,
	                this,
	                resolveValueIfEmpty
	           );
	        } else if (((bitField & 33554432) !== 0)) {
	            values = values._value();
	        } else if (((bitField & 16777216) !== 0)) {
	            return this._reject(values._reason());
	        } else {
	            return this._cancel();
	        }
	    }
	    values = util.asArray(values);
	    if (values === null) {
	        var err = apiRejection(
	            "expecting an array or an iterable object but got " + util.classString(values)).reason();
	        this._promise._rejectCallback(err, false);
	        return;
	    }

	    if (values.length === 0) {
	        if (resolveValueIfEmpty === -5) {
	            this._resolveEmptyArray();
	        }
	        else {
	            this._resolve(toResolutionValue(resolveValueIfEmpty));
	        }
	        return;
	    }
	    this._iterate(values);
	};

	PromiseArray.prototype._iterate = function(values) {
	    var len = this.getActualLength(values.length);
	    this._length = len;
	    this._values = this.shouldCopyValues() ? new Array(len) : this._values;
	    var result = this._promise;
	    var isResolved = false;
	    var bitField = null;
	    for (var i = 0; i < len; ++i) {
	        var maybePromise = tryConvertToPromise(values[i], result);

	        if (maybePromise instanceof Promise) {
	            maybePromise = maybePromise._target();
	            bitField = maybePromise._bitField;
	        } else {
	            bitField = null;
	        }

	        if (isResolved) {
	            if (bitField !== null) {
	                maybePromise.suppressUnhandledRejections();
	            }
	        } else if (bitField !== null) {
	            if (((bitField & 50397184) === 0)) {
	                maybePromise._proxy(this, i);
	                this._values[i] = maybePromise;
	            } else if (((bitField & 33554432) !== 0)) {
	                isResolved = this._promiseFulfilled(maybePromise._value(), i);
	            } else if (((bitField & 16777216) !== 0)) {
	                isResolved = this._promiseRejected(maybePromise._reason(), i);
	            } else {
	                isResolved = this._promiseCancelled(i);
	            }
	        } else {
	            isResolved = this._promiseFulfilled(maybePromise, i);
	        }
	    }
	    if (!isResolved) result._setAsyncGuaranteed();
	};

	PromiseArray.prototype._isResolved = function () {
	    return this._values === null;
	};

	PromiseArray.prototype._resolve = function (value) {
	    this._values = null;
	    this._promise._fulfill(value);
	};

	PromiseArray.prototype._cancel = function() {
	    if (this._isResolved() || !this._promise._isCancellable()) return;
	    this._values = null;
	    this._promise._cancel();
	};

	PromiseArray.prototype._reject = function (reason) {
	    this._values = null;
	    this._promise._rejectCallback(reason, false);
	};

	PromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	PromiseArray.prototype._promiseCancelled = function() {
	    this._cancel();
	    return true;
	};

	PromiseArray.prototype._promiseRejected = function (reason) {
	    this._totalResolved++;
	    this._reject(reason);
	    return true;
	};

	PromiseArray.prototype._resultCancelled = function() {
	    if (this._isResolved()) return;
	    var values = this._values;
	    this._cancel();
	    if (values instanceof Promise) {
	        values.cancel();
	    } else {
	        for (var i = 0; i < values.length; ++i) {
	            if (values[i] instanceof Promise) {
	                values[i].cancel();
	            }
	        }
	    }
	};

	PromiseArray.prototype.shouldCopyValues = function () {
	    return true;
	};

	PromiseArray.prototype.getActualLength = function (len) {
	    return len;
	};

	return PromiseArray;
	};

	},{"./util":36}],24:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var THIS = {};
	var util = _dereq_("./util");
	var nodebackForPromise = _dereq_("./nodeback");
	var withAppended = util.withAppended;
	var maybeWrapAsError = util.maybeWrapAsError;
	var canEvaluate = util.canEvaluate;
	var TypeError = _dereq_("./errors").TypeError;
	var defaultSuffix = "Async";
	var defaultPromisified = {__isPromisified__: true};
	var noCopyProps = [
	    "arity",    "length",
	    "name",
	    "arguments",
	    "caller",
	    "callee",
	    "prototype",
	    "__isPromisified__"
	];
	var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");

	var defaultFilter = function(name) {
	    return util.isIdentifier(name) &&
	        name.charAt(0) !== "_" &&
	        name !== "constructor";
	};

	function propsFilter(key) {
	    return !noCopyPropsPattern.test(key);
	}

	function isPromisified(fn) {
	    try {
	        return fn.__isPromisified__ === true;
	    }
	    catch (e) {
	        return false;
	    }
	}

	function hasPromisified(obj, key, suffix) {
	    var val = util.getDataPropertyOrDefault(obj, key + suffix,
	                                            defaultPromisified);
	    return val ? isPromisified(val) : false;
	}
	function checkValid(ret, suffix, suffixRegexp) {
	    for (var i = 0; i < ret.length; i += 2) {
	        var key = ret[i];
	        if (suffixRegexp.test(key)) {
	            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
	            for (var j = 0; j < ret.length; j += 2) {
	                if (ret[j] === keyWithoutAsyncSuffix) {
	                    throw new TypeError("Cannot promisify an API that has normal methods with '%s'-suffix\u000a\u000a    See http://goo.gl/MqrFmX\u000a"
	                        .replace("%s", suffix));
	                }
	            }
	        }
	    }
	}

	function promisifiableMethods(obj, suffix, suffixRegexp, filter) {
	    var keys = util.inheritedDataKeys(obj);
	    var ret = [];
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        var value = obj[key];
	        var passesDefaultFilter = filter === defaultFilter
	            ? true : defaultFilter(key, value, obj);
	        if (typeof value === "function" &&
	            !isPromisified(value) &&
	            !hasPromisified(obj, key, suffix) &&
	            filter(key, value, obj, passesDefaultFilter)) {
	            ret.push(key, value);
	        }
	    }
	    checkValid(ret, suffix, suffixRegexp);
	    return ret;
	}

	var escapeIdentRegex = function(str) {
	    return str.replace(/([$])/, "\\$");
	};

	var makeNodePromisifiedEval;
	if (false) {
	var switchCaseArgumentOrder = function(likelyArgumentCount) {
	    var ret = [likelyArgumentCount];
	    var min = Math.max(0, likelyArgumentCount - 1 - 3);
	    for(var i = likelyArgumentCount - 1; i >= min; --i) {
	        ret.push(i);
	    }
	    for(var i = likelyArgumentCount + 1; i <= 3; ++i) {
	        ret.push(i);
	    }
	    return ret;
	};

	var argumentSequence = function(argumentCount) {
	    return util.filledRange(argumentCount, "_arg", "");
	};

	var parameterDeclaration = function(parameterCount) {
	    return util.filledRange(
	        Math.max(parameterCount, 3), "_arg", "");
	};

	var parameterCount = function(fn) {
	    if (typeof fn.length === "number") {
	        return Math.max(Math.min(fn.length, 1023 + 1), 0);
	    }
	    return 0;
	};

	makeNodePromisifiedEval =
	function(callback, receiver, originalName, fn, _, multiArgs) {
	    var newParameterCount = Math.max(0, parameterCount(fn) - 1);
	    var argumentOrder = switchCaseArgumentOrder(newParameterCount);
	    var shouldProxyThis = typeof callback === "string" || receiver === THIS;

	    function generateCallForArgumentCount(count) {
	        var args = argumentSequence(count).join(", ");
	        var comma = count > 0 ? ", " : "";
	        var ret;
	        if (shouldProxyThis) {
	            ret = "ret = callback.call(this, {{args}}, nodeback); break;\n";
	        } else {
	            ret = receiver === undefined
	                ? "ret = callback({{args}}, nodeback); break;\n"
	                : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
	        }
	        return ret.replace("{{args}}", args).replace(", ", comma);
	    }

	    function generateArgumentSwitchCase() {
	        var ret = "";
	        for (var i = 0; i < argumentOrder.length; ++i) {
	            ret += "case " + argumentOrder[i] +":" +
	                generateCallForArgumentCount(argumentOrder[i]);
	        }

	        ret += "                                                             \n\
	        default:                                                             \n\
	            var args = new Array(len + 1);                                   \n\
	            var i = 0;                                                       \n\
	            for (var i = 0; i < len; ++i) {                                  \n\
	               args[i] = arguments[i];                                       \n\
	            }                                                                \n\
	            args[i] = nodeback;                                              \n\
	            [CodeForCall]                                                    \n\
	            break;                                                           \n\
	        ".replace("[CodeForCall]", (shouldProxyThis
	                                ? "ret = callback.apply(this, args);\n"
	                                : "ret = callback.apply(receiver, args);\n"));
	        return ret;
	    }

	    var getFunctionCode = typeof callback === "string"
	                                ? ("this != null ? this['"+callback+"'] : fn")
	                                : "fn";
	    var body = "'use strict';                                                \n\
	        var ret = function (Parameters) {                                    \n\
	            'use strict';                                                    \n\
	            var len = arguments.length;                                      \n\
	            var promise = new Promise(INTERNAL);                             \n\
	            promise._captureStackTrace();                                    \n\
	            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n\
	            var ret;                                                         \n\
	            var callback = tryCatch([GetFunctionCode]);                      \n\
	            switch(len) {                                                    \n\
	                [CodeForSwitchCase]                                          \n\
	            }                                                                \n\
	            if (ret === errorObj) {                                          \n\
	                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n\
	            }                                                                \n\
	            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n\
	            return promise;                                                  \n\
	        };                                                                   \n\
	        notEnumerableProp(ret, '__isPromisified__', true);                   \n\
	        return ret;                                                          \n\
	    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase())
	        .replace("[GetFunctionCode]", getFunctionCode);
	    body = body.replace("Parameters", parameterDeclaration(newParameterCount));
	    return new Function("Promise",
	                        "fn",
	                        "receiver",
	                        "withAppended",
	                        "maybeWrapAsError",
	                        "nodebackForPromise",
	                        "tryCatch",
	                        "errorObj",
	                        "notEnumerableProp",
	                        "INTERNAL",
	                        body)(
	                    Promise,
	                    fn,
	                    receiver,
	                    withAppended,
	                    maybeWrapAsError,
	                    nodebackForPromise,
	                    util.tryCatch,
	                    util.errorObj,
	                    util.notEnumerableProp,
	                    INTERNAL);
	};
	}

	function makeNodePromisifiedClosure(callback, receiver, _, fn, __, multiArgs) {
	    var defaultThis = (function() {return this;})();
	    var method = callback;
	    if (typeof method === "string") {
	        callback = fn;
	    }
	    function promisified() {
	        var _receiver = receiver;
	        if (receiver === THIS) _receiver = this;
	        var promise = new Promise(INTERNAL);
	        promise._captureStackTrace();
	        var cb = typeof method === "string" && this !== defaultThis
	            ? this[method] : callback;
	        var fn = nodebackForPromise(promise, multiArgs);
	        try {
	            cb.apply(_receiver, withAppended(arguments, fn));
	        } catch(e) {
	            promise._rejectCallback(maybeWrapAsError(e), true, true);
	        }
	        if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
	        return promise;
	    }
	    util.notEnumerableProp(promisified, "__isPromisified__", true);
	    return promisified;
	}

	var makeNodePromisified = canEvaluate
	    ? makeNodePromisifiedEval
	    : makeNodePromisifiedClosure;

	function promisifyAll(obj, suffix, filter, promisifier, multiArgs) {
	    var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
	    var methods =
	        promisifiableMethods(obj, suffix, suffixRegexp, filter);

	    for (var i = 0, len = methods.length; i < len; i+= 2) {
	        var key = methods[i];
	        var fn = methods[i+1];
	        var promisifiedKey = key + suffix;
	        if (promisifier === makeNodePromisified) {
	            obj[promisifiedKey] =
	                makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
	        } else {
	            var promisified = promisifier(fn, function() {
	                return makeNodePromisified(key, THIS, key,
	                                           fn, suffix, multiArgs);
	            });
	            util.notEnumerableProp(promisified, "__isPromisified__", true);
	            obj[promisifiedKey] = promisified;
	        }
	    }
	    util.toFastProperties(obj);
	    return obj;
	}

	function promisify(callback, receiver, multiArgs) {
	    return makeNodePromisified(callback, receiver, undefined,
	                                callback, null, multiArgs);
	}

	Promise.promisify = function (fn, options) {
	    if (typeof fn !== "function") {
	        throw new TypeError("expecting a function but got " + util.classString(fn));
	    }
	    if (isPromisified(fn)) {
	        return fn;
	    }
	    options = Object(options);
	    var receiver = options.context === undefined ? THIS : options.context;
	    var multiArgs = !!options.multiArgs;
	    var ret = promisify(fn, receiver, multiArgs);
	    util.copyDescriptors(fn, ret, propsFilter);
	    return ret;
	};

	Promise.promisifyAll = function (target, options) {
	    if (typeof target !== "function" && typeof target !== "object") {
	        throw new TypeError("the target of promisifyAll must be an object or a function\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    options = Object(options);
	    var multiArgs = !!options.multiArgs;
	    var suffix = options.suffix;
	    if (typeof suffix !== "string") suffix = defaultSuffix;
	    var filter = options.filter;
	    if (typeof filter !== "function") filter = defaultFilter;
	    var promisifier = options.promisifier;
	    if (typeof promisifier !== "function") promisifier = makeNodePromisified;

	    if (!util.isIdentifier(suffix)) {
	        throw new RangeError("suffix must be a valid identifier\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }

	    var keys = util.inheritedDataKeys(target);
	    for (var i = 0; i < keys.length; ++i) {
	        var value = target[keys[i]];
	        if (keys[i] !== "constructor" &&
	            util.isClass(value)) {
	            promisifyAll(value.prototype, suffix, filter, promisifier,
	                multiArgs);
	            promisifyAll(value, suffix, filter, promisifier, multiArgs);
	        }
	    }

	    return promisifyAll(target, suffix, filter, promisifier, multiArgs);
	};
	};


	},{"./errors":12,"./nodeback":20,"./util":36}],25:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, PromiseArray, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");
	var isObject = util.isObject;
	var es5 = _dereq_("./es5");
	var Es6Map;
	if (typeof Map === "function") Es6Map = Map;

	var mapToEntries = (function() {
	    var index = 0;
	    var size = 0;

	    function extractEntry(value, key) {
	        this[index] = value;
	        this[index + size] = key;
	        index++;
	    }

	    return function mapToEntries(map) {
	        size = map.size;
	        index = 0;
	        var ret = new Array(map.size * 2);
	        map.forEach(extractEntry, ret);
	        return ret;
	    };
	})();

	var entriesToMap = function(entries) {
	    var ret = new Es6Map();
	    var length = entries.length / 2 | 0;
	    for (var i = 0; i < length; ++i) {
	        var key = entries[length + i];
	        var value = entries[i];
	        ret.set(key, value);
	    }
	    return ret;
	};

	function PropertiesPromiseArray(obj) {
	    var isMap = false;
	    var entries;
	    if (Es6Map !== undefined && obj instanceof Es6Map) {
	        entries = mapToEntries(obj);
	        isMap = true;
	    } else {
	        var keys = es5.keys(obj);
	        var len = keys.length;
	        entries = new Array(len * 2);
	        for (var i = 0; i < len; ++i) {
	            var key = keys[i];
	            entries[i] = obj[key];
	            entries[i + len] = key;
	        }
	    }
	    this.constructor$(entries);
	    this._isMap = isMap;
	    this._init$(undefined, -3);
	}
	util.inherits(PropertiesPromiseArray, PromiseArray);

	PropertiesPromiseArray.prototype._init = function () {};

	PropertiesPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    this._values[index] = value;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        var val;
	        if (this._isMap) {
	            val = entriesToMap(this._values);
	        } else {
	            val = {};
	            var keyOffset = this.length();
	            for (var i = 0, len = this.length(); i < len; ++i) {
	                val[this._values[i + keyOffset]] = this._values[i];
	            }
	        }
	        this._resolve(val);
	        return true;
	    }
	    return false;
	};

	PropertiesPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	PropertiesPromiseArray.prototype.getActualLength = function (len) {
	    return len >> 1;
	};

	function props(promises) {
	    var ret;
	    var castValue = tryConvertToPromise(promises);

	    if (!isObject(castValue)) {
	        return apiRejection("cannot await properties of a non-object\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    } else if (castValue instanceof Promise) {
	        ret = castValue._then(
	            Promise.props, undefined, undefined, undefined, undefined);
	    } else {
	        ret = new PropertiesPromiseArray(castValue).promise();
	    }

	    if (castValue instanceof Promise) {
	        ret._propagateFrom(castValue, 2);
	    }
	    return ret;
	}

	Promise.prototype.props = function () {
	    return props(this);
	};

	Promise.props = function (promises) {
	    return props(promises);
	};
	};

	},{"./es5":13,"./util":36}],26:[function(_dereq_,module,exports){
	"use strict";
	function arrayMove(src, srcIndex, dst, dstIndex, len) {
	    for (var j = 0; j < len; ++j) {
	        dst[j + dstIndex] = src[j + srcIndex];
	        src[j + srcIndex] = void 0;
	    }
	}

	function Queue(capacity) {
	    this._capacity = capacity;
	    this._length = 0;
	    this._front = 0;
	}

	Queue.prototype._willBeOverCapacity = function (size) {
	    return this._capacity < size;
	};

	Queue.prototype._pushOne = function (arg) {
	    var length = this.length();
	    this._checkCapacity(length + 1);
	    var i = (this._front + length) & (this._capacity - 1);
	    this[i] = arg;
	    this._length = length + 1;
	};

	Queue.prototype.push = function (fn, receiver, arg) {
	    var length = this.length() + 3;
	    if (this._willBeOverCapacity(length)) {
	        this._pushOne(fn);
	        this._pushOne(receiver);
	        this._pushOne(arg);
	        return;
	    }
	    var j = this._front + length - 3;
	    this._checkCapacity(length);
	    var wrapMask = this._capacity - 1;
	    this[(j + 0) & wrapMask] = fn;
	    this[(j + 1) & wrapMask] = receiver;
	    this[(j + 2) & wrapMask] = arg;
	    this._length = length;
	};

	Queue.prototype.shift = function () {
	    var front = this._front,
	        ret = this[front];

	    this[front] = undefined;
	    this._front = (front + 1) & (this._capacity - 1);
	    this._length--;
	    return ret;
	};

	Queue.prototype.length = function () {
	    return this._length;
	};

	Queue.prototype._checkCapacity = function (size) {
	    if (this._capacity < size) {
	        this._resizeTo(this._capacity << 1);
	    }
	};

	Queue.prototype._resizeTo = function (capacity) {
	    var oldCapacity = this._capacity;
	    this._capacity = capacity;
	    var front = this._front;
	    var length = this._length;
	    var moveItemsCount = (front + length) & (oldCapacity - 1);
	    arrayMove(this, 0, this, oldCapacity, moveItemsCount);
	};

	module.exports = Queue;

	},{}],27:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(
	    Promise, INTERNAL, tryConvertToPromise, apiRejection) {
	var util = _dereq_("./util");

	var raceLater = function (promise) {
	    return promise.then(function(array) {
	        return race(array, promise);
	    });
	};

	function race(promises, parent) {
	    var maybePromise = tryConvertToPromise(promises);

	    if (maybePromise instanceof Promise) {
	        return raceLater(maybePromise);
	    } else {
	        promises = util.asArray(promises);
	        if (promises === null)
	            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
	    }

	    var ret = new Promise(INTERNAL);
	    if (parent !== undefined) {
	        ret._propagateFrom(parent, 3);
	    }
	    var fulfill = ret._fulfill;
	    var reject = ret._reject;
	    for (var i = 0, len = promises.length; i < len; ++i) {
	        var val = promises[i];

	        if (val === undefined && !(i in promises)) {
	            continue;
	        }

	        Promise.cast(val)._then(fulfill, reject, undefined, ret, null);
	    }
	    return ret;
	}

	Promise.race = function (promises) {
	    return race(promises, undefined);
	};

	Promise.prototype.race = function () {
	    return race(this, undefined);
	};

	};

	},{"./util":36}],28:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise,
	                          PromiseArray,
	                          apiRejection,
	                          tryConvertToPromise,
	                          INTERNAL,
	                          debug) {
	var getDomain = Promise._getDomain;
	var util = _dereq_("./util");
	var tryCatch = util.tryCatch;

	function ReductionPromiseArray(promises, fn, initialValue, _each) {
	    this.constructor$(promises);
	    var domain = getDomain();
	    this._fn = domain === null ? fn : util.domainBind(domain, fn);
	    if (initialValue !== undefined) {
	        initialValue = Promise.resolve(initialValue);
	        initialValue._attachCancellationCallback(this);
	    }
	    this._initialValue = initialValue;
	    this._currentCancellable = null;
	    if(_each === INTERNAL) {
	        this._eachValues = Array(this._length);
	    } else if (_each === 0) {
	        this._eachValues = null;
	    } else {
	        this._eachValues = undefined;
	    }
	    this._promise._captureStackTrace();
	    this._init$(undefined, -5);
	}
	util.inherits(ReductionPromiseArray, PromiseArray);

	ReductionPromiseArray.prototype._gotAccum = function(accum) {
	    if (this._eachValues !== undefined && 
	        this._eachValues !== null && 
	        accum !== INTERNAL) {
	        this._eachValues.push(accum);
	    }
	};

	ReductionPromiseArray.prototype._eachComplete = function(value) {
	    if (this._eachValues !== null) {
	        this._eachValues.push(value);
	    }
	    return this._eachValues;
	};

	ReductionPromiseArray.prototype._init = function() {};

	ReductionPromiseArray.prototype._resolveEmptyArray = function() {
	    this._resolve(this._eachValues !== undefined ? this._eachValues
	                                                 : this._initialValue);
	};

	ReductionPromiseArray.prototype.shouldCopyValues = function () {
	    return false;
	};

	ReductionPromiseArray.prototype._resolve = function(value) {
	    this._promise._resolveCallback(value);
	    this._values = null;
	};

	ReductionPromiseArray.prototype._resultCancelled = function(sender) {
	    if (sender === this._initialValue) return this._cancel();
	    if (this._isResolved()) return;
	    this._resultCancelled$();
	    if (this._currentCancellable instanceof Promise) {
	        this._currentCancellable.cancel();
	    }
	    if (this._initialValue instanceof Promise) {
	        this._initialValue.cancel();
	    }
	};

	ReductionPromiseArray.prototype._iterate = function (values) {
	    this._values = values;
	    var value;
	    var i;
	    var length = values.length;
	    if (this._initialValue !== undefined) {
	        value = this._initialValue;
	        i = 0;
	    } else {
	        value = Promise.resolve(values[0]);
	        i = 1;
	    }

	    this._currentCancellable = value;

	    if (!value.isRejected()) {
	        for (; i < length; ++i) {
	            var ctx = {
	                accum: null,
	                value: values[i],
	                index: i,
	                length: length,
	                array: this
	            };
	            value = value._then(gotAccum, undefined, undefined, ctx, undefined);
	        }
	    }

	    if (this._eachValues !== undefined) {
	        value = value
	            ._then(this._eachComplete, undefined, undefined, this, undefined);
	    }
	    value._then(completed, completed, undefined, value, this);
	};

	Promise.prototype.reduce = function (fn, initialValue) {
	    return reduce(this, fn, initialValue, null);
	};

	Promise.reduce = function (promises, fn, initialValue, _each) {
	    return reduce(promises, fn, initialValue, _each);
	};

	function completed(valueOrReason, array) {
	    if (this.isFulfilled()) {
	        array._resolve(valueOrReason);
	    } else {
	        array._reject(valueOrReason);
	    }
	}

	function reduce(promises, fn, initialValue, _each) {
	    if (typeof fn !== "function") {
	        return apiRejection("expecting a function but got " + util.classString(fn));
	    }
	    var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
	    return array.promise();
	}

	function gotAccum(accum) {
	    this.accum = accum;
	    this.array._gotAccum(accum);
	    var value = tryConvertToPromise(this.value, this.array._promise);
	    if (value instanceof Promise) {
	        this.array._currentCancellable = value;
	        return value._then(gotValue, undefined, undefined, this, undefined);
	    } else {
	        return gotValue.call(this, value);
	    }
	}

	function gotValue(value) {
	    var array = this.array;
	    var promise = array._promise;
	    var fn = tryCatch(array._fn);
	    promise._pushContext();
	    var ret;
	    if (array._eachValues !== undefined) {
	        ret = fn.call(promise._boundValue(), value, this.index, this.length);
	    } else {
	        ret = fn.call(promise._boundValue(),
	                              this.accum, value, this.index, this.length);
	    }
	    if (ret instanceof Promise) {
	        array._currentCancellable = ret;
	    }
	    var promiseCreated = promise._popContext();
	    debug.checkForgottenReturns(
	        ret,
	        promiseCreated,
	        array._eachValues !== undefined ? "Promise.each" : "Promise.reduce",
	        promise
	    );
	    return ret;
	}
	};

	},{"./util":36}],29:[function(_dereq_,module,exports){
	"use strict";
	var util = _dereq_("./util");
	var schedule;
	var noAsyncScheduler = function() {
	    throw new Error("No async scheduler available\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	};
	var NativePromise = util.getNativePromise();
	if (util.isNode && typeof MutationObserver === "undefined") {
	    var GlobalSetImmediate = global.setImmediate;
	    var ProcessNextTick = process.nextTick;
	    schedule = util.isRecentNode
	                ? function(fn) { GlobalSetImmediate.call(global, fn); }
	                : function(fn) { ProcessNextTick.call(process, fn); };
	} else if (typeof NativePromise === "function" &&
	           typeof NativePromise.resolve === "function") {
	    var nativePromise = NativePromise.resolve();
	    schedule = function(fn) {
	        nativePromise.then(fn);
	    };
	} else if ((typeof MutationObserver !== "undefined") &&
	          !(typeof window !== "undefined" &&
	            window.navigator &&
	            (window.navigator.standalone || window.cordova))) {
	    schedule = (function() {
	        var div = document.createElement("div");
	        var opts = {attributes: true};
	        var toggleScheduled = false;
	        var div2 = document.createElement("div");
	        var o2 = new MutationObserver(function() {
	            div.classList.toggle("foo");
	            toggleScheduled = false;
	        });
	        o2.observe(div2, opts);

	        var scheduleToggle = function() {
	            if (toggleScheduled) return;
	                toggleScheduled = true;
	                div2.classList.toggle("foo");
	            };

	            return function schedule(fn) {
	            var o = new MutationObserver(function() {
	                o.disconnect();
	                fn();
	            });
	            o.observe(div, opts);
	            scheduleToggle();
	        };
	    })();
	} else if (typeof setImmediate !== "undefined") {
	    schedule = function (fn) {
	        setImmediate(fn);
	    };
	} else if (typeof setTimeout !== "undefined") {
	    schedule = function (fn) {
	        setTimeout(fn, 0);
	    };
	} else {
	    schedule = noAsyncScheduler;
	}
	module.exports = schedule;

	},{"./util":36}],30:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	    function(Promise, PromiseArray, debug) {
	var PromiseInspection = Promise.PromiseInspection;
	var util = _dereq_("./util");

	function SettledPromiseArray(values) {
	    this.constructor$(values);
	}
	util.inherits(SettledPromiseArray, PromiseArray);

	SettledPromiseArray.prototype._promiseResolved = function (index, inspection) {
	    this._values[index] = inspection;
	    var totalResolved = ++this._totalResolved;
	    if (totalResolved >= this._length) {
	        this._resolve(this._values);
	        return true;
	    }
	    return false;
	};

	SettledPromiseArray.prototype._promiseFulfilled = function (value, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 33554432;
	    ret._settledValueField = value;
	    return this._promiseResolved(index, ret);
	};
	SettledPromiseArray.prototype._promiseRejected = function (reason, index) {
	    var ret = new PromiseInspection();
	    ret._bitField = 16777216;
	    ret._settledValueField = reason;
	    return this._promiseResolved(index, ret);
	};

	Promise.settle = function (promises) {
	    debug.deprecated(".settle()", ".reflect()");
	    return new SettledPromiseArray(promises).promise();
	};

	Promise.prototype.settle = function () {
	    return Promise.settle(this);
	};
	};

	},{"./util":36}],31:[function(_dereq_,module,exports){
	"use strict";
	module.exports =
	function(Promise, PromiseArray, apiRejection) {
	var util = _dereq_("./util");
	var RangeError = _dereq_("./errors").RangeError;
	var AggregateError = _dereq_("./errors").AggregateError;
	var isArray = util.isArray;
	var CANCELLATION = {};


	function SomePromiseArray(values) {
	    this.constructor$(values);
	    this._howMany = 0;
	    this._unwrap = false;
	    this._initialized = false;
	}
	util.inherits(SomePromiseArray, PromiseArray);

	SomePromiseArray.prototype._init = function () {
	    if (!this._initialized) {
	        return;
	    }
	    if (this._howMany === 0) {
	        this._resolve([]);
	        return;
	    }
	    this._init$(undefined, -5);
	    var isArrayResolved = isArray(this._values);
	    if (!this._isResolved() &&
	        isArrayResolved &&
	        this._howMany > this._canPossiblyFulfill()) {
	        this._reject(this._getRangeError(this.length()));
	    }
	};

	SomePromiseArray.prototype.init = function () {
	    this._initialized = true;
	    this._init();
	};

	SomePromiseArray.prototype.setUnwrap = function () {
	    this._unwrap = true;
	};

	SomePromiseArray.prototype.howMany = function () {
	    return this._howMany;
	};

	SomePromiseArray.prototype.setHowMany = function (count) {
	    this._howMany = count;
	};

	SomePromiseArray.prototype._promiseFulfilled = function (value) {
	    this._addFulfilled(value);
	    if (this._fulfilled() === this.howMany()) {
	        this._values.length = this.howMany();
	        if (this.howMany() === 1 && this._unwrap) {
	            this._resolve(this._values[0]);
	        } else {
	            this._resolve(this._values);
	        }
	        return true;
	    }
	    return false;

	};
	SomePromiseArray.prototype._promiseRejected = function (reason) {
	    this._addRejected(reason);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._promiseCancelled = function () {
	    if (this._values instanceof Promise || this._values == null) {
	        return this._cancel();
	    }
	    this._addRejected(CANCELLATION);
	    return this._checkOutcome();
	};

	SomePromiseArray.prototype._checkOutcome = function() {
	    if (this.howMany() > this._canPossiblyFulfill()) {
	        var e = new AggregateError();
	        for (var i = this.length(); i < this._values.length; ++i) {
	            if (this._values[i] !== CANCELLATION) {
	                e.push(this._values[i]);
	            }
	        }
	        if (e.length > 0) {
	            this._reject(e);
	        } else {
	            this._cancel();
	        }
	        return true;
	    }
	    return false;
	};

	SomePromiseArray.prototype._fulfilled = function () {
	    return this._totalResolved;
	};

	SomePromiseArray.prototype._rejected = function () {
	    return this._values.length - this.length();
	};

	SomePromiseArray.prototype._addRejected = function (reason) {
	    this._values.push(reason);
	};

	SomePromiseArray.prototype._addFulfilled = function (value) {
	    this._values[this._totalResolved++] = value;
	};

	SomePromiseArray.prototype._canPossiblyFulfill = function () {
	    return this.length() - this._rejected();
	};

	SomePromiseArray.prototype._getRangeError = function (count) {
	    var message = "Input array must contain at least " +
	            this._howMany + " items but contains only " + count + " items";
	    return new RangeError(message);
	};

	SomePromiseArray.prototype._resolveEmptyArray = function () {
	    this._reject(this._getRangeError(0));
	};

	function some(promises, howMany) {
	    if ((howMany | 0) !== howMany || howMany < 0) {
	        return apiRejection("expecting a positive integer\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    var ret = new SomePromiseArray(promises);
	    var promise = ret.promise();
	    ret.setHowMany(howMany);
	    ret.init();
	    return promise;
	}

	Promise.some = function (promises, howMany) {
	    return some(promises, howMany);
	};

	Promise.prototype.some = function (howMany) {
	    return some(this, howMany);
	};

	Promise._SomePromiseArray = SomePromiseArray;
	};

	},{"./errors":12,"./util":36}],32:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise) {
	function PromiseInspection(promise) {
	    if (promise !== undefined) {
	        promise = promise._target();
	        this._bitField = promise._bitField;
	        this._settledValueField = promise._isFateSealed()
	            ? promise._settledValue() : undefined;
	    }
	    else {
	        this._bitField = 0;
	        this._settledValueField = undefined;
	    }
	}

	PromiseInspection.prototype._settledValue = function() {
	    return this._settledValueField;
	};

	var value = PromiseInspection.prototype.value = function () {
	    if (!this.isFulfilled()) {
	        throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var reason = PromiseInspection.prototype.error =
	PromiseInspection.prototype.reason = function () {
	    if (!this.isRejected()) {
	        throw new TypeError("cannot get rejection reason of a non-rejected promise\u000a\u000a    See http://goo.gl/MqrFmX\u000a");
	    }
	    return this._settledValue();
	};

	var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
	    return (this._bitField & 33554432) !== 0;
	};

	var isRejected = PromiseInspection.prototype.isRejected = function () {
	    return (this._bitField & 16777216) !== 0;
	};

	var isPending = PromiseInspection.prototype.isPending = function () {
	    return (this._bitField & 50397184) === 0;
	};

	var isResolved = PromiseInspection.prototype.isResolved = function () {
	    return (this._bitField & 50331648) !== 0;
	};

	PromiseInspection.prototype.isCancelled = function() {
	    return (this._bitField & 8454144) !== 0;
	};

	Promise.prototype.__isCancelled = function() {
	    return (this._bitField & 65536) === 65536;
	};

	Promise.prototype._isCancelled = function() {
	    return this._target().__isCancelled();
	};

	Promise.prototype.isCancelled = function() {
	    return (this._target()._bitField & 8454144) !== 0;
	};

	Promise.prototype.isPending = function() {
	    return isPending.call(this._target());
	};

	Promise.prototype.isRejected = function() {
	    return isRejected.call(this._target());
	};

	Promise.prototype.isFulfilled = function() {
	    return isFulfilled.call(this._target());
	};

	Promise.prototype.isResolved = function() {
	    return isResolved.call(this._target());
	};

	Promise.prototype.value = function() {
	    return value.call(this._target());
	};

	Promise.prototype.reason = function() {
	    var target = this._target();
	    target._unsetRejectionIsUnhandled();
	    return reason.call(target);
	};

	Promise.prototype._value = function() {
	    return this._settledValue();
	};

	Promise.prototype._reason = function() {
	    this._unsetRejectionIsUnhandled();
	    return this._settledValue();
	};

	Promise.PromiseInspection = PromiseInspection;
	};

	},{}],33:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL) {
	var util = _dereq_("./util");
	var errorObj = util.errorObj;
	var isObject = util.isObject;

	function tryConvertToPromise(obj, context) {
	    if (isObject(obj)) {
	        if (obj instanceof Promise) return obj;
	        var then = getThen(obj);
	        if (then === errorObj) {
	            if (context) context._pushContext();
	            var ret = Promise.reject(then.e);
	            if (context) context._popContext();
	            return ret;
	        } else if (typeof then === "function") {
	            if (isAnyBluebirdPromise(obj)) {
	                var ret = new Promise(INTERNAL);
	                obj._then(
	                    ret._fulfill,
	                    ret._reject,
	                    undefined,
	                    ret,
	                    null
	                );
	                return ret;
	            }
	            return doThenable(obj, then, context);
	        }
	    }
	    return obj;
	}

	function doGetThen(obj) {
	    return obj.then;
	}

	function getThen(obj) {
	    try {
	        return doGetThen(obj);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}

	var hasProp = {}.hasOwnProperty;
	function isAnyBluebirdPromise(obj) {
	    try {
	        return hasProp.call(obj, "_promise0");
	    } catch (e) {
	        return false;
	    }
	}

	function doThenable(x, then, context) {
	    var promise = new Promise(INTERNAL);
	    var ret = promise;
	    if (context) context._pushContext();
	    promise._captureStackTrace();
	    if (context) context._popContext();
	    var synchronous = true;
	    var result = util.tryCatch(then).call(x, resolve, reject);
	    synchronous = false;

	    if (promise && result === errorObj) {
	        promise._rejectCallback(result.e, true, true);
	        promise = null;
	    }

	    function resolve(value) {
	        if (!promise) return;
	        promise._resolveCallback(value);
	        promise = null;
	    }

	    function reject(reason) {
	        if (!promise) return;
	        promise._rejectCallback(reason, synchronous, true);
	        promise = null;
	    }
	    return ret;
	}

	return tryConvertToPromise;
	};

	},{"./util":36}],34:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function(Promise, INTERNAL, debug) {
	var util = _dereq_("./util");
	var TimeoutError = Promise.TimeoutError;

	function HandleWrapper(handle)  {
	    this.handle = handle;
	}

	HandleWrapper.prototype._resultCancelled = function() {
	    clearTimeout(this.handle);
	};

	var afterValue = function(value) { return delay(+this).thenReturn(value); };
	var delay = Promise.delay = function (ms, value) {
	    var ret;
	    var handle;
	    if (value !== undefined) {
	        ret = Promise.resolve(value)
	                ._then(afterValue, null, null, ms, undefined);
	        if (debug.cancellation() && value instanceof Promise) {
	            ret._setOnCancel(value);
	        }
	    } else {
	        ret = new Promise(INTERNAL);
	        handle = setTimeout(function() { ret._fulfill(); }, +ms);
	        if (debug.cancellation()) {
	            ret._setOnCancel(new HandleWrapper(handle));
	        }
	        ret._captureStackTrace();
	    }
	    ret._setAsyncGuaranteed();
	    return ret;
	};

	Promise.prototype.delay = function (ms) {
	    return delay(ms, this);
	};

	var afterTimeout = function (promise, message, parent) {
	    var err;
	    if (typeof message !== "string") {
	        if (message instanceof Error) {
	            err = message;
	        } else {
	            err = new TimeoutError("operation timed out");
	        }
	    } else {
	        err = new TimeoutError(message);
	    }
	    util.markAsOriginatingFromRejection(err);
	    promise._attachExtraTrace(err);
	    promise._reject(err);

	    if (parent != null) {
	        parent.cancel();
	    }
	};

	function successClear(value) {
	    clearTimeout(this.handle);
	    return value;
	}

	function failureClear(reason) {
	    clearTimeout(this.handle);
	    throw reason;
	}

	Promise.prototype.timeout = function (ms, message) {
	    ms = +ms;
	    var ret, parent;

	    var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
	        if (ret.isPending()) {
	            afterTimeout(ret, message, parent);
	        }
	    }, ms));

	    if (debug.cancellation()) {
	        parent = this.then();
	        ret = parent._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	        ret._setOnCancel(handleWrapper);
	    } else {
	        ret = this._then(successClear, failureClear,
	                            undefined, handleWrapper, undefined);
	    }

	    return ret;
	};

	};

	},{"./util":36}],35:[function(_dereq_,module,exports){
	"use strict";
	module.exports = function (Promise, apiRejection, tryConvertToPromise,
	    createContext, INTERNAL, debug) {
	    var util = _dereq_("./util");
	    var TypeError = _dereq_("./errors").TypeError;
	    var inherits = _dereq_("./util").inherits;
	    var errorObj = util.errorObj;
	    var tryCatch = util.tryCatch;
	    var NULL = {};

	    function thrower(e) {
	        setTimeout(function(){throw e;}, 0);
	    }

	    function castPreservingDisposable(thenable) {
	        var maybePromise = tryConvertToPromise(thenable);
	        if (maybePromise !== thenable &&
	            typeof thenable._isDisposable === "function" &&
	            typeof thenable._getDisposer === "function" &&
	            thenable._isDisposable()) {
	            maybePromise._setDisposable(thenable._getDisposer());
	        }
	        return maybePromise;
	    }
	    function dispose(resources, inspection) {
	        var i = 0;
	        var len = resources.length;
	        var ret = new Promise(INTERNAL);
	        function iterator() {
	            if (i >= len) return ret._fulfill();
	            var maybePromise = castPreservingDisposable(resources[i++]);
	            if (maybePromise instanceof Promise &&
	                maybePromise._isDisposable()) {
	                try {
	                    maybePromise = tryConvertToPromise(
	                        maybePromise._getDisposer().tryDispose(inspection),
	                        resources.promise);
	                } catch (e) {
	                    return thrower(e);
	                }
	                if (maybePromise instanceof Promise) {
	                    return maybePromise._then(iterator, thrower,
	                                              null, null, null);
	                }
	            }
	            iterator();
	        }
	        iterator();
	        return ret;
	    }

	    function Disposer(data, promise, context) {
	        this._data = data;
	        this._promise = promise;
	        this._context = context;
	    }

	    Disposer.prototype.data = function () {
	        return this._data;
	    };

	    Disposer.prototype.promise = function () {
	        return this._promise;
	    };

	    Disposer.prototype.resource = function () {
	        if (this.promise().isFulfilled()) {
	            return this.promise().value();
	        }
	        return NULL;
	    };

	    Disposer.prototype.tryDispose = function(inspection) {
	        var resource = this.resource();
	        var context = this._context;
	        if (context !== undefined) context._pushContext();
	        var ret = resource !== NULL
	            ? this.doDispose(resource, inspection) : null;
	        if (context !== undefined) context._popContext();
	        this._promise._unsetDisposable();
	        this._data = null;
	        return ret;
	    };

	    Disposer.isDisposer = function (d) {
	        return (d != null &&
	                typeof d.resource === "function" &&
	                typeof d.tryDispose === "function");
	    };

	    function FunctionDisposer(fn, promise, context) {
	        this.constructor$(fn, promise, context);
	    }
	    inherits(FunctionDisposer, Disposer);

	    FunctionDisposer.prototype.doDispose = function (resource, inspection) {
	        var fn = this.data();
	        return fn.call(resource, resource, inspection);
	    };

	    function maybeUnwrapDisposer(value) {
	        if (Disposer.isDisposer(value)) {
	            this.resources[this.index]._setDisposable(value);
	            return value.promise();
	        }
	        return value;
	    }

	    function ResourceList(length) {
	        this.length = length;
	        this.promise = null;
	        this[length-1] = null;
	    }

	    ResourceList.prototype._resultCancelled = function() {
	        var len = this.length;
	        for (var i = 0; i < len; ++i) {
	            var item = this[i];
	            if (item instanceof Promise) {
	                item.cancel();
	            }
	        }
	    };

	    Promise.using = function () {
	        var len = arguments.length;
	        if (len < 2) return apiRejection(
	                        "you must pass at least 2 arguments to Promise.using");
	        var fn = arguments[len - 1];
	        if (typeof fn !== "function") {
	            return apiRejection("expecting a function but got " + util.classString(fn));
	        }
	        var input;
	        var spreadArgs = true;
	        if (len === 2 && Array.isArray(arguments[0])) {
	            input = arguments[0];
	            len = input.length;
	            spreadArgs = false;
	        } else {
	            input = arguments;
	            len--;
	        }
	        var resources = new ResourceList(len);
	        for (var i = 0; i < len; ++i) {
	            var resource = input[i];
	            if (Disposer.isDisposer(resource)) {
	                var disposer = resource;
	                resource = resource.promise();
	                resource._setDisposable(disposer);
	            } else {
	                var maybePromise = tryConvertToPromise(resource);
	                if (maybePromise instanceof Promise) {
	                    resource =
	                        maybePromise._then(maybeUnwrapDisposer, null, null, {
	                            resources: resources,
	                            index: i
	                    }, undefined);
	                }
	            }
	            resources[i] = resource;
	        }

	        var reflectedResources = new Array(resources.length);
	        for (var i = 0; i < reflectedResources.length; ++i) {
	            reflectedResources[i] = Promise.resolve(resources[i]).reflect();
	        }

	        var resultPromise = Promise.all(reflectedResources)
	            .then(function(inspections) {
	                for (var i = 0; i < inspections.length; ++i) {
	                    var inspection = inspections[i];
	                    if (inspection.isRejected()) {
	                        errorObj.e = inspection.error();
	                        return errorObj;
	                    } else if (!inspection.isFulfilled()) {
	                        resultPromise.cancel();
	                        return;
	                    }
	                    inspections[i] = inspection.value();
	                }
	                promise._pushContext();

	                fn = tryCatch(fn);
	                var ret = spreadArgs
	                    ? fn.apply(undefined, inspections) : fn(inspections);
	                var promiseCreated = promise._popContext();
	                debug.checkForgottenReturns(
	                    ret, promiseCreated, "Promise.using", promise);
	                return ret;
	            });

	        var promise = resultPromise.lastly(function() {
	            var inspection = new Promise.PromiseInspection(resultPromise);
	            return dispose(resources, inspection);
	        });
	        resources.promise = promise;
	        promise._setOnCancel(resources);
	        return promise;
	    };

	    Promise.prototype._setDisposable = function (disposer) {
	        this._bitField = this._bitField | 131072;
	        this._disposer = disposer;
	    };

	    Promise.prototype._isDisposable = function () {
	        return (this._bitField & 131072) > 0;
	    };

	    Promise.prototype._getDisposer = function () {
	        return this._disposer;
	    };

	    Promise.prototype._unsetDisposable = function () {
	        this._bitField = this._bitField & (~131072);
	        this._disposer = undefined;
	    };

	    Promise.prototype.disposer = function (fn) {
	        if (typeof fn === "function") {
	            return new FunctionDisposer(fn, this, createContext());
	        }
	        throw new TypeError();
	    };

	};

	},{"./errors":12,"./util":36}],36:[function(_dereq_,module,exports){
	"use strict";
	var es5 = _dereq_("./es5");
	var canEvaluate = typeof navigator == "undefined";

	var errorObj = {e: {}};
	var tryCatchTarget;
	var globalObject = typeof self !== "undefined" ? self :
	    typeof window !== "undefined" ? window :
	    typeof global !== "undefined" ? global :
	    this !== undefined ? this : null;

	function tryCatcher() {
	    try {
	        var target = tryCatchTarget;
	        tryCatchTarget = null;
	        return target.apply(this, arguments);
	    } catch (e) {
	        errorObj.e = e;
	        return errorObj;
	    }
	}
	function tryCatch(fn) {
	    tryCatchTarget = fn;
	    return tryCatcher;
	}

	var inherits = function(Child, Parent) {
	    var hasProp = {}.hasOwnProperty;

	    function T() {
	        this.constructor = Child;
	        this.constructor$ = Parent;
	        for (var propertyName in Parent.prototype) {
	            if (hasProp.call(Parent.prototype, propertyName) &&
	                propertyName.charAt(propertyName.length-1) !== "$"
	           ) {
	                this[propertyName + "$"] = Parent.prototype[propertyName];
	            }
	        }
	    }
	    T.prototype = Parent.prototype;
	    Child.prototype = new T();
	    return Child.prototype;
	};


	function isPrimitive(val) {
	    return val == null || val === true || val === false ||
	        typeof val === "string" || typeof val === "number";

	}

	function isObject(value) {
	    return typeof value === "function" ||
	           typeof value === "object" && value !== null;
	}

	function maybeWrapAsError(maybeError) {
	    if (!isPrimitive(maybeError)) return maybeError;

	    return new Error(safeToString(maybeError));
	}

	function withAppended(target, appendee) {
	    var len = target.length;
	    var ret = new Array(len + 1);
	    var i;
	    for (i = 0; i < len; ++i) {
	        ret[i] = target[i];
	    }
	    ret[i] = appendee;
	    return ret;
	}

	function getDataPropertyOrDefault(obj, key, defaultValue) {
	    if (es5.isES5) {
	        var desc = Object.getOwnPropertyDescriptor(obj, key);

	        if (desc != null) {
	            return desc.get == null && desc.set == null
	                    ? desc.value
	                    : defaultValue;
	        }
	    } else {
	        return {}.hasOwnProperty.call(obj, key) ? obj[key] : undefined;
	    }
	}

	function notEnumerableProp(obj, name, value) {
	    if (isPrimitive(obj)) return obj;
	    var descriptor = {
	        value: value,
	        configurable: true,
	        enumerable: false,
	        writable: true
	    };
	    es5.defineProperty(obj, name, descriptor);
	    return obj;
	}

	function thrower(r) {
	    throw r;
	}

	var inheritedDataKeys = (function() {
	    var excludedPrototypes = [
	        Array.prototype,
	        Object.prototype,
	        Function.prototype
	    ];

	    var isExcludedProto = function(val) {
	        for (var i = 0; i < excludedPrototypes.length; ++i) {
	            if (excludedPrototypes[i] === val) {
	                return true;
	            }
	        }
	        return false;
	    };

	    if (es5.isES5) {
	        var getKeys = Object.getOwnPropertyNames;
	        return function(obj) {
	            var ret = [];
	            var visitedKeys = Object.create(null);
	            while (obj != null && !isExcludedProto(obj)) {
	                var keys;
	                try {
	                    keys = getKeys(obj);
	                } catch (e) {
	                    return ret;
	                }
	                for (var i = 0; i < keys.length; ++i) {
	                    var key = keys[i];
	                    if (visitedKeys[key]) continue;
	                    visitedKeys[key] = true;
	                    var desc = Object.getOwnPropertyDescriptor(obj, key);
	                    if (desc != null && desc.get == null && desc.set == null) {
	                        ret.push(key);
	                    }
	                }
	                obj = es5.getPrototypeOf(obj);
	            }
	            return ret;
	        };
	    } else {
	        var hasProp = {}.hasOwnProperty;
	        return function(obj) {
	            if (isExcludedProto(obj)) return [];
	            var ret = [];

	            /*jshint forin:false */
	            enumeration: for (var key in obj) {
	                if (hasProp.call(obj, key)) {
	                    ret.push(key);
	                } else {
	                    for (var i = 0; i < excludedPrototypes.length; ++i) {
	                        if (hasProp.call(excludedPrototypes[i], key)) {
	                            continue enumeration;
	                        }
	                    }
	                    ret.push(key);
	                }
	            }
	            return ret;
	        };
	    }

	})();

	var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
	function isClass(fn) {
	    try {
	        if (typeof fn === "function") {
	            var keys = es5.names(fn.prototype);

	            var hasMethods = es5.isES5 && keys.length > 1;
	            var hasMethodsOtherThanConstructor = keys.length > 0 &&
	                !(keys.length === 1 && keys[0] === "constructor");
	            var hasThisAssignmentAndStaticMethods =
	                thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;

	            if (hasMethods || hasMethodsOtherThanConstructor ||
	                hasThisAssignmentAndStaticMethods) {
	                return true;
	            }
	        }
	        return false;
	    } catch (e) {
	        return false;
	    }
	}

	function toFastProperties(obj) {
	    /*jshint -W027,-W055,-W031*/
	    function FakeConstructor() {}
	    FakeConstructor.prototype = obj;
	    var l = 8;
	    while (l--) new FakeConstructor();
	    return obj;
	    eval(obj);
	}

	var rident = /^[a-z$_][a-z$_0-9]*$/i;
	function isIdentifier(str) {
	    return rident.test(str);
	}

	function filledRange(count, prefix, suffix) {
	    var ret = new Array(count);
	    for(var i = 0; i < count; ++i) {
	        ret[i] = prefix + i + suffix;
	    }
	    return ret;
	}

	function safeToString(obj) {
	    try {
	        return obj + "";
	    } catch (e) {
	        return "[no string representation]";
	    }
	}

	function isError(obj) {
	    return obj !== null &&
	           typeof obj === "object" &&
	           typeof obj.message === "string" &&
	           typeof obj.name === "string";
	}

	function markAsOriginatingFromRejection(e) {
	    try {
	        notEnumerableProp(e, "isOperational", true);
	    }
	    catch(ignore) {}
	}

	function originatesFromRejection(e) {
	    if (e == null) return false;
	    return ((e instanceof Error["__BluebirdErrorTypes__"].OperationalError) ||
	        e["isOperational"] === true);
	}

	function canAttachTrace(obj) {
	    return isError(obj) && es5.propertyIsWritable(obj, "stack");
	}

	var ensureErrorObject = (function() {
	    if (!("stack" in new Error())) {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            try {throw new Error(safeToString(value));}
	            catch(err) {return err;}
	        };
	    } else {
	        return function(value) {
	            if (canAttachTrace(value)) return value;
	            return new Error(safeToString(value));
	        };
	    }
	})();

	function classString(obj) {
	    return {}.toString.call(obj);
	}

	function copyDescriptors(from, to, filter) {
	    var keys = es5.names(from);
	    for (var i = 0; i < keys.length; ++i) {
	        var key = keys[i];
	        if (filter(key)) {
	            try {
	                es5.defineProperty(to, key, es5.getDescriptor(from, key));
	            } catch (ignore) {}
	        }
	    }
	}

	var asArray = function(v) {
	    if (es5.isArray(v)) {
	        return v;
	    }
	    return null;
	};

	if (typeof Symbol !== "undefined" && Symbol.iterator) {
	    var ArrayFrom = typeof Array.from === "function" ? function(v) {
	        return Array.from(v);
	    } : function(v) {
	        var ret = [];
	        var it = v[Symbol.iterator]();
	        var itResult;
	        while (!((itResult = it.next()).done)) {
	            ret.push(itResult.value);
	        }
	        return ret;
	    };

	    asArray = function(v) {
	        if (es5.isArray(v)) {
	            return v;
	        } else if (v != null && typeof v[Symbol.iterator] === "function") {
	            return ArrayFrom(v);
	        }
	        return null;
	    };
	}

	var isNode = typeof process !== "undefined" &&
	        classString(process).toLowerCase() === "[object process]";

	var hasEnvVariables = typeof process !== "undefined" &&
	    typeof process.env !== "undefined";

	function env(key) {
	    return hasEnvVariables ? process.env[key] : undefined;
	}

	function getNativePromise() {
	    if (typeof Promise === "function") {
	        try {
	            var promise = new Promise(function(){});
	            if ({}.toString.call(promise) === "[object Promise]") {
	                return Promise;
	            }
	        } catch (e) {}
	    }
	}

	function domainBind(self, cb) {
	    return self.bind(cb);
	}

	var ret = {
	    isClass: isClass,
	    isIdentifier: isIdentifier,
	    inheritedDataKeys: inheritedDataKeys,
	    getDataPropertyOrDefault: getDataPropertyOrDefault,
	    thrower: thrower,
	    isArray: es5.isArray,
	    asArray: asArray,
	    notEnumerableProp: notEnumerableProp,
	    isPrimitive: isPrimitive,
	    isObject: isObject,
	    isError: isError,
	    canEvaluate: canEvaluate,
	    errorObj: errorObj,
	    tryCatch: tryCatch,
	    inherits: inherits,
	    withAppended: withAppended,
	    maybeWrapAsError: maybeWrapAsError,
	    toFastProperties: toFastProperties,
	    filledRange: filledRange,
	    toString: safeToString,
	    canAttachTrace: canAttachTrace,
	    ensureErrorObject: ensureErrorObject,
	    originatesFromRejection: originatesFromRejection,
	    markAsOriginatingFromRejection: markAsOriginatingFromRejection,
	    classString: classString,
	    copyDescriptors: copyDescriptors,
	    hasDevTools: typeof chrome !== "undefined" && chrome &&
	                 typeof chrome.loadTimes === "function",
	    isNode: isNode,
	    hasEnvVariables: hasEnvVariables,
	    env: env,
	    global: globalObject,
	    getNativePromise: getNativePromise,
	    domainBind: domainBind
	};
	ret.isRecentNode = ret.isNode && (function() {
	    var version = process.versions.node.split(".").map(Number);
	    return (version[0] === 0 && version[1] > 10) || (version[0] > 0);
	})();

	if (ret.isNode) ret.toFastProperties(process);

	try {throw new Error(); } catch (e) {ret.lastLineError = e;}
	module.exports = ret;

	},{"./es5":13}]},{},[4])(4)
	});                    ;if (typeof window !== 'undefined' && window !== null) {                               window.P = window.Promise;                                                     } else if (typeof self !== 'undefined' && self !== null) {                             self.P = self.Promise;                                                         }
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), (function() { return this; }()), __webpack_require__(34).setImmediate))

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	var concatMap = __webpack_require__(139);
	var balanced = __webpack_require__(133);

	module.exports = expandTop;

	var escSlash = '\0SLASH'+Math.random()+'\0';
	var escOpen = '\0OPEN'+Math.random()+'\0';
	var escClose = '\0CLOSE'+Math.random()+'\0';
	var escComma = '\0COMMA'+Math.random()+'\0';
	var escPeriod = '\0PERIOD'+Math.random()+'\0';

	function numeric(str) {
	  return parseInt(str, 10) == str
	    ? parseInt(str, 10)
	    : str.charCodeAt(0);
	}

	function escapeBraces(str) {
	  return str.split('\\\\').join(escSlash)
	            .split('\\{').join(escOpen)
	            .split('\\}').join(escClose)
	            .split('\\,').join(escComma)
	            .split('\\.').join(escPeriod);
	}

	function unescapeBraces(str) {
	  return str.split(escSlash).join('\\')
	            .split(escOpen).join('{')
	            .split(escClose).join('}')
	            .split(escComma).join(',')
	            .split(escPeriod).join('.');
	}


	// Basically just str.split(","), but handling cases
	// where we have nested braced sections, which should be
	// treated as individual members, like {a,{b,c},d}
	function parseCommaParts(str) {
	  if (!str)
	    return [''];

	  var parts = [];
	  var m = balanced('{', '}', str);

	  if (!m)
	    return str.split(',');

	  var pre = m.pre;
	  var body = m.body;
	  var post = m.post;
	  var p = pre.split(',');

	  p[p.length-1] += '{' + body + '}';
	  var postParts = parseCommaParts(post);
	  if (post.length) {
	    p[p.length-1] += postParts.shift();
	    p.push.apply(p, postParts);
	  }

	  parts.push.apply(parts, p);

	  return parts;
	}

	function expandTop(str) {
	  if (!str)
	    return [];

	  // I don't know why Bash 4.3 does this, but it does.
	  // Anything starting with {} will have the first two bytes preserved
	  // but *only* at the top level, so {},a}b will not expand to anything,
	  // but a{},b}c will be expanded to [a}c,abc].
	  // One could argue that this is a bug in Bash, but since the goal of
	  // this module is to match Bash's rules, we escape a leading {}
	  if (str.substr(0, 2) === '{}') {
	    str = '\\{\\}' + str.substr(2);
	  }

	  return expand(escapeBraces(str), true).map(unescapeBraces);
	}

	function identity(e) {
	  return e;
	}

	function embrace(str) {
	  return '{' + str + '}';
	}
	function isPadded(el) {
	  return /^-?0\d/.test(el);
	}

	function lte(i, y) {
	  return i <= y;
	}
	function gte(i, y) {
	  return i >= y;
	}

	function expand(str, isTop) {
	  var expansions = [];

	  var m = balanced('{', '}', str);
	  if (!m || /\$$/.test(m.pre)) return [str];

	  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
	  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
	  var isSequence = isNumericSequence || isAlphaSequence;
	  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
	  if (!isSequence && !isOptions) {
	    // {a},b}
	    if (m.post.match(/,.*\}/)) {
	      str = m.pre + '{' + m.body + escClose + m.post;
	      return expand(str);
	    }
	    return [str];
	  }

	  var n;
	  if (isSequence) {
	    n = m.body.split(/\.\./);
	  } else {
	    n = parseCommaParts(m.body);
	    if (n.length === 1) {
	      // x{{a,b}}y ==> x{a}y x{b}y
	      n = expand(n[0], false).map(embrace);
	      if (n.length === 1) {
	        var post = m.post.length
	          ? expand(m.post, false)
	          : [''];
	        return post.map(function(p) {
	          return m.pre + n[0] + p;
	        });
	      }
	    }
	  }

	  // at this point, n is the parts, and we know it's not a comma set
	  // with a single entry.

	  // no need to expand pre, since it is guaranteed to be free of brace-sets
	  var pre = m.pre;
	  var post = m.post.length
	    ? expand(m.post, false)
	    : [''];

	  var N;

	  if (isSequence) {
	    var x = numeric(n[0]);
	    var y = numeric(n[1]);
	    var width = Math.max(n[0].length, n[1].length)
	    var incr = n.length == 3
	      ? Math.abs(numeric(n[2]))
	      : 1;
	    var test = lte;
	    var reverse = y < x;
	    if (reverse) {
	      incr *= -1;
	      test = gte;
	    }
	    var pad = n.some(isPadded);

	    N = [];

	    for (var i = x; test(i, y); i += incr) {
	      var c;
	      if (isAlphaSequence) {
	        c = String.fromCharCode(i);
	        if (c === '\\')
	          c = '';
	      } else {
	        c = String(i);
	        if (pad) {
	          var need = width - c.length;
	          if (need > 0) {
	            var z = new Array(need + 1).join('0');
	            if (i < 0)
	              c = '-' + z + c.slice(1);
	            else
	              c = z + c;
	          }
	        }
	      }
	      N.push(c);
	    }
	  } else {
	    N = concatMap(n, function(el) { return expand(el, false) });
	  }

	  for (var j = 0; j < N.length; j++) {
	    for (var k = 0; k < post.length; k++) {
	      var expansion = pre + N[j] + post[k];
	      if (!isTop || isSequence || expansion)
	        expansions.push(expansion);
	    }
	  }

	  return expansions;
	}



/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	var argv = process.argv;

	var terminator = argv.indexOf('--');
	var hasFlag = function (flag) {
		flag = '--' + flag;
		var pos = argv.indexOf(flag);
		return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
	};

	module.exports = (function () {
		if ('FORCE_COLOR' in process.env) {
			return true;
		}

		if (hasFlag('no-color') ||
			hasFlag('no-colors') ||
			hasFlag('color=false')) {
			return false;
		}

		if (hasFlag('color') ||
			hasFlag('colors') ||
			hasFlag('color=true') ||
			hasFlag('color=always')) {
			return true;
		}

		if (process.stdout && !process.stdout.isTTY) {
			return false;
		}

		if (process.platform === 'win32') {
			return true;
		}

		if ('COLORTERM' in process.env) {
			return true;
		}

		if (process.env.TERM === 'dumb') {
			return false;
		}

		if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
			return true;
		}

		return false;
	})();

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 139 */
/***/ function(module, exports) {

	module.exports = function (xs, fn) {
	    var res = [];
	    for (var i = 0; i < xs.length; i++) {
	        var x = fn(xs[i], i);
	        if (isArray(x)) res.push.apply(res, x);
	        else res.push(x);
	    }
	    return res;
	};

	var isArray = Array.isArray || function (xs) {
	    return Object.prototype.toString.call(xs) === '[object Array]';
	};


/***/ },
/* 140 */
/***/ function(module, exports) {

	module.exports = function cleanAtrule(node, item, list) {
	    if (node.block) {
	        // otherwise removed at-rule don't prevent @import for removal
	        this.root.firstAtrulesAllowed = false;

	        if (node.block.type === 'Block' && node.block.declarations.isEmpty()) {
	            list.remove(item);
	            return;
	        }

	        if (node.block.type === 'StyleSheet' && node.block.rules.isEmpty()) {
	            list.remove(item);
	            return;
	        }
	    }

	    switch (node.name) {
	        case 'charset':
	            if (node.expression.sequence.isEmpty()) {
	                list.remove(item);
	                return;
	            }

	            // if there is any rule before @charset -> remove it
	            if (item.prev) {
	                list.remove(item);
	                return;
	            }

	            break;

	        case 'import':
	            if (!this.root.firstAtrulesAllowed) {
	                list.remove(item);
	                return;
	            }

	            // if there are some rules that not an @import or @charset before @import
	            // remove it
	            list.prevUntil(item.prev, function(rule) {
	                if (rule.type === 'Atrule') {
	                    if (rule.name === 'import' || rule.name === 'charset') {
	                        return;
	                    }
	                }

	                this.root.firstAtrulesAllowed = false;
	                list.remove(item);
	                return true;
	            }, this);

	            break;
	    }
	};


/***/ },
/* 141 */
/***/ function(module, exports) {

	module.exports = function cleanComment(data, item, list) {
	    list.remove(item);
	};


/***/ },
/* 142 */
/***/ function(module, exports) {

	module.exports = function cleanDeclartion(node, item, list) {
	    if (node.value.sequence.isEmpty()) {
	        list.remove(item);
	    }
	};


/***/ },
/* 143 */
/***/ function(module, exports) {

	module.exports = function cleanIdentifier(node, item, list) {
	    // remove useless universal selector
	    if (this.selector !== null && node.name === '*') {
	        // remove when universal selector isn't last
	        if (item.next && item.next.data.type !== 'Combinator') {
	            list.remove(item);
	        }
	    }
	};


/***/ },
/* 144 */
/***/ function(module, exports) {

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function cleanUnused(node, usageData) {
	    return node.selector.selectors.each(function(selector, item, list) {
	        var hasUnused = selector.sequence.some(function(node) {
	            switch (node.type) {
	                case 'Class':
	                    return usageData.classes && !hasOwnProperty.call(usageData.classes, node.name);

	                case 'Id':
	                    return usageData.ids && !hasOwnProperty.call(usageData.ids, node.name);

	                case 'Identifier':
	                    // ignore universal selector
	                    if (node.name !== '*') {
	                        // TODO: remove toLowerCase when type selectors will be normalized
	                        return usageData.tags && !hasOwnProperty.call(usageData.tags, node.name.toLowerCase());
	                    }

	                    break;
	            }
	        });

	        if (hasUnused) {
	            list.remove(item);
	        }
	    });
	}

	module.exports = function cleanRuleset(node, item, list, usageData) {
	    if (usageData) {
	        cleanUnused(node, usageData);
	    }

	    if (node.selector.selectors.isEmpty() ||
	        node.block.declarations.isEmpty()) {
	        list.remove(item);
	    }
	};


/***/ },
/* 145 */
/***/ function(module, exports) {

	function canCleanWhitespace(node) {
	    if (node.type !== 'Operator') {
	        return false;
	    }

	    return node.value !== '+' && node.value !== '-';
	}

	module.exports = function cleanWhitespace(node, item, list) {
	    var prev = item.prev && item.prev.data;
	    var next = item.next && item.next.data;

	    if (canCleanWhitespace(prev) || canCleanWhitespace(next)) {
	        list.remove(item);
	    }
	};


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	var walk = __webpack_require__(10).all;
	var handlers = {
	    Space: __webpack_require__(145),
	    Atrule: __webpack_require__(140),
	    Ruleset: __webpack_require__(144),
	    Declaration: __webpack_require__(142),
	    Identifier: __webpack_require__(143),
	    Comment: __webpack_require__(141)
	};

	module.exports = function(ast, usageData) {
	    walk(ast, function(node, item, list) {
	        if (handlers.hasOwnProperty(node.type)) {
	            handlers[node.type].call(this, node, item, list, usageData);
	        }
	    });
	};


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	var resolveKeyword = __webpack_require__(25).keyword;
	var compressKeyframes = __webpack_require__(153);

	module.exports = function(node) {
	    // compress @keyframe selectors
	    if (resolveKeyword(node.name).name === 'keyframes') {
	        compressKeyframes(node);
	    }
	};


/***/ },
/* 148 */
/***/ function(module, exports) {

	// Can unquote attribute detection
	// Adopted implementation of Mathias Bynens
	// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
	var escapesRx = /\\([0-9A-Fa-f]{1,6})[ \t\n\f\r]?|\\./g;
	var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

	function canUnquote(value) {
	    if (value === '' || value === '-') {
	        return;
	    }

	    // Escapes are valid, so replace them with a valid non-empty string
	    value = value.replace(escapesRx, 'a');

	    return !blockUnquoteRx.test(value);
	}

	module.exports = function(node) {
	    var attrValue = node.value;

	    if (!attrValue || attrValue.type !== 'String') {
	        return;
	    }

	    var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, '$2');
	    if (canUnquote(unquotedValue)) {
	        node.value = {
	            type: 'Identifier',
	            info: attrValue.info,
	            name: unquotedValue
	        };
	    }
	};


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	var packNumber = __webpack_require__(31).pack;
	var LENGTH_UNIT = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	module.exports = function compressDimension(node, item) {
	    var value = packNumber(node.value);

	    node.value = value;

	    if (value === '0' && this.declaration) {
	        var unit = node.unit.toLowerCase();

	        // only length values can be compressed
	        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
	            return;
	        }

	        // issue #200: don't remove units in flex property as it could change value meaning
	        if (this.declaration.property.name === 'flex') {
	            return;
	        }

	        // issue #222: don't remove units inside calc
	        if (this['function'] && this['function'].name === 'calc') {
	            return;
	        }

	        item.data = {
	            type: 'Number',
	            info: node.info,
	            value: value
	        };
	    }
	};


/***/ },
/* 150 */
/***/ function(module, exports) {

	module.exports = function(node) {
	    var value = node.value;

	    // remove escaped \n, i.e.
	    // .a { content: "foo\
	    // bar"}
	    // ->
	    // .a { content: "foobar" }
	    value = value.replace(/\\\n/g, '');

	    node.value = value;
	};


/***/ },
/* 151 */
/***/ function(module, exports) {

	var UNICODE = '\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?';
	var ESCAPE = '(' + UNICODE + '|\\\\[^\\n\\r\\f0-9a-fA-F])';
	var NONPRINTABLE = '\u0000\u0008\u000b\u000e-\u001f\u007f';
	var SAFE_URL = new RegExp('^(' + ESCAPE + '|[^\"\'\\(\\)\\\\\\s' + NONPRINTABLE + '])*$', 'i');

	module.exports = function(node) {
	    var value = node.value;

	    if (value.type !== 'String') {
	        return;
	    }

	    var quote = value.value[0];
	    var url = value.value.substr(1, value.value.length - 2);

	    // convert `\\` to `/`
	    url = url.replace(/\\\\/g, '/');

	    // remove quotes when safe
	    // https://www.w3.org/TR/css-syntax-3/#url-unquoted-diagram
	    if (SAFE_URL.test(url)) {
	        node.value = {
	            type: 'Raw',
	            info: node.value.info,
	            value: url
	        };
	    } else {
	        // use double quotes if string has no double quotes
	        // otherwise use original quotes
	        // TODO: make better quote type selection
	        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
	    }
	};


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	var resolveName = __webpack_require__(25).property;
	var handlers = {
	    'font': __webpack_require__(157),
	    'font-weight': __webpack_require__(156),
	    'background': __webpack_require__(155)
	};

	module.exports = function compressValue(node) {
	    if (!this.declaration) {
	        return;
	    }

	    var property = resolveName(this.declaration.property.name);

	    if (handlers.hasOwnProperty(property.name)) {
	        handlers[property.name](node);
	    }
	};


/***/ },
/* 153 */
/***/ function(module, exports) {

	module.exports = function(node) {
	    node.block.rules.each(function(ruleset) {
	        ruleset.selector.selectors.each(function(simpleselector) {
	            simpleselector.sequence.each(function(data, item) {
	                if (data.type === 'Percentage' && data.value === '100') {
	                    item.data = {
	                        type: 'Identifier',
	                        info: data.info,
	                        name: 'to'
	                    };
	                } else if (data.type === 'Identifier' && data.name === 'from') {
	                    item.data = {
	                        type: 'Percentage',
	                        info: data.info,
	                        value: '0'
	                    };
	                }
	            });
	        });
	    });
	};


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	var walk = __webpack_require__(10).all;
	var handlers = {
	    Atrule: __webpack_require__(147),
	    Attribute: __webpack_require__(148),
	    Value: __webpack_require__(152),
	    Dimension: __webpack_require__(149),
	    Percentage: __webpack_require__(31),
	    Number: __webpack_require__(31),
	    String: __webpack_require__(150),
	    Url: __webpack_require__(151),
	    Hash: __webpack_require__(38).compressHex,
	    Identifier: __webpack_require__(38).compressIdent,
	    Function: __webpack_require__(38).compressFunction
	};

	module.exports = function(ast) {
	    walk(ast, function(node, item, list) {
	        if (handlers.hasOwnProperty(node.type)) {
	            handlers[node.type].call(this, node, item, list);
	        }
	    });
	};


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);

	module.exports = function compressBackground(node) {
	    function lastType() {
	        if (buffer.length) {
	            return buffer[buffer.length - 1].type;
	        }
	    }

	    function flush() {
	        if (lastType() === 'Space') {
	            buffer.pop();
	        }

	        if (!buffer.length) {
	            buffer.unshift(
	                {
	                    type: 'Number',
	                    value: '0'
	                },
	                {
	                    type: 'Space'
	                },
	                {
	                    type: 'Number',
	                    value: '0'
	                }
	            );
	        }

	        newValue.push.apply(newValue, buffer);

	        buffer = [];
	    }

	    var newValue = [];
	    var buffer = [];

	    node.sequence.each(function(node) {
	        if (node.type === 'Operator' && node.value === ',') {
	            flush();
	            newValue.push(node);
	            return;
	        }

	        // remove defaults
	        if (node.type === 'Identifier') {
	            if (node.name === 'transparent' ||
	                node.name === 'none' ||
	                node.name === 'repeat' ||
	                node.name === 'scroll') {
	                return;
	            }
	        }

	        // don't add redundant spaces
	        if (node.type === 'Space' && (!buffer.length || lastType() === 'Space')) {
	            return;
	        }

	        buffer.push(node);
	    });

	    flush();
	    node.sequence = new List(newValue);
	};


/***/ },
/* 156 */
/***/ function(module, exports) {

	module.exports = function compressFontWeight(node) {
	    var value = node.sequence.head.data;

	    if (value.type === 'Identifier') {
	        switch (value.name) {
	            case 'normal':
	                node.sequence.head.data = {
	                    type: 'Number',
	                    info: value.info,
	                    value: '400'
	                };
	                break;
	            case 'bold':
	                node.sequence.head.data = {
	                    type: 'Number',
	                    info: value.info,
	                    value: '700'
	                };
	                break;
	        }
	    }
	};


/***/ },
/* 157 */
/***/ function(module, exports) {

	module.exports = function compressFont(node) {
	    var list = node.sequence;

	    list.eachRight(function(node, item) {
	        if (node.type === 'Identifier') {
	            if (node.name === 'bold') {
	                item.data = {
	                    type: 'Number',
	                    info: node.info,
	                    value: '700'
	                };
	            } else if (node.name === 'normal') {
	                var prev = item.prev;

	                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
	                    this.remove(prev);
	                }

	                this.remove(item);
	            } else if (node.name === 'medium') {
	                var next = item.next;

	                if (!next || next.data.type !== 'Operator') {
	                    this.remove(item);
	                }
	            }
	        }
	    });

	    // remove redundant spaces
	    list.each(function(node, item) {
	        if (node.type === 'Space') {
	            if (!item.prev || !item.next || item.next.data.type === 'Space') {
	                this.remove(item);
	            }
	        }
	    });

	    if (list.isEmpty()) {
	        list.insert(list.createItem({
	            type: 'Identifier',
	            name: 'normal'
	        }));
	    }
	};


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);
	var usageUtils = __webpack_require__(171);
	var clean = __webpack_require__(146);
	var compress = __webpack_require__(154);
	var restructureBlock = __webpack_require__(166);
	var walkRules = __webpack_require__(10).rules;

	function readBlock(stylesheet) {
	    var buffer = new List();
	    var nonSpaceTokenInBuffer = false;
	    var protectedComment;

	    stylesheet.rules.nextUntil(stylesheet.rules.head, function(node, item, list) {
	        if (node.type === 'Comment' && node.value.charAt(0) === '!') {
	            if (nonSpaceTokenInBuffer || protectedComment) {
	                return true;
	            }

	            list.remove(item);
	            protectedComment = node;
	            return;
	        }

	        if (node.type !== 'Space') {
	            nonSpaceTokenInBuffer = true;
	        }

	        buffer.insert(list.remove(item));
	    });

	    return {
	        comment: protectedComment,
	        stylesheet: {
	            type: 'StyleSheet',
	            rules: buffer
	        }
	    };
	}

	function compressBlock(ast, usageData, num, logger) {
	    logger('Compress block #' + num, null, true);

	    var seed = 1;
	    ast.firstAtrulesAllowed = ast.firstAtrulesAllowed;
	    walkRules(ast, function() {
	        if (!this.stylesheet.id) {
	            this.stylesheet.id = seed++;
	        }
	    });
	    logger('init', ast);

	    // remove redundant
	    clean(ast, usageData);
	    logger('clean', ast);

	    // compress nodes
	    compress(ast, usageData);
	    logger('compress', ast);

	    return ast;
	}

	module.exports = function compress(ast, options) {
	    options = options || {};
	    ast = ast || { type: 'StyleSheet', rules: new List() };

	    var logger = typeof options.logger === 'function' ? options.logger : Function();
	    var restructuring =
	        'restructure' in options ? options.restructure :
	        'restructuring' in options ? options.restructuring :
	        true;
	    var result = new List();
	    var block;
	    var firstAtrulesAllowed = true;
	    var blockNum = 1;
	    var blockRules;
	    var blockMode = false;
	    var usageData = false;
	    var info = ast.info || null;

	    if (ast.type !== 'StyleSheet') {
	        blockMode = true;
	        ast = {
	            type: 'StyleSheet',
	            rules: new List([{
	                type: 'Ruleset',
	                selector: {
	                    type: 'Selector',
	                    selectors: new List([{
	                        type: 'SimpleSelector',
	                        sequence: new List([{
	                            type: 'Identifier',
	                            name: 'x'
	                        }])
	                    }])
	                },
	                block: ast
	            }])
	        };
	    }

	    if (options.usage) {
	        usageData = usageUtils.buildIndex(options.usage);
	    }

	    do {
	        block = readBlock(ast);
	        // console.log(JSON.stringify(block.stylesheet, null, 2));
	        block.stylesheet.firstAtrulesAllowed = firstAtrulesAllowed;
	        block.stylesheet = compressBlock(block.stylesheet, usageData, blockNum++, logger);

	        // structure optimisations
	        if (restructuring) {
	            restructureBlock(block.stylesheet, usageData, logger);
	        }

	        blockRules = block.stylesheet.rules;

	        if (block.comment) {
	            // add \n before comment if there is another content in result
	            if (!result.isEmpty()) {
	                result.insert(List.createItem({
	                    type: 'Raw',
	                    value: '\n'
	                }));
	            }

	            result.insert(List.createItem(block.comment));

	            // add \n after comment if block is not empty
	            if (!blockRules.isEmpty()) {
	                result.insert(List.createItem({
	                    type: 'Raw',
	                    value: '\n'
	                }));
	            }
	        }

	        if (firstAtrulesAllowed && !blockRules.isEmpty()) {
	            var lastRule = blockRules.last();

	            if (lastRule.type !== 'Atrule' ||
	               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
	                firstAtrulesAllowed = false;
	            }
	        }

	        result.appendList(blockRules);
	    } while (!ast.rules.isEmpty());

	    if (blockMode) {
	        result = !result.isEmpty() ? result.first().block : {
	            type: 'Block',
	            info: info,
	            declarations: new List()
	        };
	    } else {
	        result = {
	            type: 'StyleSheet',
	            info: info,
	            rules: result
	        };
	    }

	    return {
	        ast: result
	    };
	};


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(39);
	var walkRules = __webpack_require__(10).rules;

	function processRuleset(node, item, list) {
	    var selectors = node.selector.selectors;
	    var declarations = node.block.declarations;

	    list.prevUntil(item.prev, function(prev) {
	        // skip non-ruleset node if safe
	        if (prev.type !== 'Ruleset') {
	            return utils.unsafeToSkipNode.call(selectors, prev);
	        }

	        var prevSelectors = prev.selector.selectors;
	        var prevDeclarations = prev.block.declarations;

	        // try to join rulesets with equal pseudo signature
	        if (node.pseudoSignature === prev.pseudoSignature) {
	            // try to join by selectors
	            if (utils.isEqualLists(prevSelectors, selectors)) {
	                prevDeclarations.appendList(declarations);
	                list.remove(item);
	                return true;
	            }

	            // try to join by declarations
	            if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
	                utils.addSelectors(prevSelectors, selectors);
	                list.remove(item);
	                return true;
	            }
	        }

	        // go to prev ruleset if has no selector similarities
	        return utils.hasSimilarSelectors(selectors, prevSelectors);
	    });
	};

	// NOTE: direction should be left to right, since rulesets merge to left
	// ruleset. When direction right to left unmerged rulesets may prevent lookup
	// TODO: remove initial merge
	module.exports = function initialMergeRuleset(ast) {
	    walkRules(ast, function(node, item, list) {
	        if (node.type === 'Ruleset') {
	            processRuleset(node, item, list);
	        }
	    });
	};


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	var walkRulesRight = __webpack_require__(10).rulesRight;

	function isMediaRule(node) {
	    return node.type === 'Atrule' && node.name === 'media';
	}

	function processAtrule(node, item, list) {
	    if (!isMediaRule(node)) {
	        return;
	    }

	    var prev = item.prev && item.prev.data;

	    if (!prev || !isMediaRule(prev)) {
	        return;
	    }

	    // merge @media with same query
	    if (node.expression.id === prev.expression.id) {
	        prev.block.rules.appendList(node.block.rules);
	        prev.info = {
	            primary: prev.info,
	            merged: node.info
	        };
	        list.remove(item);
	    }
	};

	module.exports = function rejoinAtrule(ast) {
	    walkRulesRight(ast, function(node, item, list) {
	        if (node.type === 'Atrule') {
	            processAtrule(node, item, list);
	        }
	    });
	};


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);
	var walkRulesRight = __webpack_require__(10).rulesRight;

	function processRuleset(node, item, list) {
	    var selectors = node.selector.selectors;

	    // generate new rule sets:
	    // .a, .b { color: red; }
	    // ->
	    // .a { color: red; }
	    // .b { color: red; }

	    // while there are more than 1 simple selector split for rulesets
	    while (selectors.head !== selectors.tail) {
	        var newSelectors = new List();
	        newSelectors.insert(selectors.remove(selectors.head));

	        list.insert(list.createItem({
	            type: 'Ruleset',
	            info: node.info,
	            pseudoSignature: node.pseudoSignature,
	            selector: {
	                type: 'Selector',
	                info: node.selector.info,
	                selectors: newSelectors
	            },
	            block: {
	                type: 'Block',
	                info: node.block.info,
	                declarations: node.block.declarations.copy()
	            }
	        }), item);
	    }
	};

	module.exports = function disjoinRuleset(ast) {
	    walkRulesRight(ast, function(node, item, list) {
	        if (node.type === 'Ruleset') {
	            processRuleset(node, item, list);
	        }
	    });
	};


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);
	var translate = __webpack_require__(18);
	var walkRulesRight = __webpack_require__(10).rulesRight;

	var REPLACE = 1;
	var REMOVE = 2;
	var TOP = 0;
	var RIGHT = 1;
	var BOTTOM = 2;
	var LEFT = 3;
	var SIDES = ['top', 'right', 'bottom', 'left'];
	var SIDE = {
	    'margin-top': 'top',
	    'margin-right': 'right',
	    'margin-bottom': 'bottom',
	    'margin-left': 'left',

	    'padding-top': 'top',
	    'padding-right': 'right',
	    'padding-bottom': 'bottom',
	    'padding-left': 'left',

	    'border-top-color': 'top',
	    'border-right-color': 'right',
	    'border-bottom-color': 'bottom',
	    'border-left-color': 'left',
	    'border-top-width': 'top',
	    'border-right-width': 'right',
	    'border-bottom-width': 'bottom',
	    'border-left-width': 'left',
	    'border-top-style': 'top',
	    'border-right-style': 'right',
	    'border-bottom-style': 'bottom',
	    'border-left-style': 'left'
	};
	var MAIN_PROPERTY = {
	    'margin': 'margin',
	    'margin-top': 'margin',
	    'margin-right': 'margin',
	    'margin-bottom': 'margin',
	    'margin-left': 'margin',

	    'padding': 'padding',
	    'padding-top': 'padding',
	    'padding-right': 'padding',
	    'padding-bottom': 'padding',
	    'padding-left': 'padding',

	    'border-color': 'border-color',
	    'border-top-color': 'border-color',
	    'border-right-color': 'border-color',
	    'border-bottom-color': 'border-color',
	    'border-left-color': 'border-color',
	    'border-width': 'border-width',
	    'border-top-width': 'border-width',
	    'border-right-width': 'border-width',
	    'border-bottom-width': 'border-width',
	    'border-left-width': 'border-width',
	    'border-style': 'border-style',
	    'border-top-style': 'border-style',
	    'border-right-style': 'border-style',
	    'border-bottom-style': 'border-style',
	    'border-left-style': 'border-style'
	};

	function TRBL(name) {
	    this.name = name;
	    this.info = null;
	    this.iehack = undefined;
	    this.sides = {
	        'top': null,
	        'right': null,
	        'bottom': null,
	        'left': null
	    };
	}

	TRBL.prototype.getValueSequence = function(value, count) {
	    var values = [];
	    var iehack = false;
	    var hasBadValues = value.sequence.some(function(child) {
	        var special = false;

	        switch (child.type) {
	            case 'Identifier':
	                switch (child.name) {
	                    case '\\9':
	                        iehack = true;
	                        return;

	                    case 'inherit':
	                    case 'initial':
	                    case 'unset':
	                    case 'revert':
	                        special = child.name;
	                        break;
	                }
	                break;

	            case 'Dimension':
	                switch (child.unit) {
	                    // is not supported until IE11
	                    case 'rem':

	                    // v* units is too buggy across browsers and better
	                    // don't merge values with those units
	                    case 'vw':
	                    case 'vh':
	                    case 'vmin':
	                    case 'vmax':
	                    case 'vm': // IE9 supporting "vm" instead of "vmin".
	                        special = child.unit;
	                        break;
	                }
	                break;

	            case 'Number':
	            case 'Percentage':
	                break;

	            case 'Space':
	                return false; // ignore space

	            default:
	                return true;  // bad value
	        }

	        values.push({
	            node: child,
	            special: special,
	            important: value.important
	        });
	    });

	    if (hasBadValues || values.length > count) {
	        return false;
	    }

	    if (typeof this.iehack === 'boolean' && this.iehack !== iehack) {
	        return false;
	    }

	    this.iehack = iehack; // move outside

	    return values;
	};

	TRBL.prototype.canOverride = function(side, value) {
	    var currentValue = this.sides[side];

	    return !currentValue || (value.important && !currentValue.important);
	};

	TRBL.prototype.add = function(name, value, info) {
	    function attemptToAdd() {
	        var sides = this.sides;
	        var side = SIDE[name];

	        if (side) {
	            if (side in sides) {
	                var values = this.getValueSequence(value, 1);

	                if (!values || !values.length) {
	                    return false;
	                }

	                // can mix only if specials are equal
	                for (var key in sides) {
	                    if (sides[key] !== null && sides[key].special !== values[0].special) {
	                        return false;
	                    }
	                }

	                if (!this.canOverride(side, values[0])) {
	                    return true;
	                }

	                sides[side] = values[0];
	                return true;
	            }
	        } else if (name === this.name) {
	            var values = this.getValueSequence(value, 4);

	            if (!values || !values.length) {
	                return false;
	            }

	            switch (values.length) {
	                case 1:
	                    values[RIGHT] = values[TOP];
	                    values[BOTTOM] = values[TOP];
	                    values[LEFT] = values[TOP];
	                    break;

	                case 2:
	                    values[BOTTOM] = values[TOP];
	                    values[LEFT] = values[RIGHT];
	                    break;

	                case 3:
	                    values[LEFT] = values[RIGHT];
	                    break;
	            }

	            // can mix only if specials are equal
	            for (var i = 0; i < 4; i++) {
	                for (var key in sides) {
	                    if (sides[key] !== null && sides[key].special !== values[i].special) {
	                        return false;
	                    }
	                }
	            }

	            for (var i = 0; i < 4; i++) {
	                if (this.canOverride(SIDES[i], values[i])) {
	                    sides[SIDES[i]] = values[i];
	                }
	            }

	            return true;
	        }
	    }

	    if (!attemptToAdd.call(this)) {
	        return false;
	    }

	    if (this.info) {
	        this.info = {
	            primary: this.info,
	            merged: info
	        };
	    } else {
	        this.info = info;
	    }

	    return true;
	};

	TRBL.prototype.isOkToMinimize = function() {
	    var top = this.sides.top;
	    var right = this.sides.right;
	    var bottom = this.sides.bottom;
	    var left = this.sides.left;

	    if (top && right && bottom && left) {
	        var important =
	            top.important +
	            right.important +
	            bottom.important +
	            left.important;

	        return important === 0 || important === 4;
	    }

	    return false;
	};

	TRBL.prototype.getValue = function() {
	    var result = [];
	    var sides = this.sides;
	    var values = [
	        sides.top,
	        sides.right,
	        sides.bottom,
	        sides.left
	    ];
	    var stringValues = [
	        translate(sides.top.node),
	        translate(sides.right.node),
	        translate(sides.bottom.node),
	        translate(sides.left.node)
	    ];

	    if (stringValues[LEFT] === stringValues[RIGHT]) {
	        values.pop();
	        if (stringValues[BOTTOM] === stringValues[TOP]) {
	            values.pop();
	            if (stringValues[RIGHT] === stringValues[TOP]) {
	                values.pop();
	            }
	        }
	    }

	    for (var i = 0; i < values.length; i++) {
	        if (i) {
	            result.push({ type: 'Space' });
	        }

	        result.push(values[i].node);
	    }

	    if (this.iehack) {
	        result.push({ type: 'Space' }, {
	            type: 'Identifier',
	            info: {},
	            name: '\\9'
	        });
	    }

	    return {
	        type: 'Value',
	        info: {},
	        important: sides.top.important,
	        sequence: new List(result)
	    };
	};

	TRBL.prototype.getProperty = function() {
	    return {
	        type: 'Property',
	        info: {},
	        name: this.name
	    };
	};

	function processRuleset(ruleset, shorts, shortDeclarations, lastShortSelector) {
	    var declarations = ruleset.block.declarations;
	    var selector = ruleset.selector.selectors.first().id;

	    ruleset.block.declarations.eachRight(function(declaration, item) {
	        var property = declaration.property.name;

	        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
	            return;
	        }

	        var key = MAIN_PROPERTY[property];
	        var shorthand;
	        var operation;

	        if (!lastShortSelector || selector === lastShortSelector) {
	            if (key in shorts) {
	                operation = REMOVE;
	                shorthand = shorts[key];
	            }
	        }

	        if (!shorthand || !shorthand.add(property, declaration.value, declaration.info)) {
	            operation = REPLACE;
	            shorthand = new TRBL(key);
	            shorthand.add(property, declaration.value, declaration.info);
	        }

	        shorts[key] = shorthand;
	        shortDeclarations.push({
	            operation: operation,
	            block: declarations,
	            item: item,
	            shorthand: shorthand
	        });

	        lastShortSelector = selector;
	    });

	    return lastShortSelector;
	};

	function processShorthands(shortDeclarations, markDeclaration) {
	    shortDeclarations.forEach(function(item) {
	        var shorthand = item.shorthand;

	        if (!shorthand.isOkToMinimize()) {
	            return;
	        }

	        if (item.operation === REPLACE) {
	            item.item.data = markDeclaration({
	                type: 'Declaration',
	                info: shorthand.info,
	                property: shorthand.getProperty(),
	                value: shorthand.getValue(),
	                id: 0,
	                length: 0,
	                fingerprint: null
	            });
	        } else {
	            item.block.remove(item.item);
	        }
	    });
	};

	module.exports = function restructBlock(ast, indexer) {
	    var stylesheetMap = {};
	    var shortDeclarations = [];

	    walkRulesRight(ast, function(node) {
	        if (node.type !== 'Ruleset') {
	            return;
	        }

	        var stylesheet = this.stylesheet;
	        var rulesetId = (node.pseudoSignature || '') + '|' + node.selector.selectors.first().id;
	        var rulesetMap;
	        var shorts;

	        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	            rulesetMap = {
	                lastShortSelector: null
	            };
	            stylesheetMap[stylesheet.id] = rulesetMap;
	        } else {
	            rulesetMap = stylesheetMap[stylesheet.id];
	        }

	        if (rulesetMap.hasOwnProperty(rulesetId)) {
	            shorts = rulesetMap[rulesetId];
	        } else {
	            shorts = {};
	            rulesetMap[rulesetId] = shorts;
	        }

	        rulesetMap.lastShortSelector = processRuleset.call(this, node, shorts, shortDeclarations, rulesetMap.lastShortSelector);
	    });

	    processShorthands(shortDeclarations, indexer.declaration);
	};


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	var resolveProperty = __webpack_require__(25).property;
	var resolveKeyword = __webpack_require__(25).keyword;
	var walkRulesRight = __webpack_require__(10).rulesRight;
	var translate = __webpack_require__(18);
	var dontRestructure = {
	    'src': 1 // https://github.com/afelix/csso/issues/50
	};

	var DONT_MIX_VALUE = {
	    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
	    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
	    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
	    'text-align': /^(start|end|match-parent|justify-all)$/i
	};

	var NEEDLESS_TABLE = {
	    'border-width': ['border'],
	    'border-style': ['border'],
	    'border-color': ['border'],
	    'border-top': ['border'],
	    'border-right': ['border'],
	    'border-bottom': ['border'],
	    'border-left': ['border'],
	    'border-top-width': ['border-top', 'border-width', 'border'],
	    'border-right-width': ['border-right', 'border-width', 'border'],
	    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
	    'border-left-width': ['border-left', 'border-width', 'border'],
	    'border-top-style': ['border-top', 'border-style', 'border'],
	    'border-right-style': ['border-right', 'border-style', 'border'],
	    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
	    'border-left-style': ['border-left', 'border-style', 'border'],
	    'border-top-color': ['border-top', 'border-color', 'border'],
	    'border-right-color': ['border-right', 'border-color', 'border'],
	    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
	    'border-left-color': ['border-left', 'border-color', 'border'],
	    'margin-top': ['margin'],
	    'margin-right': ['margin'],
	    'margin-bottom': ['margin'],
	    'margin-left': ['margin'],
	    'padding-top': ['padding'],
	    'padding-right': ['padding'],
	    'padding-bottom': ['padding'],
	    'padding-left': ['padding'],
	    'font-style': ['font'],
	    'font-variant': ['font'],
	    'font-weight': ['font'],
	    'font-size': ['font'],
	    'font-family': ['font'],
	    'list-style-type': ['list-style'],
	    'list-style-position': ['list-style'],
	    'list-style-image': ['list-style']
	};

	function getPropertyFingerprint(propertyName, declaration, fingerprints) {
	    var realName = resolveProperty(propertyName).name;

	    if (realName === 'background' ||
	       (realName === 'filter' && declaration.value.sequence.first().type === 'Progid')) {
	        return propertyName + ':' + translate(declaration.value);
	    }

	    var declarationId = declaration.id;
	    var fingerprint = fingerprints[declarationId];

	    if (!fingerprint) {
	        var vendorId = '';
	        var hack9 = '';
	        var special = {};

	        declaration.value.sequence.each(function walk(node) {
	            switch (node.type) {
	                case 'Argument':
	                case 'Value':
	                case 'Braces':
	                    node.sequence.each(walk);
	                    break;

	                case 'Identifier':
	                    var name = node.name;

	                    if (!vendorId) {
	                        vendorId = resolveKeyword(name).vendor;
	                    }

	                    if (name === '\\9') {
	                        hack9 = name;
	                    }

	                    if (DONT_MIX_VALUE.hasOwnProperty(realName) &&
	                        DONT_MIX_VALUE[realName].test(name)) {
	                        special[name] = true;
	                    }

	                    break;

	                case 'Function':
	                    var name = node.name;

	                    if (!vendorId) {
	                        vendorId = resolveKeyword(name).vendor;
	                    }

	                    if (name === 'rect') {
	                        // there are 2 forms of rect:
	                        //   rect(<top>, <right>, <bottom>, <left>) - standart
	                        //   rect(<top> <right> <bottom> <left>) – backwards compatible syntax
	                        // only the same form values can be merged
	                        if (node.arguments.size < 4) {
	                            name = 'rect-backward';
	                        }
	                    }

	                    special[name + '()'] = true;

	                    // check nested tokens too
	                    node.arguments.each(walk);

	                    break;

	                case 'Dimension':
	                    var unit = node.unit;

	                    switch (unit) {
	                        // is not supported until IE11
	                        case 'rem':

	                        // v* units is too buggy across browsers and better
	                        // don't merge values with those units
	                        case 'vw':
	                        case 'vh':
	                        case 'vmin':
	                        case 'vmax':
	                        case 'vm': // IE9 supporting "vm" instead of "vmin".
	                            special[unit] = true;
	                            break;
	                    }
	                    break;
	            }
	        });

	        fingerprint = '|' + Object.keys(special).sort() + '|' + hack9 + vendorId;

	        fingerprints[declarationId] = fingerprint;
	    }

	    return propertyName + fingerprint;
	}

	function needless(props, declaration, fingerprints) {
	    var property = resolveProperty(declaration.property.name);

	    if (NEEDLESS_TABLE.hasOwnProperty(property.name)) {
	        var table = NEEDLESS_TABLE[property.name];

	        for (var i = 0; i < table.length; i++) {
	            var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
	            var prev = props[ppre];

	            if (prev && (!declaration.value.important || prev.item.data.value.important)) {
	                return prev;
	            }
	        }
	    }
	}

	function processRuleset(ruleset, item, list, props, fingerprints) {
	    var declarations = ruleset.block.declarations;

	    declarations.eachRight(function(declaration, declarationItem) {
	        var property = declaration.property.name;
	        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
	        var prev = props[fingerprint];

	        if (prev && !dontRestructure.hasOwnProperty(property)) {
	            if (declaration.value.important && !prev.item.data.value.important) {
	                props[fingerprint] = {
	                    block: declarations,
	                    item: declarationItem
	                };

	                prev.block.remove(prev.item);
	                declaration.info = {
	                    primary: declaration.info,
	                    merged: prev.item.data.info
	                };
	            } else {
	                declarations.remove(declarationItem);
	                prev.item.data.info = {
	                    primary: prev.item.data.info,
	                    merged: declaration.info
	                };
	            }
	        } else {
	            var prev = needless(props, declaration, fingerprints);

	            if (prev) {
	                declarations.remove(declarationItem);
	                prev.item.data.info = {
	                    primary: prev.item.data.info,
	                    merged: declaration.info
	                };
	            } else {
	                declaration.fingerprint = fingerprint;

	                props[fingerprint] = {
	                    block: declarations,
	                    item: declarationItem
	                };
	            }
	        }
	    });

	    if (declarations.isEmpty()) {
	        list.remove(item);
	    }
	};

	module.exports = function restructBlock(ast) {
	    var stylesheetMap = {};
	    var fingerprints = Object.create(null);

	    walkRulesRight(ast, function(node, item, list) {
	        if (node.type !== 'Ruleset') {
	            return;
	        }

	        var stylesheet = this.stylesheet;
	        var rulesetId = (node.pseudoSignature || '') + '|' + node.selector.selectors.first().id;
	        var rulesetMap;
	        var props;

	        if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
	            rulesetMap = {};
	            stylesheetMap[stylesheet.id] = rulesetMap;
	        } else {
	            rulesetMap = stylesheetMap[stylesheet.id];
	        }

	        if (rulesetMap.hasOwnProperty(rulesetId)) {
	            props = rulesetMap[rulesetId];
	        } else {
	            props = {};
	            rulesetMap[rulesetId] = props;
	        }

	        processRuleset.call(this, node, item, list, props, fingerprints);
	    });
	};


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(39);
	var walkRules = __webpack_require__(10).rules;

	/*
	    At this step all rules has single simple selector. We try to join by equal
	    declaration blocks to first rule, e.g.

	    .a { color: red }
	    b { ... }
	    .b { color: red }
	    ->
	    .a, .b { color: red }
	    b { ... }
	*/

	function processRuleset(node, item, list) {
	    var selectors = node.selector.selectors;
	    var declarations = node.block.declarations;
	    var nodeCompareMarker = selectors.first().compareMarker;
	    var skippedCompareMarkers = {};

	    list.nextUntil(item.next, function(next, nextItem) {
	        // skip non-ruleset node if safe
	        if (next.type !== 'Ruleset') {
	            return utils.unsafeToSkipNode.call(selectors, next);
	        }

	        if (node.pseudoSignature !== next.pseudoSignature) {
	            return true;
	        }

	        var nextFirstSelector = next.selector.selectors.head;
	        var nextDeclarations = next.block.declarations;
	        var nextCompareMarker = nextFirstSelector.data.compareMarker;

	        // if next ruleset has same marked as one of skipped then stop joining
	        if (nextCompareMarker in skippedCompareMarkers) {
	            return true;
	        }

	        // try to join by selectors
	        if (selectors.head === selectors.tail) {
	            if (selectors.first().id === nextFirstSelector.data.id) {
	                declarations.appendList(nextDeclarations);
	                list.remove(nextItem);
	                return;
	            }
	        }

	        // try to join by properties
	        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
	            var nextStr = nextFirstSelector.data.id;

	            selectors.some(function(data, item) {
	                var curStr = data.id;

	                if (nextStr < curStr) {
	                    selectors.insert(nextFirstSelector, item);
	                    return true;
	                }

	                if (!item.next) {
	                    selectors.insert(nextFirstSelector);
	                    return true;
	                }
	            });

	            list.remove(nextItem);
	            return;
	        }

	        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
	        if (nextCompareMarker === nodeCompareMarker) {
	            return true;
	        }

	        skippedCompareMarkers[nextCompareMarker] = true;
	    });
	};

	module.exports = function mergeRuleset(ast) {
	    walkRules(ast, function(node, item, list) {
	        if (node.type === 'Ruleset') {
	            processRuleset(node, item, list);
	        }
	    });
	};


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	var List = __webpack_require__(15);
	var utils = __webpack_require__(39);
	var walkRulesRight = __webpack_require__(10).rulesRight;

	function calcSelectorLength(list) {
	    var length = 0;

	    list.each(function(data) {
	        length += data.id.length + 1;
	    });

	    return length - 1;
	}

	function calcDeclarationsLength(tokens) {
	    var length = 0;

	    for (var i = 0; i < tokens.length; i++) {
	        length += tokens[i].length;
	    }

	    return (
	        length +          // declarations
	        tokens.length - 1 // delimeters
	    );
	}

	function inList(selector) {
	    return selector.compareMarker in this;
	}

	function processRuleset(node, item, list) {
	    var avoidRulesMerge = this.stylesheet.avoidRulesMerge;
	    var selectors = node.selector.selectors;
	    var block = node.block;
	    var skippedCompareMarkers = Object.create(null);

	    list.prevUntil(item.prev, function(prev, prevItem) {
	        // skip non-ruleset node if safe
	        if (prev.type !== 'Ruleset') {
	            return utils.unsafeToSkipNode.call(selectors, prev);
	        }

	        var prevSelectors = prev.selector.selectors;
	        var prevBlock = prev.block;

	        if (node.pseudoSignature !== prev.pseudoSignature) {
	            return true;
	        }

	        // try prev ruleset if simpleselectors has no equal specifity and element selector
	        if (prevSelectors.some(inList, skippedCompareMarkers)) {
	            return true;
	        }

	        // try to join by selectors
	        if (utils.isEqualLists(prevSelectors, selectors)) {
	            prevBlock.declarations.appendList(block.declarations);
	            list.remove(item);
	            return true;
	        }

	        // try to join by properties
	        var diff = utils.compareDeclarations(block.declarations, prevBlock.declarations);

	        // console.log(diff.eq, diff.ne1, diff.ne2);

	        if (diff.eq.length) {
	            if (!diff.ne1.length && !diff.ne2.length) {
	                // equal blocks
	                utils.addSelectors(selectors, prevSelectors);
	                list.remove(prevItem);
	                return true;
	            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
	                                              TODO: need to be checked */

	                if (diff.ne1.length && !diff.ne2.length) {
	                    // prevBlock is subset block
	                    var selectorLength = calcSelectorLength(selectors);
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    if (selectorLength < blockLength) {
	                        utils.addSelectors(prevSelectors, selectors);
	                        block.declarations = new List(diff.ne1);
	                    }
	                } else if (!diff.ne1.length && diff.ne2.length) {
	                    // node is subset of prevBlock
	                    var selectorLength = calcSelectorLength(prevSelectors);
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    if (selectorLength < blockLength) {
	                        utils.addSelectors(selectors, prevSelectors);
	                        prevBlock.declarations = new List(diff.ne2);
	                    }
	                } else {
	                    // diff.ne1.length && diff.ne2.length
	                    // extract equal block
	                    var newSelector = {
	                        type: 'Selector',
	                        info: {},
	                        selectors: utils.addSelectors(prevSelectors.copy(), selectors)
	                    };
	                    var newBlockLength = calcSelectorLength(newSelector.selectors) + 2; // selectors length + curly braces length
	                    var blockLength = calcDeclarationsLength(diff.eq); // declarations length

	                    // create new ruleset if declarations length greater than
	                    // ruleset description overhead
	                    if (blockLength >= newBlockLength) {
	                        var newRuleset = {
	                            type: 'Ruleset',
	                            info: {},
	                            pseudoSignature: node.pseudoSignature,
	                            selector: newSelector,
	                            block: {
	                                type: 'Block',
	                                info: {},
	                                declarations: new List(diff.eq)
	                            }
	                        };

	                        block.declarations = new List(diff.ne1);
	                        prevBlock.declarations = new List(diff.ne2.concat(diff.ne2overrided));
	                        list.insert(list.createItem(newRuleset), prevItem);
	                        return true;
	                    }
	                }
	            }
	        }

	        prevSelectors.each(function(data) {
	            skippedCompareMarkers[data.compareMarker] = true;
	        });
	    });
	};

	module.exports = function restructRuleset(ast) {
	    walkRulesRight(ast, function(node, item, list) {
	        if (node.type === 'Ruleset') {
	            processRuleset.call(this, node, item, list);
	        }
	    });
	};


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	var prepare = __webpack_require__(168);
	var initialMergeRuleset = __webpack_require__(159);
	var mergeAtrule = __webpack_require__(160);
	var disjoinRuleset = __webpack_require__(161);
	var restructShorthand = __webpack_require__(162);
	var restructBlock = __webpack_require__(163);
	var mergeRuleset = __webpack_require__(164);
	var restructRuleset = __webpack_require__(165);

	module.exports = function(ast, usageData, debug) {
	    // prepare ast for restructing
	    var indexer = prepare(ast, usageData);
	    debug('prepare', ast);

	    initialMergeRuleset(ast);
	    debug('initialMergeRuleset', ast);

	    mergeAtrule(ast);
	    debug('mergeAtrule', ast);

	    disjoinRuleset(ast);
	    debug('disjoinRuleset', ast);

	    restructShorthand(ast, indexer);
	    debug('restructShorthand', ast);

	    restructBlock(ast);
	    debug('restructBlock', ast);

	    mergeRuleset(ast);
	    debug('mergeRuleset', ast);

	    restructRuleset(ast);
	    debug('restructRuleset', ast);
	};


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	var translate = __webpack_require__(18);

	function Index() {
	    this.seed = 0;
	    this.map = Object.create(null);
	}

	Index.prototype.resolve = function(str) {
	    var index = this.map[str];

	    if (!index) {
	        index = ++this.seed;
	        this.map[str] = index;
	    }

	    return index;
	};

	module.exports = function createDeclarationIndexer() {
	    var names = new Index();
	    var values = new Index();

	    return function markDeclaration(node) {
	        var property = node.property.name;
	        var value = translate(node.value);

	        node.id = names.resolve(property) + (values.resolve(value) << 12);
	        node.length = property.length + 1 + value.length;

	        return node;
	    };
	};


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	var resolveKeyword = __webpack_require__(25).keyword;
	var walkRules = __webpack_require__(10).rules;
	var translate = __webpack_require__(18);
	var createDeclarationIndexer = __webpack_require__(167);
	var processSelector = __webpack_require__(169);

	function walk(node, markDeclaration, usageData) {
	    switch (node.type) {
	        case 'Ruleset':
	            node.block.declarations.each(markDeclaration);
	            processSelector(node, usageData);
	            break;

	        case 'Atrule':
	            if (node.expression) {
	                node.expression.id = translate(node.expression);
	            }

	            // compare keyframe selectors by its values
	            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
	            if (resolveKeyword(node.name).name === 'keyframes') {
	                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
	                                                       TODO: need to be checked */
	                node.block.rules.each(function(ruleset) {
	                    ruleset.selector.selectors.each(function(simpleselector) {
	                        simpleselector.compareMarker = simpleselector.id;
	                    });
	                });
	            }
	            break;
	    }
	};

	module.exports = function prepare(ast, usageData) {
	    var markDeclaration = createDeclarationIndexer();

	    walkRules(ast, function(node) {
	        walk(node, markDeclaration, usageData);
	    });

	    return {
	        declaration: markDeclaration
	    };
	};


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	var translate = __webpack_require__(18);
	var specificity = __webpack_require__(170);

	var nonFreezePseudoElements = {
	    'first-letter': true,
	    'first-line': true,
	    'after': true,
	    'before': true
	};
	var nonFreezePseudoClasses = {
	    'link': true,
	    'visited': true,
	    'hover': true,
	    'active': true,
	    'first-letter': true,
	    'first-line': true,
	    'after': true,
	    'before': true
	};

	module.exports = function freeze(node, usageData) {
	    var pseudos = Object.create(null);
	    var hasPseudo = false;

	    node.selector.selectors.each(function(simpleSelector) {
	        var tagName = '*';
	        var scope = 0;

	        simpleSelector.sequence.some(function(node) {
	            switch (node.type) {
	                case 'Class':
	                    if (usageData && usageData.scopes) {
	                        var classScope = usageData.scopes[node.name] || 0;

	                        if (scope !== 0 && classScope !== scope) {
	                            throw new Error('Selector can\'t has classes from different scopes: ' + translate(simpleSelector));
	                        }

	                        scope = classScope;
	                    }
	                    break;

	                case 'PseudoClass':
	                    if (!nonFreezePseudoClasses.hasOwnProperty(node.name)) {
	                        pseudos[node.name] = true;
	                        hasPseudo = true;
	                    }
	                    break;

	                case 'PseudoElement':
	                    if (!nonFreezePseudoElements.hasOwnProperty(node.name)) {
	                        pseudos[node.name] = true;
	                        hasPseudo = true;
	                    }
	                    break;

	                case 'FunctionalPseudo':
	                    pseudos[node.name] = true;
	                    hasPseudo = true;
	                    break;

	                case 'Negation':
	                    pseudos.not = true;
	                    hasPseudo = true;
	                    break;

	                case 'Identifier':
	                    tagName = node.name;
	                    break;

	                case 'Combinator':
	                    tagName = '*';
	                    break;
	            }
	        });

	        simpleSelector.id = translate(simpleSelector);
	        simpleSelector.compareMarker = specificity(simpleSelector).toString();

	        if (scope) {
	            simpleSelector.compareMarker += ':' + scope;
	        }

	        if (tagName !== '*') {
	            simpleSelector.compareMarker += ',' + tagName;
	        }
	    });

	    if (hasPseudo) {
	        node.pseudoSignature = Object.keys(pseudos).sort().join(',');
	    }
	};


/***/ },
/* 170 */
/***/ function(module, exports) {

	module.exports = function specificity(simpleSelector) {
	    var A = 0;
	    var B = 0;
	    var C = 0;

	    simpleSelector.sequence.each(function walk(data) {
	        switch (data.type) {
	            case 'SimpleSelector':
	            case 'Negation':
	                data.sequence.each(walk);
	                break;

	            case 'Id':
	                A++;
	                break;

	            case 'Class':
	            case 'Attribute':
	            case 'FunctionalPseudo':
	                B++;
	                break;

	            case 'Identifier':
	                if (data.name !== '*') {
	                    C++;
	                }
	                break;

	            case 'PseudoElement':
	                C++;
	                break;

	            case 'PseudoClass':
	                var name = data.name.toLowerCase();
	                if (name === 'before' ||
	                    name === 'after' ||
	                    name === 'first-line' ||
	                    name === 'first-letter') {
	                    C++;
	                } else {
	                    B++;
	                }
	                break;
	        }
	    });

	    return [A, B, C];
	};


/***/ },
/* 171 */
/***/ function(module, exports) {

	var hasOwnProperty = Object.prototype.hasOwnProperty;

	function buildMap(list, caseInsensitive) {
	    var map = Object.create(null);

	    if (!Array.isArray(list)) {
	        return false;
	    }

	    for (var i = 0; i < list.length; i++) {
	        var name = list[i];

	        if (caseInsensitive) {
	            name = name.toLowerCase();
	        }

	        map[name] = true;
	    }

	    return map;
	}

	function buildIndex(data) {
	    var scopes = false;

	    if (data.scopes && Array.isArray(data.scopes)) {
	        scopes = Object.create(null);

	        for (var i = 0; i < data.scopes.length; i++) {
	            var list = data.scopes[i];

	            if (!list || !Array.isArray(list)) {
	                throw new Error('Wrong usage format');
	            }

	            for (var j = 0; j < list.length; j++) {
	                var name = list[j];

	                if (hasOwnProperty.call(scopes, name)) {
	                    throw new Error('Class can\'t be used for several scopes: ' + name);
	                }

	                scopes[name] = i + 1;
	            }
	        }
	    }

	    return {
	        tags: buildMap(data.tags, true),
	        ids: buildMap(data.ids),
	        classes: buildMap(data.classes),
	        scopes: scopes
	    };
	}

	module.exports = {
	    buildIndex: buildIndex
	};


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	var parse = __webpack_require__(173);
	var compress = __webpack_require__(158);
	var translate = __webpack_require__(18);
	var translateWithSourceMap = __webpack_require__(175);
	var walkers = __webpack_require__(10);

	function debugOutput(name, options, startTime, data) {
	    if (options.debug) {
	        console.error('## ' + name + ' done in %d ms\n', Date.now() - startTime);
	    }

	    return data;
	}

	function createDefaultLogger(level) {
	    var lastDebug;

	    return function logger(title, ast) {
	        var line = title;

	        if (ast) {
	            line = '[' + ((Date.now() - lastDebug) / 1000).toFixed(3) + 's] ' + line;
	        }

	        if (level > 1 && ast) {
	            var css = translate(ast, true);

	            // when level 2, limit css to 256 symbols
	            if (level === 2 && css.length > 256) {
	                css = css.substr(0, 256) + '...';
	            }

	            line += '\n  ' + css + '\n';
	        }

	        console.error(line);
	        lastDebug = Date.now();
	    };
	}

	function copy(obj) {
	    var result = {};

	    for (var key in obj) {
	        result[key] = obj[key];
	    }

	    return result;
	}

	function buildCompressOptions(options) {
	    options = copy(options);

	    if (typeof options.logger !== 'function' && options.debug) {
	        options.logger = createDefaultLogger(options.debug);
	    }

	    return options;
	}

	function minify(context, source, options) {
	    options = options || {};

	    var filename = options.filename || '<unknown>';
	    var result;

	    // parse
	    var ast = debugOutput('parsing', options, Date.now(),
	        parse(source, {
	            context: context,
	            filename: filename,
	            positions: Boolean(options.sourceMap)
	        })
	    );

	    // compress
	    var compressResult = debugOutput('compress', options, Date.now(),
	        compress(ast, buildCompressOptions(options))
	    );

	    // translate
	    if (options.sourceMap) {
	        result = debugOutput('translateWithSourceMap', options, Date.now(), (function() {
	            var tmp = translateWithSourceMap(compressResult.ast);
	            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
	            tmp.map.setSourceContent(filename, source);
	            return tmp;
	        })());
	    } else {
	        result = debugOutput('translate', options, Date.now(), {
	            css: translate(compressResult.ast),
	            map: null
	        });
	    }

	    return result;
	}

	function minifyStylesheet(source, options) {
	    return minify('stylesheet', source, options);
	};

	function minifyBlock(source, options) {
	    return minify('block', source, options);
	}

	module.exports = {
	    version: __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"../package.json\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())).version,

	    // main methods
	    minify: minifyStylesheet,
	    minifyBlock: minifyBlock,

	    // step by step
	    parse: parse,
	    compress: compress,
	    translate: translate,
	    translateWithSourceMap: translateWithSourceMap,

	    // walkers
	    walk: walkers.all,
	    walkRules: walkers.rules,
	    walkRulesRight: walkers.rulesRight
	};


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var TokenType = __webpack_require__(50).TokenType;
	var Scanner = __webpack_require__(174);
	var List = __webpack_require__(15);
	var needPositions;
	var filename;
	var scanner;

	var SCOPE_ATRULE_EXPRESSION = 1;
	var SCOPE_SELECTOR = 2;
	var SCOPE_VALUE = 3;

	var specialFunctions = {};
	specialFunctions[SCOPE_ATRULE_EXPRESSION] = {
	    url: getUri
	};
	specialFunctions[SCOPE_SELECTOR] = {
	    url: getUri,
	    not: getNotFunction
	};
	specialFunctions[SCOPE_VALUE] = {
	    url: getUri,
	    expression: getOldIEExpression,
	    var: getVarFunction
	};

	var initialContext = {
	    stylesheet: getStylesheet,
	    atrule: getAtrule,
	    atruleExpression: getAtruleExpression,
	    ruleset: getRuleset,
	    selector: getSelector,
	    simpleSelector: getSimpleSelector,
	    block: getBlock,
	    declaration: getDeclaration,
	    value: getValue
	};

	var blockMode = {
	    'declaration': true,
	    'property': true
	};

	function parseError(message) {
	    var error = new Error(message);
	    var line = 1;
	    var column = 1;
	    var lines;

	    if (scanner.token !== null) {
	        line = scanner.token.line;
	        column = scanner.token.column;
	    } else if (scanner.prevToken !== null) {
	        lines = scanner.prevToken.value.trimRight().split(/\n|\r\n?|\f/);
	        line = scanner.prevToken.line + lines.length - 1;
	        column = lines.length > 1
	            ? lines[lines.length - 1].length + 1
	            : scanner.prevToken.column + lines[lines.length - 1].length;
	    }

	    error.name = 'CssSyntaxError';
	    error.parseError = {
	        line: line,
	        column: column
	    };

	    throw error;
	}

	function eat(tokenType) {
	    if (scanner.token !== null && scanner.token.type === tokenType) {
	        scanner.next();
	        return true;
	    }

	    parseError(tokenType + ' is expected');
	}

	function expectIdentifier(name, eat) {
	    if (scanner.token !== null) {
	        if (scanner.token.type === TokenType.Identifier &&
	            scanner.token.value.toLowerCase() === name) {
	            if (eat) {
	                scanner.next();
	            }

	            return true;
	        }
	    }

	    parseError('Identifier `' + name + '` is expected');
	}

	function expectAny(what) {
	    if (scanner.token !== null) {
	        for (var i = 1, type = scanner.token.type; i < arguments.length; i++) {
	            if (type === arguments[i]) {
	                return true;
	            }
	        }
	    }

	    parseError(what + ' is expected');
	}

	function getInfo() {
	    if (needPositions && scanner.token) {
	        return {
	            source: filename,
	            offset: scanner.token.offset,
	            line: scanner.token.line,
	            column: scanner.token.column
	        };
	    }

	    return null;

	}

	function removeTrailingSpaces(list) {
	    while (list.tail) {
	        if (list.tail.data.type === 'Space') {
	            list.remove(list.tail);
	        } else {
	            break;
	        }
	    }
	}

	function getStylesheet(nested) {
	    var child = null;
	    var node = {
	        type: 'StyleSheet',
	        info: getInfo(),
	        rules: new List()
	    };

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.Space:
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.Comment:
	                // ignore comments except exclamation comments on top level
	                if (nested || scanner.token.value.charAt(2) !== '!') {
	                    scanner.next();
	                    child = null;
	                } else {
	                    child = getComment();
	                }
	                break;

	            case TokenType.Unknown:
	                child = getUnknown();
	                break;

	            case TokenType.CommercialAt:
	                child = getAtrule();
	                break;

	            case TokenType.RightCurlyBracket:
	                if (!nested) {
	                    parseError('Unexpected right curly brace');
	                }

	                break scan;

	            default:
	                child = getRuleset();
	        }

	        if (child !== null) {
	            node.rules.insert(List.createItem(child));
	        }
	    }

	    return node;
	}

	// '//' ...
	// TODO: remove it as wrong thing
	function getUnknown() {
	    var info = getInfo();
	    var value = scanner.token.value;

	    eat(TokenType.Unknown);

	    return {
	        type: 'Unknown',
	        info: info,
	        value: value
	    };
	}

	function isBlockAtrule() {
	    for (var offset = 1, cursor; cursor = scanner.lookup(offset); offset++) {
	        var type = cursor.type;

	        if (type === TokenType.RightCurlyBracket) {
	            return true;
	        }

	        if (type === TokenType.LeftCurlyBracket ||
	            type === TokenType.CommercialAt) {
	            return false;
	        }
	    }

	    return true;
	}

	function getAtruleExpression() {
	    var child = null;
	    var node = {
	        type: 'AtruleExpression',
	        info: getInfo(),
	        sequence: new List()
	    };

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.Semicolon:
	                break scan;

	            case TokenType.LeftCurlyBracket:
	                break scan;

	            case TokenType.Space:
	                if (node.sequence.isEmpty()) {
	                    scanner.next(); // ignore spaces in beginning
	                    child = null;
	                } else {
	                    child = getS();
	                }
	                break;

	            case TokenType.Comment: // ignore comments
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.Comma:
	                child = getOperator();
	                break;

	            case TokenType.Colon:
	                child = getPseudo();
	                break;

	            case TokenType.LeftParenthesis:
	                child = getBraces(SCOPE_ATRULE_EXPRESSION);
	                break;

	            default:
	                child = getAny(SCOPE_ATRULE_EXPRESSION);
	        }

	        if (child !== null) {
	            node.sequence.insert(List.createItem(child));
	        }
	    }

	    removeTrailingSpaces(node.sequence);

	    return node;
	}

	function getAtrule() {
	    eat(TokenType.CommercialAt);

	    var node = {
	        type: 'Atrule',
	        info: getInfo(),
	        name: readIdent(false),
	        expression: getAtruleExpression(),
	        block: null
	    };

	    if (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.Semicolon:
	                scanner.next();  // {
	                break;

	            case TokenType.LeftCurlyBracket:
	                scanner.next();  // {

	                if (isBlockAtrule()) {
	                    node.block = getBlock();
	                } else {
	                    node.block = getStylesheet(true);
	                }

	                eat(TokenType.RightCurlyBracket);
	                break;

	            default:
	                parseError('Unexpected input');
	        }
	    }

	    return node;
	}

	function getRuleset() {
	    return {
	        type: 'Ruleset',
	        info: getInfo(),
	        selector: getSelector(),
	        block: getBlockWithBrackets()
	    };
	}

	function getSelector() {
	    var isBadSelector = false;
	    var lastComma = true;
	    var node = {
	        type: 'Selector',
	        info: getInfo(),
	        selectors: new List()
	    };

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.LeftCurlyBracket:
	                break scan;

	            case TokenType.Comma:
	                if (lastComma) {
	                    isBadSelector = true;
	                }

	                lastComma = true;
	                scanner.next();
	                break;

	            default:
	                if (!lastComma) {
	                    isBadSelector = true;
	                }

	                lastComma = false;
	                node.selectors.insert(List.createItem(getSimpleSelector()));

	                if (node.selectors.tail.data.sequence.isEmpty()) {
	                    isBadSelector = true;
	                }
	        }
	    }

	    if (lastComma) {
	        isBadSelector = true;
	        // parseError('Unexpected trailing comma');
	    }

	    if (isBadSelector) {
	        node.selectors = new List();
	    }

	    return node;
	}

	function getSimpleSelector(nested) {
	    var child = null;
	    var combinator = null;
	    var node = {
	        type: 'SimpleSelector',
	        info: getInfo(),
	        sequence: new List()
	    };

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.Comma:
	                break scan;

	            case TokenType.LeftCurlyBracket:
	                if (nested) {
	                    parseError('Unexpected input');
	                }

	                break scan;

	            case TokenType.RightParenthesis:
	                if (!nested) {
	                    parseError('Unexpected input');
	                }

	                break scan;

	            case TokenType.Comment:
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.Space:
	                child = null;
	                if (!combinator && node.sequence.head) {
	                    combinator = getCombinator();
	                } else {
	                    scanner.next();
	                }
	                break;

	            case TokenType.PlusSign:
	            case TokenType.GreaterThanSign:
	            case TokenType.Tilde:
	            case TokenType.Solidus:
	                if (combinator && combinator.name !== ' ') {
	                    parseError('Unexpected combinator');
	                }

	                child = null;
	                combinator = getCombinator();
	                break;

	            case TokenType.FullStop:
	                child = getClass();
	                break;

	            case TokenType.LeftSquareBracket:
	                child = getAttribute();
	                break;

	            case TokenType.NumberSign:
	                child = getShash();
	                break;

	            case TokenType.Colon:
	                child = getPseudo();
	                break;

	            case TokenType.LowLine:
	            case TokenType.Identifier:
	            case TokenType.Asterisk:
	                child = getNamespacedIdentifier(false);
	                break;

	            case TokenType.HyphenMinus:
	            case TokenType.DecimalNumber:
	                child = tryGetPercentage() || getNamespacedIdentifier(false);
	                break;

	            default:
	                parseError('Unexpected input');
	        }

	        if (child !== null) {
	            if (combinator !== null) {
	                node.sequence.insert(List.createItem(combinator));
	                combinator = null;
	            }

	            node.sequence.insert(List.createItem(child));
	        }
	    }

	    if (combinator && combinator.name !== ' ') {
	        parseError('Unexpected combinator');
	    }

	    return node;
	}

	function getDeclarations() {
	    var child = null;
	    var declarations = new List();

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.RightCurlyBracket:
	                break scan;

	            case TokenType.Space:
	            case TokenType.Comment:
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.Semicolon: // ;
	                scanner.next();
	                child = null;
	                break;

	            default:
	                child = getDeclaration();
	        }

	        if (child !== null) {
	            declarations.insert(List.createItem(child));
	        }
	    }

	    return declarations;
	}

	function getBlockWithBrackets() {
	    var info = getInfo();
	    var node;

	    eat(TokenType.LeftCurlyBracket);
	    node = {
	        type: 'Block',
	        info: info,
	        declarations: getDeclarations()
	    };
	    eat(TokenType.RightCurlyBracket);

	    return node;
	}

	function getBlock() {
	    return {
	        type: 'Block',
	        info: getInfo(),
	        declarations: getDeclarations()
	    };
	}

	function getDeclaration(nested) {
	    var info = getInfo();
	    var property = getProperty();
	    var value;

	    eat(TokenType.Colon);

	    // check it's a filter
	    if (/filter$/.test(property.name.toLowerCase()) && checkProgid()) {
	        value = getFilterValue();
	    } else {
	        value = getValue(nested);
	    }

	    return {
	        type: 'Declaration',
	        info: info,
	        property: property,
	        value: value
	    };
	}

	function getProperty() {
	    var name = '';
	    var node = {
	        type: 'Property',
	        info: getInfo(),
	        name: null
	    };

	    for (; scanner.token !== null; scanner.next()) {
	        var type = scanner.token.type;

	        if (type !== TokenType.Solidus &&
	            type !== TokenType.Asterisk &&
	            type !== TokenType.DollarSign) {
	            break;
	        }

	        name += scanner.token.value;
	    }

	    node.name = name + readIdent(true);

	    readSC();

	    return node;
	}

	function getValue(nested) {
	    var child = null;
	    var node = {
	        type: 'Value',
	        info: getInfo(),
	        important: false,
	        sequence: new List()
	    };

	    readSC();

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.RightCurlyBracket:
	            case TokenType.Semicolon:
	                break scan;

	            case TokenType.RightParenthesis:
	                if (!nested) {
	                    parseError('Unexpected input');
	                }
	                break scan;

	            case TokenType.Space:
	                child = getS();
	                break;

	            case TokenType.Comment: // ignore comments
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.NumberSign:
	                child = getVhash();
	                break;

	            case TokenType.Solidus:
	            case TokenType.Comma:
	                child = getOperator();
	                break;

	            case TokenType.LeftParenthesis:
	            case TokenType.LeftSquareBracket:
	                child = getBraces(SCOPE_VALUE);
	                break;

	            case TokenType.ExclamationMark:
	                node.important = getImportant();
	                child = null;
	                break;

	            default:
	                // check for unicode range: U+0F00, U+0F00-0FFF, u+0F00??
	                if (scanner.token.type === TokenType.Identifier) {
	                    var prefix = scanner.token.value;
	                    if (prefix === 'U' || prefix === 'u') {
	                        if (scanner.lookupType(1, TokenType.PlusSign)) {
	                            scanner.next(); // U or u
	                            scanner.next(); // +

	                            child = {
	                                type: 'Identifier',
	                                info: getInfo(), // FIXME: wrong position
	                                name: prefix + '+' + readUnicodeRange(true)
	                            };
	                        }
	                        break;
	                    }
	                }

	                child = getAny(SCOPE_VALUE);
	        }

	        if (child !== null) {
	            node.sequence.insert(List.createItem(child));
	        }
	    }

	    removeTrailingSpaces(node.sequence);

	    return node;
	}

	// any = string | percentage | dimension | number | uri | functionExpression | funktion | unary | operator | ident
	function getAny(scope) {
	    switch (scanner.token.type) {
	        case TokenType.String:
	            return getString();

	        case TokenType.LowLine:
	        case TokenType.Identifier:
	            break;

	        case TokenType.FullStop:
	        case TokenType.DecimalNumber:
	        case TokenType.HyphenMinus:
	        case TokenType.PlusSign:
	            var number = tryGetNumber();

	            if (number !== null) {
	                if (scanner.token !== null) {
	                    if (scanner.token.type === TokenType.PercentSign) {
	                        return getPercentage(number);
	                    } else if (scanner.token.type === TokenType.Identifier) {
	                        return getDimension(number.value);
	                    }
	                }

	                return number;
	            }

	            if (scanner.token.type === TokenType.HyphenMinus) {
	                var next = scanner.lookup(1);
	                if (next && (next.type === TokenType.Identifier || next.type === TokenType.HyphenMinus)) {
	                    break;
	                }
	            }

	            if (scanner.token.type === TokenType.HyphenMinus ||
	                scanner.token.type === TokenType.PlusSign) {
	                return getOperator();
	            }

	            parseError('Unexpected input');

	        default:
	            parseError('Unexpected input');
	    }

	    var ident = getIdentifier(false);

	    if (scanner.token !== null && scanner.token.type === TokenType.LeftParenthesis) {
	        return getFunction(scope, ident);
	    }

	    return ident;
	}

	function readAttrselector() {
	    expectAny('Attribute selector (=, ~=, ^=, $=, *=, |=)',
	        TokenType.EqualsSign,        // =
	        TokenType.Tilde,             // ~=
	        TokenType.CircumflexAccent,  // ^=
	        TokenType.DollarSign,        // $=
	        TokenType.Asterisk,          // *=
	        TokenType.VerticalLine       // |=
	    );

	    var name;

	    if (scanner.token.type === TokenType.EqualsSign) {
	        name = '=';
	        scanner.next();
	    } else {
	        name = scanner.token.value + '=';
	        scanner.next();
	        eat(TokenType.EqualsSign);
	    }

	    return name;
	}

	// '[' S* attrib_name ']'
	// '[' S* attrib_name S* attrib_match S* [ IDENT | STRING ] S* attrib_flags? S* ']'
	function getAttribute() {
	    var node = {
	        type: 'Attribute',
	        info: getInfo(),
	        name: null,
	        operator: null,
	        value: null,
	        flags: null
	    };

	    eat(TokenType.LeftSquareBracket);

	    readSC();

	    node.name = getNamespacedIdentifier(true);

	    readSC();

	    if (scanner.token !== null && scanner.token.type !== TokenType.RightSquareBracket) {
	        node.operator = readAttrselector();

	        readSC();

	        if (scanner.token !== null && scanner.token.type === TokenType.String) {
	            node.value = getString();
	        } else {
	            node.value = getIdentifier(false);
	        }

	        readSC();

	        // attribute flags
	        if (scanner.token !== null && scanner.token.type === TokenType.Identifier) {
	            node.flags = scanner.token.value;

	            scanner.next();
	            readSC();
	        }
	    }

	    eat(TokenType.RightSquareBracket);

	    return node;
	}

	function getBraces(scope) {
	    var close;
	    var child = null;
	    var node = {
	        type: 'Braces',
	        info: getInfo(),
	        open: scanner.token.value,
	        close: null,
	        sequence: new List()
	    };

	    if (scanner.token.type === TokenType.LeftParenthesis) {
	        close = TokenType.RightParenthesis;
	    } else {
	        close = TokenType.RightSquareBracket;
	    }

	    // left brace
	    scanner.next();

	    readSC();

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case close:
	                node.close = scanner.token.value;
	                break scan;

	            case TokenType.Space:
	                child = getS();
	                break;

	            case TokenType.Comment:
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.NumberSign: // ??
	                child = getVhash();
	                break;

	            case TokenType.LeftParenthesis:
	            case TokenType.LeftSquareBracket:
	                child = getBraces(scope);
	                break;

	            case TokenType.Solidus:
	            case TokenType.Asterisk:
	            case TokenType.Comma:
	            case TokenType.Colon:
	                child = getOperator();
	                break;

	            default:
	                child = getAny(scope);
	        }

	        if (child !== null) {
	            node.sequence.insert(List.createItem(child));
	        }
	    }

	    removeTrailingSpaces(node.sequence);

	    // right brace
	    eat(close);

	    return node;
	}

	// '.' ident
	function getClass() {
	    var info = getInfo();

	    eat(TokenType.FullStop);

	    return {
	        type: 'Class',
	        info: info,
	        name: readIdent(false)
	    };
	}

	// '#' ident
	function getShash() {
	    var info = getInfo();

	    eat(TokenType.NumberSign);

	    return {
	        type: 'Id',
	        info: info,
	        name: readIdent(false)
	    };
	}

	// + | > | ~ | /deep/
	function getCombinator() {
	    var info = getInfo();
	    var combinator;

	    switch (scanner.token.type) {
	        case TokenType.Space:
	            combinator = ' ';
	            scanner.next();
	            break;

	        case TokenType.PlusSign:
	        case TokenType.GreaterThanSign:
	        case TokenType.Tilde:
	            combinator = scanner.token.value;
	            scanner.next();
	            break;

	        case TokenType.Solidus:
	            combinator = '/deep/';
	            scanner.next();

	            expectIdentifier('deep', true);

	            eat(TokenType.Solidus);
	            break;

	        default:
	            parseError('Combinator (+, >, ~, /deep/) is expected');
	    }

	    return {
	        type: 'Combinator',
	        info: info,
	        name: combinator
	    };
	}

	// '/*' .* '*/'
	function getComment() {
	    var info = getInfo();
	    var value = scanner.token.value;
	    var len = value.length;

	    if (len > 4 && value.charAt(len - 2) === '*' && value.charAt(len - 1) === '/') {
	        len -= 2;
	    }

	    scanner.next();

	    return {
	        type: 'Comment',
	        info: info,
	        value: value.substring(2, len)
	    };
	}

	// special reader for units to avoid adjoined IE hacks (i.e. '1px\9')
	function readUnit() {
	    if (scanner.token !== null && scanner.token.type === TokenType.Identifier) {
	        var unit = scanner.token.value;
	        var backSlashPos = unit.indexOf('\\');

	        // no backslash in unit name
	        if (backSlashPos === -1) {
	            scanner.next();
	            return unit;
	        }

	        // patch token
	        scanner.token.value = unit.substr(backSlashPos);
	        scanner.token.offset += backSlashPos;
	        scanner.token.column += backSlashPos;

	        // return unit w/o backslash part
	        return unit.substr(0, backSlashPos);
	    }

	    parseError('Identifier is expected');
	}

	// number ident
	function getDimension(number) {
	    return {
	        type: 'Dimension',
	        info: getInfo(),
	        value: number || readNumber(),
	        unit: readUnit()
	    };
	}

	// number "%"
	function tryGetPercentage() {
	    var number = tryGetNumber();

	    if (number && scanner.token !== null && scanner.token.type === TokenType.PercentSign) {
	        return getPercentage(number);
	    }

	    return null;
	}

	function getPercentage(number) {
	    var info;

	    if (!number) {
	        info = getInfo();
	        number = readNumber();
	    } else {
	        info = number.info;
	        number = number.value;
	    }

	    eat(TokenType.PercentSign);

	    return {
	        type: 'Percentage',
	        info: info,
	        value: number
	    };
	}

	// ident '(' functionBody ')' |
	// not '(' <simpleSelector>* ')'
	function getFunction(scope, ident) {
	    var defaultArguments = getFunctionArguments;

	    if (!ident) {
	        ident = getIdentifier(false);
	    }

	    // parse special functions
	    var name = ident.name.toLowerCase();

	    if (specialFunctions.hasOwnProperty(scope)) {
	        if (specialFunctions[scope].hasOwnProperty(name)) {
	            return specialFunctions[scope][name](scope, ident);
	        }
	    }

	    return getFunctionInternal(defaultArguments, scope, ident);
	}

	function getFunctionInternal(functionArgumentsReader, scope, ident) {
	    var args;

	    eat(TokenType.LeftParenthesis);
	    args = functionArgumentsReader(scope);
	    eat(TokenType.RightParenthesis);

	    return {
	        type: scope === SCOPE_SELECTOR ? 'FunctionalPseudo' : 'Function',
	        info: ident.info,
	        name: ident.name,
	        arguments: args
	    };
	}

	function getFunctionArguments(scope) {
	    var args = new List();
	    var argument = null;
	    var child = null;

	    readSC();

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.RightParenthesis:
	                break scan;

	            case TokenType.Space:
	                child = getS();
	                break;

	            case TokenType.Comment: // ignore comments
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.NumberSign: // TODO: not sure it should be here
	                child = getVhash();
	                break;

	            case TokenType.LeftParenthesis:
	            case TokenType.LeftSquareBracket:
	                child = getBraces(scope);
	                break;

	            case TokenType.Comma:
	                removeTrailingSpaces(argument.sequence);
	                scanner.next();
	                readSC();
	                argument = null;
	                child = null;
	                break;

	            case TokenType.Solidus:
	            case TokenType.Asterisk:
	            case TokenType.Colon:
	            case TokenType.EqualsSign:
	                child = getOperator();
	                break;

	            default:
	                child = getAny(scope);
	        }

	        if (argument === null) {
	            argument = {
	                type: 'Argument',
	                sequence: new List()
	            };
	            args.insert(List.createItem(argument));
	        }

	        if (child !== null) {
	            argument.sequence.insert(List.createItem(child));
	        }
	    }

	    if (argument !== null) {
	        removeTrailingSpaces(argument.sequence);
	    }

	    return args;
	}

	function getVarFunction(scope, ident) {
	    return getFunctionInternal(getVarFunctionArguments, scope, ident);
	}

	function getNotFunctionArguments() {
	    var args = new List();
	    var wasSelector = false;

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.RightParenthesis:
	                if (!wasSelector) {
	                    parseError('Simple selector is expected');
	                }

	                break scan;

	            case TokenType.Comma:
	                if (!wasSelector) {
	                    parseError('Simple selector is expected');
	                }

	                wasSelector = false;
	                scanner.next();
	                break;

	            default:
	                wasSelector = true;
	                args.insert(List.createItem(getSimpleSelector(true)));
	        }
	    }

	    return args;
	}

	function getNotFunction(scope, ident) {
	    var args;

	    eat(TokenType.LeftParenthesis);
	    args = getNotFunctionArguments(scope);
	    eat(TokenType.RightParenthesis);

	    return {
	        type: 'Negation',
	        info: ident.info,
	        // name: ident.name,  // TODO: add name?
	        sequence: args        // FIXME: -> arguments?
	    };
	}

	// var '(' ident (',' <declaration-value>)? ')'
	function getVarFunctionArguments() { // TODO: special type Variable?
	    var args = new List();

	    readSC();

	    args.insert(List.createItem({
	        type: 'Argument',
	        sequence: new List([getIdentifier(true)])
	    }));

	    readSC();

	    if (scanner.token !== null && scanner.token.type === TokenType.Comma) {
	        eat(TokenType.Comma);
	        readSC();

	        args.insert(List.createItem({
	            type: 'Argument',
	            sequence: new List([getValue(true)])
	        }));

	        readSC();
	    }

	    return args;
	}

	// url '(' ws* (string | raw) ws* ')'
	function getUri(scope, ident) {
	    var node = {
	        type: 'Url',
	        info: ident.info,
	        // name: ident.name,
	        value: null
	    };

	    eat(TokenType.LeftParenthesis); // (

	    readSC();

	    if (scanner.token.type === TokenType.String) {
	        node.value = getString();
	        readSC();
	    } else {
	        var rawInfo = getInfo();
	        var raw = '';

	        for (; scanner.token !== null; scanner.next()) {
	            var type = scanner.token.type;

	            if (type === TokenType.Space ||
	                type === TokenType.LeftParenthesis ||
	                type === TokenType.RightParenthesis) {
	                break;
	            }

	            raw += scanner.token.value;
	        }

	        node.value = {
	            type: 'Raw',
	            info: rawInfo,
	            value: raw
	        };

	        readSC();
	    }

	    eat(TokenType.RightParenthesis); // )

	    return node;
	}

	// expression '(' raw ')'
	function getOldIEExpression(scope, ident) {
	    var balance = 0;
	    var raw = '';

	    eat(TokenType.LeftParenthesis);

	    for (; scanner.token !== null; scanner.next()) {
	        if (scanner.token.type === TokenType.RightParenthesis) {
	            if (balance === 0) {
	                break;
	            }

	            balance--;
	        } else if (scanner.token.type === TokenType.LeftParenthesis) {
	            balance++;
	        }

	        raw += scanner.token.value;
	    }

	    eat(TokenType.RightParenthesis);

	    return {
	        type: 'Function',
	        info: ident.info,
	        name: ident.name,
	        arguments: new List([{
	            type: 'Argument',
	            sequence: new List([{
	                type: 'Raw',
	                value: raw
	            }])
	        }])
	    };
	}

	function readUnicodeRange(tryNext) {
	    var hex = '';

	    for (; scanner.token !== null; scanner.next()) {
	        if (scanner.token.type !== TokenType.DecimalNumber &&
	            scanner.token.type !== TokenType.Identifier) {
	            break;
	        }

	        hex += scanner.token.value;
	    }

	    if (!/^[0-9a-f]{1,6}$/i.test(hex)) {
	        parseError('Unexpected input');
	    }

	    // U+abc???
	    if (tryNext) {
	        for (; hex.length < 6 && scanner.token !== null; scanner.next()) {
	            if (scanner.token.type !== TokenType.QuestionMark) {
	                break;
	            }

	            hex += scanner.token.value;
	            tryNext = false;
	        }
	    }

	    // U+aaa-bbb
	    if (tryNext) {
	        if (scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {
	            scanner.next();

	            var next = readUnicodeRange(false);

	            if (!next) {
	                parseError('Unexpected input');
	            }

	            hex += '-' + next;
	        }
	    }

	    return hex;
	}

	function readIdent(varAllowed) {
	    var name = '';

	    // optional first -
	    if (scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {
	        name = '-';
	        scanner.next();

	        if (varAllowed && scanner.token !== null && scanner.token.type === TokenType.HyphenMinus) {
	            name = '--';
	            scanner.next();
	        }
	    }

	    expectAny('Identifier',
	        TokenType.LowLine,
	        TokenType.Identifier
	    );

	    if (scanner.token !== null) {
	        name += scanner.token.value;
	        scanner.next();

	        for (; scanner.token !== null; scanner.next()) {
	            var type = scanner.token.type;

	            if (type !== TokenType.LowLine &&
	                type !== TokenType.Identifier &&
	                type !== TokenType.DecimalNumber &&
	                type !== TokenType.HyphenMinus) {
	                break;
	            }

	            name += scanner.token.value;
	        }
	    }

	    return name;
	}

	function getNamespacedIdentifier(checkColon) {
	    if (scanner.token === null) {
	        parseError('Unexpected end of input');
	    }

	    var info = getInfo();
	    var name;

	    if (scanner.token.type === TokenType.Asterisk) {
	        checkColon = false;
	        name = '*';
	        scanner.next();
	    } else {
	        name = readIdent(false);
	    }

	    if (scanner.token !== null) {
	        if (scanner.token.type === TokenType.VerticalLine &&
	            scanner.lookupType(1, TokenType.EqualsSign) === false) {
	            name += '|';

	            if (scanner.next() !== null) {
	                if (scanner.token.type === TokenType.HyphenMinus ||
	                    scanner.token.type === TokenType.Identifier ||
	                    scanner.token.type === TokenType.LowLine) {
	                    name += readIdent(false);
	                } else if (scanner.token.type === TokenType.Asterisk) {
	                    checkColon = false;
	                    name += '*';
	                    scanner.next();
	                }
	            }
	        }
	    }

	    if (checkColon && scanner.token !== null && scanner.token.type === TokenType.Colon) {
	        scanner.next();
	        name += ':' + readIdent(false);
	    }

	    return {
	        type: 'Identifier',
	        info: info,
	        name: name
	    };
	}

	function getIdentifier(varAllowed) {
	    return {
	        type: 'Identifier',
	        info: getInfo(),
	        name: readIdent(varAllowed)
	    };
	}

	// ! ws* important
	function getImportant() { // TODO?
	    // var info = getInfo();

	    eat(TokenType.ExclamationMark);

	    readSC();

	    // return {
	    //     type: 'Identifier',
	    //     info: info,
	    //     name: readIdent(false)
	    // };

	    expectIdentifier('important');

	    readIdent(false);

	    // should return identifier in future for original source restoring as is
	    // returns true for now since it's fit to optimizer purposes
	    return true;
	}

	// odd | even | number? n
	function getNth() {
	    expectAny('Number, odd or even',
	        TokenType.Identifier,
	        TokenType.DecimalNumber
	    );

	    var info = getInfo();
	    var value = scanner.token.value;
	    var cmpValue;

	    if (scanner.token.type === TokenType.DecimalNumber) {
	        var next = scanner.lookup(1);
	        if (next !== null &&
	            next.type === TokenType.Identifier &&
	            next.value.toLowerCase() === 'n') {
	            value += next.value;
	            scanner.next();
	        }
	    } else {
	        var cmpValue = value.toLowerCase();
	        if (cmpValue !== 'odd' && cmpValue !== 'even' && cmpValue !== 'n') {
	            parseError('Unexpected identifier');
	        }
	    }

	    scanner.next();

	    return {
	        type: 'Nth',
	        info: info,
	        value: value
	    };
	}

	function getNthSelector() {
	    var info = getInfo();
	    var sequence = new List();
	    var node;
	    var child = null;

	    eat(TokenType.Colon);
	    expectIdentifier('nth', false);

	    node = {
	        type: 'FunctionalPseudo',
	        info: info,
	        name: readIdent(false),
	        arguments: new List([{
	            type: 'Argument',
	            sequence: sequence
	        }])
	    };

	    eat(TokenType.LeftParenthesis);

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.RightParenthesis:
	                break scan;

	            case TokenType.Space:
	            case TokenType.Comment:
	                scanner.next();
	                child = null;
	                break;

	            case TokenType.HyphenMinus:
	            case TokenType.PlusSign:
	                child = getOperator();
	                break;

	            default:
	                child = getNth();
	        }

	        if (child !== null) {
	            sequence.insert(List.createItem(child));
	        }
	    }

	    eat(TokenType.RightParenthesis);

	    return node;
	}

	function readNumber() {
	    var wasDigits = false;
	    var number = '';
	    var offset = 0;

	    if (scanner.lookupType(offset, TokenType.HyphenMinus)) {
	        number = '-';
	        offset++;
	    }

	    if (scanner.lookupType(offset, TokenType.DecimalNumber)) {
	        wasDigits = true;
	        number += scanner.lookup(offset).value;
	        offset++;
	    }

	    if (scanner.lookupType(offset, TokenType.FullStop)) {
	        number += '.';
	        offset++;
	    }

	    if (scanner.lookupType(offset, TokenType.DecimalNumber)) {
	        wasDigits = true;
	        number += scanner.lookup(offset).value;
	        offset++;
	    }

	    if (wasDigits) {
	        while (offset--) {
	            scanner.next();
	        }

	        return number;
	    }

	    return null;
	}

	function tryGetNumber() {
	    var info = getInfo();
	    var number = readNumber();

	    if (number !== null) {
	        return {
	            type: 'Number',
	            info: info,
	            value: number
	        };
	    }

	    return null;
	}

	// '/' | '*' | ',' | ':' | '=' | '+' | '-'
	// TODO: remove '=' since it's wrong operator, but theat as operator
	// to make old things like `filter: alpha(opacity=0)` works
	function getOperator() {
	    var node = {
	        type: 'Operator',
	        info: getInfo(),
	        value: scanner.token.value
	    };

	    scanner.next();

	    return node;
	}

	function getFilterValue() { // TODO
	    var progid;
	    var node = {
	        type: 'Value',
	        info: getInfo(),
	        important: false,
	        sequence: new List()
	    };

	    while (progid = checkProgid()) {
	        node.sequence.insert(List.createItem(getProgid(progid)));
	    }

	    readSC(node);

	    if (scanner.token !== null && scanner.token.type === TokenType.ExclamationMark) {
	        node.important = getImportant();
	    }

	    return node;
	}

	// 'progid:' ws* 'DXImageTransform.Microsoft.' ident ws* '(' .* ')'
	function checkProgid() {
	    function checkSC(offset) {
	        for (var cursor; cursor = scanner.lookup(offset); offset++) {
	            if (cursor.type !== TokenType.Space &&
	                cursor.type !== TokenType.Comment) {
	                break;
	            }
	        }

	        return offset;
	    }

	    var offset = checkSC(0);

	    if (scanner.lookup(offset + 1) === null ||
	        scanner.lookup(offset + 0).value.toLowerCase() !== 'progid' ||
	        scanner.lookup(offset + 1).type !== TokenType.Colon) {
	        return false; // fail
	    }

	    offset += 2;
	    offset = checkSC(offset);

	    if (scanner.lookup(offset + 5) === null ||
	        scanner.lookup(offset + 0).value.toLowerCase() !== 'dximagetransform' ||
	        scanner.lookup(offset + 1).type !== TokenType.FullStop ||
	        scanner.lookup(offset + 2).value.toLowerCase() !== 'microsoft' ||
	        scanner.lookup(offset + 3).type !== TokenType.FullStop ||
	        scanner.lookup(offset + 4).type !== TokenType.Identifier) {
	        return false; // fail
	    }

	    offset += 5;
	    offset = checkSC(offset);

	    if (scanner.lookupType(offset, TokenType.LeftParenthesis) === false) {
	        return false; // fail
	    }

	    for (var cursor; cursor = scanner.lookup(offset); offset++) {
	        if (cursor.type === TokenType.RightParenthesis) {
	            return cursor;
	        }
	    }

	    return false;
	}

	function getProgid(progidEnd) {
	    var value = '';
	    var node = {
	        type: 'Progid',
	        info: getInfo(),
	        value: null
	    };

	    if (!progidEnd) {
	        progidEnd = checkProgid();
	    }

	    if (!progidEnd) {
	        parseError('progid is expected');
	    }

	    readSC(node);

	    var rawInfo = getInfo();
	    for (; scanner.token && scanner.token !== progidEnd; scanner.next()) {
	        value += scanner.token.value;
	    }

	    eat(TokenType.RightParenthesis);
	    value += ')';

	    node.value = {
	        type: 'Raw',
	        info: rawInfo,
	        value: value
	    };

	    readSC(node);

	    return node;
	}

	// <pseudo-element> | <nth-selector> | <pseudo-class>
	function getPseudo() {
	    var next = scanner.lookup(1);

	    if (next === null) {
	        scanner.next();
	        parseError('Colon or identifier is expected');
	    }

	    if (next.type === TokenType.Colon) {
	        return getPseudoElement();
	    }

	    if (next.type === TokenType.Identifier &&
	        next.value.toLowerCase() === 'nth') {
	        return getNthSelector();
	    }

	    return getPseudoClass();
	}

	// :: ident
	function getPseudoElement() {
	    var info = getInfo();

	    eat(TokenType.Colon);
	    eat(TokenType.Colon);

	    return {
	        type: 'PseudoElement',
	        info: info,
	        name: readIdent(false)
	    };
	}

	// : ( ident | function )
	function getPseudoClass() {
	    var info = getInfo();
	    var ident = eat(TokenType.Colon) && getIdentifier(false);

	    if (scanner.token !== null && scanner.token.type === TokenType.LeftParenthesis) {
	        return getFunction(SCOPE_SELECTOR, ident);
	    }

	    return {
	        type: 'PseudoClass',
	        info: info,
	        name: ident.name
	    };
	}

	// ws
	function getS() {
	    var node = {
	        type: 'Space'
	        // value: scanner.token.value
	    };

	    scanner.next();

	    return node;
	}

	function readSC() {
	    // var nodes = [];

	    scan:
	    while (scanner.token !== null) {
	        switch (scanner.token.type) {
	            case TokenType.Space:
	                scanner.next();
	                // nodes.push(getS());
	                break;

	            case TokenType.Comment:
	                scanner.next();
	                // nodes.push(getComment());
	                break;

	            default:
	                break scan;
	        }
	    }

	    return null;

	    // return nodes.length ? new List(nodes) : null;
	}

	// node: String
	function getString() {
	    var node = {
	        type: 'String',
	        info: getInfo(),
	        value: scanner.token.value
	    };

	    scanner.next();

	    return node;
	}

	// # ident
	function getVhash() {
	    var info = getInfo();
	    var value;

	    eat(TokenType.NumberSign);

	    expectAny('Number or identifier',
	        TokenType.DecimalNumber,
	        TokenType.Identifier
	    );

	    value = scanner.token.value;

	    if (scanner.token.type === TokenType.DecimalNumber &&
	        scanner.lookupType(1, TokenType.Identifier)) {
	        scanner.next();
	        value += scanner.token.value;
	    }

	    scanner.next();

	    return {
	        type: 'Hash',
	        info: info,
	        value: value
	    };
	}

	module.exports = function parse(source, options) {
	    var ast;

	    if (!options || typeof options !== 'object') {
	        options = {};
	    }

	    var context = options.context || 'stylesheet';
	    needPositions = Boolean(options.positions);
	    filename = options.filename || '<unknown>';

	    if (!initialContext.hasOwnProperty(context)) {
	        throw new Error('Unknown context `' + context + '`');
	    }

	    scanner = new Scanner(source, blockMode.hasOwnProperty(context), options.line, options.column);
	    scanner.next();
	    ast = initialContext[context]();

	    scanner = null;

	    // console.log(JSON.stringify(ast, null, 4));
	    // console.log(require('../utils/stringify.js')(ast, true));
	    return ast;
	};


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var TokenType = __webpack_require__(50).TokenType;

	var TAB = 9;
	var N = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;
	var DOUBLE_QUOTE = 34;
	var QUOTE = 39;
	var RIGHT_PARENTHESIS = 41;
	var STAR = 42;
	var SLASH = 47;
	var BACK_SLASH = 92;
	var UNDERSCORE = 95;
	var LEFT_CURLY_BRACE = 123;
	var RIGHT_CURLY_BRACE = 125;

	var WHITESPACE = 1;
	var PUNCTUATOR = 2;
	var DIGIT = 3;
	var STRING_SQ = 4;
	var STRING_DQ = 5;

	var PUNCTUATION = {
	    9:  TokenType.Tab,                // '\t'
	    10: TokenType.Newline,            // '\n'
	    13: TokenType.Newline,            // '\r'
	    32: TokenType.Space,              // ' '
	    33: TokenType.ExclamationMark,    // '!'
	    34: TokenType.QuotationMark,      // '"'
	    35: TokenType.NumberSign,         // '#'
	    36: TokenType.DollarSign,         // '$'
	    37: TokenType.PercentSign,        // '%'
	    38: TokenType.Ampersand,          // '&'
	    39: TokenType.Apostrophe,         // '\''
	    40: TokenType.LeftParenthesis,    // '('
	    41: TokenType.RightParenthesis,   // ')'
	    42: TokenType.Asterisk,           // '*'
	    43: TokenType.PlusSign,           // '+'
	    44: TokenType.Comma,              // ','
	    45: TokenType.HyphenMinus,        // '-'
	    46: TokenType.FullStop,           // '.'
	    47: TokenType.Solidus,            // '/'
	    58: TokenType.Colon,              // ':'
	    59: TokenType.Semicolon,          // ';'
	    60: TokenType.LessThanSign,       // '<'
	    61: TokenType.EqualsSign,         // '='
	    62: TokenType.GreaterThanSign,    // '>'
	    63: TokenType.QuestionMark,       // '?'
	    64: TokenType.CommercialAt,       // '@'
	    91: TokenType.LeftSquareBracket,  // '['
	    93: TokenType.RightSquareBracket, // ']'
	    94: TokenType.CircumflexAccent,   // '^'
	    95: TokenType.LowLine,            // '_'
	    123: TokenType.LeftCurlyBracket,  // '{'
	    124: TokenType.VerticalLine,      // '|'
	    125: TokenType.RightCurlyBracket, // '}'
	    126: TokenType.Tilde              // '~'
	};
	var SYMBOL_CATEGORY_LENGTH = Math.max.apply(null, Object.keys(PUNCTUATION)) + 1;
	var SYMBOL_CATEGORY = new Uint32Array(SYMBOL_CATEGORY_LENGTH);
	var IS_PUNCTUATOR = new Uint32Array(SYMBOL_CATEGORY_LENGTH);

	// fill categories
	Object.keys(PUNCTUATION).forEach(function(key) {
	    SYMBOL_CATEGORY[Number(key)] = PUNCTUATOR;
	    IS_PUNCTUATOR[Number(key)] = PUNCTUATOR;
	}, SYMBOL_CATEGORY);

	// don't treat as punctuator
	IS_PUNCTUATOR[UNDERSCORE] = 0;

	for (var i = 48; i <= 57; i++) {
	    SYMBOL_CATEGORY[i] = DIGIT;
	}

	SYMBOL_CATEGORY[SPACE] = WHITESPACE;
	SYMBOL_CATEGORY[TAB] = WHITESPACE;
	SYMBOL_CATEGORY[N] = WHITESPACE;
	SYMBOL_CATEGORY[R] = WHITESPACE;
	SYMBOL_CATEGORY[F] = WHITESPACE;

	SYMBOL_CATEGORY[QUOTE] = STRING_SQ;
	SYMBOL_CATEGORY[DOUBLE_QUOTE] = STRING_DQ;

	//
	// scanner
	//

	var Scanner = function(source, initBlockMode, initLine, initColumn) {
	    this.source = source;

	    this.pos = source.charCodeAt(0) === 0xFEFF ? 1 : 0;
	    this.eof = this.pos === this.source.length;
	    this.lastPos = this.pos;
	    this.line = typeof initLine === 'undefined' ? 1 : initLine;
	    this.lineStartPos = typeof initColumn === 'undefined' ? -1 : -initColumn;

	    this.minBlockMode = initBlockMode ? 1 : 0;
	    this.blockMode = this.minBlockMode;
	    this.urlMode = false;

	    this.prevToken = null;
	    this.token = null;
	    this.buffer = [];
	};

	Scanner.prototype = {
	    lookup: function(offset) {
	        if (offset === 0) {
	            return this.token;
	        }

	        for (var i = this.buffer.length; !this.eof && i < offset; i++) {
	            this.buffer.push(this.getToken());
	        }

	        return offset <= this.buffer.length ? this.buffer[offset - 1] : null;
	    },
	    lookupType: function(offset, type) {
	        var token = this.lookup(offset);

	        return token !== null && token.type === type;
	    },
	    next: function() {
	        this.prevToken = this.token;

	        if (this.buffer.length !== 0) {
	            this.token = this.buffer.shift();
	        } else if (!this.eof) {
	            this.token = this.getToken();
	        } else {
	            this.token = null;
	        }

	        return this.token;
	    },

	    tokenize: function() {
	        var tokens = [];

	        for (; this.pos < this.source.length; this.pos++) {
	            tokens.push(this.getToken());
	        }

	        return tokens;
	    },

	    getToken: function() {
	        var code = this.source.charCodeAt(this.pos);
	        var line = this.line;
	        var column = this.pos - this.lineStartPos;
	        var lastPos;
	        var next;
	        var type;
	        var value;

	        switch (code < SYMBOL_CATEGORY_LENGTH ? SYMBOL_CATEGORY[code] : 0) {
	            case DIGIT:
	                type = TokenType.DecimalNumber;
	                value = this.readDecimalNumber();
	                break;

	            case STRING_SQ:
	            case STRING_DQ:
	                type = TokenType.String;
	                value = this.readString(code);
	                break;

	            case WHITESPACE:
	                type = TokenType.Space;
	                value = this.readSpaces();
	                break;

	            case PUNCTUATOR:
	                if (code === SLASH) {
	                    next = this.source.charCodeAt(this.pos + 1);

	                    if (next === STAR) { // /*
	                        type = TokenType.Comment;
	                        value = this.readComment();
	                        break;
	                    } else if (next === SLASH && !this.urlMode) { // //
	                        if (this.blockMode > 0) {
	                            var skip = 2;

	                            while (this.source.charCodeAt(this.pos + 2) === SLASH) {
	                                skip++;
	                            }

	                            type = TokenType.Identifier;
	                            value = this.readIdentifier(skip);

	                            this.urlMode = this.urlMode || value === 'url';
	                        } else {
	                            type = TokenType.Unknown;
	                            value = this.readUnknown();
	                        }
	                        break;
	                    }
	                }

	                type = PUNCTUATION[code];
	                value = String.fromCharCode(code);
	                this.pos++;

	                if (code === RIGHT_PARENTHESIS) {
	                    this.urlMode = false;
	                } else if (code === LEFT_CURLY_BRACE) {
	                    this.blockMode++;
	                } else if (code === RIGHT_CURLY_BRACE) {
	                    if (this.blockMode > this.minBlockMode) {
	                        this.blockMode--;
	                    }
	                }

	                break;

	            default:
	                type = TokenType.Identifier;
	                value = this.readIdentifier(0);

	                this.urlMode = this.urlMode || value === 'url';
	        }

	        lastPos = this.lastPos === 0 ? this.lastPos : this.lastPos - 1;
	        this.lastPos = this.pos;
	        this.eof = this.pos === this.source.length;

	        return {
	            type: type,
	            value: value,

	            offset: lastPos,
	            line: line,
	            column: column
	        };
	    },

	    isNewline: function(code) {
	        if (code === N || code === F || code === R) {
	            if (code === R && this.pos + 1 < this.source.length && this.source.charCodeAt(this.pos + 1) === N) {
	                this.pos++;
	            }

	            this.line++;
	            this.lineStartPos = this.pos;
	            return true;
	        }

	        return false;
	    },

	    readSpaces: function() {
	        var start = this.pos;

	        for (; this.pos < this.source.length; this.pos++) {
	            var code = this.source.charCodeAt(this.pos);

	            if (!this.isNewline(code) && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return this.source.substring(start, this.pos);
	    },

	    readComment: function() {
	        var start = this.pos;

	        for (this.pos += 2; this.pos < this.source.length; this.pos++) {
	            var code = this.source.charCodeAt(this.pos);

	            if (code === STAR) { // */
	                if (this.source.charCodeAt(this.pos + 1) === SLASH) {
	                    this.pos += 2;
	                    break;
	                }
	            } else {
	                this.isNewline(code);
	            }
	        }

	        return this.source.substring(start, this.pos);
	    },

	    readUnknown: function() {
	        var start = this.pos;

	        for (this.pos += 2; this.pos < this.source.length; this.pos++) {
	            if (this.isNewline(this.source.charCodeAt(this.pos), this.source)) {
	                break;
	            }
	        }

	        return this.source.substring(start, this.pos);
	    },

	    readString: function(quote) {
	        var start = this.pos;
	        var res = '';

	        for (this.pos++; this.pos < this.source.length; this.pos++) {
	            var code = this.source.charCodeAt(this.pos);

	            if (code === BACK_SLASH) {
	                var end = this.pos++;

	                if (this.isNewline(this.source.charCodeAt(this.pos), this.source)) {
	                    res += this.source.substring(start, end);
	                    start = this.pos + 1;
	                }
	            } else if (code === quote) {
	                this.pos++;
	                break;
	            }
	        }

	        return res + this.source.substring(start, this.pos);
	    },

	    readDecimalNumber: function() {
	        var start = this.pos;
	        var code;

	        for (this.pos++; this.pos < this.source.length; this.pos++) {
	            code = this.source.charCodeAt(this.pos);

	            if (code < 48 || code > 57) {  // 0 .. 9
	                break;
	            }
	        }

	        return this.source.substring(start, this.pos);
	    },

	    readIdentifier: function(skip) {
	        var start = this.pos;

	        for (this.pos += skip; this.pos < this.source.length; this.pos++) {
	            var code = this.source.charCodeAt(this.pos);

	            if (code === BACK_SLASH) {
	                this.pos++;

	                // skip escaped unicode sequence that can ends with space
	                // [0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
	                for (var i = 0; i < 7 && this.pos + i < this.source.length; i++) {
	                    code = this.source.charCodeAt(this.pos + i);

	                    if (i !== 6) {
	                        if ((code >= 48 && code <= 57) ||  // 0 .. 9
	                            (code >= 65 && code <= 70) ||  // A .. F
	                            (code >= 97 && code <= 102)) { // a .. f
	                            continue;
	                        }
	                    }

	                    if (i > 0) {
	                        this.pos += i - 1;
	                        if (code === SPACE || code === TAB || this.isNewline(code)) {
	                            this.pos++;
	                        }
	                    }

	                    break;
	                }
	            } else if (code < SYMBOL_CATEGORY_LENGTH &&
	                       IS_PUNCTUATOR[code] === PUNCTUATOR) {
	                break;
	            }
	        }

	        return this.source.substring(start, this.pos);
	    }
	};

	module.exports = Scanner;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	var SourceMapGenerator = __webpack_require__(76).SourceMapGenerator;
	var SourceNode = __webpack_require__(76).SourceNode;

	// Our own implementation of SourceNode#toStringWithSourceMap,
	// since SourceNode doesn't allow multiple references to original source.
	// Also, as we know structure of result we could be optimize generation
	// (currently it's ~40% faster).
	function walk(node, fn) {
	    for (var chunk, i = 0; i < node.children.length; i++) {
	        chunk = node.children[i];

	        if (chunk instanceof SourceNode) {
	            // this is a hack, because source maps doesn't support for 1(generated):N(original)
	            // if (chunk.merged) {
	            //     fn('', chunk);
	            // }

	            walk(chunk, fn);
	        } else {
	            fn(chunk, node);
	        }
	    }
	}

	function generateSourceMap(root) {
	    var map = new SourceMapGenerator();
	    var css = '';
	    var sourceMappingActive = false;
	    var lastOriginalLine = null;
	    var lastOriginalColumn = null;
	    var lastIndexOfNewline;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: generated
	    };

	    walk(root, function(chunk, original) {
	        if (original.line !== null &&
	            original.column !== null) {
	            if (lastOriginalLine !== original.line ||
	                lastOriginalColumn !== original.column) {
	                map.addMapping({
	                    source: original.source,
	                    original: original,
	                    generated: generated
	                });
	            }

	            lastOriginalLine = original.line;
	            lastOriginalColumn = original.column;
	            sourceMappingActive = true;
	        } else if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	            sourceMappingActive = false;
	        }

	        css += chunk;

	        lastIndexOfNewline = chunk.lastIndexOf('\n');
	        if (lastIndexOfNewline !== -1) {
	            generated.line += chunk.match(/\n/g).length;
	            generated.column = chunk.length - lastIndexOfNewline - 1;
	        } else {
	            generated.column += chunk.length;
	        }
	    });

	    return {
	        css: css,
	        map: map
	    };
	};

	function each(list) {
	    if (list.head === null) {
	        return '';
	    }

	    if (list.head === list.tail) {
	        return translate(list.head.data);
	    }

	    return list.map(translate).join('');
	}

	function eachDelim(list, delimeter) {
	    if (list.head === null) {
	        return '';
	    }

	    if (list.head === list.tail) {
	        return translate(list.head.data);
	    }

	    return list.map(translate).join(delimeter);
	}

	function createAnonymousSourceNode(children) {
	    return new SourceNode(
	        null,
	        null,
	        null,
	        children
	    );
	}

	function createSourceNode(info, children) {
	    if (info.primary) {
	        // special marker node to add several references to original
	        // var merged = createSourceNode(info.merged, []);
	        // merged.merged = true;
	        // children.unshift(merged);

	        // use recursion, because primary can also has a primary/merged info
	        return createSourceNode(info.primary, children);
	    }

	    return new SourceNode(
	        info.line,
	        info.column - 1,
	        info.source,
	        children
	    );
	}

	function translate(node) {
	    switch (node.type) {
	        case 'StyleSheet':
	            return createAnonymousSourceNode(node.rules.map(translate));

	        case 'Atrule':
	            var nodes = ['@', node.name];

	            if (node.expression && !node.expression.sequence.isEmpty()) {
	                nodes.push(' ', translate(node.expression));
	            }

	            if (node.block) {
	                nodes.push('{', translate(node.block), '}');
	            } else {
	                nodes.push(';');
	            }

	            return createSourceNode(node.info, nodes);

	        case 'Ruleset':
	            return createAnonymousSourceNode([
	                translate(node.selector), '{', translate(node.block), '}'
	            ]);

	        case 'Selector':
	            return createAnonymousSourceNode(node.selectors.map(translate)).join(',');

	        case 'SimpleSelector':
	            return createSourceNode(node.info, node.sequence.map(function(node) {
	                // add extra spaces around /deep/ combinator since comment beginning/ending may to be produced
	                if (node.type === 'Combinator' && node.name === '/deep/') {
	                    return ' ' + translate(node) + ' ';
	                }

	                return translate(node);
	            }));

	        case 'Block':
	            return createAnonymousSourceNode(node.declarations.map(translate)).join(';');

	        case 'Declaration':
	            return createSourceNode(
	                node.info,
	                [translate(node.property), ':', translate(node.value)]
	            );

	        case 'Value':
	            return node.important
	                ? each(node.sequence) + '!important'
	                : each(node.sequence);

	        case 'Attribute':
	            var result = translate(node.name);

	            if (node.operator !== null) {
	                result += node.operator;

	                if (node.value !== null) {
	                    result += translate(node.value);

	                    if (node.flags !== null) {
	                        result += (node.value.type !== 'String' ? ' ' : '') + node.flags;
	                    }
	                }
	            }

	            return '[' + result + ']';

	        case 'FunctionalPseudo':
	            return ':' + node.name + '(' + eachDelim(node.arguments, ',') + ')';

	        case 'Function':
	            return node.name + '(' + eachDelim(node.arguments, ',') + ')';

	        case 'Negation':
	            return ':not(' + eachDelim(node.sequence, ',') + ')';

	        case 'Braces':
	            return node.open + each(node.sequence) + node.close;

	        case 'Argument':
	        case 'AtruleExpression':
	            return each(node.sequence);

	        case 'Url':
	            return 'url(' + translate(node.value) + ')';

	        case 'Progid':
	            return translate(node.value);

	        case 'Property':
	            return node.name;

	        case 'Combinator':
	            return node.name;

	        case 'Identifier':
	            return node.name;

	        case 'PseudoClass':
	            return ':' + node.name;

	        case 'PseudoElement':
	            return '::' + node.name;

	        case 'Class':
	            return '.' + node.name;

	        case 'Id':
	            return '#' + node.name;

	        case 'Hash':
	            return '#' + node.value;

	        case 'Dimension':
	            return node.value + node.unit;

	        case 'Nth':
	            return node.value;

	        case 'Number':
	            return node.value;

	        case 'String':
	            return node.value;

	        case 'Operator':
	            return node.value;

	        case 'Raw':
	            return node.value;

	        case 'Unknown':
	            return node.value;

	        case 'Percentage':
	            return node.value + '%';

	        case 'Space':
	            return ' ';

	        case 'Comment':
	            return '/*' + node.value + '*/';

	        default:
	            throw new Error('Unknown node type: ' + node.type);
	    }
	}

	module.exports = function(node) {
	    return generateSourceMap(
	        createAnonymousSourceNode(translate(node))
	    );
	};



/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/*
	 * Date Format 1.2.3
	 * (c) 2007-2009 Steven Levithan <stevenlevithan.com>
	 * MIT license
	 *
	 * Includes enhancements by Scott Trenda <scott.trenda.net>
	 * and Kris Kowal <cixar.com/~kris.kowal/>
	 *
	 * Accepts a date, a mask, or a date and a mask.
	 * Returns a formatted version of the given date.
	 * The date defaults to the current date/time.
	 * The mask defaults to dateFormat.masks.default.
	 */

	(function(global) {
	  'use strict';

	  var dateFormat = (function() {
	      var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZWN]|'[^']*'|'[^']*'/g;
	      var timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g;
	      var timezoneClip = /[^-+\dA-Z]/g;
	  
	      // Regexes and supporting functions are cached through closure
	      return function (date, mask, utc, gmt) {
	  
	        // You can't provide utc if you skip other args (use the 'UTC:' mask prefix)
	        if (arguments.length === 1 && kindOf(date) === 'string' && !/\d/.test(date)) {
	          mask = date;
	          date = undefined;
	        }
	  
	        date = date || new Date;
	  
	        if(!(date instanceof Date)) {
	          date = new Date(date);
	        }
	  
	        if (isNaN(date)) {
	          throw TypeError('Invalid date');
	        }
	  
	        mask = String(dateFormat.masks[mask] || mask || dateFormat.masks['default']);
	  
	        // Allow setting the utc/gmt argument via the mask
	        var maskSlice = mask.slice(0, 4);
	        if (maskSlice === 'UTC:' || maskSlice === 'GMT:') {
	          mask = mask.slice(4);
	          utc = true;
	          if (maskSlice === 'GMT:') {
	            gmt = true;
	          }
	        }
	  
	        var _ = utc ? 'getUTC' : 'get';
	        var d = date[_ + 'Date']();
	        var D = date[_ + 'Day']();
	        var m = date[_ + 'Month']();
	        var y = date[_ + 'FullYear']();
	        var H = date[_ + 'Hours']();
	        var M = date[_ + 'Minutes']();
	        var s = date[_ + 'Seconds']();
	        var L = date[_ + 'Milliseconds']();
	        var o = utc ? 0 : date.getTimezoneOffset();
	        var W = getWeek(date);
	        var N = getDayOfWeek(date);
	        var flags = {
	          d:    d,
	          dd:   pad(d),
	          ddd:  dateFormat.i18n.dayNames[D],
	          dddd: dateFormat.i18n.dayNames[D + 7],
	          m:    m + 1,
	          mm:   pad(m + 1),
	          mmm:  dateFormat.i18n.monthNames[m],
	          mmmm: dateFormat.i18n.monthNames[m + 12],
	          yy:   String(y).slice(2),
	          yyyy: y,
	          h:    H % 12 || 12,
	          hh:   pad(H % 12 || 12),
	          H:    H,
	          HH:   pad(H),
	          M:    M,
	          MM:   pad(M),
	          s:    s,
	          ss:   pad(s),
	          l:    pad(L, 3),
	          L:    pad(Math.round(L / 10)),
	          t:    H < 12 ? 'a'  : 'p',
	          tt:   H < 12 ? 'am' : 'pm',
	          T:    H < 12 ? 'A'  : 'P',
	          TT:   H < 12 ? 'AM' : 'PM',
	          Z:    gmt ? 'GMT' : utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
	          o:    (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
	          S:    ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10],
	          W:    W,
	          N:    N
	        };
	  
	        return mask.replace(token, function (match) {
	          if (match in flags) {
	            return flags[match];
	          }
	          return match.slice(1, match.length - 1);
	        });
	      };
	    })();

	  dateFormat.masks = {
	    'default':               'ddd mmm dd yyyy HH:MM:ss',
	    'shortDate':             'm/d/yy',
	    'mediumDate':            'mmm d, yyyy',
	    'longDate':              'mmmm d, yyyy',
	    'fullDate':              'dddd, mmmm d, yyyy',
	    'shortTime':             'h:MM TT',
	    'mediumTime':            'h:MM:ss TT',
	    'longTime':              'h:MM:ss TT Z',
	    'isoDate':               'yyyy-mm-dd',
	    'isoTime':               'HH:MM:ss',
	    'isoDateTime':           'yyyy-mm-dd\'T\'HH:MM:sso',
	    'isoUtcDateTime':        'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\'',
	    'expiresHeaderFormat':   'ddd, dd mmm yyyy HH:MM:ss Z'
	  };

	  // Internationalization strings
	  dateFormat.i18n = {
	    dayNames: [
	      'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
	      'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
	    ],
	    monthNames: [
	      'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
	      'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
	    ]
	  };

	function pad(val, len) {
	  val = String(val);
	  len = len || 2;
	  while (val.length < len) {
	    val = '0' + val;
	  }
	  return val;
	}

	/**
	 * Get the ISO 8601 week number
	 * Based on comments from
	 * http://techblog.procurios.nl/k/n618/news/view/33796/14863/Calculate-ISO-8601-week-and-year-in-javascript.html
	 *
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getWeek(date) {
	  // Remove time components of date
	  var targetThursday = new Date(date.getFullYear(), date.getMonth(), date.getDate());

	  // Change date to Thursday same week
	  targetThursday.setDate(targetThursday.getDate() - ((targetThursday.getDay() + 6) % 7) + 3);

	  // Take January 4th as it is always in week 1 (see ISO 8601)
	  var firstThursday = new Date(targetThursday.getFullYear(), 0, 4);

	  // Change date to Thursday same week
	  firstThursday.setDate(firstThursday.getDate() - ((firstThursday.getDay() + 6) % 7) + 3);

	  // Check if daylight-saving-time-switch occured and correct for it
	  var ds = targetThursday.getTimezoneOffset() - firstThursday.getTimezoneOffset();
	  targetThursday.setHours(targetThursday.getHours() - ds);

	  // Number of weeks between target Thursday and first Thursday
	  var weekDiff = (targetThursday - firstThursday) / (86400000*7);
	  return 1 + Math.floor(weekDiff);
	}

	/**
	 * Get ISO-8601 numeric representation of the day of the week
	 * 1 (for Monday) through 7 (for Sunday)
	 * 
	 * @param  {Object} `date`
	 * @return {Number}
	 */
	function getDayOfWeek(date) {
	  var dow = date.getDay();
	  if(dow === 0) {
	    dow = 7;
	  }
	  return dow;
	}

	/**
	 * kind-of shortcut
	 * @param  {*} val
	 * @return {String}
	 */
	function kindOf(val) {
	  if (val === null) {
	    return 'null';
	  }

	  if (val === undefined) {
	    return 'undefined';
	  }

	  if (typeof val !== 'object') {
	    return typeof val;
	  }

	  if (Array.isArray(val)) {
	    return 'array';
	  }

	  return {}.toString.call(val)
	    .slice(8, -1).toLowerCase();
	};



	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
	      return dateFormat;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    module.exports = dateFormat;
	  } else {
	    global.dateFormat = dateFormat;
	  }
	})(this);


/***/ },
/* 177 */
/***/ function(module, exports) {

	var deprecated = {
	  method: function(msg, log, fn) {
	    var called = false;
	    return function(){
	      if (!called) {
	        called = true;
	        log(msg);
	      }
	      return fn.apply(this, arguments);
	    };
	  },

	  field: function(msg, log, parent, field, val) {
	    var called = false;
	    var getter = function(){
	      if (!called) {
	        called = true;
	        log(msg);
	      }
	      return val;
	    };
	    var setter = function(v) {
	      if (!called) {
	        called = true;
	        log(msg);
	      }
	      val = v;
	      return v;
	    };
	    Object.defineProperty(parent, field, {
	      get: getter,
	      set: setter,
	      enumerable: true
	    });
	    return;
	  }
	};

	module.exports = deprecated;

/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	var stream = __webpack_require__(181);

	var duplex2 = module.exports = function duplex2(options, writable, readable) {
	  return new DuplexWrapper(options, writable, readable);
	};

	var DuplexWrapper = exports.DuplexWrapper = function DuplexWrapper(options, writable, readable) {
	  if (typeof readable === "undefined") {
	    readable = writable;
	    writable = options;
	    options = null;
	  }

	  options = options || {};
	  options.objectMode = true;

	  stream.Duplex.call(this, options);

	  this._bubbleErrors = (typeof options.bubbleErrors === "undefined") || !!options.bubbleErrors;

	  this._writable = writable;
	  this._readable = readable;

	  var self = this;

	  writable.once("finish", function() {
	    self.end();
	  });

	  this.once("finish", function() {
	    writable.end();
	  });

	  readable.on("data", function(e) {
	    if (!self.push(e)) {
	      readable.pause();
	    }
	  });

	  readable.once("end", function() {
	    return self.push(null);
	  });

	  if (this._bubbleErrors) {
	    writable.on("error", function(err) {
	      return self.emit("error", err);
	    });

	    readable.on("error", function(err) {
	      return self.emit("error", err);
	    });
	  }
	};
	DuplexWrapper.prototype = Object.create(stream.Duplex.prototype, {constructor: {value: DuplexWrapper}});

	DuplexWrapper.prototype._write = function _write(input, encoding, done) {
	  this._writable.write(input, encoding, done);
	};

	DuplexWrapper.prototype._read = function _read(n) {
	  this._readable.resume();
	};


/***/ },
/* 179 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	module.exports = PassThrough;

	var Transform = __webpack_require__(53);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = __webpack_require__(52);
	exports.Stream = __webpack_require__(3);
	exports.Readable = exports;
	exports.Writable = __webpack_require__(54);
	exports.Duplex = __webpack_require__(19);
	exports.Transform = __webpack_require__(53);
	exports.PassThrough = __webpack_require__(180);
	if (!process.browser && process.env.READABLE_STREAM === 'disable') {
	  module.exports = __webpack_require__(3);
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	var once = __webpack_require__(183);

	var noop = function() {};

	var isRequest = function(stream) {
		return stream.setHeader && typeof stream.abort === 'function';
	};

	var eos = function(stream, opts, callback) {
		if (typeof opts === 'function') return eos(stream, null, opts);
		if (!opts) opts = {};

		callback = once(callback || noop);

		var ws = stream._writableState;
		var rs = stream._readableState;
		var readable = opts.readable || (opts.readable !== false && stream.readable);
		var writable = opts.writable || (opts.writable !== false && stream.writable);

		var onlegacyfinish = function() {
			if (!stream.writable) onfinish();
		};

		var onfinish = function() {
			writable = false;
			if (!readable) callback();
		};

		var onend = function() {
			readable = false;
			if (!writable) callback();
		};

		var onclose = function() {
			if (readable && !(rs && rs.ended)) return callback(new Error('premature close'));
			if (writable && !(ws && ws.ended)) return callback(new Error('premature close'));
		};

		var onrequest = function() {
			stream.req.on('finish', onfinish);
		};

		if (isRequest(stream)) {
			stream.on('complete', onfinish);
			stream.on('abort', onclose);
			if (stream.req) onrequest();
			else stream.on('request', onrequest);
		} else if (writable && !ws) { // legacy streams
			stream.on('end', onlegacyfinish);
			stream.on('close', onlegacyfinish);
		}

		stream.on('end', onend);
		stream.on('finish', onfinish);
		if (opts.error !== false) stream.on('error', callback);
		stream.on('close', onclose);

		return stream;
	};

	module.exports = eos;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	var wrappy = __webpack_require__(46)
	module.exports = wrappy(once)

	once.proto = once(function () {
	  Object.defineProperty(Function.prototype, 'once', {
	    value: function () {
	      return once(this)
	    },
	    configurable: true
	  })
	})

	function once (fn) {
	  var f = function () {
	    if (f.called) return f.value
	    f.called = true
	    return f.value = fn.apply(this, arguments)
	  }
	  f.called = false
	  return f
	}


/***/ },
/* 184 */
/***/ function(module, exports) {

	'use strict';

	var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

	module.exports = function (str) {
		if (typeof str !== 'string') {
			throw new TypeError('Expected a string');
		}

		return str.replace(matchOperatorsRe, '\\$&');
	};


/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
	  Copyright (c) jQuery Foundation, Inc. and Contributors, All Rights Reserved.

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (root, factory) {
	    'use strict';

	    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,
	    // Rhino, and plain browser loading.

	    /* istanbul ignore next */
	    if (true) {
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else if (typeof exports !== 'undefined') {
	        factory(exports);
	    } else {
	        factory((root.esprima = {}));
	    }
	}(this, function (exports) {
	    'use strict';

	    var Token,
	        TokenName,
	        FnExprTokens,
	        Syntax,
	        PlaceHolders,
	        Messages,
	        Regex,
	        source,
	        strict,
	        index,
	        lineNumber,
	        lineStart,
	        hasLineTerminator,
	        lastIndex,
	        lastLineNumber,
	        lastLineStart,
	        startIndex,
	        startLineNumber,
	        startLineStart,
	        scanning,
	        length,
	        lookahead,
	        state,
	        extra,
	        isBindingElement,
	        isAssignmentTarget,
	        firstCoverInitializedNameError;

	    Token = {
	        BooleanLiteral: 1,
	        EOF: 2,
	        Identifier: 3,
	        Keyword: 4,
	        NullLiteral: 5,
	        NumericLiteral: 6,
	        Punctuator: 7,
	        StringLiteral: 8,
	        RegularExpression: 9,
	        Template: 10
	    };

	    TokenName = {};
	    TokenName[Token.BooleanLiteral] = 'Boolean';
	    TokenName[Token.EOF] = '<end>';
	    TokenName[Token.Identifier] = 'Identifier';
	    TokenName[Token.Keyword] = 'Keyword';
	    TokenName[Token.NullLiteral] = 'Null';
	    TokenName[Token.NumericLiteral] = 'Numeric';
	    TokenName[Token.Punctuator] = 'Punctuator';
	    TokenName[Token.StringLiteral] = 'String';
	    TokenName[Token.RegularExpression] = 'RegularExpression';
	    TokenName[Token.Template] = 'Template';

	    // A function following one of those tokens is an expression.
	    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	                    'return', 'case', 'delete', 'throw', 'void',
	                    // assignment operators
	                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',
	                    '&=', '|=', '^=', ',',
	                    // binary/unary operators
	                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	                    '<=', '<', '>', '!=', '!=='];

	    Syntax = {
	        AssignmentExpression: 'AssignmentExpression',
	        AssignmentPattern: 'AssignmentPattern',
	        ArrayExpression: 'ArrayExpression',
	        ArrayPattern: 'ArrayPattern',
	        ArrowFunctionExpression: 'ArrowFunctionExpression',
	        BlockStatement: 'BlockStatement',
	        BinaryExpression: 'BinaryExpression',
	        BreakStatement: 'BreakStatement',
	        CallExpression: 'CallExpression',
	        CatchClause: 'CatchClause',
	        ClassBody: 'ClassBody',
	        ClassDeclaration: 'ClassDeclaration',
	        ClassExpression: 'ClassExpression',
	        ConditionalExpression: 'ConditionalExpression',
	        ContinueStatement: 'ContinueStatement',
	        DoWhileStatement: 'DoWhileStatement',
	        DebuggerStatement: 'DebuggerStatement',
	        EmptyStatement: 'EmptyStatement',
	        ExportAllDeclaration: 'ExportAllDeclaration',
	        ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	        ExportNamedDeclaration: 'ExportNamedDeclaration',
	        ExportSpecifier: 'ExportSpecifier',
	        ExpressionStatement: 'ExpressionStatement',
	        ForStatement: 'ForStatement',
	        ForOfStatement: 'ForOfStatement',
	        ForInStatement: 'ForInStatement',
	        FunctionDeclaration: 'FunctionDeclaration',
	        FunctionExpression: 'FunctionExpression',
	        Identifier: 'Identifier',
	        IfStatement: 'IfStatement',
	        ImportDeclaration: 'ImportDeclaration',
	        ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	        ImportSpecifier: 'ImportSpecifier',
	        Literal: 'Literal',
	        LabeledStatement: 'LabeledStatement',
	        LogicalExpression: 'LogicalExpression',
	        MemberExpression: 'MemberExpression',
	        MetaProperty: 'MetaProperty',
	        MethodDefinition: 'MethodDefinition',
	        NewExpression: 'NewExpression',
	        ObjectExpression: 'ObjectExpression',
	        ObjectPattern: 'ObjectPattern',
	        Program: 'Program',
	        Property: 'Property',
	        RestElement: 'RestElement',
	        ReturnStatement: 'ReturnStatement',
	        SequenceExpression: 'SequenceExpression',
	        SpreadElement: 'SpreadElement',
	        Super: 'Super',
	        SwitchCase: 'SwitchCase',
	        SwitchStatement: 'SwitchStatement',
	        TaggedTemplateExpression: 'TaggedTemplateExpression',
	        TemplateElement: 'TemplateElement',
	        TemplateLiteral: 'TemplateLiteral',
	        ThisExpression: 'ThisExpression',
	        ThrowStatement: 'ThrowStatement',
	        TryStatement: 'TryStatement',
	        UnaryExpression: 'UnaryExpression',
	        UpdateExpression: 'UpdateExpression',
	        VariableDeclaration: 'VariableDeclaration',
	        VariableDeclarator: 'VariableDeclarator',
	        WhileStatement: 'WhileStatement',
	        WithStatement: 'WithStatement',
	        YieldExpression: 'YieldExpression'
	    };

	    PlaceHolders = {
	        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'
	    };

	    // Error messages should be identical to V8.
	    Messages = {
	        UnexpectedToken: 'Unexpected token %0',
	        UnexpectedNumber: 'Unexpected number',
	        UnexpectedString: 'Unexpected string',
	        UnexpectedIdentifier: 'Unexpected identifier',
	        UnexpectedReserved: 'Unexpected reserved word',
	        UnexpectedTemplate: 'Unexpected quasi %0',
	        UnexpectedEOS: 'Unexpected end of input',
	        NewlineAfterThrow: 'Illegal newline after throw',
	        InvalidRegExp: 'Invalid regular expression',
	        UnterminatedRegExp: 'Invalid regular expression: missing /',
	        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	        InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	        InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	        NoCatchOrFinally: 'Missing catch or finally after try',
	        UnknownLabel: 'Undefined label \'%0\'',
	        Redeclaration: '%0 \'%1\' has already been declared',
	        IllegalContinue: 'Illegal continue statement',
	        IllegalBreak: 'Illegal break statement',
	        IllegalReturn: 'Illegal return statement',
	        StrictModeWith: 'Strict mode code may not include a with statement',
	        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	        StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	        StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	        StrictReservedWord: 'Use of future reserved word in strict mode',
	        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	        DefaultRestParameter: 'Unexpected token =',
	        ObjectPatternAsRestParameter: 'Unexpected token {',
	        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	        ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	        DuplicateConstructor: 'A class may only have one constructor',
	        StaticPrototype: 'Classes may not have static property named prototype',
	        MissingFromClause: 'Unexpected token',
	        NoAsAfterImportNamespace: 'Unexpected token',
	        InvalidModuleSpecifier: 'Unexpected token',
	        IllegalImportDeclaration: 'Unexpected token',
	        IllegalExportDeclaration: 'Unexpected token',
	        DuplicateBinding: 'Duplicate binding %0'
	    };

	    // See also tools/generate-unicode-regex.js.
	    Regex = {
	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
	        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,

	        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
	        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	    };

	    // Ensure the condition is true, otherwise throw an error.
	    // This is only to have a better contract semantic, i.e. another safety net
	    // to catch a logic error. The condition shall be fulfilled in normal case.
	    // Do NOT use this to enforce a certain condition on any user input.

	    function assert(condition, message) {
	        /* istanbul ignore if */
	        if (!condition) {
	            throw new Error('ASSERT: ' + message);
	        }
	    }

	    function isDecimalDigit(ch) {
	        return (ch >= 0x30 && ch <= 0x39);   // 0..9
	    }

	    function isHexDigit(ch) {
	        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;
	    }

	    function isOctalDigit(ch) {
	        return '01234567'.indexOf(ch) >= 0;
	    }

	    function octalToDecimal(ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);

	        if (index < length && isOctalDigit(source[index])) {
	            octal = true;
	            code = code * 8 + '01234567'.indexOf(source[index++]);

	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 &&
	                    index < length &&
	                    isOctalDigit(source[index])) {
	                code = code * 8 + '01234567'.indexOf(source[index++]);
	            }
	        }

	        return {
	            code: code,
	            octal: octal
	        };
	    }

	    // ECMA-262 11.2 White Space

	    function isWhiteSpace(ch) {
	        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||
	            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);
	    }

	    // ECMA-262 11.3 Line Terminators

	    function isLineTerminator(ch) {
	        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);
	    }

	    // ECMA-262 11.6 Identifier Names and Identifiers

	    function fromCodePoint(cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	            String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    }

	    function isIdentifierStart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch)));
	    }

	    function isIdentifierPart(ch) {
	        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)
	            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z
	            (ch >= 0x61 && ch <= 0x7A) ||         // a..z
	            (ch >= 0x30 && ch <= 0x39) ||         // 0..9
	            (ch === 0x5C) ||                      // \ (backslash)
	            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch)));
	    }

	    // ECMA-262 11.6.2.2 Future Reserved Words

	    function isFutureReservedWord(id) {
	        switch (id) {
	        case 'enum':
	        case 'export':
	        case 'import':
	        case 'super':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isStrictModeReservedWord(id) {
	        switch (id) {
	        case 'implements':
	        case 'interface':
	        case 'package':
	        case 'private':
	        case 'protected':
	        case 'public':
	        case 'static':
	        case 'yield':
	        case 'let':
	            return true;
	        default:
	            return false;
	        }
	    }

	    function isRestrictedWord(id) {
	        return id === 'eval' || id === 'arguments';
	    }

	    // ECMA-262 11.6.2.1 Keywords

	    function isKeyword(id) {
	        switch (id.length) {
	        case 2:
	            return (id === 'if') || (id === 'in') || (id === 'do');
	        case 3:
	            return (id === 'var') || (id === 'for') || (id === 'new') ||
	                (id === 'try') || (id === 'let');
	        case 4:
	            return (id === 'this') || (id === 'else') || (id === 'case') ||
	                (id === 'void') || (id === 'with') || (id === 'enum');
	        case 5:
	            return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                (id === 'class') || (id === 'super');
	        case 6:
	            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                (id === 'switch') || (id === 'export') || (id === 'import');
	        case 7:
	            return (id === 'default') || (id === 'finally') || (id === 'extends');
	        case 8:
	            return (id === 'function') || (id === 'continue') || (id === 'debugger');
	        case 10:
	            return (id === 'instanceof');
	        default:
	            return false;
	        }
	    }

	    // ECMA-262 11.4 Comments

	    function addComment(type, value, start, end, loc) {
	        var comment;

	        assert(typeof start === 'number', 'Comment must have valid position');

	        state.lastCommentStart = start;

	        comment = {
	            type: type,
	            value: value
	        };
	        if (extra.range) {
	            comment.range = [start, end];
	        }
	        if (extra.loc) {
	            comment.loc = loc;
	        }
	        extra.comments.push(comment);
	        if (extra.attachComment) {
	            extra.leadingComments.push(comment);
	            extra.trailingComments.push(comment);
	        }
	        if (extra.tokenize) {
	            comment.type = comment.type + 'Comment';
	            if (extra.delegate) {
	                comment = extra.delegate(comment);
	            }
	            extra.tokens.push(comment);
	        }
	    }

	    function skipSingleLineComment(offset) {
	        var start, loc, ch, comment;

	        start = index - offset;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart - offset
	            }
	        };

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            ++index;
	            if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                if (extra.comments) {
	                    comment = source.slice(start + offset, index - 1);
	                    loc.end = {
	                        line: lineNumber,
	                        column: index - lineStart - 1
	                    };
	                    addComment('Line', comment, start, index - 1, loc);
	                }
	                if (ch === 13 && source.charCodeAt(index) === 10) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                return;
	            }
	        }

	        if (extra.comments) {
	            comment = source.slice(start + offset, index);
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            addComment('Line', comment, start, index, loc);
	        }
	    }

	    function skipMultiLineComment() {
	        var start, loc, ch, comment;

	        if (extra.comments) {
	            start = index - 2;
	            loc = {
	                start: {
	                    line: lineNumber,
	                    column: index - lineStart - 2
	                }
	            };
	        }

	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (isLineTerminator(ch)) {
	                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {
	                    ++index;
	                }
	                hasLineTerminator = true;
	                ++lineNumber;
	                ++index;
	                lineStart = index;
	            } else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (source.charCodeAt(index + 1) === 0x2F) {
	                    ++index;
	                    ++index;
	                    if (extra.comments) {
	                        comment = source.slice(start + 2, index - 2);
	                        loc.end = {
	                            line: lineNumber,
	                            column: index - lineStart
	                        };
	                        addComment('Block', comment, start, index, loc);
	                    }
	                    return;
	                }
	                ++index;
	            } else {
	                ++index;
	            }
	        }

	        // Ran off the end of the file - the whole thing is a comment
	        if (extra.comments) {
	            loc.end = {
	                line: lineNumber,
	                column: index - lineStart
	            };
	            comment = source.slice(start + 2, index);
	            addComment('Block', comment, start, index, loc);
	        }
	        tolerateUnexpectedToken();
	    }

	    function skipComment() {
	        var ch, start;
	        hasLineTerminator = false;

	        start = (index === 0);
	        while (index < length) {
	            ch = source.charCodeAt(index);

	            if (isWhiteSpace(ch)) {
	                ++index;
	            } else if (isLineTerminator(ch)) {
	                hasLineTerminator = true;
	                ++index;
	                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {
	                    ++index;
	                }
	                ++lineNumber;
	                lineStart = index;
	                start = true;
	            } else if (ch === 0x2F) { // U+002F is '/'
	                ch = source.charCodeAt(index + 1);
	                if (ch === 0x2F) {
	                    ++index;
	                    ++index;
	                    skipSingleLineComment(2);
	                    start = true;
	                } else if (ch === 0x2A) {  // U+002A is '*'
	                    ++index;
	                    ++index;
	                    skipMultiLineComment();
	                } else {
	                    break;
	                }
	            } else if (start && ch === 0x2D) { // U+002D is '-'
	                // U+003E is '>'
	                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    index += 3;
	                    skipSingleLineComment(3);
	                } else {
	                    break;
	                }
	            } else if (ch === 0x3C) { // U+003C is '<'
	                if (source.slice(index + 1, index + 4) === '!--') {
	                    ++index; // `<`
	                    ++index; // `!`
	                    ++index; // `-`
	                    ++index; // `-`
	                    skipSingleLineComment(4);
	                } else {
	                    break;
	                }
	            } else {
	                break;
	            }
	        }
	    }

	    function scanHexEscape(prefix) {
	        var i, len, ch, code = 0;

	        len = (prefix === 'u') ? 4 : 2;
	        for (i = 0; i < len; ++i) {
	            if (index < length && isHexDigit(source[index])) {
	                ch = source[index++];
	                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	            } else {
	                return '';
	            }
	        }
	        return String.fromCharCode(code);
	    }

	    function scanUnicodeCodePointEscape() {
	        var ch, code;

	        ch = source[index];
	        code = 0;

	        // At least, one hex digit is required.
	        if (ch === '}') {
	            throwUnexpectedToken();
	        }

	        while (index < length) {
	            ch = source[index++];
	            if (!isHexDigit(ch)) {
	                break;
	            }
	            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
	        }

	        if (code > 0x10FFFF || ch !== '}') {
	            throwUnexpectedToken();
	        }

	        return fromCodePoint(code);
	    }

	    function codePointAt(i) {
	        var cp, first, second;

	        cp = source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            second = source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }

	        return cp;
	    }

	    function getComplexIdentifier() {
	        var cp, ch, id;

	        cp = codePointAt(index);
	        id = fromCodePoint(cp);
	        index += id.length;

	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        if (cp === 0x5C) {
	            if (source.charCodeAt(index) !== 0x75) {
	                throwUnexpectedToken();
	            }
	            ++index;
	            if (source[index] === '{') {
	                ++index;
	                ch = scanUnicodeCodePointEscape();
	            } else {
	                ch = scanHexEscape('u');
	                cp = ch.charCodeAt(0);
	                if (!ch || ch === '\\' || !isIdentifierStart(cp)) {
	                    throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }

	        while (index < length) {
	            cp = codePointAt(index);
	            if (!isIdentifierPart(cp)) {
	                break;
	            }
	            ch = fromCodePoint(cp);
	            id += ch;
	            index += ch.length;

	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (source.charCodeAt(index) !== 0x75) {
	                    throwUnexpectedToken();
	                }
	                ++index;
	                if (source[index] === '{') {
	                    ++index;
	                    ch = scanUnicodeCodePointEscape();
	                } else {
	                    ch = scanHexEscape('u');
	                    cp = ch.charCodeAt(0);
	                    if (!ch || ch === '\\' || !isIdentifierPart(cp)) {
	                        throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }

	        return id;
	    }

	    function getIdentifier() {
	        var start, ch;

	        start = index++;
	        while (index < length) {
	            ch = source.charCodeAt(index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                index = start;
	                return getComplexIdentifier();
	            } else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                index = start;
	                return getComplexIdentifier();
	            }
	            if (isIdentifierPart(ch)) {
	                ++index;
	            } else {
	                break;
	            }
	        }

	        return source.slice(start, index);
	    }

	    function scanIdentifier() {
	        var start, id, type;

	        start = index;

	        // Backslash (U+005C) starts an escaped character.
	        id = (source.charCodeAt(index) === 0x5C) ? getComplexIdentifier() : getIdentifier();

	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = Token.Identifier;
	        } else if (isKeyword(id)) {
	            type = Token.Keyword;
	        } else if (id === 'null') {
	            type = Token.NullLiteral;
	        } else if (id === 'true' || id === 'false') {
	            type = Token.BooleanLiteral;
	        } else {
	            type = Token.Identifier;
	        }

	        return {
	            type: type,
	            value: id,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }


	    // ECMA-262 11.7 Punctuators

	    function scanPunctuator() {
	        var token, str;

	        token = {
	            type: Token.Punctuator,
	            value: '',
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: index,
	            end: index
	        };

	        // Check for most common single-character punctuators.
	        str = source[index];
	        switch (str) {

	        case '(':
	            if (extra.tokenize) {
	                extra.openParenToken = extra.tokenValues.length;
	            }
	            ++index;
	            break;

	        case '{':
	            if (extra.tokenize) {
	                extra.openCurlyToken = extra.tokenValues.length;
	            }
	            state.curlyStack.push('{');
	            ++index;
	            break;

	        case '.':
	            ++index;
	            if (source[index] === '.' && source[index + 1] === '.') {
	                // Spread operator: ...
	                index += 2;
	                str = '...';
	            }
	            break;

	        case '}':
	            ++index;
	            state.curlyStack.pop();
	            break;
	        case ')':
	        case ';':
	        case ',':
	        case '[':
	        case ']':
	        case ':':
	        case '?':
	        case '~':
	            ++index;
	            break;

	        default:
	            // 4-character punctuator.
	            str = source.substr(index, 4);
	            if (str === '>>>=') {
	                index += 4;
	            } else {

	                // 3-character punctuators.
	                str = str.substr(0, 3);
	                if (str === '===' || str === '!==' || str === '>>>' ||
	                    str === '<<=' || str === '>>=') {
	                    index += 3;
	                } else {

	                    // 2-character punctuators.
	                    str = str.substr(0, 2);
	                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                        str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                        str === '<=' || str === '>=' || str === '=>') {
	                        index += 2;
	                    } else {

	                        // 1-character punctuators.
	                        str = source[index];
	                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                            ++index;
	                        }
	                    }
	                }
	            }
	        }

	        if (index === token.start) {
	            throwUnexpectedToken();
	        }

	        token.end = index;
	        token.value = str;
	        return token;
	    }

	    // ECMA-262 11.8.3 Numeric Literals

	    function scanHexLiteral(start) {
	        var number = '';

	        while (index < length) {
	            if (!isHexDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt('0x' + number, 16),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanBinaryLiteral(start) {
	        var ch, number;

	        number = '';

	        while (index < length) {
	            ch = source[index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            number += source[index++];
	        }

	        if (number.length === 0) {
	            // only 0b or 0B
	            throwUnexpectedToken();
	        }

	        if (index < length) {
	            ch = source.charCodeAt(index);
	            /* istanbul ignore else */
	            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {
	                throwUnexpectedToken();
	            }
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 2),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function scanOctalLiteral(prefix, start) {
	        var number, octal;

	        if (isOctalDigit(prefix)) {
	            octal = true;
	            number = '0' + source[index++];
	        } else {
	            octal = false;
	            ++index;
	            number = '';
	        }

	        while (index < length) {
	            if (!isOctalDigit(source[index])) {
	                break;
	            }
	            number += source[index++];
	        }

	        if (!octal && number.length === 0) {
	            // only 0o or 0O
	            throwUnexpectedToken();
	        }

	        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseInt(number, 8),
	            octal: octal,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    function isImplicitOctalLiteral() {
	        var i, ch;

	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (i = index + 1; i < length; ++i) {
	            ch = source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!isOctalDigit(ch)) {
	                return true;
	            }
	        }

	        return true;
	    }

	    function scanNumericLiteral() {
	        var number, start, ch;

	        ch = source[index];
	        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),
	            'Numeric literal must start with a decimal digit or a decimal point');

	        start = index;
	        number = '';
	        if (ch !== '.') {
	            number = source[index++];
	            ch = source[index];

	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (number === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++index;
	                    return scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++index;
	                    return scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return scanOctalLiteral(ch, start);
	                }

	                if (isOctalDigit(ch)) {
	                    if (isImplicitOctalLiteral()) {
	                        return scanOctalLiteral(ch, start);
	                    }
	                }
	            }

	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === '.') {
	            number += source[index++];
	            while (isDecimalDigit(source.charCodeAt(index))) {
	                number += source[index++];
	            }
	            ch = source[index];
	        }

	        if (ch === 'e' || ch === 'E') {
	            number += source[index++];

	            ch = source[index];
	            if (ch === '+' || ch === '-') {
	                number += source[index++];
	            }
	            if (isDecimalDigit(source.charCodeAt(index))) {
	                while (isDecimalDigit(source.charCodeAt(index))) {
	                    number += source[index++];
	                }
	            } else {
	                throwUnexpectedToken();
	            }
	        }

	        if (isIdentifierStart(source.charCodeAt(index))) {
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.NumericLiteral,
	            value: parseFloat(number),
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.4 String Literals

	    function scanStringLiteral() {
	        var str = '', quote, start, ch, unescaped, octToDec, octal = false;

	        quote = source[index];
	        assert((quote === '\'' || quote === '"'),
	            'String literal must starts with a quote');

	        start = index;
	        ++index;

	        while (index < length) {
	            ch = source[index++];

	            if (ch === quote) {
	                quote = '';
	                break;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            str += scanUnicodeCodePointEscape();
	                        } else {
	                            unescaped = scanHexEscape(ch);
	                            if (!unescaped) {
	                                throw throwUnexpectedToken();
	                            }
	                            str += unescaped;
	                        }
	                        break;
	                    case 'n':
	                        str += '\n';
	                        break;
	                    case 'r':
	                        str += '\r';
	                        break;
	                    case 't':
	                        str += '\t';
	                        break;
	                    case 'b':
	                        str += '\b';
	                        break;
	                    case 'f':
	                        str += '\f';
	                        break;
	                    case 'v':
	                        str += '\x0B';
	                        break;
	                    case '8':
	                    case '9':
	                        str += ch;
	                        tolerateUnexpectedToken();
	                        break;

	                    default:
	                        if (isOctalDigit(ch)) {
	                            octToDec = octalToDecimal(ch);

	                            octal = octToDec.octal || octal;
	                            str += String.fromCharCode(octToDec.code);
	                        } else {
	                            str += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            } else {
	                str += ch;
	            }
	        }

	        if (quote !== '') {
	            index = start;
	            throwUnexpectedToken();
	        }

	        return {
	            type: Token.StringLiteral,
	            value: str,
	            octal: octal,
	            lineNumber: startLineNumber,
	            lineStart: startLineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.6 Template Literal Lexical Components

	    function scanTemplate() {
	        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;

	        terminated = false;
	        tail = false;
	        start = index;
	        head = (source[index] === '`');
	        rawOffset = 2;

	        ++index;

	        while (index < length) {
	            ch = source[index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            } else if (ch === '$') {
	                if (source[index] === '{') {
	                    state.curlyStack.push('${');
	                    ++index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            } else if (ch === '\\') {
	                ch = source[index++];
	                if (!isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                    case 'n':
	                        cooked += '\n';
	                        break;
	                    case 'r':
	                        cooked += '\r';
	                        break;
	                    case 't':
	                        cooked += '\t';
	                        break;
	                    case 'u':
	                    case 'x':
	                        if (source[index] === '{') {
	                            ++index;
	                            cooked += scanUnicodeCodePointEscape();
	                        } else {
	                            restore = index;
	                            unescaped = scanHexEscape(ch);
	                            if (unescaped) {
	                                cooked += unescaped;
	                            } else {
	                                index = restore;
	                                cooked += ch;
	                            }
	                        }
	                        break;
	                    case 'b':
	                        cooked += '\b';
	                        break;
	                    case 'f':
	                        cooked += '\f';
	                        break;
	                    case 'v':
	                        cooked += '\v';
	                        break;

	                    default:
	                        if (ch === '0') {
	                            if (isDecimalDigit(source.charCodeAt(index))) {
	                                // Illegal: \01 \02 and so on
	                                throwError(Messages.TemplateOctalLiteral);
	                            }
	                            cooked += '\0';
	                        } else if (isOctalDigit(ch)) {
	                            // Illegal: \1 \2
	                            throwError(Messages.TemplateOctalLiteral);
	                        } else {
	                            cooked += ch;
	                        }
	                        break;
	                    }
	                } else {
	                    ++lineNumber;
	                    if (ch === '\r' && source[index] === '\n') {
	                        ++index;
	                    }
	                    lineStart = index;
	                }
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                ++lineNumber;
	                if (ch === '\r' && source[index] === '\n') {
	                    ++index;
	                }
	                lineStart = index;
	                cooked += '\n';
	            } else {
	                cooked += ch;
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken();
	        }

	        if (!head) {
	            state.curlyStack.pop();
	        }

	        return {
	            type: Token.Template,
	            value: {
	                cooked: cooked,
	                raw: source.slice(start + 1, index - rawOffset)
	            },
	            head: head,
	            tail: tail,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            start: start,
	            end: index
	        };
	    }

	    // ECMA-262 11.8.5 Regular Expression Literals

	    function testRegExp(pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF',
	            tmp = pattern;

	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                // Replace every Unicode escape sequence with the equivalent
	                // BMP character or a constant ASCII code point in the case of
	                // astral symbols. (See the above note on `astralSubstitute`
	                // for more information.)
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                    var codePoint = parseInt($1 || $2, 16);
	                    if (codePoint > 0x10FFFF) {
	                        throwUnexpectedToken(null, Messages.InvalidRegExp);
	                    }
	                    if (codePoint <= 0xFFFF) {
	                        return String.fromCharCode(codePoint);
	                    }
	                    return astralSubstitute;
	                })
	                // Replace each paired surrogate with a single ASCII symbol to
	                // avoid throwing on regular expressions that are only valid in
	                // combination with the "u" flag.
	                .replace(
	                    /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
	                    astralSubstitute
	                );
	        }

	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        } catch (e) {
	            throwUnexpectedToken(null, Messages.InvalidRegExp);
	        }

	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        } catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    }

	    function scanRegExpBody() {
	        var ch, str, classMarker, terminated, body;

	        ch = source[index];
	        assert(ch === '/', 'Regular expression literal must start with a slash');
	        str = source[index++];

	        classMarker = false;
	        terminated = false;
	        while (index < length) {
	            ch = source[index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = source[index++];
	                // ECMA-262 7.8.5
	                if (isLineTerminator(ch.charCodeAt(0))) {
	                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            } else if (isLineTerminator(ch.charCodeAt(0))) {
	                throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	            } else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            } else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                } else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }

	        if (!terminated) {
	            throwUnexpectedToken(null, Messages.UnterminatedRegExp);
	        }

	        // Exclude leading and trailing slash.
	        body = str.substr(1, str.length - 2);
	        return {
	            value: body,
	            literal: str
	        };
	    }

	    function scanRegExpFlags() {
	        var ch, str, flags, restore;

	        str = '';
	        flags = '';
	        while (index < length) {
	            ch = source[index];
	            if (!isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }

	            ++index;
	            if (ch === '\\' && index < length) {
	                ch = source[index];
	                if (ch === 'u') {
	                    ++index;
	                    restore = index;
	                    ch = scanHexEscape('u');
	                    if (ch) {
	                        flags += ch;
	                        for (str += '\\u'; restore < index; ++restore) {
	                            str += source[restore];
	                        }
	                    } else {
	                        index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    tolerateUnexpectedToken();
	                } else {
	                    str += '\\';
	                    tolerateUnexpectedToken();
	                }
	            } else {
	                flags += ch;
	                str += ch;
	            }
	        }

	        return {
	            value: flags,
	            literal: str
	        };
	    }

	    function scanRegExp() {
	        var start, body, flags, value;
	        scanning = true;

	        lookahead = null;
	        skipComment();
	        start = index;

	        body = scanRegExpBody();
	        flags = scanRegExpFlags();
	        value = testRegExp(body.value, flags.value);
	        scanning = false;
	        if (extra.tokenize) {
	            return {
	                type: Token.RegularExpression,
	                value: value,
	                regex: {
	                    pattern: body.value,
	                    flags: flags.value
	                },
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: start,
	                end: index
	            };
	        }

	        return {
	            literal: body.literal + flags.literal,
	            value: value,
	            regex: {
	                pattern: body.value,
	                flags: flags.value
	            },
	            start: start,
	            end: index
	        };
	    }

	    function collectRegex() {
	        var pos, loc, regex, token;

	        skipComment();

	        pos = index;
	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        regex = scanRegExp();

	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        /* istanbul ignore next */
	        if (!extra.tokenize) {
	            // Pop the previous token, which is likely '/' or '/='
	            if (extra.tokens.length > 0) {
	                token = extra.tokens[extra.tokens.length - 1];
	                if (token.range[0] === pos && token.type === 'Punctuator') {
	                    if (token.value === '/' || token.value === '/=') {
	                        extra.tokens.pop();
	                    }
	                }
	            }

	            extra.tokens.push({
	                type: 'RegularExpression',
	                value: regex.literal,
	                regex: regex.regex,
	                range: [pos, index],
	                loc: loc
	            });
	        }

	        return regex;
	    }

	    function isIdentifierName(token) {
	        return token.type === Token.Identifier ||
	            token.type === Token.Keyword ||
	            token.type === Token.BooleanLiteral ||
	            token.type === Token.NullLiteral;
	    }

	    // Using the following algorithm:
	    // https://github.com/mozilla/sweet.js/wiki/design

	    function advanceSlash() {
	        var regex, previous, check;

	        function testKeyword(value) {
	            return value && (value.length > 1) && (value[0] >= 'a') && (value[0] <= 'z');
	        }

	        previous = extra.tokenValues[extra.tokenValues.length - 1];
	        regex = (previous !== null);

	        switch (previous) {
	        case 'this':
	        case ']':
	            regex = false;
	            break;

	        case ')':
	            check = extra.tokenValues[extra.openParenToken - 1];
	            regex = (check === 'if' || check === 'while' || check === 'for' || check === 'with');
	            break;

	        case '}':
	            // Dividing a function by anything makes little sense,
	            // but we have to check for that.
	            regex = false;
	            if (testKeyword(extra.tokenValues[extra.openCurlyToken - 3])) {
	                // Anonymous function, e.g. function(){} /42
	                check = extra.tokenValues[extra.openCurlyToken - 4];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : false;
	            } else if (testKeyword(extra.tokenValues[extra.openCurlyToken - 4])) {
	                // Named function, e.g. function f(){} /42/
	                check = extra.tokenValues[extra.openCurlyToken - 5];
	                regex = check ? (FnExprTokens.indexOf(check) < 0) : true;
	            }
	        }

	        return regex ? collectRegex() : scanPunctuator();
	    }

	    function advance() {
	        var cp, token;

	        if (index >= length) {
	            return {
	                type: Token.EOF,
	                lineNumber: lineNumber,
	                lineStart: lineStart,
	                start: index,
	                end: index
	            };
	        }

	        cp = source.charCodeAt(index);

	        if (isIdentifierStart(cp)) {
	            token = scanIdentifier();
	            if (strict && isStrictModeReservedWord(token.value)) {
	                token.type = Token.Keyword;
	            }
	            return token;
	        }

	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return scanPunctuator();
	        }

	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return scanStringLiteral();
	        }

	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (isDecimalDigit(source.charCodeAt(index + 1))) {
	                return scanNumericLiteral();
	            }
	            return scanPunctuator();
	        }

	        if (isDecimalDigit(cp)) {
	            return scanNumericLiteral();
	        }

	        // Slash (/) U+002F can also start a regex.
	        if (extra.tokenize && cp === 0x2F) {
	            return advanceSlash();
	        }

	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {
	            return scanTemplate();
	        }

	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            cp = codePointAt(index);
	            if (isIdentifierStart(cp)) {
	                return scanIdentifier();
	            }
	        }

	        return scanPunctuator();
	    }

	    function collectToken() {
	        var loc, token, value, entry;

	        loc = {
	            start: {
	                line: lineNumber,
	                column: index - lineStart
	            }
	        };

	        token = advance();
	        loc.end = {
	            line: lineNumber,
	            column: index - lineStart
	        };

	        if (token.type !== Token.EOF) {
	            value = source.slice(token.start, token.end);
	            entry = {
	                type: TokenName[token.type],
	                value: value,
	                range: [token.start, token.end],
	                loc: loc
	            };
	            if (token.regex) {
	                entry.regex = {
	                    pattern: token.regex.pattern,
	                    flags: token.regex.flags
	                };
	            }
	            if (extra.tokenValues) {
	                extra.tokenValues.push((entry.type === 'Punctuator' || entry.type === 'Keyword') ? entry.value : null);
	            }
	            if (extra.tokenize) {
	                if (!extra.range) {
	                    delete entry.range;
	                }
	                if (!extra.loc) {
	                    delete entry.loc;
	                }
	                if (extra.delegate) {
	                    entry = extra.delegate(entry);
	                }
	            }
	            extra.tokens.push(entry);
	        }

	        return token;
	    }

	    function lex() {
	        var token;
	        scanning = true;

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        skipComment();

	        token = lookahead;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	        return token;
	    }

	    function peek() {
	        scanning = true;

	        skipComment();

	        lastIndex = index;
	        lastLineNumber = lineNumber;
	        lastLineStart = lineStart;

	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;

	        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();
	        scanning = false;
	    }

	    function Position() {
	        this.line = startLineNumber;
	        this.column = startIndex - startLineStart;
	    }

	    function SourceLocation() {
	        this.start = new Position();
	        this.end = null;
	    }

	    function WrappingSourceLocation(startToken) {
	        this.start = {
	            line: startToken.lineNumber,
	            column: startToken.start - startToken.lineStart
	        };
	        this.end = null;
	    }

	    function Node() {
	        if (extra.range) {
	            this.range = [startIndex, 0];
	        }
	        if (extra.loc) {
	            this.loc = new SourceLocation();
	        }
	    }

	    function WrappingNode(startToken) {
	        if (extra.range) {
	            this.range = [startToken.start, 0];
	        }
	        if (extra.loc) {
	            this.loc = new WrappingSourceLocation(startToken);
	        }
	    }

	    WrappingNode.prototype = Node.prototype = {

	        processComment: function () {
	            var lastChild,
	                innerComments,
	                leadingComments,
	                trailingComments,
	                bottomRight = extra.bottomRightStack,
	                i,
	                comment,
	                last = bottomRight[bottomRight.length - 1];

	            if (this.type === Syntax.Program) {
	                if (this.body.length > 0) {
	                    return;
	                }
	            }
	            /**
	             * patch innnerComments for properties empty block
	             * `function a() {/** comments **\/}`
	             */

	            if (this.type === Syntax.BlockStatement && this.body.length === 0) {
	                innerComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (this.range[1] >= comment.range[1]) {
	                        innerComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                if (innerComments.length) {
	                    this.innerComments = innerComments;
	                    //bottomRight.push(this);
	                    return;
	                }
	            }

	            if (extra.trailingComments.length > 0) {
	                trailingComments = [];
	                for (i = extra.trailingComments.length - 1; i >= 0; --i) {
	                    comment = extra.trailingComments[i];
	                    if (comment.range[0] >= this.range[1]) {
	                        trailingComments.unshift(comment);
	                        extra.trailingComments.splice(i, 1);
	                    }
	                }
	                extra.trailingComments = [];
	            } else {
	                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {
	                    trailingComments = last.trailingComments;
	                    delete last.trailingComments;
	                }
	            }

	            // Eating the stack.
	            while (last && last.range[0] >= this.range[0]) {
	                lastChild = bottomRight.pop();
	                last = bottomRight[bottomRight.length - 1];
	            }

	            if (lastChild) {
	                if (lastChild.leadingComments) {
	                    leadingComments = [];
	                    for (i = lastChild.leadingComments.length - 1; i >= 0; --i) {
	                        comment = lastChild.leadingComments[i];
	                        if (comment.range[1] <= this.range[0]) {
	                            leadingComments.unshift(comment);
	                            lastChild.leadingComments.splice(i, 1);
	                        }
	                    }

	                    if (!lastChild.leadingComments.length) {
	                        lastChild.leadingComments = undefined;
	                    }
	                }
	            } else if (extra.leadingComments.length > 0) {
	                leadingComments = [];
	                for (i = extra.leadingComments.length - 1; i >= 0; --i) {
	                    comment = extra.leadingComments[i];
	                    if (comment.range[1] <= this.range[0]) {
	                        leadingComments.unshift(comment);
	                        extra.leadingComments.splice(i, 1);
	                    }
	                }
	            }


	            if (leadingComments && leadingComments.length > 0) {
	                this.leadingComments = leadingComments;
	            }
	            if (trailingComments && trailingComments.length > 0) {
	                this.trailingComments = trailingComments;
	            }

	            bottomRight.push(this);
	        },

	        finish: function () {
	            if (extra.range) {
	                this.range[1] = lastIndex;
	            }
	            if (extra.loc) {
	                this.loc.end = {
	                    line: lastLineNumber,
	                    column: lastIndex - lastLineStart
	                };
	                if (extra.source) {
	                    this.loc.source = extra.source;
	                }
	            }

	            if (extra.attachComment) {
	                this.processComment();
	            }
	        },

	        finishArrayExpression: function (elements) {
	            this.type = Syntax.ArrayExpression;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrayPattern: function (elements) {
	            this.type = Syntax.ArrayPattern;
	            this.elements = elements;
	            this.finish();
	            return this;
	        },

	        finishArrowFunctionExpression: function (params, defaults, body, expression) {
	            this.type = Syntax.ArrowFunctionExpression;
	            this.id = null;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = false;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishAssignmentExpression: function (operator, left, right) {
	            this.type = Syntax.AssignmentExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishAssignmentPattern: function (left, right) {
	            this.type = Syntax.AssignmentPattern;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBinaryExpression: function (operator, left, right) {
	            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;
	            this.operator = operator;
	            this.left = left;
	            this.right = right;
	            this.finish();
	            return this;
	        },

	        finishBlockStatement: function (body) {
	            this.type = Syntax.BlockStatement;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishBreakStatement: function (label) {
	            this.type = Syntax.BreakStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishCallExpression: function (callee, args) {
	            this.type = Syntax.CallExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishCatchClause: function (param, body) {
	            this.type = Syntax.CatchClause;
	            this.param = param;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassBody: function (body) {
	            this.type = Syntax.ClassBody;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassDeclaration: function (id, superClass, body) {
	            this.type = Syntax.ClassDeclaration;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishClassExpression: function (id, superClass, body) {
	            this.type = Syntax.ClassExpression;
	            this.id = id;
	            this.superClass = superClass;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishConditionalExpression: function (test, consequent, alternate) {
	            this.type = Syntax.ConditionalExpression;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishContinueStatement: function (label) {
	            this.type = Syntax.ContinueStatement;
	            this.label = label;
	            this.finish();
	            return this;
	        },

	        finishDebuggerStatement: function () {
	            this.type = Syntax.DebuggerStatement;
	            this.finish();
	            return this;
	        },

	        finishDoWhileStatement: function (body, test) {
	            this.type = Syntax.DoWhileStatement;
	            this.body = body;
	            this.test = test;
	            this.finish();
	            return this;
	        },

	        finishEmptyStatement: function () {
	            this.type = Syntax.EmptyStatement;
	            this.finish();
	            return this;
	        },

	        finishExpressionStatement: function (expression) {
	            this.type = Syntax.ExpressionStatement;
	            this.expression = expression;
	            this.finish();
	            return this;
	        },

	        finishForStatement: function (init, test, update, body) {
	            this.type = Syntax.ForStatement;
	            this.init = init;
	            this.test = test;
	            this.update = update;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishForOfStatement: function (left, right, body) {
	            this.type = Syntax.ForOfStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishForInStatement: function (left, right, body) {
	            this.type = Syntax.ForInStatement;
	            this.left = left;
	            this.right = right;
	            this.body = body;
	            this.each = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionDeclaration: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionDeclaration;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishFunctionExpression: function (id, params, defaults, body, generator) {
	            this.type = Syntax.FunctionExpression;
	            this.id = id;
	            this.params = params;
	            this.defaults = defaults;
	            this.body = body;
	            this.generator = generator;
	            this.expression = false;
	            this.finish();
	            return this;
	        },

	        finishIdentifier: function (name) {
	            this.type = Syntax.Identifier;
	            this.name = name;
	            this.finish();
	            return this;
	        },

	        finishIfStatement: function (test, consequent, alternate) {
	            this.type = Syntax.IfStatement;
	            this.test = test;
	            this.consequent = consequent;
	            this.alternate = alternate;
	            this.finish();
	            return this;
	        },

	        finishLabeledStatement: function (label, body) {
	            this.type = Syntax.LabeledStatement;
	            this.label = label;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishLiteral: function (token) {
	            this.type = Syntax.Literal;
	            this.value = token.value;
	            this.raw = source.slice(token.start, token.end);
	            if (token.regex) {
	                this.regex = token.regex;
	            }
	            this.finish();
	            return this;
	        },

	        finishMemberExpression: function (accessor, object, property) {
	            this.type = Syntax.MemberExpression;
	            this.computed = accessor === '[';
	            this.object = object;
	            this.property = property;
	            this.finish();
	            return this;
	        },

	        finishMetaProperty: function (meta, property) {
	            this.type = Syntax.MetaProperty;
	            this.meta = meta;
	            this.property = property;
	            this.finish();
	            return this;
	        },

	        finishNewExpression: function (callee, args) {
	            this.type = Syntax.NewExpression;
	            this.callee = callee;
	            this.arguments = args;
	            this.finish();
	            return this;
	        },

	        finishObjectExpression: function (properties) {
	            this.type = Syntax.ObjectExpression;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishObjectPattern: function (properties) {
	            this.type = Syntax.ObjectPattern;
	            this.properties = properties;
	            this.finish();
	            return this;
	        },

	        finishPostfixExpression: function (operator, argument) {
	            this.type = Syntax.UpdateExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = false;
	            this.finish();
	            return this;
	        },

	        finishProgram: function (body, sourceType) {
	            this.type = Syntax.Program;
	            this.body = body;
	            this.sourceType = sourceType;
	            this.finish();
	            return this;
	        },

	        finishProperty: function (kind, key, computed, value, method, shorthand) {
	            this.type = Syntax.Property;
	            this.key = key;
	            this.computed = computed;
	            this.value = value;
	            this.kind = kind;
	            this.method = method;
	            this.shorthand = shorthand;
	            this.finish();
	            return this;
	        },

	        finishRestElement: function (argument) {
	            this.type = Syntax.RestElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishReturnStatement: function (argument) {
	            this.type = Syntax.ReturnStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSequenceExpression: function (expressions) {
	            this.type = Syntax.SequenceExpression;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishSpreadElement: function (argument) {
	            this.type = Syntax.SpreadElement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishSwitchCase: function (test, consequent) {
	            this.type = Syntax.SwitchCase;
	            this.test = test;
	            this.consequent = consequent;
	            this.finish();
	            return this;
	        },

	        finishSuper: function () {
	            this.type = Syntax.Super;
	            this.finish();
	            return this;
	        },

	        finishSwitchStatement: function (discriminant, cases) {
	            this.type = Syntax.SwitchStatement;
	            this.discriminant = discriminant;
	            this.cases = cases;
	            this.finish();
	            return this;
	        },

	        finishTaggedTemplateExpression: function (tag, quasi) {
	            this.type = Syntax.TaggedTemplateExpression;
	            this.tag = tag;
	            this.quasi = quasi;
	            this.finish();
	            return this;
	        },

	        finishTemplateElement: function (value, tail) {
	            this.type = Syntax.TemplateElement;
	            this.value = value;
	            this.tail = tail;
	            this.finish();
	            return this;
	        },

	        finishTemplateLiteral: function (quasis, expressions) {
	            this.type = Syntax.TemplateLiteral;
	            this.quasis = quasis;
	            this.expressions = expressions;
	            this.finish();
	            return this;
	        },

	        finishThisExpression: function () {
	            this.type = Syntax.ThisExpression;
	            this.finish();
	            return this;
	        },

	        finishThrowStatement: function (argument) {
	            this.type = Syntax.ThrowStatement;
	            this.argument = argument;
	            this.finish();
	            return this;
	        },

	        finishTryStatement: function (block, handler, finalizer) {
	            this.type = Syntax.TryStatement;
	            this.block = block;
	            this.guardedHandlers = [];
	            this.handlers = handler ? [handler] : [];
	            this.handler = handler;
	            this.finalizer = finalizer;
	            this.finish();
	            return this;
	        },

	        finishUnaryExpression: function (operator, argument) {
	            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;
	            this.operator = operator;
	            this.argument = argument;
	            this.prefix = true;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclaration: function (declarations) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = 'var';
	            this.finish();
	            return this;
	        },

	        finishLexicalDeclaration: function (declarations, kind) {
	            this.type = Syntax.VariableDeclaration;
	            this.declarations = declarations;
	            this.kind = kind;
	            this.finish();
	            return this;
	        },

	        finishVariableDeclarator: function (id, init) {
	            this.type = Syntax.VariableDeclarator;
	            this.id = id;
	            this.init = init;
	            this.finish();
	            return this;
	        },

	        finishWhileStatement: function (test, body) {
	            this.type = Syntax.WhileStatement;
	            this.test = test;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishWithStatement: function (object, body) {
	            this.type = Syntax.WithStatement;
	            this.object = object;
	            this.body = body;
	            this.finish();
	            return this;
	        },

	        finishExportSpecifier: function (local, exported) {
	            this.type = Syntax.ExportSpecifier;
	            this.exported = exported || local;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportDefaultSpecifier: function (local) {
	            this.type = Syntax.ImportDefaultSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishImportNamespaceSpecifier: function (local) {
	            this.type = Syntax.ImportNamespaceSpecifier;
	            this.local = local;
	            this.finish();
	            return this;
	        },

	        finishExportNamedDeclaration: function (declaration, specifiers, src) {
	            this.type = Syntax.ExportNamedDeclaration;
	            this.declaration = declaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishExportDefaultDeclaration: function (declaration) {
	            this.type = Syntax.ExportDefaultDeclaration;
	            this.declaration = declaration;
	            this.finish();
	            return this;
	        },

	        finishExportAllDeclaration: function (src) {
	            this.type = Syntax.ExportAllDeclaration;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishImportSpecifier: function (local, imported) {
	            this.type = Syntax.ImportSpecifier;
	            this.local = local || imported;
	            this.imported = imported;
	            this.finish();
	            return this;
	        },

	        finishImportDeclaration: function (specifiers, src) {
	            this.type = Syntax.ImportDeclaration;
	            this.specifiers = specifiers;
	            this.source = src;
	            this.finish();
	            return this;
	        },

	        finishYieldExpression: function (argument, delegate) {
	            this.type = Syntax.YieldExpression;
	            this.argument = argument;
	            this.delegate = delegate;
	            this.finish();
	            return this;
	        }
	    };


	    function recordError(error) {
	        var e, existing;

	        for (e = 0; e < extra.errors.length; e++) {
	            existing = extra.errors[e];
	            // Prevent duplicated error.
	            /* istanbul ignore next */
	            if (existing.index === error.index && existing.message === error.message) {
	                return;
	            }
	        }

	        extra.errors.push(error);
	    }

	    function constructError(msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        } catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        } finally {
	            return error;
	        }
	    }

	    function createError(line, pos, description) {
	        var msg, column, error;

	        msg = 'Line ' + line + ': ' + description;
	        column = pos - (scanning ? lineStart : lastLineStart) + 1;
	        error = constructError(msg, column);
	        error.lineNumber = line;
	        error.description = description;
	        error.index = pos;
	        return error;
	    }

	    // Throw an exception

	    function throwError(messageFormat) {
	        var args, msg;

	        args = Array.prototype.slice.call(arguments, 1);
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        throw createError(lastLineNumber, lastIndex, msg);
	    }

	    function tolerateError(messageFormat) {
	        var args, msg, error;

	        args = Array.prototype.slice.call(arguments, 1);
	        /* istanbul ignore next */
	        msg = messageFormat.replace(/%(\d)/g,
	            function (whole, idx) {
	                assert(idx < args.length, 'Message reference must be in range');
	                return args[idx];
	            }
	        );

	        error = createError(lineNumber, lastIndex, msg);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Throw an exception because of the token.

	    function unexpectedTokenError(token, message) {
	        var value, msg = message || Messages.UnexpectedToken;

	        if (token) {
	            if (!message) {
	                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :
	                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :
	                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :
	                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :
	                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :
	                    Messages.UnexpectedToken;

	                if (token.type === Token.Keyword) {
	                    if (isFutureReservedWord(token.value)) {
	                        msg = Messages.UnexpectedReserved;
	                    } else if (strict && isStrictModeReservedWord(token.value)) {
	                        msg = Messages.StrictReservedWord;
	                    }
	                }
	            }

	            value = (token.type === Token.Template) ? token.value.raw : token.value;
	        } else {
	            value = 'ILLEGAL';
	        }

	        msg = msg.replace('%0', value);

	        return (token && typeof token.lineNumber === 'number') ?
	            createError(token.lineNumber, token.start, msg) :
	            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);
	    }

	    function throwUnexpectedToken(token, message) {
	        throw unexpectedTokenError(token, message);
	    }

	    function tolerateUnexpectedToken(token, message) {
	        var error = unexpectedTokenError(token, message);
	        if (extra.errors) {
	            recordError(error);
	        } else {
	            throw error;
	        }
	    }

	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.

	    function expect(value) {
	        var token = lex();
	        if (token.type !== Token.Punctuator || token.value !== value) {
	            throwUnexpectedToken(token);
	        }
	    }

	    /**
	     * @name expectCommaSeparator
	     * @description Quietly expect a comma when in tolerant mode, otherwise delegates
	     * to <code>expect(value)</code>
	     * @since 2.0
	     */
	    function expectCommaSeparator() {
	        var token;

	        if (extra.errors) {
	            token = lookahead;
	            if (token.type === Token.Punctuator && token.value === ',') {
	                lex();
	            } else if (token.type === Token.Punctuator && token.value === ';') {
	                lex();
	                tolerateUnexpectedToken(token);
	            } else {
	                tolerateUnexpectedToken(token, Messages.UnexpectedToken);
	            }
	        } else {
	            expect(',');
	        }
	    }

	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.

	    function expectKeyword(keyword) {
	        var token = lex();
	        if (token.type !== Token.Keyword || token.value !== keyword) {
	            throwUnexpectedToken(token);
	        }
	    }

	    // Return true if the next token matches the specified punctuator.

	    function match(value) {
	        return lookahead.type === Token.Punctuator && lookahead.value === value;
	    }

	    // Return true if the next token matches the specified keyword

	    function matchKeyword(keyword) {
	        return lookahead.type === Token.Keyword && lookahead.value === keyword;
	    }

	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)

	    function matchContextualKeyword(keyword) {
	        return lookahead.type === Token.Identifier && lookahead.value === keyword;
	    }

	    // Return true if the next token is an assignment operator

	    function matchAssign() {
	        var op;

	        if (lookahead.type !== Token.Punctuator) {
	            return false;
	        }
	        op = lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    }

	    function consumeSemicolon() {
	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {
	            lex();
	            return;
	        }

	        if (hasLineTerminator) {
	            return;
	        }

	        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.
	        lastIndex = startIndex;
	        lastLineNumber = startLineNumber;
	        lastLineStart = startLineStart;

	        if (lookahead.type !== Token.EOF && !match('}')) {
	            throwUnexpectedToken(lookahead);
	        }
	    }

	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    function isolateCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        if (firstCoverInitializedNameError !== null) {
	            throwUnexpectedToken(firstCoverInitializedNameError);
	        }
	        isBindingElement = oldIsBindingElement;
	        isAssignmentTarget = oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;
	        return result;
	    }

	    function inheritCoverGrammar(parser) {
	        var oldIsBindingElement = isBindingElement,
	            oldIsAssignmentTarget = isAssignmentTarget,
	            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,
	            result;
	        isBindingElement = true;
	        isAssignmentTarget = true;
	        firstCoverInitializedNameError = null;
	        result = parser();
	        isBindingElement = isBindingElement && oldIsBindingElement;
	        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;
	        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;
	        return result;
	    }

	    // ECMA-262 13.3.3 Destructuring Binding Patterns

	    function parseArrayPattern(params, kind) {
	        var node = new Node(), elements = [], rest, restNode;
	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else {
	                if (match('...')) {
	                    restNode = new Node();
	                    lex();
	                    params.push(lookahead);
	                    rest = parseVariableIdentifier(kind);
	                    elements.push(restNode.finishRestElement(rest));
	                    break;
	                } else {
	                    elements.push(parsePatternWithDefault(params, kind));
	                }
	                if (!match(']')) {
	                    expect(',');
	                }
	            }

	        }

	        expect(']');

	        return node.finishArrayPattern(elements);
	    }

	    function parsePropertyPattern(params, kind) {
	        var node = new Node(), key, keyToken, computed = match('['), init;
	        if (lookahead.type === Token.Identifier) {
	            keyToken = lookahead;
	            key = parseVariableIdentifier();
	            if (match('=')) {
	                params.push(keyToken);
	                lex();
	                init = parseAssignmentExpression();

	                return node.finishProperty(
	                    'init', key, false,
	                    new WrappingNode(keyToken).finishAssignmentPattern(key, init), false, true);
	            } else if (!match(':')) {
	                params.push(keyToken);
	                return node.finishProperty('init', key, false, key, false, true);
	            }
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        expect(':');
	        init = parsePatternWithDefault(params, kind);
	        return node.finishProperty('init', key, computed, init, false, false);
	    }

	    function parseObjectPattern(params, kind) {
	        var node = new Node(), properties = [];

	        expect('{');

	        while (!match('}')) {
	            properties.push(parsePropertyPattern(params, kind));
	            if (!match('}')) {
	                expect(',');
	            }
	        }

	        lex();

	        return node.finishObjectPattern(properties);
	    }

	    function parsePattern(params, kind) {
	        if (match('[')) {
	            return parseArrayPattern(params, kind);
	        } else if (match('{')) {
	            return parseObjectPattern(params, kind);
	        } else if (matchKeyword('let')) {
	            if (kind === 'const' || kind === 'let') {
	                tolerateUnexpectedToken(lookahead, Messages.UnexpectedToken);
	            }
	        }

	        params.push(lookahead);
	        return parseVariableIdentifier(kind);
	    }

	    function parsePatternWithDefault(params, kind) {
	        var startToken = lookahead, pattern, previousAllowYield, right;
	        pattern = parsePattern(params, kind);
	        if (match('=')) {
	            lex();
	            previousAllowYield = state.allowYield;
	            state.allowYield = true;
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowYield = previousAllowYield;
	            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);
	        }
	        return pattern;
	    }

	    // ECMA-262 12.2.5 Array Initializer

	    function parseArrayInitializer() {
	        var elements = [], node = new Node(), restSpread;

	        expect('[');

	        while (!match(']')) {
	            if (match(',')) {
	                lex();
	                elements.push(null);
	            } else if (match('...')) {
	                restSpread = new Node();
	                lex();
	                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    isAssignmentTarget = isBindingElement = false;
	                    expect(',');
	                }
	                elements.push(restSpread);
	            } else {
	                elements.push(inheritCoverGrammar(parseAssignmentExpression));

	                if (!match(']')) {
	                    expect(',');
	                }
	            }
	        }

	        lex();

	        return node.finishArrayExpression(elements);
	    }

	    // ECMA-262 12.2.6 Object Initializer

	    function parsePropertyFunction(node, paramInfo, isGenerator) {
	        var previousStrict, body;

	        isAssignmentTarget = isBindingElement = false;

	        previousStrict = strict;
	        body = isolateCoverGrammar(parseFunctionSourceElements);

	        if (strict && paramInfo.firstRestricted) {
	            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);
	        }
	        if (strict && paramInfo.stricted) {
	            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);
	        }

	        strict = previousStrict;
	        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body, isGenerator);
	    }

	    function parsePropertyMethodFunction() {
	        var params, method, node = new Node(),
	            previousAllowYield = state.allowYield;

	        state.allowYield = false;
	        params = parseParams();
	        state.allowYield = previousAllowYield;

	        state.allowYield = false;
	        method = parsePropertyFunction(node, params, false);
	        state.allowYield = previousAllowYield;

	        return method;
	    }

	    function parseObjectPropertyKey() {
	        var token, node = new Node(), expr;

	        token = lex();

	        // Note: This function is called only from parseObjectProperty(), where
	        // EOF and Punctuator tokens are already filtered out.

	        switch (token.type) {
	        case Token.StringLiteral:
	        case Token.NumericLiteral:
	            if (strict && token.octal) {
	                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);
	            }
	            return node.finishLiteral(token);
	        case Token.Identifier:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.Keyword:
	            return node.finishIdentifier(token.value);
	        case Token.Punctuator:
	            if (token.value === '[') {
	                expr = isolateCoverGrammar(parseAssignmentExpression);
	                expect(']');
	                return expr;
	            }
	            break;
	        }
	        throwUnexpectedToken(token);
	    }

	    function lookaheadPropertyName() {
	        switch (lookahead.type) {
	        case Token.Identifier:
	        case Token.StringLiteral:
	        case Token.BooleanLiteral:
	        case Token.NullLiteral:
	        case Token.NumericLiteral:
	        case Token.Keyword:
	            return true;
	        case Token.Punctuator:
	            return lookahead.value === '[';
	        }
	        return false;
	    }

	    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,
	    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.
	    // This can only be determined after we consumed up to the left parentheses.
	    //
	    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller
	    // is responsible to visit other options.
	    function tryParseMethodDefinition(token, key, computed, node) {
	        var value, options, methodNode, params,
	            previousAllowYield = state.allowYield;

	        if (token.type === Token.Identifier) {
	            // check for `get` and `set`;

	            if (token.value === 'get' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');
	                expect(')');

	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, {
	                    params: [],
	                    defaults: [],
	                    stricted: null,
	                    firstRestricted: null,
	                    message: null
	                }, false);
	                state.allowYield = previousAllowYield;

	                return node.finishProperty('get', key, computed, value, false, false);
	            } else if (token.value === 'set' && lookaheadPropertyName()) {
	                computed = match('[');
	                key = parseObjectPropertyKey();
	                methodNode = new Node();
	                expect('(');

	                options = {
	                    params: [],
	                    defaultCount: 0,
	                    defaults: [],
	                    firstRestricted: null,
	                    paramSet: {}
	                };
	                if (match(')')) {
	                    tolerateUnexpectedToken(lookahead);
	                } else {
	                    state.allowYield = false;
	                    parseParam(options);
	                    state.allowYield = previousAllowYield;
	                    if (options.defaultCount === 0) {
	                        options.defaults = [];
	                    }
	                }
	                expect(')');

	                state.allowYield = false;
	                value = parsePropertyFunction(methodNode, options, false);
	                state.allowYield = previousAllowYield;

	                return node.finishProperty('set', key, computed, value, false, false);
	            }
	        } else if (token.type === Token.Punctuator && token.value === '*' && lookaheadPropertyName()) {
	            computed = match('[');
	            key = parseObjectPropertyKey();
	            methodNode = new Node();

	            state.allowYield = true;
	            params = parseParams();
	            state.allowYield = previousAllowYield;

	            state.allowYield = false;
	            value = parsePropertyFunction(methodNode, params, true);
	            state.allowYield = previousAllowYield;

	            return node.finishProperty('init', key, computed, value, true, false);
	        }

	        if (key && match('(')) {
	            value = parsePropertyMethodFunction();
	            return node.finishProperty('init', key, computed, value, true, false);
	        }

	        // Not a MethodDefinition.
	        return null;
	    }

	    function parseObjectProperty(hasProto) {
	        var token = lookahead, node = new Node(), computed, key, maybeMethod, proto, value;

	        computed = match('[');
	        if (match('*')) {
	            lex();
	        } else {
	            key = parseObjectPropertyKey();
	        }
	        maybeMethod = tryParseMethodDefinition(token, key, computed, node);
	        if (maybeMethod) {
	            return maybeMethod;
	        }

	        if (!key) {
	            throwUnexpectedToken(lookahead);
	        }

	        // Check for duplicated __proto__
	        if (!computed) {
	            proto = (key.type === Syntax.Identifier && key.name === '__proto__') ||
	                (key.type === Syntax.Literal && key.value === '__proto__');
	            if (hasProto.value && proto) {
	                tolerateError(Messages.DuplicateProtoProperty);
	            }
	            hasProto.value |= proto;
	        }

	        if (match(':')) {
	            lex();
	            value = inheritCoverGrammar(parseAssignmentExpression);
	            return node.finishProperty('init', key, computed, value, false, false);
	        }

	        if (token.type === Token.Identifier) {
	            if (match('=')) {
	                firstCoverInitializedNameError = lookahead;
	                lex();
	                value = isolateCoverGrammar(parseAssignmentExpression);
	                return node.finishProperty('init', key, computed,
	                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);
	            }
	            return node.finishProperty('init', key, computed, key, false, true);
	        }

	        throwUnexpectedToken(lookahead);
	    }

	    function parseObjectInitializer() {
	        var properties = [], hasProto = {value: false}, node = new Node();

	        expect('{');

	        while (!match('}')) {
	            properties.push(parseObjectProperty(hasProto));

	            if (!match('}')) {
	                expectCommaSeparator();
	            }
	        }

	        expect('}');

	        return node.finishObjectExpression(properties);
	    }

	    function reinterpretExpressionAsPattern(expr) {
	        var i;
	        switch (expr.type) {
	        case Syntax.Identifier:
	        case Syntax.MemberExpression:
	        case Syntax.RestElement:
	        case Syntax.AssignmentPattern:
	            break;
	        case Syntax.SpreadElement:
	            expr.type = Syntax.RestElement;
	            reinterpretExpressionAsPattern(expr.argument);
	            break;
	        case Syntax.ArrayExpression:
	            expr.type = Syntax.ArrayPattern;
	            for (i = 0; i < expr.elements.length; i++) {
	                if (expr.elements[i] !== null) {
	                    reinterpretExpressionAsPattern(expr.elements[i]);
	                }
	            }
	            break;
	        case Syntax.ObjectExpression:
	            expr.type = Syntax.ObjectPattern;
	            for (i = 0; i < expr.properties.length; i++) {
	                reinterpretExpressionAsPattern(expr.properties[i].value);
	            }
	            break;
	        case Syntax.AssignmentExpression:
	            expr.type = Syntax.AssignmentPattern;
	            reinterpretExpressionAsPattern(expr.left);
	            break;
	        default:
	            // Allow other node type for tolerant parsing.
	            break;
	        }
	    }

	    // ECMA-262 12.2.9 Template Literals

	    function parseTemplateElement(option) {
	        var node, token;

	        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {
	            throwUnexpectedToken();
	        }

	        node = new Node();
	        token = lex();

	        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);
	    }

	    function parseTemplateLiteral() {
	        var quasi, quasis, expressions, node = new Node();

	        quasi = parseTemplateElement({ head: true });
	        quasis = [quasi];
	        expressions = [];

	        while (!quasi.tail) {
	            expressions.push(parseExpression());
	            quasi = parseTemplateElement({ head: false });
	            quasis.push(quasi);
	        }

	        return node.finishTemplateLiteral(quasis, expressions);
	    }

	    // ECMA-262 12.2.10 The Grouping Operator

	    function parseGroupExpression() {
	        var expr, expressions, startToken, i, params = [];

	        expect('(');

	        if (match(')')) {
	            lex();
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [],
	                rawParams: []
	            };
	        }

	        startToken = lookahead;
	        if (match('...')) {
	            expr = parseRestElement(params);
	            expect(')');
	            if (!match('=>')) {
	                expect('=>');
	            }
	            return {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: [expr]
	            };
	        }

	        isBindingElement = true;
	        expr = inheritCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            isAssignmentTarget = false;
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();

	                if (match('...')) {
	                    if (!isBindingElement) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    expressions.push(parseRestElement(params));
	                    expect(')');
	                    if (!match('=>')) {
	                        expect('=>');
	                    }
	                    isBindingElement = false;
	                    for (i = 0; i < expressions.length; i++) {
	                        reinterpretExpressionAsPattern(expressions[i]);
	                    }
	                    return {
	                        type: PlaceHolders.ArrowParameterPlaceHolder,
	                        params: expressions
	                    };
	                }

	                expressions.push(inheritCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }


	        expect(')');

	        if (match('=>')) {
	            if (expr.type === Syntax.Identifier && expr.name === 'yield') {
	                return {
	                    type: PlaceHolders.ArrowParameterPlaceHolder,
	                    params: [expr]
	                };
	            }

	            if (!isBindingElement) {
	                throwUnexpectedToken(lookahead);
	            }

	            if (expr.type === Syntax.SequenceExpression) {
	                for (i = 0; i < expr.expressions.length; i++) {
	                    reinterpretExpressionAsPattern(expr.expressions[i]);
	                }
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            expr = {
	                type: PlaceHolders.ArrowParameterPlaceHolder,
	                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]
	            };
	        }
	        isBindingElement = false;
	        return expr;
	    }


	    // ECMA-262 12.2 Primary Expressions

	    function parsePrimaryExpression() {
	        var type, token, expr, node;

	        if (match('(')) {
	            isBindingElement = false;
	            return inheritCoverGrammar(parseGroupExpression);
	        }

	        if (match('[')) {
	            return inheritCoverGrammar(parseArrayInitializer);
	        }

	        if (match('{')) {
	            return inheritCoverGrammar(parseObjectInitializer);
	        }

	        type = lookahead.type;
	        node = new Node();

	        if (type === Token.Identifier) {
	            if (state.sourceType === 'module' && lookahead.value === 'await') {
	                tolerateUnexpectedToken(lookahead);
	            }
	            expr = node.finishIdentifier(lex().value);
	        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            if (strict && lookahead.octal) {
	                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);
	            }
	            expr = node.finishLiteral(lex());
	        } else if (type === Token.Keyword) {
	            if (!strict && state.allowYield && matchKeyword('yield')) {
	                return parseNonComputedProperty();
	            }
	            if (!strict && matchKeyword('let')) {
	                return node.finishIdentifier(lex().value);
	            }
	            isAssignmentTarget = isBindingElement = false;
	            if (matchKeyword('function')) {
	                return parseFunctionExpression();
	            }
	            if (matchKeyword('this')) {
	                lex();
	                return node.finishThisExpression();
	            }
	            if (matchKeyword('class')) {
	                return parseClassExpression();
	            }
	            throwUnexpectedToken(lex());
	        } else if (type === Token.BooleanLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = (token.value === 'true');
	            expr = node.finishLiteral(token);
	        } else if (type === Token.NullLiteral) {
	            isAssignmentTarget = isBindingElement = false;
	            token = lex();
	            token.value = null;
	            expr = node.finishLiteral(token);
	        } else if (match('/') || match('/=')) {
	            isAssignmentTarget = isBindingElement = false;
	            index = startIndex;

	            if (typeof extra.tokens !== 'undefined') {
	                token = collectRegex();
	            } else {
	                token = scanRegExp();
	            }
	            lex();
	            expr = node.finishLiteral(token);
	        } else if (type === Token.Template) {
	            expr = parseTemplateLiteral();
	        } else {
	            throwUnexpectedToken(lex());
	        }

	        return expr;
	    }

	    // ECMA-262 12.3 Left-Hand-Side Expressions

	    function parseArguments() {
	        var args = [], expr;

	        expect('(');

	        if (!match(')')) {
	            while (startIndex < length) {
	                if (match('...')) {
	                    expr = new Node();
	                    lex();
	                    expr.finishSpreadElement(isolateCoverGrammar(parseAssignmentExpression));
	                } else {
	                    expr = isolateCoverGrammar(parseAssignmentExpression);
	                }
	                args.push(expr);
	                if (match(')')) {
	                    break;
	                }
	                expectCommaSeparator();
	            }
	        }

	        expect(')');

	        return args;
	    }

	    function parseNonComputedProperty() {
	        var token, node = new Node();

	        token = lex();

	        if (!isIdentifierName(token)) {
	            throwUnexpectedToken(token);
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseNonComputedMember() {
	        expect('.');

	        return parseNonComputedProperty();
	    }

	    function parseComputedMember() {
	        var expr;

	        expect('[');

	        expr = isolateCoverGrammar(parseExpression);

	        expect(']');

	        return expr;
	    }

	    // ECMA-262 12.3.3 The new Operator

	    function parseNewExpression() {
	        var callee, args, node = new Node();

	        expectKeyword('new');

	        if (match('.')) {
	            lex();
	            if (lookahead.type === Token.Identifier && lookahead.value === 'target') {
	                if (state.inFunctionBody) {
	                    lex();
	                    return node.finishMetaProperty('new', 'target');
	                }
	            }
	            throwUnexpectedToken(lookahead);
	        }

	        callee = isolateCoverGrammar(parseLeftHandSideExpression);
	        args = match('(') ? parseArguments() : [];

	        isAssignmentTarget = isBindingElement = false;

	        return node.finishNewExpression(callee, args);
	    }

	    // ECMA-262 12.3.4 Function Calls

	    function parseLeftHandSideExpressionAllowCall() {
	        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;

	        startToken = lookahead;
	        state.allowIn = true;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('(') && !match('.') && !match('[')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (match('(')) {
	                isBindingElement = false;
	                isAssignmentTarget = false;
	                args = parseArguments();
	                expr = new WrappingNode(startToken).finishCallExpression(expr, args);
	            } else if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        state.allowIn = previousAllowIn;

	        return expr;
	    }

	    // ECMA-262 12.3 Left-Hand-Side Expressions

	    function parseLeftHandSideExpression() {
	        var quasi, expr, property, startToken;
	        assert(state.allowIn, 'callee of new expression always allow in keyword.');

	        startToken = lookahead;

	        if (matchKeyword('super') && state.inFunctionBody) {
	            expr = new Node();
	            lex();
	            expr = expr.finishSuper();
	            if (!match('[') && !match('.')) {
	                throwUnexpectedToken(lookahead);
	            }
	        } else {
	            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);
	        }

	        for (;;) {
	            if (match('[')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);
	            } else if (match('.')) {
	                isBindingElement = false;
	                isAssignmentTarget = true;
	                property = parseNonComputedMember();
	                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);
	            } else if (lookahead.type === Token.Template && lookahead.head) {
	                quasi = parseTemplateLiteral();
	                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);
	            } else {
	                break;
	            }
	        }
	        return expr;
	    }

	    // ECMA-262 12.4 Postfix Expressions

	    function parsePostfixExpression() {
	        var expr, token, startToken = lookahead;

	        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);

	        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {
	            if (match('++') || match('--')) {
	                // ECMA-262 11.3.1, 11.3.2
	                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                    tolerateError(Messages.StrictLHSPostfix);
	                }

	                if (!isAssignmentTarget) {
	                    tolerateError(Messages.InvalidLHSInAssignment);
	                }

	                isAssignmentTarget = isBindingElement = false;

	                token = lex();
	                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);
	            }
	        }

	        return expr;
	    }

	    // ECMA-262 12.5 Unary Operators

	    function parseUnaryExpression() {
	        var token, expr, startToken;

	        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {
	            expr = parsePostfixExpression();
	        } else if (match('++') || match('--')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            // ECMA-262 11.4.4, 11.4.5
	            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {
	                tolerateError(Messages.StrictLHSPrefix);
	            }

	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (match('+') || match('-') || match('~') || match('!')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            isAssignmentTarget = isBindingElement = false;
	        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
	            startToken = lookahead;
	            token = lex();
	            expr = inheritCoverGrammar(parseUnaryExpression);
	            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);
	            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {
	                tolerateError(Messages.StrictDelete);
	            }
	            isAssignmentTarget = isBindingElement = false;
	        } else {
	            expr = parsePostfixExpression();
	        }

	        return expr;
	    }

	    function binaryPrecedence(token, allowIn) {
	        var prec = 0;

	        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {
	            return 0;
	        }

	        switch (token.value) {
	        case '||':
	            prec = 1;
	            break;

	        case '&&':
	            prec = 2;
	            break;

	        case '|':
	            prec = 3;
	            break;

	        case '^':
	            prec = 4;
	            break;

	        case '&':
	            prec = 5;
	            break;

	        case '==':
	        case '!=':
	        case '===':
	        case '!==':
	            prec = 6;
	            break;

	        case '<':
	        case '>':
	        case '<=':
	        case '>=':
	        case 'instanceof':
	            prec = 7;
	            break;

	        case 'in':
	            prec = allowIn ? 7 : 0;
	            break;

	        case '<<':
	        case '>>':
	        case '>>>':
	            prec = 8;
	            break;

	        case '+':
	        case '-':
	            prec = 9;
	            break;

	        case '*':
	        case '/':
	        case '%':
	            prec = 11;
	            break;

	        default:
	            break;
	        }

	        return prec;
	    }

	    // ECMA-262 12.6 Multiplicative Operators
	    // ECMA-262 12.7 Additive Operators
	    // ECMA-262 12.8 Bitwise Shift Operators
	    // ECMA-262 12.9 Relational Operators
	    // ECMA-262 12.10 Equality Operators
	    // ECMA-262 12.11 Binary Bitwise Operators
	    // ECMA-262 12.12 Binary Logical Operators

	    function parseBinaryExpression() {
	        var marker, markers, expr, token, prec, stack, right, operator, left, i;

	        marker = lookahead;
	        left = inheritCoverGrammar(parseUnaryExpression);

	        token = lookahead;
	        prec = binaryPrecedence(token, state.allowIn);
	        if (prec === 0) {
	            return left;
	        }
	        isAssignmentTarget = isBindingElement = false;
	        token.prec = prec;
	        lex();

	        markers = [marker, lookahead];
	        right = isolateCoverGrammar(parseUnaryExpression);

	        stack = [left, token, right];

	        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {

	            // Reduce: make a binary expression from the three topmost entries.
	            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
	                right = stack.pop();
	                operator = stack.pop().value;
	                left = stack.pop();
	                markers.pop();
	                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);
	                stack.push(expr);
	            }

	            // Shift.
	            token = lex();
	            token.prec = prec;
	            stack.push(token);
	            markers.push(lookahead);
	            expr = isolateCoverGrammar(parseUnaryExpression);
	            stack.push(expr);
	        }

	        // Final reduce to clean-up the stack.
	        i = stack.length - 1;
	        expr = stack[i];
	        markers.pop();
	        while (i > 1) {
	            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
	            i -= 2;
	        }

	        return expr;
	    }


	    // ECMA-262 12.13 Conditional Operator

	    function parseConditionalExpression() {
	        var expr, previousAllowIn, consequent, alternate, startToken;

	        startToken = lookahead;

	        expr = inheritCoverGrammar(parseBinaryExpression);
	        if (match('?')) {
	            lex();
	            previousAllowIn = state.allowIn;
	            state.allowIn = true;
	            consequent = isolateCoverGrammar(parseAssignmentExpression);
	            state.allowIn = previousAllowIn;
	            expect(':');
	            alternate = isolateCoverGrammar(parseAssignmentExpression);

	            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);
	            isAssignmentTarget = isBindingElement = false;
	        }

	        return expr;
	    }

	    // ECMA-262 14.2 Arrow Function Definitions

	    function parseConciseBody() {
	        if (match('{')) {
	            return parseFunctionSourceElements();
	        }
	        return isolateCoverGrammar(parseAssignmentExpression);
	    }

	    function checkPatternParam(options, param) {
	        var i;
	        switch (param.type) {
	        case Syntax.Identifier:
	            validateParam(options, param, param.name);
	            break;
	        case Syntax.RestElement:
	            checkPatternParam(options, param.argument);
	            break;
	        case Syntax.AssignmentPattern:
	            checkPatternParam(options, param.left);
	            break;
	        case Syntax.ArrayPattern:
	            for (i = 0; i < param.elements.length; i++) {
	                if (param.elements[i] !== null) {
	                    checkPatternParam(options, param.elements[i]);
	                }
	            }
	            break;
	        case Syntax.YieldExpression:
	            break;
	        default:
	            assert(param.type === Syntax.ObjectPattern, 'Invalid type');
	            for (i = 0; i < param.properties.length; i++) {
	                checkPatternParam(options, param.properties[i].value);
	            }
	            break;
	        }
	    }
	    function reinterpretAsCoverFormalsList(expr) {
	        var i, len, param, params, defaults, defaultCount, options, token;

	        defaults = [];
	        defaultCount = 0;
	        params = [expr];

	        switch (expr.type) {
	        case Syntax.Identifier:
	            break;
	        case PlaceHolders.ArrowParameterPlaceHolder:
	            params = expr.params;
	            break;
	        default:
	            return null;
	        }

	        options = {
	            paramSet: {}
	        };

	        for (i = 0, len = params.length; i < len; i += 1) {
	            param = params[i];
	            switch (param.type) {
	            case Syntax.AssignmentPattern:
	                params[i] = param.left;
	                if (param.right.type === Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        throwUnexpectedToken(lookahead);
	                    }
	                    param.right.type = Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	                defaults.push(param.right);
	                ++defaultCount;
	                checkPatternParam(options, param.left);
	                break;
	            default:
	                checkPatternParam(options, param);
	                params[i] = param;
	                defaults.push(null);
	                break;
	            }
	        }

	        if (strict || !state.allowYield) {
	            for (i = 0, len = params.length; i < len; i += 1) {
	                param = params[i];
	                if (param.type === Syntax.YieldExpression) {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }

	        if (options.message === Messages.StrictParamDupe) {
	            token = strict ? options.stricted : options.firstRestricted;
	            throwUnexpectedToken(token, options.message);
	        }

	        if (defaultCount === 0) {
	            defaults = [];
	        }

	        return {
	            params: params,
	            defaults: defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseArrowFunctionExpression(options, node) {
	        var previousStrict, previousAllowYield, body;

	        if (hasLineTerminator) {
	            tolerateUnexpectedToken(lookahead);
	        }
	        expect('=>');

	        previousStrict = strict;
	        previousAllowYield = state.allowYield;
	        state.allowYield = true;

	        body = parseConciseBody();

	        if (strict && options.firstRestricted) {
	            throwUnexpectedToken(options.firstRestricted, options.message);
	        }
	        if (strict && options.stricted) {
	            tolerateUnexpectedToken(options.stricted, options.message);
	        }

	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);
	    }

	    // ECMA-262 14.4 Yield expression

	    function parseYieldExpression() {
	        var argument, expr, delegate, previousAllowYield;

	        argument = null;
	        expr = new Node();
	        delegate = false;

	        expectKeyword('yield');

	        if (!hasLineTerminator) {
	            previousAllowYield = state.allowYield;
	            state.allowYield = false;
	            delegate = match('*');
	            if (delegate) {
	                lex();
	                argument = parseAssignmentExpression();
	            } else {
	                if (!match(';') && !match('}') && !match(')') && lookahead.type !== Token.EOF) {
	                    argument = parseAssignmentExpression();
	                }
	            }
	            state.allowYield = previousAllowYield;
	        }

	        return expr.finishYieldExpression(argument, delegate);
	    }

	    // ECMA-262 12.14 Assignment Operators

	    function parseAssignmentExpression() {
	        var token, expr, right, list, startToken;

	        startToken = lookahead;
	        token = lookahead;

	        if (!state.allowYield && matchKeyword('yield')) {
	            return parseYieldExpression();
	        }

	        expr = parseConditionalExpression();

	        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {
	            isAssignmentTarget = isBindingElement = false;
	            list = reinterpretAsCoverFormalsList(expr);

	            if (list) {
	                firstCoverInitializedNameError = null;
	                return parseArrowFunctionExpression(list, new WrappingNode(startToken));
	            }

	            return expr;
	        }

	        if (matchAssign()) {
	            if (!isAssignmentTarget) {
	                tolerateError(Messages.InvalidLHSInAssignment);
	            }

	            // ECMA-262 12.1.1
	            if (strict && expr.type === Syntax.Identifier) {
	                if (isRestrictedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);
	                }
	                if (isStrictModeReservedWord(expr.name)) {
	                    tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	                }
	            }

	            if (!match('=')) {
	                isAssignmentTarget = isBindingElement = false;
	            } else {
	                reinterpretExpressionAsPattern(expr);
	            }

	            token = lex();
	            right = isolateCoverGrammar(parseAssignmentExpression);
	            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);
	            firstCoverInitializedNameError = null;
	        }

	        return expr;
	    }

	    // ECMA-262 12.15 Comma Operator

	    function parseExpression() {
	        var expr, startToken = lookahead, expressions;

	        expr = isolateCoverGrammar(parseAssignmentExpression);

	        if (match(',')) {
	            expressions = [expr];

	            while (startIndex < length) {
	                if (!match(',')) {
	                    break;
	                }
	                lex();
	                expressions.push(isolateCoverGrammar(parseAssignmentExpression));
	            }

	            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);
	        }

	        return expr;
	    }

	    // ECMA-262 13.2 Block

	    function parseStatementListItem() {
	        if (lookahead.type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'export':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);
	                }
	                return parseExportDeclaration();
	            case 'import':
	                if (state.sourceType !== 'module') {
	                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);
	                }
	                return parseImportDeclaration();
	            case 'const':
	                return parseLexicalDeclaration({inFor: false});
	            case 'function':
	                return parseFunctionDeclaration(new Node());
	            case 'class':
	                return parseClassDeclaration();
	            }
	        }

	        if (matchKeyword('let') && isLexicalDeclaration()) {
	            return parseLexicalDeclaration({inFor: false});
	        }

	        return parseStatement();
	    }

	    function parseStatementList() {
	        var list = [];
	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            list.push(parseStatementListItem());
	        }

	        return list;
	    }

	    function parseBlock() {
	        var block, node = new Node();

	        expect('{');

	        block = parseStatementList();

	        expect('}');

	        return node.finishBlockStatement(block);
	    }

	    // ECMA-262 13.3.2 Variable Statement

	    function parseVariableIdentifier(kind) {
	        var token, node = new Node();

	        token = lex();

	        if (token.type === Token.Keyword && token.value === 'yield') {
	            if (strict) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } if (!state.allowYield) {
	                throwUnexpectedToken(token);
	            }
	        } else if (token.type !== Token.Identifier) {
	            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {
	                tolerateUnexpectedToken(token, Messages.StrictReservedWord);
	            } else {
	                if (strict || token.value !== 'let' || kind !== 'var') {
	                    throwUnexpectedToken(token);
	                }
	            }
	        } else if (state.sourceType === 'module' && token.type === Token.Identifier && token.value === 'await') {
	            tolerateUnexpectedToken(token);
	        }

	        return node.finishIdentifier(token.value);
	    }

	    function parseVariableDeclaration(options) {
	        var init = null, id, node = new Node(), params = [];

	        id = parsePattern(params, 'var');

	        // ECMA-262 12.2.1
	        if (strict && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (match('=')) {
	            lex();
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        } else if (id.type !== Syntax.Identifier && !options.inFor) {
	            expect('=');
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseVariableDeclarationList(options) {
	        var opt, list;

	        opt = { inFor: options.inFor };
	        list = [parseVariableDeclaration(opt)];

	        while (match(',')) {
	            lex();
	            list.push(parseVariableDeclaration(opt));
	        }

	        return list;
	    }

	    function parseVariableStatement(node) {
	        var declarations;

	        expectKeyword('var');

	        declarations = parseVariableDeclarationList({ inFor: false });

	        consumeSemicolon();

	        return node.finishVariableDeclaration(declarations);
	    }

	    // ECMA-262 13.3.1 Let and Const Declarations

	    function parseLexicalBinding(kind, options) {
	        var init = null, id, node = new Node(), params = [];

	        id = parsePattern(params, kind);

	        // ECMA-262 12.2.1
	        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {
	            tolerateError(Messages.StrictVarName);
	        }

	        if (kind === 'const') {
	            if (!matchKeyword('in') && !matchContextualKeyword('of')) {
	                expect('=');
	                init = isolateCoverGrammar(parseAssignmentExpression);
	            }
	        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {
	            expect('=');
	            init = isolateCoverGrammar(parseAssignmentExpression);
	        }

	        return node.finishVariableDeclarator(id, init);
	    }

	    function parseBindingList(kind, options) {
	        var list = [parseLexicalBinding(kind, options)];

	        while (match(',')) {
	            lex();
	            list.push(parseLexicalBinding(kind, options));
	        }

	        return list;
	    }


	    function tokenizerState() {
	        return {
	            index: index,
	            lineNumber: lineNumber,
	            lineStart: lineStart,
	            hasLineTerminator: hasLineTerminator,
	            lastIndex: lastIndex,
	            lastLineNumber: lastLineNumber,
	            lastLineStart: lastLineStart,
	            startIndex: startIndex,
	            startLineNumber: startLineNumber,
	            startLineStart: startLineStart,
	            lookahead: lookahead,
	            tokenCount: extra.tokens ? extra.tokens.length : 0
	        };
	    }

	    function resetTokenizerState(ts) {
	        index = ts.index;
	        lineNumber = ts.lineNumber;
	        lineStart = ts.lineStart;
	        hasLineTerminator = ts.hasLineTerminator;
	        lastIndex = ts.lastIndex;
	        lastLineNumber = ts.lastLineNumber;
	        lastLineStart = ts.lastLineStart;
	        startIndex = ts.startIndex;
	        startLineNumber = ts.startLineNumber;
	        startLineStart = ts.startLineStart;
	        lookahead = ts.lookahead;
	        if (extra.tokens) {
	            extra.tokens.splice(ts.tokenCount, extra.tokens.length);
	        }
	    }

	    function isLexicalDeclaration() {
	        var lexical, ts;

	        ts = tokenizerState();

	        lex();
	        lexical = (lookahead.type === Token.Identifier) || match('[') || match('{') ||
	            matchKeyword('let') || matchKeyword('yield');

	        resetTokenizerState(ts);

	        return lexical;
	    }

	    function parseLexicalDeclaration(options) {
	        var kind, declarations, node = new Node();

	        kind = lex().value;
	        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');

	        declarations = parseBindingList(kind, options);

	        consumeSemicolon();

	        return node.finishLexicalDeclaration(declarations, kind);
	    }

	    function parseRestElement(params) {
	        var param, node = new Node();

	        lex();

	        if (match('{')) {
	            throwError(Messages.ObjectPatternAsRestParameter);
	        }

	        params.push(lookahead);

	        param = parseVariableIdentifier();

	        if (match('=')) {
	            throwError(Messages.DefaultRestParameter);
	        }

	        if (!match(')')) {
	            throwError(Messages.ParameterAfterRestParameter);
	        }

	        return node.finishRestElement(param);
	    }

	    // ECMA-262 13.4 Empty Statement

	    function parseEmptyStatement(node) {
	        expect(';');
	        return node.finishEmptyStatement();
	    }

	    // ECMA-262 12.4 Expression Statement

	    function parseExpressionStatement(node) {
	        var expr = parseExpression();
	        consumeSemicolon();
	        return node.finishExpressionStatement(expr);
	    }

	    // ECMA-262 13.6 If statement

	    function parseIfStatement(node) {
	        var test, consequent, alternate;

	        expectKeyword('if');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        consequent = parseStatement();

	        if (matchKeyword('else')) {
	            lex();
	            alternate = parseStatement();
	        } else {
	            alternate = null;
	        }

	        return node.finishIfStatement(test, consequent, alternate);
	    }

	    // ECMA-262 13.7 Iteration Statements

	    function parseDoWhileStatement(node) {
	        var body, test, oldInIteration;

	        expectKeyword('do');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        if (match(';')) {
	            lex();
	        }

	        return node.finishDoWhileStatement(body, test);
	    }

	    function parseWhileStatement(node) {
	        var test, body, oldInIteration;

	        expectKeyword('while');

	        expect('(');

	        test = parseExpression();

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = parseStatement();

	        state.inIteration = oldInIteration;

	        return node.finishWhileStatement(test, body);
	    }

	    function parseForStatement(node) {
	        var init, forIn, initSeq, initStartToken, test, update, left, right, kind, declarations,
	            body, oldInIteration, previousAllowIn = state.allowIn;

	        init = test = update = null;
	        forIn = true;

	        expectKeyword('for');

	        expect('(');

	        if (match(';')) {
	            lex();
	        } else {
	            if (matchKeyword('var')) {
	                init = new Node();
	                lex();

	                state.allowIn = false;
	                declarations = parseVariableDeclarationList({ inFor: true });
	                state.allowIn = previousAllowIn;

	                if (declarations.length === 1 && matchKeyword('in')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                    init = init.finishVariableDeclaration(declarations);
	                    lex();
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    init = init.finishVariableDeclaration(declarations);
	                    expect(';');
	                }
	            } else if (matchKeyword('const') || matchKeyword('let')) {
	                init = new Node();
	                kind = lex().value;

	                if (!strict && lookahead.value === 'in') {
	                    init = init.finishIdentifier(kind);
	                    lex();
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else {
	                    state.allowIn = false;
	                    declarations = parseBindingList(kind, {inFor: true});
	                    state.allowIn = previousAllowIn;

	                    if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseExpression();
	                        init = null;
	                    } else if (declarations.length === 1 && declarations[0].init === null && matchContextualKeyword('of')) {
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                        lex();
	                        left = init;
	                        right = parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    } else {
	                        consumeSemicolon();
	                        init = init.finishLexicalDeclaration(declarations, kind);
	                    }
	                }
	            } else {
	                initStartToken = lookahead;
	                state.allowIn = false;
	                init = inheritCoverGrammar(parseAssignmentExpression);
	                state.allowIn = previousAllowIn;

	                if (matchKeyword('in')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForIn);
	                    }

	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseExpression();
	                    init = null;
	                } else if (matchContextualKeyword('of')) {
	                    if (!isAssignmentTarget) {
	                        tolerateError(Messages.InvalidLHSInForLoop);
	                    }

	                    lex();
	                    reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                } else {
	                    if (match(',')) {
	                        initSeq = [init];
	                        while (match(',')) {
	                            lex();
	                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));
	                        }
	                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);
	                    }
	                    expect(';');
	                }
	            }
	        }

	        if (typeof left === 'undefined') {

	            if (!match(';')) {
	                test = parseExpression();
	            }
	            expect(';');

	            if (!match(')')) {
	                update = parseExpression();
	            }
	        }

	        expect(')');

	        oldInIteration = state.inIteration;
	        state.inIteration = true;

	        body = isolateCoverGrammar(parseStatement);

	        state.inIteration = oldInIteration;

	        return (typeof left === 'undefined') ?
	                node.finishForStatement(init, test, update, body) :
	                forIn ? node.finishForInStatement(left, right, body) :
	                    node.finishForOfStatement(left, right, body);
	    }

	    // ECMA-262 13.8 The continue statement

	    function parseContinueStatement(node) {
	        var label = null, key;

	        expectKeyword('continue');

	        // Optimize the most common form: 'continue;'.
	        if (source.charCodeAt(startIndex) === 0x3B) {
	            lex();

	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!state.inIteration) {
	                throwError(Messages.IllegalContinue);
	            }

	            return node.finishContinueStatement(null);
	        }

	        if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !state.inIteration) {
	            throwError(Messages.IllegalContinue);
	        }

	        return node.finishContinueStatement(label);
	    }

	    // ECMA-262 13.9 The break statement

	    function parseBreakStatement(node) {
	        var label = null, key;

	        expectKeyword('break');

	        // Catch the very common case first: immediately a semicolon (U+003B).
	        if (source.charCodeAt(lastIndex) === 0x3B) {
	            lex();

	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }

	            return node.finishBreakStatement(null);
	        }

	        if (hasLineTerminator) {
	            if (!(state.inIteration || state.inSwitch)) {
	                throwError(Messages.IllegalBreak);
	            }
	        } else if (lookahead.type === Token.Identifier) {
	            label = parseVariableIdentifier();

	            key = '$' + label.name;
	            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.UnknownLabel, label.name);
	            }
	        }

	        consumeSemicolon();

	        if (label === null && !(state.inIteration || state.inSwitch)) {
	            throwError(Messages.IllegalBreak);
	        }

	        return node.finishBreakStatement(label);
	    }

	    // ECMA-262 13.10 The return statement

	    function parseReturnStatement(node) {
	        var argument = null;

	        expectKeyword('return');

	        if (!state.inFunctionBody) {
	            tolerateError(Messages.IllegalReturn);
	        }

	        // 'return' followed by a space and an identifier is very common.
	        if (source.charCodeAt(lastIndex) === 0x20) {
	            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {
	                argument = parseExpression();
	                consumeSemicolon();
	                return node.finishReturnStatement(argument);
	            }
	        }

	        if (hasLineTerminator) {
	            // HACK
	            return node.finishReturnStatement(null);
	        }

	        if (!match(';')) {
	            if (!match('}') && lookahead.type !== Token.EOF) {
	                argument = parseExpression();
	            }
	        }

	        consumeSemicolon();

	        return node.finishReturnStatement(argument);
	    }

	    // ECMA-262 13.11 The with statement

	    function parseWithStatement(node) {
	        var object, body;

	        if (strict) {
	            tolerateError(Messages.StrictModeWith);
	        }

	        expectKeyword('with');

	        expect('(');

	        object = parseExpression();

	        expect(')');

	        body = parseStatement();

	        return node.finishWithStatement(object, body);
	    }

	    // ECMA-262 13.12 The switch statement

	    function parseSwitchCase() {
	        var test, consequent = [], statement, node = new Node();

	        if (matchKeyword('default')) {
	            lex();
	            test = null;
	        } else {
	            expectKeyword('case');
	            test = parseExpression();
	        }
	        expect(':');

	        while (startIndex < length) {
	            if (match('}') || matchKeyword('default') || matchKeyword('case')) {
	                break;
	            }
	            statement = parseStatementListItem();
	            consequent.push(statement);
	        }

	        return node.finishSwitchCase(test, consequent);
	    }

	    function parseSwitchStatement(node) {
	        var discriminant, cases, clause, oldInSwitch, defaultFound;

	        expectKeyword('switch');

	        expect('(');

	        discriminant = parseExpression();

	        expect(')');

	        expect('{');

	        cases = [];

	        if (match('}')) {
	            lex();
	            return node.finishSwitchStatement(discriminant, cases);
	        }

	        oldInSwitch = state.inSwitch;
	        state.inSwitch = true;
	        defaultFound = false;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            clause = parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    throwError(Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }

	        state.inSwitch = oldInSwitch;

	        expect('}');

	        return node.finishSwitchStatement(discriminant, cases);
	    }

	    // ECMA-262 13.14 The throw statement

	    function parseThrowStatement(node) {
	        var argument;

	        expectKeyword('throw');

	        if (hasLineTerminator) {
	            throwError(Messages.NewlineAfterThrow);
	        }

	        argument = parseExpression();

	        consumeSemicolon();

	        return node.finishThrowStatement(argument);
	    }

	    // ECMA-262 13.15 The try statement

	    function parseCatchClause() {
	        var param, params = [], paramMap = {}, key, i, body, node = new Node();

	        expectKeyword('catch');

	        expect('(');
	        if (match(')')) {
	            throwUnexpectedToken(lookahead);
	        }

	        param = parsePattern(params);
	        for (i = 0; i < params.length; i++) {
	            key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                tolerateError(Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }

	        // ECMA-262 12.14.1
	        if (strict && isRestrictedWord(param.name)) {
	            tolerateError(Messages.StrictCatchVariable);
	        }

	        expect(')');
	        body = parseBlock();
	        return node.finishCatchClause(param, body);
	    }

	    function parseTryStatement(node) {
	        var block, handler = null, finalizer = null;

	        expectKeyword('try');

	        block = parseBlock();

	        if (matchKeyword('catch')) {
	            handler = parseCatchClause();
	        }

	        if (matchKeyword('finally')) {
	            lex();
	            finalizer = parseBlock();
	        }

	        if (!handler && !finalizer) {
	            throwError(Messages.NoCatchOrFinally);
	        }

	        return node.finishTryStatement(block, handler, finalizer);
	    }

	    // ECMA-262 13.16 The debugger statement

	    function parseDebuggerStatement(node) {
	        expectKeyword('debugger');

	        consumeSemicolon();

	        return node.finishDebuggerStatement();
	    }

	    // 13 Statements

	    function parseStatement() {
	        var type = lookahead.type,
	            expr,
	            labeledBody,
	            key,
	            node;

	        if (type === Token.EOF) {
	            throwUnexpectedToken(lookahead);
	        }

	        if (type === Token.Punctuator && lookahead.value === '{') {
	            return parseBlock();
	        }
	        isAssignmentTarget = isBindingElement = true;
	        node = new Node();

	        if (type === Token.Punctuator) {
	            switch (lookahead.value) {
	            case ';':
	                return parseEmptyStatement(node);
	            case '(':
	                return parseExpressionStatement(node);
	            default:
	                break;
	            }
	        } else if (type === Token.Keyword) {
	            switch (lookahead.value) {
	            case 'break':
	                return parseBreakStatement(node);
	            case 'continue':
	                return parseContinueStatement(node);
	            case 'debugger':
	                return parseDebuggerStatement(node);
	            case 'do':
	                return parseDoWhileStatement(node);
	            case 'for':
	                return parseForStatement(node);
	            case 'function':
	                return parseFunctionDeclaration(node);
	            case 'if':
	                return parseIfStatement(node);
	            case 'return':
	                return parseReturnStatement(node);
	            case 'switch':
	                return parseSwitchStatement(node);
	            case 'throw':
	                return parseThrowStatement(node);
	            case 'try':
	                return parseTryStatement(node);
	            case 'var':
	                return parseVariableStatement(node);
	            case 'while':
	                return parseWhileStatement(node);
	            case 'with':
	                return parseWithStatement(node);
	            default:
	                break;
	            }
	        }

	        expr = parseExpression();

	        // ECMA-262 12.12 Labelled Statements
	        if ((expr.type === Syntax.Identifier) && match(':')) {
	            lex();

	            key = '$' + expr.name;
	            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {
	                throwError(Messages.Redeclaration, 'Label', expr.name);
	            }

	            state.labelSet[key] = true;
	            labeledBody = parseStatement();
	            delete state.labelSet[key];
	            return node.finishLabeledStatement(expr, labeledBody);
	        }

	        consumeSemicolon();

	        return node.finishExpressionStatement(expr);
	    }

	    // ECMA-262 14.1 Function Definition

	    function parseFunctionSourceElements() {
	        var statement, body = [], token, directive, firstRestricted,
	            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody,
	            node = new Node();

	        expect('{');

	        while (startIndex < length) {
	            if (lookahead.type !== Token.StringLiteral) {
	                break;
	            }
	            token = lookahead;

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        oldLabelSet = state.labelSet;
	        oldInIteration = state.inIteration;
	        oldInSwitch = state.inSwitch;
	        oldInFunctionBody = state.inFunctionBody;

	        state.labelSet = {};
	        state.inIteration = false;
	        state.inSwitch = false;
	        state.inFunctionBody = true;

	        while (startIndex < length) {
	            if (match('}')) {
	                break;
	            }
	            body.push(parseStatementListItem());
	        }

	        expect('}');

	        state.labelSet = oldLabelSet;
	        state.inIteration = oldInIteration;
	        state.inSwitch = oldInSwitch;
	        state.inFunctionBody = oldInFunctionBody;

	        return node.finishBlockStatement(body);
	    }

	    function validateParam(options, param, name) {
	        var key = '$' + name;
	        if (strict) {
	            if (isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        } else if (!options.firstRestricted) {
	            if (isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictParamName;
	            } else if (isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = Messages.StrictReservedWord;
	            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = Messages.StrictParamDupe;
	            }
	        }
	        options.paramSet[key] = true;
	    }

	    function parseParam(options) {
	        var token, param, params = [], i, def;

	        token = lookahead;
	        if (token.value === '...') {
	            param = parseRestElement(params);
	            validateParam(options, param.argument, param.argument.name);
	            options.params.push(param);
	            options.defaults.push(null);
	            return false;
	        }

	        param = parsePatternWithDefault(params);
	        for (i = 0; i < params.length; i++) {
	            validateParam(options, params[i], params[i].value);
	        }

	        if (param.type === Syntax.AssignmentPattern) {
	            def = param.right;
	            param = param.left;
	            ++options.defaultCount;
	        }

	        options.params.push(param);
	        options.defaults.push(def);

	        return !match(')');
	    }

	    function parseParams(firstRestricted) {
	        var options;

	        options = {
	            params: [],
	            defaultCount: 0,
	            defaults: [],
	            firstRestricted: firstRestricted
	        };

	        expect('(');

	        if (!match(')')) {
	            options.paramSet = {};
	            while (startIndex < length) {
	                if (!parseParam(options)) {
	                    break;
	                }
	                expect(',');
	            }
	        }

	        expect(')');

	        if (options.defaultCount === 0) {
	            options.defaults = [];
	        }

	        return {
	            params: options.params,
	            defaults: options.defaults,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    }

	    function parseFunctionDeclaration(node, identifierIsOptional) {
	        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict,
	            isGenerator, previousAllowYield;

	        previousAllowYield = state.allowYield;

	        expectKeyword('function');

	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }

	        if (!identifierIsOptional || !match('(')) {
	            token = lookahead;
	            id = parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        state.allowYield = !isGenerator;
	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }


	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }

	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishFunctionDeclaration(id, params, defaults, body, isGenerator);
	    }

	    function parseFunctionExpression() {
	        var token, id = null, stricted, firstRestricted, message, tmp,
	            params = [], defaults = [], body, previousStrict, node = new Node(),
	            isGenerator, previousAllowYield;

	        previousAllowYield = state.allowYield;

	        expectKeyword('function');

	        isGenerator = match('*');
	        if (isGenerator) {
	            lex();
	        }

	        state.allowYield = !isGenerator;
	        if (!match('(')) {
	            token = lookahead;
	            id = (!strict && !isGenerator && matchKeyword('yield')) ? parseNonComputedProperty() : parseVariableIdentifier();
	            if (strict) {
	                if (isRestrictedWord(token.value)) {
	                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);
	                }
	            } else {
	                if (isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictFunctionName;
	                } else if (isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = Messages.StrictReservedWord;
	                }
	            }
	        }

	        tmp = parseParams(firstRestricted);
	        params = tmp.params;
	        defaults = tmp.defaults;
	        stricted = tmp.stricted;
	        firstRestricted = tmp.firstRestricted;
	        if (tmp.message) {
	            message = tmp.message;
	        }

	        previousStrict = strict;
	        body = parseFunctionSourceElements();
	        if (strict && firstRestricted) {
	            throwUnexpectedToken(firstRestricted, message);
	        }
	        if (strict && stricted) {
	            tolerateUnexpectedToken(stricted, message);
	        }
	        strict = previousStrict;
	        state.allowYield = previousAllowYield;

	        return node.finishFunctionExpression(id, params, defaults, body, isGenerator);
	    }

	    // ECMA-262 14.5 Class Definitions

	    function parseClassBody() {
	        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;

	        classBody = new Node();

	        expect('{');
	        body = [];
	        while (!match('}')) {
	            if (match(';')) {
	                lex();
	            } else {
	                method = new Node();
	                token = lookahead;
	                isStatic = false;
	                computed = match('[');
	                if (match('*')) {
	                    lex();
	                } else {
	                    key = parseObjectPropertyKey();
	                    if (key.name === 'static' && (lookaheadPropertyName() || match('*'))) {
	                        token = lookahead;
	                        isStatic = true;
	                        computed = match('[');
	                        if (match('*')) {
	                            lex();
	                        } else {
	                            key = parseObjectPropertyKey();
	                        }
	                    }
	                }
	                method = tryParseMethodDefinition(token, key, computed, method);
	                if (method) {
	                    method['static'] = isStatic; // jscs:ignore requireDotNotation
	                    if (method.kind === 'init') {
	                        method.kind = 'method';
	                    }
	                    if (!isStatic) {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {
	                            if (method.kind !== 'method' || !method.method || method.value.generator) {
	                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);
	                            }
	                            if (hasConstructor) {
	                                throwUnexpectedToken(token, Messages.DuplicateConstructor);
	                            } else {
	                                hasConstructor = true;
	                            }
	                            method.kind = 'constructor';
	                        }
	                    } else {
	                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {
	                            throwUnexpectedToken(token, Messages.StaticPrototype);
	                        }
	                    }
	                    method.type = Syntax.MethodDefinition;
	                    delete method.method;
	                    delete method.shorthand;
	                    body.push(method);
	                } else {
	                    throwUnexpectedToken(lookahead);
	                }
	            }
	        }
	        lex();
	        return classBody.finishClassBody(body);
	    }

	    function parseClassDeclaration(identifierIsOptional) {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (!identifierIsOptional || lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassDeclaration(id, superClass, classBody);
	    }

	    function parseClassExpression() {
	        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;
	        strict = true;

	        expectKeyword('class');

	        if (lookahead.type === Token.Identifier) {
	            id = parseVariableIdentifier();
	        }

	        if (matchKeyword('extends')) {
	            lex();
	            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);
	        }
	        classBody = parseClassBody();
	        strict = previousStrict;

	        return classNode.finishClassExpression(id, superClass, classBody);
	    }

	    // ECMA-262 15.2 Modules

	    function parseModuleSpecifier() {
	        var node = new Node();

	        if (lookahead.type !== Token.StringLiteral) {
	            throwError(Messages.InvalidModuleSpecifier);
	        }
	        return node.finishLiteral(lex());
	    }

	    // ECMA-262 15.2.3 Exports

	    function parseExportSpecifier() {
	        var exported, local, node = new Node(), def;
	        if (matchKeyword('default')) {
	            // export {default} from 'something';
	            def = new Node();
	            lex();
	            local = def.finishIdentifier('default');
	        } else {
	            local = parseVariableIdentifier();
	        }
	        if (matchContextualKeyword('as')) {
	            lex();
	            exported = parseNonComputedProperty();
	        }
	        return node.finishExportSpecifier(local, exported);
	    }

	    function parseExportNamedDeclaration(node) {
	        var declaration = null,
	            isExportFromIdentifier,
	            src = null, specifiers = [];

	        // non-default export
	        if (lookahead.type === Token.Keyword) {
	            // covers:
	            // export var f = 1;
	            switch (lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = parseLexicalDeclaration({inFor: false});
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = parseStatementListItem();
	                    return node.finishExportNamedDeclaration(declaration, specifiers, null);
	            }
	        }

	        expect('{');
	        while (!match('}')) {
	            isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');
	            specifiers.push(parseExportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');

	        if (matchContextualKeyword('from')) {
	            // covering:
	            // export {default} from 'foo';
	            // export {foo} from 'foo';
	            lex();
	            src = parseModuleSpecifier();
	            consumeSemicolon();
	        } else if (isExportFromIdentifier) {
	            // covering:
	            // export {default}; // missing fromClause
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        } else {
	            // cover
	            // export {foo};
	            consumeSemicolon();
	        }
	        return node.finishExportNamedDeclaration(declaration, specifiers, src);
	    }

	    function parseExportDefaultDeclaration(node) {
	        var declaration = null,
	            expression = null;

	        // covers:
	        // export default ...
	        expectKeyword('default');

	        if (matchKeyword('function')) {
	            // covers:
	            // export default function foo () {}
	            // export default function () {}
	            declaration = parseFunctionDeclaration(new Node(), true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }
	        if (matchKeyword('class')) {
	            declaration = parseClassDeclaration(true);
	            return node.finishExportDefaultDeclaration(declaration);
	        }

	        if (matchContextualKeyword('from')) {
	            throwError(Messages.UnexpectedToken, lookahead.value);
	        }

	        // covers:
	        // export default {};
	        // export default [];
	        // export default (1 + 2);
	        if (match('{')) {
	            expression = parseObjectInitializer();
	        } else if (match('[')) {
	            expression = parseArrayInitializer();
	        } else {
	            expression = parseAssignmentExpression();
	        }
	        consumeSemicolon();
	        return node.finishExportDefaultDeclaration(expression);
	    }

	    function parseExportAllDeclaration(node) {
	        var src;

	        // covers:
	        // export * from 'foo';
	        expect('*');
	        if (!matchContextualKeyword('from')) {
	            throwError(lookahead.value ?
	                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	        }
	        lex();
	        src = parseModuleSpecifier();
	        consumeSemicolon();

	        return node.finishExportAllDeclaration(src);
	    }

	    function parseExportDeclaration() {
	        var node = new Node();
	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalExportDeclaration);
	        }

	        expectKeyword('export');

	        if (matchKeyword('default')) {
	            return parseExportDefaultDeclaration(node);
	        }
	        if (match('*')) {
	            return parseExportAllDeclaration(node);
	        }
	        return parseExportNamedDeclaration(node);
	    }

	    // ECMA-262 15.2.2 Imports

	    function parseImportSpecifier() {
	        // import {<foo as bar>} ...;
	        var local, imported, node = new Node();

	        imported = parseNonComputedProperty();
	        if (matchContextualKeyword('as')) {
	            lex();
	            local = parseVariableIdentifier();
	        }

	        return node.finishImportSpecifier(local, imported);
	    }

	    function parseNamedImports() {
	        var specifiers = [];
	        // {foo, bar as bas}
	        expect('{');
	        while (!match('}')) {
	            specifiers.push(parseImportSpecifier());
	            if (!match('}')) {
	                expect(',');
	                if (match('}')) {
	                    break;
	                }
	            }
	        }
	        expect('}');
	        return specifiers;
	    }

	    function parseImportDefaultSpecifier() {
	        // import <foo> ...;
	        var local, node = new Node();

	        local = parseNonComputedProperty();

	        return node.finishImportDefaultSpecifier(local);
	    }

	    function parseImportNamespaceSpecifier() {
	        // import <* as foo> ...;
	        var local, node = new Node();

	        expect('*');
	        if (!matchContextualKeyword('as')) {
	            throwError(Messages.NoAsAfterImportNamespace);
	        }
	        lex();
	        local = parseNonComputedProperty();

	        return node.finishImportNamespaceSpecifier(local);
	    }

	    function parseImportDeclaration() {
	        var specifiers = [], src, node = new Node();

	        if (state.inFunctionBody) {
	            throwError(Messages.IllegalImportDeclaration);
	        }

	        expectKeyword('import');

	        if (lookahead.type === Token.StringLiteral) {
	            // import 'foo';
	            src = parseModuleSpecifier();
	        } else {

	            if (match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(parseNamedImports());
	            } else if (match('*')) {
	                // import * as foo
	                specifiers.push(parseImportNamespaceSpecifier());
	            } else if (isIdentifierName(lookahead) && !matchKeyword('default')) {
	                // import foo
	                specifiers.push(parseImportDefaultSpecifier());
	                if (match(',')) {
	                    lex();
	                    if (match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(parseImportNamespaceSpecifier());
	                    } else if (match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(parseNamedImports());
	                    } else {
	                        throwUnexpectedToken(lookahead);
	                    }
	                }
	            } else {
	                throwUnexpectedToken(lex());
	            }

	            if (!matchContextualKeyword('from')) {
	                throwError(lookahead.value ?
	                        Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);
	            }
	            lex();
	            src = parseModuleSpecifier();
	        }

	        consumeSemicolon();
	        return node.finishImportDeclaration(specifiers, src);
	    }

	    // ECMA-262 15.1 Scripts

	    function parseScriptBody() {
	        var statement, body = [], token, directive, firstRestricted;

	        while (startIndex < length) {
	            token = lookahead;
	            if (token.type !== Token.StringLiteral) {
	                break;
	            }

	            statement = parseStatementListItem();
	            body.push(statement);
	            if (statement.expression.type !== Syntax.Literal) {
	                // this is not directive
	                break;
	            }
	            directive = source.slice(token.start + 1, token.end - 1);
	            if (directive === 'use strict') {
	                strict = true;
	                if (firstRestricted) {
	                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);
	                }
	            } else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }

	        while (startIndex < length) {
	            statement = parseStatementListItem();
	            /* istanbul ignore if */
	            if (typeof statement === 'undefined') {
	                break;
	            }
	            body.push(statement);
	        }
	        return body;
	    }

	    function parseProgram() {
	        var body, node;

	        peek();
	        node = new Node();

	        body = parseScriptBody();
	        return node.finishProgram(body, state.sourceType);
	    }

	    function filterTokenLocation() {
	        var i, entry, token, tokens = [];

	        for (i = 0; i < extra.tokens.length; ++i) {
	            entry = extra.tokens[i];
	            token = {
	                type: entry.type,
	                value: entry.value
	            };
	            if (entry.regex) {
	                token.regex = {
	                    pattern: entry.regex.pattern,
	                    flags: entry.regex.flags
	                };
	            }
	            if (extra.range) {
	                token.range = entry.range;
	            }
	            if (extra.loc) {
	                token.loc = entry.loc;
	            }
	            tokens.push(token);
	        }

	        extra.tokens = tokens;
	    }

	    function tokenize(code, options, delegate) {
	        var toString,
	            tokens;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: []
	        };

	        extra = {};

	        // Options matching.
	        options = options || {};

	        // Of course we collect tokens here.
	        options.tokens = true;
	        extra.tokens = [];
	        extra.tokenValues = [];
	        extra.tokenize = true;
	        extra.delegate = delegate;

	        // The following two fields are necessary to compute the Regex tokens.
	        extra.openParenToken = -1;
	        extra.openCurlyToken = -1;

	        extra.range = (typeof options.range === 'boolean') && options.range;
	        extra.loc = (typeof options.loc === 'boolean') && options.loc;

	        if (typeof options.comment === 'boolean' && options.comment) {
	            extra.comments = [];
	        }
	        if (typeof options.tolerant === 'boolean' && options.tolerant) {
	            extra.errors = [];
	        }

	        try {
	            peek();
	            if (lookahead.type === Token.EOF) {
	                return extra.tokens;
	            }

	            lex();
	            while (lookahead.type !== Token.EOF) {
	                try {
	                    lex();
	                } catch (lexError) {
	                    if (extra.errors) {
	                        recordError(lexError);
	                        // We have to break on the first error
	                        // to avoid infinite loops.
	                        break;
	                    } else {
	                        throw lexError;
	                    }
	                }
	            }

	            tokens = extra.tokens;
	            if (typeof extra.errors !== 'undefined') {
	                tokens.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }
	        return tokens;
	    }

	    function parse(code, options) {
	        var program, toString;

	        toString = String;
	        if (typeof code !== 'string' && !(code instanceof String)) {
	            code = toString(code);
	        }

	        source = code;
	        index = 0;
	        lineNumber = (source.length > 0) ? 1 : 0;
	        lineStart = 0;
	        startIndex = index;
	        startLineNumber = lineNumber;
	        startLineStart = lineStart;
	        length = source.length;
	        lookahead = null;
	        state = {
	            allowIn: true,
	            allowYield: true,
	            labelSet: {},
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            lastCommentStart: -1,
	            curlyStack: [],
	            sourceType: 'script'
	        };
	        strict = false;

	        extra = {};
	        if (typeof options !== 'undefined') {
	            extra.range = (typeof options.range === 'boolean') && options.range;
	            extra.loc = (typeof options.loc === 'boolean') && options.loc;
	            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;

	            if (extra.loc && options.source !== null && options.source !== undefined) {
	                extra.source = toString(options.source);
	            }

	            if (typeof options.tokens === 'boolean' && options.tokens) {
	                extra.tokens = [];
	            }
	            if (typeof options.comment === 'boolean' && options.comment) {
	                extra.comments = [];
	            }
	            if (typeof options.tolerant === 'boolean' && options.tolerant) {
	                extra.errors = [];
	            }
	            if (extra.attachComment) {
	                extra.range = true;
	                extra.comments = [];
	                extra.bottomRightStack = [];
	                extra.trailingComments = [];
	                extra.leadingComments = [];
	            }
	            if (options.sourceType === 'module') {
	                // very restrictive condition for now
	                state.sourceType = options.sourceType;
	                strict = true;
	            }
	        }

	        try {
	            program = parseProgram();
	            if (typeof extra.comments !== 'undefined') {
	                program.comments = extra.comments;
	            }
	            if (typeof extra.tokens !== 'undefined') {
	                filterTokenLocation();
	                program.tokens = extra.tokens;
	            }
	            if (typeof extra.errors !== 'undefined') {
	                program.errors = extra.errors;
	            }
	        } catch (e) {
	            throw e;
	        } finally {
	            extra = {};
	        }

	        return program;
	    }

	    // Sync with *.json manifests.
	    exports.version = '2.7.3';

	    exports.tokenize = tokenize;

	    exports.parse = parse;

	    // Deep copy.
	    /* istanbul ignore next */
	    exports.Syntax = (function () {
	        var name, types = {};

	        if (typeof Object.create === 'function') {
	            types = Object.create(null);
	        }

	        for (name in Syntax) {
	            if (Syntax.hasOwnProperty(name)) {
	                types[name] = Syntax[name];
	            }
	        }

	        if (typeof Object.freeze === 'function') {
	            Object.freeze(types);
	        }

	        return types;
	    }());

	}));
	/* vim: set sw=4 ts=4 et tw=80 : */


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	/*
	  Initial code from https://github.com/gulpjs/gulp-util/blob/v3.0.6/lib/log.js
	 */
	var chalk = __webpack_require__(37);
	var timestamp = __webpack_require__(298);

	function getTimestamp(){
	  return '['+chalk.grey(timestamp('HH:mm:ss'))+']';
	}

	function log(){
	  var time = getTimestamp();
	  process.stdout.write(time + ' ');
	  console.log.apply(console, arguments);
	  return this;
	}

	function info(){
	  var time = getTimestamp();
	  process.stdout.write(time + ' ');
	  console.info.apply(console, arguments);
	  return this;
	}

	function dir(){
	  var time = getTimestamp();
	  process.stdout.write(time + ' ');
	  console.dir.apply(console, arguments);
	  return this;
	}

	function warn(){
	  var time = getTimestamp();
	  process.stderr.write(time + ' ');
	  console.warn.apply(console, arguments);
	  return this;
	}

	function error(){
	  var time = getTimestamp();
	  process.stderr.write(time + ' ');
	  console.error.apply(console, arguments);
	  return this;
	}

	module.exports = log;
	module.exports.info = info;
	module.exports.dir = dir;
	module.exports.warn = warn;
	module.exports.error = error;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 187 */
/***/ function(module, exports) {

	function findIndex(array, predicate, self) {
	  var len = array.length;
	  var i;
	  if (len === 0) return -1;
	  if (typeof predicate !== 'function') {
	    throw new TypeError(predicate + ' must be a function');
	  }

	  if (self) {
	    for (i = 0; i < len; i++) {
	      if (predicate.call(self, array[i], i, array)) {
	        return i;
	      }
	    }
	  } else {
	    for (i = 0; i < len; i++) {
	      if (predicate(array[i], i, array)) {
	        return i;
	      }
	    }
	  }

	  return -1;
	}

	module.exports = findIndex


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';
	var util = __webpack_require__(9);
	var Transform = __webpack_require__(3).Transform;

	function ctor(options, transform) {
		util.inherits(FirstChunk, Transform);

		if (typeof options === 'function') {
			transform = options;
			options = {};
		}

		if (typeof transform !== 'function') {
			throw new Error('transform function required');
		}

		function FirstChunk(options2) {
			if (!(this instanceof FirstChunk)) {
				return new FirstChunk(options2);
			}

			Transform.call(this, options2);

			this._firstChunk = true;
			this._transformCalled = false;
			this._minSize = options.minSize;
		}

		FirstChunk.prototype._transform = function (chunk, enc, cb) {
			this._enc = enc;

			if (this._firstChunk) {
				this._firstChunk = false;

				if (this._minSize == null) {
					transform.call(this, chunk, enc, cb);
					this._transformCalled = true;
					return;
				}

				this._buffer = chunk;
				cb();
				return;
			}

			if (this._minSize == null) {
				this.push(chunk);
				cb();
				return;
			}

			if (this._buffer.length < this._minSize) {
				this._buffer = Buffer.concat([this._buffer, chunk]);
				cb();
				return;
			}

			if (this._buffer.length >= this._minSize) {
				transform.call(this, this._buffer.slice(), enc, function () {
					this.push(chunk);
					cb();
				}.bind(this));
				this._transformCalled = true;
				this._buffer = false;
				return;
			}

			this.push(chunk);
			cb();
		};

		FirstChunk.prototype._flush = function (cb) {
			if (!this._buffer) {
				cb();
				return;
			}

			if (this._transformCalled) {
				this.push(this._buffer);
				cb();
			} else {
				transform.call(this, this._buffer.slice(), this._enc, cb);
			}
		};

		return FirstChunk;
	}

	module.exports = function () {
		return ctor.apply(ctor, arguments)();
	};

	module.exports.ctor = ctor;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*
	 * gaze
	 * https://github.com/shama/gaze
	 *
	 * Copyright (c) 2013 Kyle Robinson Young
	 * Licensed under the MIT license.
	 */

	'use strict';

	// libs
	var util = __webpack_require__(9);
	var EE = __webpack_require__(11).EventEmitter;
	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(6);
	var globule = __webpack_require__(195);
	var helper = __webpack_require__(190);

	// shim setImmediate for node v0.8
	var setImmediate = __webpack_require__(34).setImmediate;
	if (typeof setImmediate !== 'function') {
	  setImmediate = process.nextTick;
	}

	// globals
	var delay = 10;

	// `Gaze` EventEmitter object to return in the callback
	function Gaze(patterns, opts, done) {
	  var self = this;
	  EE.call(self);

	  // If second arg is the callback
	  if (typeof opts === 'function') {
	    done = opts;
	    opts = {};
	  }

	  // Default options
	  opts = opts || {};
	  opts.mark = true;
	  opts.interval = opts.interval || 100;
	  opts.debounceDelay = opts.debounceDelay || 500;
	  opts.cwd = opts.cwd || process.cwd();
	  this.options = opts;

	  // Default done callback
	  done = done || function() {};

	  // Remember our watched dir:files
	  this._watched = Object.create(null);

	  // Store watchers
	  this._watchers = Object.create(null);

	  // Store watchFile listeners
	  this._pollers = Object.create(null);

	  // Store patterns
	  this._patterns = [];

	  // Cached events for debouncing
	  this._cached = Object.create(null);

	  // Set maxListeners
	  if (this.options.maxListeners) {
	    this.setMaxListeners(this.options.maxListeners);
	    Gaze.super_.prototype.setMaxListeners(this.options.maxListeners);
	    delete this.options.maxListeners;
	  }

	  // Initialize the watch on files
	  if (patterns) {
	    this.add(patterns, done);
	  }

	  // keep the process alive
	  this._keepalive = setInterval(function() {}, 200);

	  return this;
	}
	util.inherits(Gaze, EE);

	// Main entry point. Start watching and call done when setup
	module.exports = function gaze(patterns, opts, done) {
	  return new Gaze(patterns, opts, done);
	};
	module.exports.Gaze = Gaze;

	// Override the emit function to emit `all` events
	// and debounce on duplicate events per file
	Gaze.prototype.emit = function() {
	  var self = this;
	  var args = arguments;

	  var e = args[0];
	  var filepath = args[1];
	  var timeoutId;

	  // If not added/deleted/changed/renamed then just emit the event
	  if (e.slice(-2) !== 'ed') {
	    Gaze.super_.prototype.emit.apply(self, args);
	    return this;
	  }

	  // Detect rename event, if added and previous deleted is in the cache
	  if (e === 'added') {
	    Object.keys(this._cached).forEach(function(oldFile) {
	      if (self._cached[oldFile].indexOf('deleted') !== -1) {
	        args[0] = e = 'renamed';
	        [].push.call(args, oldFile);
	        delete self._cached[oldFile];
	        return false;
	      }
	    });
	  }

	  // If cached doesnt exist, create a delay before running the next
	  // then emit the event
	  var cache = this._cached[filepath] || [];
	  if (cache.indexOf(e) === -1) {
	    helper.objectPush(self._cached, filepath, e);
	    clearTimeout(timeoutId);
	    timeoutId = setTimeout(function() {
	      delete self._cached[filepath];
	    }, this.options.debounceDelay);
	    // Emit the event and `all` event
	    Gaze.super_.prototype.emit.apply(self, args);
	    Gaze.super_.prototype.emit.apply(self, ['all', e].concat([].slice.call(args, 1)));
	  }

	  // Detect if new folder added to trigger for matching files within folder
	  if (e === 'added') {
	    if (helper.isDir(filepath)) {
	      fs.readdirSync(filepath).map(function(file) {
	        return path.join(filepath, file);
	      }).filter(function(file) {
	        return globule.isMatch(self._patterns, file, self.options);
	      }).forEach(function(file) {
	        self.emit('added', file);
	      });
	    }
	  }

	  return this;
	};

	// Close watchers
	Gaze.prototype.close = function(_reset) {
	  var self = this;
	  _reset = _reset === false ? false : true;
	  Object.keys(self._watchers).forEach(function(file) {
	    self._watchers[file].close();
	  });
	  self._watchers = Object.create(null);
	  Object.keys(this._watched).forEach(function(dir) {
	    self._unpollDir(dir);
	  });
	  if (_reset) {
	    self._watched = Object.create(null);
	    setTimeout(function() {
	      self.emit('end');
	      self.removeAllListeners();
	      clearInterval(self._keepalive);
	    }, delay + 100);
	  }
	  return self;
	};

	// Add file patterns to be watched
	Gaze.prototype.add = function(files, done) {
	  if (typeof files === 'string') { files = [files]; }
	  this._patterns = helper.unique.apply(null, [this._patterns, files]);
	  files = globule.find(this._patterns, this.options);
	  this._addToWatched(files);
	  this.close(false);
	  this._initWatched(done);
	};

	// Dont increment patterns and dont call done if nothing added
	Gaze.prototype._internalAdd = function(file, done) {
	  var files = [];
	  if (helper.isDir(file)) {
	    files = [helper.markDir(file)].concat(globule.find(this._patterns, this.options));
	  } else {
	    if (globule.isMatch(this._patterns, file, this.options)) {
	      files = [file];
	    }
	  }
	  if (files.length > 0) {
	    this._addToWatched(files);
	    this.close(false);
	    this._initWatched(done);
	  }
	};

	// Remove file/dir from `watched`
	Gaze.prototype.remove = function(file) {
	  var self = this;
	  if (this._watched[file]) {
	    // is dir, remove all files
	    this._unpollDir(file);
	    delete this._watched[file];
	  } else {
	    // is a file, find and remove
	    Object.keys(this._watched).forEach(function(dir) {
	      var index = self._watched[dir].indexOf(file);
	      if (index !== -1) {
	        self._unpollFile(file);
	        self._watched[dir].splice(index, 1);
	        return false;
	      }
	    });
	  }
	  if (this._watchers[file]) {
	    this._watchers[file].close();
	  }
	  return this;
	};

	// Return watched files
	Gaze.prototype.watched = function() {
	  return this._watched;
	};

	// Returns `watched` files with relative paths to process.cwd()
	Gaze.prototype.relative = function(dir, unixify) {
	  var self = this;
	  var relative = Object.create(null);
	  var relDir, relFile, unixRelDir;
	  var cwd = this.options.cwd || process.cwd();
	  if (dir === '') { dir = '.'; }
	  dir = helper.markDir(dir);
	  unixify = unixify || false;
	  Object.keys(this._watched).forEach(function(dir) {
	    relDir = path.relative(cwd, dir) + path.sep;
	    if (relDir === path.sep) { relDir = '.'; }
	    unixRelDir = unixify ? helper.unixifyPathSep(relDir) : relDir;
	    relative[unixRelDir] = self._watched[dir].map(function(file) {
	      relFile = path.relative(path.join(cwd, relDir) || '', file || '');
	      if (helper.isDir(file)) {
	        relFile = helper.markDir(relFile);
	      }
	      if (unixify) {
	        relFile = helper.unixifyPathSep(relFile);
	      }
	      return relFile;
	    });
	  });
	  if (dir && unixify) {
	    dir = helper.unixifyPathSep(dir);
	  }
	  return dir ? relative[dir] || [] : relative;
	};

	// Adds files and dirs to watched
	Gaze.prototype._addToWatched = function(files) {
	  for (var i = 0; i < files.length; i++) {
	    var file = files[i];
	    var filepath = path.resolve(this.options.cwd, file);

	    var dirname = (helper.isDir(file)) ? filepath : path.dirname(filepath);
	    dirname = helper.markDir(dirname);

	    // If a new dir is added
	    if (helper.isDir(file) && !(filepath in this._watched)) {
	      helper.objectPush(this._watched, filepath, []);
	    }

	    if (file.slice(-1) === '/') { filepath += path.sep; }
	    helper.objectPush(this._watched, path.dirname(filepath) + path.sep, filepath);

	    // add folders into the mix
	    var readdir = fs.readdirSync(dirname);
	    for (var j = 0; j < readdir.length; j++) {
	      var dirfile = path.join(dirname, readdir[j]);
	      if (fs.lstatSync(dirfile).isDirectory()) {
	        helper.objectPush(this._watched, dirname, dirfile + path.sep);
	      }
	    }
	  }
	  return this;
	};

	Gaze.prototype._watchDir = function(dir, done) {
	  var self = this;
	  var timeoutId;
	  try {
	    this._watchers[dir] = fs.watch(dir, function(event) {
	      // race condition. Let's give the fs a little time to settle down. so we
	      // don't fire events on non existent files.
	      clearTimeout(timeoutId);
	      timeoutId = setTimeout(function() {
	        // race condition. Ensure that this directory is still being watched
	        // before continuing.
	        if ((dir in self._watchers) && fs.existsSync(dir)) {
	          done(null, dir);
	        }
	      }, delay + 100);
	    });
	  } catch (err) {
	    return this._handleError(err);
	  }
	  return this;
	};

	Gaze.prototype._unpollFile = function(file) {
	  if (this._pollers[file]) {
	    fs.unwatchFile(file, this._pollers[file] );
	    delete this._pollers[file];
	  }
	  return this;
	};

	Gaze.prototype._unpollDir = function(dir) {
	  this._unpollFile(dir);
	  for (var i = 0; i < this._watched[dir].length; i++) {
	    this._unpollFile(this._watched[dir][i]);
	  }
	};

	Gaze.prototype._pollFile = function(file, done) {
	  var opts = { persistent: true, interval: this.options.interval };
	  if (!this._pollers[file]) {
	    this._pollers[file] = function(curr, prev) {
	      done(null, file);
	    };
	    try {
	      fs.watchFile(file, opts, this._pollers[file]);
	    } catch (err) {
	      return this._handleError(err);
	    }
	  }
	  return this;
	};

	// Initialize the actual watch on `watched` files
	Gaze.prototype._initWatched = function(done) {
	  var self = this;
	  var cwd = this.options.cwd || process.cwd();
	  var curWatched = Object.keys(self._watched);

	  // if no matching files
	  if (curWatched.length < 1) {
	    // Defer to emitting to give a chance to attach event handlers.
	    setImmediate(function () {
	      self.emit('ready', self);
	      if (done) { done.call(self, null, self); }
	      self.emit('nomatch');
	    });
	    return;
	  }

	  helper.forEachSeries(curWatched, function(dir, next) {
	    dir = dir || '';
	    var files = self._watched[dir];
	    // Triggered when a watched dir has an event
	    self._watchDir(dir, function(event, dirpath) {
	      var relDir = cwd === dir ? '.' : path.relative(cwd, dir);
	      relDir = relDir || '';

	      fs.readdir(dirpath, function(err, current) {
	        if (err) { return self.emit('error', err); }
	        if (!current) { return; }

	        try {
	          // append path.sep to directories so they match previous.
	          current = current.map(function(curPath) {
	            if (fs.existsSync(path.join(dir, curPath)) && fs.lstatSync(path.join(dir, curPath)).isDirectory()) {
	              return curPath + path.sep;
	            } else {
	              return curPath;
	            }
	          });
	        } catch (err) {
	          // race condition-- sometimes the file no longer exists
	        }

	        // Get watched files for this dir
	        var previous = self.relative(relDir);

	        // If file was deleted
	        previous.filter(function(file) {
	          return current.indexOf(file) < 0;
	        }).forEach(function(file) {
	          if (!helper.isDir(file)) {
	            var filepath = path.join(dir, file);
	            self.remove(filepath);
	            self.emit('deleted', filepath);
	          }
	        });

	        // If file was added
	        current.filter(function(file) {
	          return previous.indexOf(file) < 0;
	        }).forEach(function(file) {
	          // Is it a matching pattern?
	          var relFile = path.join(relDir, file);
	          // Add to watch then emit event
	          self._internalAdd(relFile, function() {
	            self.emit('added', path.join(dir, file));
	          });
	        });

	      });
	    });

	    // Watch for change/rename events on files
	    files.forEach(function(file) {
	      if (helper.isDir(file)) { return; }
	      self._pollFile(file, function(err, filepath) {
	        // Only emit changed if the file still exists
	        // Prevents changed/deleted duplicate events
	        if (fs.existsSync(filepath)) {
	          self.emit('changed', filepath);
	        }
	      });
	    });

	    next();
	  }, function() {

	    // Return this instance of Gaze
	    // delay before ready solves a lot of issues
	    setTimeout(function() {
	      self.emit('ready', self);
	      if (done) { done.call(self, null, self); }
	    }, delay + 100);

	  });
	};

	// If an error, handle it here
	Gaze.prototype._handleError = function(err) {
	  if (err.code === 'EMFILE') {
	    return this.emit('error', new Error('EMFILE: Too many opened files.'));
	  }
	  return this.emit('error', err);
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var path = __webpack_require__(6);
	var helper = module.exports = {};

	// Returns boolean whether filepath is dir terminated
	helper.isDir = function isDir(dir) {
	  if (typeof dir !== 'string') { return false; }
	  return (dir.slice(-(path.sep.length)) === path.sep);
	};

	// Create a `key:[]` if doesnt exist on `obj` then push or concat the `val`
	helper.objectPush = function objectPush(obj, key, val) {
	  if (obj[key] == null) { obj[key] = []; }
	  if (Array.isArray(val)) { obj[key] = obj[key].concat(val); }
	  else if (val) { obj[key].push(val); }
	  return obj[key] = helper.unique(obj[key]);
	};

	// Ensures the dir is marked with path.sep
	helper.markDir = function markDir(dir) {
	  if (typeof dir === 'string' &&
	    dir.slice(-(path.sep.length)) !== path.sep &&
	    dir !== '.') {
	    dir += path.sep;
	  }
	  return dir;
	};

	// Changes path.sep to unix ones for testing
	helper.unixifyPathSep = function unixifyPathSep(filepath) {
	  return (process.platform === 'win32') ? String(filepath).replace(/\\/g, '/') : filepath;
	};

	/**
	 * Lo-Dash 1.0.1 <http://lodash.com/>
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
	 * Available under MIT license <http://lodash.com/license>
	 */
	helper.unique = function unique() { var array = Array.prototype.concat.apply(Array.prototype, arguments); var result = []; for (var i = 0; i < array.length; i++) { if (result.indexOf(array[i]) === -1) { result.push(array[i]); } } return result; };

	/**
	 * Copyright (c) 2010 Caolan McMahon
	 * Available under MIT license <https://raw.github.com/caolan/async/master/LICENSE>
	 */
	helper.forEachSeries = function forEachSeries(arr, iterator, callback) {
	  if (!arr.length) { return callback(); }
	  var completed = 0;
	  var iterate = function() {
	    iterator(arr[completed], function (err) {
	      if (err) {
	        callback(err);
	        callback = function() {};
	      } else {
	        completed += 1;
	        if (completed === arr.length) {
	          callback(null);
	        } else {
	          iterate();
	        }
	      }
	    });
	  };
	  iterate();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*jslint node: true */

	'use strict';

	var through2 = __webpack_require__(29);
	var Combine = __webpack_require__(270);
	var unique = __webpack_require__(299);

	var glob = __webpack_require__(56);
	var minimatch = __webpack_require__(33);
	var glob2base = __webpack_require__(194);
	var path = __webpack_require__(6);

	var gs = {
	  // creates a stream for a single glob or filter
	  createStream: function(ourGlob, negatives, opt) {
	    if (!negatives) negatives = [];
	    if (!opt) opt = {};
	    if (typeof opt.cwd !== 'string') opt.cwd = process.cwd();
	    if (typeof opt.dot !== 'boolean') opt.dot = false;
	    if (typeof opt.silent !== 'boolean') opt.silent = true;
	    if (typeof opt.nonull !== 'boolean') opt.nonull = false;
	    if (typeof opt.cwdbase !== 'boolean') opt.cwdbase = false;
	    if (opt.cwdbase) opt.base = opt.cwd;

	    // remove path relativity to make globs make sense
	    ourGlob = unrelative(opt.cwd, ourGlob);
	    negatives = negatives.map(unrelative.bind(null, opt.cwd));

	    // create globbing stuff
	    var globber = new glob.Glob(ourGlob, opt);

	    // extract base path from glob
	    var basePath = opt.base ? opt.base : glob2base(globber);

	    // create stream and map events from globber to it
	    var stream = through2.obj(negatives.length ? filterNegatives : undefined);

	    globber.on('error', stream.emit.bind(stream, 'error'));
	    globber.on('end', function(/* some args here so can't use bind directly */){
	      stream.end();
	    });
	    globber.on('match', function(filename) {
	      stream.write({
	        cwd: opt.cwd,
	        base: basePath,
	        path: path.resolve(opt.cwd, filename)
	      });
	    });

	    return stream;

	    function filterNegatives(filename, enc, cb) {
	      var matcha = isMatch.bind(null, filename, opt);
	      if (negatives.every(matcha)) {
	        cb(null, filename); // pass
	      } else {
	        cb(); // ignore
	      }
	    }
	  },

	  // creates a stream for multiple globs or filters
	  create: function(globs, opt) {
	    if (!opt) opt = {};

	    // only one glob no need to aggregate
	    if (!Array.isArray(globs)) return gs.createStream(globs, null, opt);

	    var positives = globs.filter(isPositive);
	    var negatives = globs.filter(isNegative);

	    if (positives.length === 0) throw new Error("Missing positive glob");

	    // only one positive glob no need to aggregate
	    if (positives.length === 1) return gs.createStream(positives[0], negatives, opt);

	    // create all individual streams
	    var streams = positives.map(function(glob){
	      return gs.createStream(glob, negatives, opt);
	    });

	    // then just pipe them to a single unique stream and return it
	    var aggregate = new Combine(streams);
	    var uniqueStream = unique('path');

	    return aggregate.pipe(uniqueStream);
	  }
	};

	function isMatch(file, opt, pattern) {
	  if (typeof pattern === 'string') return minimatch(file.path, pattern, opt);
	  if (pattern instanceof RegExp) return pattern.test(file.path);
	  return true; // unknown glob type?
	}

	function isNegative(pattern) {
	  if (typeof pattern !== 'string') return true;
	  if (pattern[0] === '!') return true;
	  return false;
	}

	function isPositive(pattern) {
	  return !isNegative(pattern);
	}

	function unrelative(cwd, glob) {
	  var mod = '';
	  if (glob[0] === '!') {
	    mod = glob[0];
	    glob = glob.slice(1);
	  }
	  return mod+path.resolve(cwd, glob);
	}


	module.exports = gs;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {module.exports = globSync
	globSync.GlobSync = GlobSync

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))
	var minimatch = __webpack_require__(33)
	var Minimatch = minimatch.Minimatch
	var Glob = __webpack_require__(56).Glob
	var util = __webpack_require__(9)
	var path = __webpack_require__(6)
	var assert = __webpack_require__(30)
	var common = __webpack_require__(55)
	var alphasort = common.alphasort
	var alphasorti = common.alphasorti
	var isAbsolute = common.isAbsolute
	var setopts = common.setopts
	var ownProp = common.ownProp
	var childrenIgnored = common.childrenIgnored

	function globSync (pattern, options) {
	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  return new GlobSync(pattern, options).found
	}

	function GlobSync (pattern, options) {
	  if (!pattern)
	    throw new Error('must provide pattern')

	  if (typeof options === 'function' || arguments.length === 3)
	    throw new TypeError('callback provided to sync glob\n'+
	                        'See: https://github.com/isaacs/node-glob/issues/167')

	  if (!(this instanceof GlobSync))
	    return new GlobSync(pattern, options)

	  setopts(this, pattern, options)

	  if (this.noprocess)
	    return this

	  var n = this.minimatch.set.length
	  this.matches = new Array(n)
	  for (var i = 0; i < n; i ++) {
	    this._process(this.minimatch.set[i], i, false)
	  }
	  this._finish()
	}

	GlobSync.prototype._finish = function () {
	  assert(this instanceof GlobSync)
	  if (this.realpath) {
	    var self = this
	    this.matches.forEach(function (matchset, index) {
	      var set = self.matches[index] = Object.create(null)
	      for (var p in matchset) {
	        try {
	          p = self._makeAbs(p)
	          var real = fs.realpathSync(p, this.realpathCache)
	          set[real] = true
	        } catch (er) {
	          if (er.syscall === 'stat')
	            set[self._makeAbs(p)] = true
	          else
	            throw er
	        }
	      }
	    })
	  }
	  common.finish(this)
	}


	GlobSync.prototype._process = function (pattern, index, inGlobStar) {
	  assert(this instanceof GlobSync)

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === 'string') {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // See if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      this._processSimple(pattern.join('/'), index)
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's 'absolute' like /foo/bar,
	      // or 'relative' like '../baz'
	      prefix = pattern.slice(0, n).join('/')
	      break
	  }

	  var remain = pattern.slice(n)

	  // get the list of entries.
	  var read
	  if (prefix === null)
	    read = '.'
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
	    if (!prefix || !isAbsolute(prefix))
	      prefix = '/' + prefix
	    read = prefix
	  } else
	    read = prefix

	  var abs = this._makeAbs(read)

	  //if ignored, skip processing
	  if (childrenIgnored(this, read))
	    return

	  var isGlobStar = remain[0] === minimatch.GLOBSTAR
	  if (isGlobStar)
	    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
	  else
	    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
	}


	GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
	  var entries = this._readdir(abs, inGlobStar)

	  // if the abs isn't a dir, then nothing can match!
	  if (!entries)
	    return

	  // It will only match dot entries if it starts with a dot, or if
	  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	  var pn = remain[0]
	  var negate = !!this.minimatch.negate
	  var rawGlob = pn._glob
	  var dotOk = this.dot || rawGlob.charAt(0) === '.'

	  var matchedEntries = []
	  for (var i = 0; i < entries.length; i++) {
	    var e = entries[i]
	    if (e.charAt(0) !== '.' || dotOk) {
	      var m
	      if (negate && !prefix) {
	        m = !e.match(pn)
	      } else {
	        m = e.match(pn)
	      }
	      if (m)
	        matchedEntries.push(e)
	    }
	  }

	  var len = matchedEntries.length
	  // If there are no matched entries, then nothing matches.
	  if (len === 0)
	    return

	  // if this is the last remaining pattern bit, then no need for
	  // an additional stat *unless* the user has specified mark or
	  // stat explicitly.  We know they exist, since readdir returned
	  // them.

	  if (remain.length === 1 && !this.mark && !this.stat) {
	    if (!this.matches[index])
	      this.matches[index] = Object.create(null)

	    for (var i = 0; i < len; i ++) {
	      var e = matchedEntries[i]
	      if (prefix) {
	        if (prefix.slice(-1) !== '/')
	          e = prefix + '/' + e
	        else
	          e = prefix + e
	      }

	      if (e.charAt(0) === '/' && !this.nomount) {
	        e = path.join(this.root, e)
	      }
	      this.matches[index][e] = true
	    }
	    // This was the last one, and no stats were needed
	    return
	  }

	  // now test all matched entries as stand-ins for that part
	  // of the pattern.
	  remain.shift()
	  for (var i = 0; i < len; i ++) {
	    var e = matchedEntries[i]
	    var newPattern
	    if (prefix)
	      newPattern = [prefix, e]
	    else
	      newPattern = [e]
	    this._process(newPattern.concat(remain), index, inGlobStar)
	  }
	}


	GlobSync.prototype._emitMatch = function (index, e) {
	  var abs = this._makeAbs(e)
	  if (this.mark)
	    e = this._mark(e)

	  if (this.matches[index][e])
	    return

	  if (this.nodir) {
	    var c = this.cache[this._makeAbs(e)]
	    if (c === 'DIR' || Array.isArray(c))
	      return
	  }

	  this.matches[index][e] = true
	  if (this.stat)
	    this._stat(e)
	}


	GlobSync.prototype._readdirInGlobStar = function (abs) {
	  // follow all symlinked directories forever
	  // just proceed as if this is a non-globstar situation
	  if (this.follow)
	    return this._readdir(abs, false)

	  var entries
	  var lstat
	  var stat
	  try {
	    lstat = fs.lstatSync(abs)
	  } catch (er) {
	    // lstat failed, doesn't exist
	    return null
	  }

	  var isSym = lstat.isSymbolicLink()
	  this.symlinks[abs] = isSym

	  // If it's not a symlink or a dir, then it's definitely a regular file.
	  // don't bother doing a readdir in that case.
	  if (!isSym && !lstat.isDirectory())
	    this.cache[abs] = 'FILE'
	  else
	    entries = this._readdir(abs, false)

	  return entries
	}

	GlobSync.prototype._readdir = function (abs, inGlobStar) {
	  var entries

	  if (inGlobStar && !ownProp(this.symlinks, abs))
	    return this._readdirInGlobStar(abs)

	  if (ownProp(this.cache, abs)) {
	    var c = this.cache[abs]
	    if (!c || c === 'FILE')
	      return null

	    if (Array.isArray(c))
	      return c
	  }

	  try {
	    return this._readdirEntries(abs, fs.readdirSync(abs))
	  } catch (er) {
	    this._readdirError(abs, er)
	    return null
	  }
	}

	GlobSync.prototype._readdirEntries = function (abs, entries) {
	  // if we haven't asked to stat everything, then just
	  // assume that everything in there exists, so we can avoid
	  // having to stat it a second time.
	  if (!this.mark && !this.stat) {
	    for (var i = 0; i < entries.length; i ++) {
	      var e = entries[i]
	      if (abs === '/')
	        e = abs + e
	      else
	        e = abs + '/' + e
	      this.cache[e] = true
	    }
	  }

	  this.cache[abs] = entries

	  // mark and cache dir-ness
	  return entries
	}

	GlobSync.prototype._readdirError = function (f, er) {
	  // handle errors, and cache the information
	  switch (er.code) {
	    case 'ENOTDIR': // totally normal. means it *does* exist.
	      this.cache[this._makeAbs(f)] = 'FILE'
	      break

	    case 'ENOENT': // not terribly unusual
	    case 'ELOOP':
	    case 'ENAMETOOLONG':
	    case 'UNKNOWN':
	      this.cache[this._makeAbs(f)] = false
	      break

	    default: // some unusual error.  Treat as failure.
	      this.cache[this._makeAbs(f)] = false
	      if (this.strict) throw er
	      if (!this.silent) console.error('glob error', er)
	      break
	  }
	}

	GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

	  var entries = this._readdir(abs, inGlobStar)

	  // no entries means not a dir, so it can never have matches
	  // foo.txt/** doesn't match foo.txt
	  if (!entries)
	    return

	  // test without the globstar, and with every child both below
	  // and replacing the globstar.
	  var remainWithoutGlobStar = remain.slice(1)
	  var gspref = prefix ? [ prefix ] : []
	  var noGlobStar = gspref.concat(remainWithoutGlobStar)

	  // the noGlobStar pattern exits the inGlobStar state
	  this._process(noGlobStar, index, false)

	  var len = entries.length
	  var isSym = this.symlinks[abs]

	  // If it's a symlink, and we're in a globstar, then stop
	  if (isSym && inGlobStar)
	    return

	  for (var i = 0; i < len; i++) {
	    var e = entries[i]
	    if (e.charAt(0) === '.' && !this.dot)
	      continue

	    // these two cases enter the inGlobStar state
	    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
	    this._process(instead, index, true)

	    var below = gspref.concat(entries[i], remain)
	    this._process(below, index, true)
	  }
	}

	GlobSync.prototype._processSimple = function (prefix, index) {
	  // XXX review this.  Shouldn't it be doing the mounting etc
	  // before doing stat?  kinda weird?
	  var exists = this._stat(prefix)

	  if (!this.matches[index])
	    this.matches[index] = Object.create(null)

	  // If it doesn't exist, then just mark the lack of results
	  if (!exists)
	    return

	  if (prefix && isAbsolute(prefix) && !this.nomount) {
	    var trail = /[\/\\]$/.test(prefix)
	    if (prefix.charAt(0) === '/') {
	      prefix = path.join(this.root, prefix)
	    } else {
	      prefix = path.resolve(this.root, prefix)
	      if (trail)
	        prefix += '/'
	    }
	  }

	  if (process.platform === 'win32')
	    prefix = prefix.replace(/\\/g, '/')

	  // Mark this as a match
	  this.matches[index][prefix] = true
	}

	// Returns either 'DIR', 'FILE', or false
	GlobSync.prototype._stat = function (f) {
	  var abs = this._makeAbs(f)
	  var needDir = f.slice(-1) === '/'

	  if (f.length > this.maxLength)
	    return false

	  if (!this.stat && ownProp(this.cache, abs)) {
	    var c = this.cache[abs]

	    if (Array.isArray(c))
	      c = 'DIR'

	    // It exists, but maybe not how we need it
	    if (!needDir || c === 'DIR')
	      return c

	    if (needDir && c === 'FILE')
	      return false

	    // otherwise we have to stat, because maybe c=true
	    // if we know it exists, but not what it is.
	  }

	  var exists
	  var stat = this.statCache[abs]
	  if (!stat) {
	    var lstat
	    try {
	      lstat = fs.lstatSync(abs)
	    } catch (er) {
	      return false
	    }

	    if (lstat.isSymbolicLink()) {
	      try {
	        stat = fs.statSync(abs)
	      } catch (er) {
	        stat = lstat
	      }
	    } else {
	      stat = lstat
	    }
	  }

	  this.statCache[abs] = stat

	  var c = stat.isDirectory() ? 'DIR' : 'FILE'
	  this.cache[abs] = this.cache[abs] || c

	  if (needDir && c !== 'DIR')
	    return false

	  return c
	}

	GlobSync.prototype._mark = function (p) {
	  return common.mark(this, p)
	}

	GlobSync.prototype._makeAbs = function (f) {
	  return common.makeAbs(this, f)
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	var gaze = __webpack_require__(189);
	var EventEmitter = __webpack_require__(11).EventEmitter;

	module.exports = function(glob, opts, cb) {
	  var out = new EventEmitter();

	  if (typeof opts === 'function') {
	    cb = opts;
	    opts = {};
	  }

	  var watcher = gaze(glob, opts, function(err, rwatcher){
	    if (err) out.emit('error', err);
	    rwatcher.on('all', function(evt, path, old){
	      var outEvt = {type: evt, path: path};
	      if(old) outEvt.old = old;
	      out.emit('change', outEvt);
	      if(cb) cb(outEvt);
	    });
	  });

	  watcher.on('end', out.emit.bind(out, 'end'));
	  watcher.on('error', out.emit.bind(out, 'error'));
	  watcher.on('ready', out.emit.bind(out, 'ready'));
	  watcher.on('nomatch', out.emit.bind(out, 'nomatch'));

	  out.end = function(){
	    return watcher.close();
	  };
	  out.add = function(){
	    return watcher.add.apply(watcher, arguments);
	  };
	  out.remove = function(){
	    return watcher.remove();
	  };
	  out._watcher = watcher;

	  return out;
	};


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var path = __webpack_require__(6);
	var findIndex = __webpack_require__(187);

	var flattenGlob = function(arr){
	  var out = [];
	  var flat = true;
	  for(var i = 0; i < arr.length; i++) {
	    if (typeof arr[i] !== 'string') {
	      flat = false;
	      break;
	    }
	    out.push(arr[i]);
	  }

	  // last one is a file or specific dir
	  // so we pop it off
	  if (flat) {
	    out.pop();
	  }
	  return out;
	};

	var flattenExpansion = function(set) {
	  var first = set[0];
	  var toCompare = set.slice(1);

	  // find index where the diff is
	  var idx = findIndex(first, function(v, idx){
	    if (typeof v !== 'string') {
	      return true;
	    }

	    var matched = toCompare.every(function(arr){
	      return v === arr[idx];
	    });

	    return !matched;
	  });

	  return first.slice(0, idx);
	};

	var setToBase = function(set) {
	  // normal something/*.js
	  if (set.length <= 1) {
	    return flattenGlob(set[0]);
	  }
	  // has expansion
	  return flattenExpansion(set);
	};

	module.exports = function(glob) {
	  var set = glob.minimatch.set;
	  var baseParts = setToBase(set);
	  var basePath = path.normalize(baseParts.join(path.sep))+path.sep;
	  return basePath;
	};


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * globule
	 * https://github.com/cowboy/node-globule
	 *
	 * Copyright (c) 2013 "Cowboy" Ben Alman
	 * Licensed under the MIT license.
	 */

	'use strict';

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var path = __webpack_require__(6);

	var _ = __webpack_require__(199);
	var glob = __webpack_require__(196);
	var minimatch = __webpack_require__(12);

	// The module.
	var globule = exports;

	// Process specified wildcard glob patterns or filenames against a
	// callback, excluding and uniquing files in the result set.
	function processPatterns(patterns, fn) {
	  return _.flatten(patterns).reduce(function(result, pattern) {
	    if (pattern.indexOf('!') === 0) {
	      // If the first character is ! all matches via this pattern should be
	      // removed from the result set.
	      pattern = pattern.slice(1);
	      return _.difference(result, fn(pattern));
	    } else {
	      // Otherwise, add all matching filepaths to the result set.
	      return _.union(result, fn(pattern));
	    }
	  }, []);
	}

	// Match a filepath or filepaths against one or more wildcard patterns. Returns
	// all matching filepaths. This behaves just like minimatch.match, but supports
	// any number of patterns.
	globule.match = function(patterns, filepaths, options) {
	  // Return empty set if either patterns or filepaths was omitted.
	  if (patterns == null || filepaths == null) { return []; }
	  // Normalize patterns and filepaths to arrays.
	  if (!_.isArray(patterns)) { patterns = [patterns]; }
	  if (!_.isArray(filepaths)) { filepaths = [filepaths]; }
	  // Return empty set if there are no patterns or filepaths.
	  if (patterns.length === 0 || filepaths.length === 0) { return []; }
	  // Return all matching filepaths.
	  return processPatterns(patterns, function(pattern) {
	    return minimatch.match(filepaths, pattern, options || {});
	  });
	};

	// Match a filepath or filepaths against one or more wildcard patterns. Returns
	// true if any of the patterns match.
	globule.isMatch = function() {
	  return globule.match.apply(null, arguments).length > 0;
	};

	// Return an array of all file paths that match the given wildcard patterns.
	globule.find = function() {
	  var args = _.toArray(arguments);
	  // If the last argument is an options object, remove it from args.
	  var options = _.isPlainObject(args[args.length - 1]) ? args.pop() : {};
	  // Use the first argument if it's an Array, otherwise use all arguments.
	  var patterns = _.isArray(args[0]) ? args[0] : args;
	  // Return empty set if there are no patterns or filepaths.
	  if (patterns.length === 0) { return []; }
	  var srcBase = options.srcBase || options.cwd;
	  // Create glob-specific options object.
	  var globOptions = _.extend({}, options);
	  if (srcBase) {
	    globOptions.cwd = srcBase;
	  }
	  // Get all matching filepaths.
	  var matches = processPatterns(patterns, function(pattern) {
	    return glob.sync(pattern, globOptions);
	  });
	  // If srcBase and prefixBase were specified, prefix srcBase to matched paths.
	  if (srcBase && options.prefixBase) {
	    matches = matches.map(function(filepath) {
	      return path.join(srcBase, filepath);
	    });
	  }
	  // Filter result set?
	  if (options.filter) {
	    matches = matches.filter(function(filepath) {
	      // If srcBase was specified but prefixBase was NOT, prefix srcBase
	      // temporarily, for filtering.
	      if (srcBase && !options.prefixBase) {
	        filepath = path.join(srcBase, filepath);
	      }
	      try {
	        if (_.isFunction(options.filter)) {
	          return options.filter(filepath, options);
	        } else {
	          // If the file is of the right type and exists, this should work.
	          return fs.statSync(filepath)[options.filter]();
	        }
	      } catch(err) {
	        // Otherwise, it's probably not the right type.
	        return false;
	      }
	    });
	  }
	  return matches;
	};

	var pathSeparatorRe = /[\/\\]/g;
	var extDotRe = {
	  first: /(\.[^\/]*)?$/,
	  last: /(\.[^\/\.]*)?$/,
	};
	function rename(dest, options) {
	  // Flatten path?
	  if (options.flatten) {
	    dest = path.basename(dest);
	  }
	  // Change the extension?
	  if (options.ext) {
	    dest = dest.replace(extDotRe[options.extDot], options.ext);
	  }
	  // Join dest and destBase?
	  if (options.destBase) {
	    dest = path.join(options.destBase, dest);
	  }
	  return dest;
	}

	// Build a mapping of src-dest filepaths from the given set of filepaths.
	globule.mapping = function(filepaths, options) {
	  // Return empty set if filepaths was omitted.
	  if (filepaths == null) { return []; }
	  options = _.defaults({}, options, {
	    extDot: 'first',
	    rename: rename,
	  });
	  var files = [];
	  var fileByDest = {};
	  // Find all files matching pattern, using passed-in options.
	  filepaths.forEach(function(src) {
	    // Generate destination filename.
	    var dest = options.rename(src, options);
	    // Prepend srcBase to all src paths.
	    if (options.srcBase) {
	      src = path.join(options.srcBase, src);
	    }
	    // Normalize filepaths to be unix-style.
	    dest = dest.replace(pathSeparatorRe, '/');
	    src = src.replace(pathSeparatorRe, '/');
	    // Map correct src path to dest path.
	    if (fileByDest[dest]) {
	      // If dest already exists, push this src onto that dest's src array.
	      fileByDest[dest].src.push(src);
	    } else {
	      // Otherwise create a new src-dest file mapping object.
	      files.push({
	        src: [src],
	        dest: dest,
	      });
	      // And store a reference for later use.
	      fileByDest[dest] = files[files.length - 1];
	    }
	  });
	  return files;
	};

	// Return a mapping of src-dest filepaths from files matching the given
	// wildcard patterns.
	globule.findMapping = function(patterns, options) {
	  return globule.mapping(globule.find(patterns, options), options);
	};


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Approach:
	//
	// 1. Get the minimatch set
	// 2. For each pattern in the set, PROCESS(pattern)
	// 3. Store matches per-set, then uniq them
	//
	// PROCESS(pattern)
	// Get the first [n] items from pattern that are all strings
	// Join these together.  This is PREFIX.
	//   If there is no more remaining, then stat(PREFIX) and
	//   add to matches if it succeeds.  END.
	// readdir(PREFIX) as ENTRIES
	//   If fails, END
	//   If pattern[n] is GLOBSTAR
	//     // handle the case where the globstar match is empty
	//     // by pruning it out, and testing the resulting pattern
	//     PROCESS(pattern[0..n] + pattern[n+1 .. $])
	//     // handle other cases.
	//     for ENTRY in ENTRIES (not dotfiles)
	//       // attach globstar + tail onto the entry
	//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $])
	//
	//   else // not globstar
	//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
	//       Test ENTRY against pattern[n]
	//       If fails, continue
	//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
	//
	// Caveat:
	//   Cache all stats and readdirs results to minimize syscall.  Since all
	//   we ever care about is existence and directory-ness, we can just keep
	//   `true` for files, and [children,...] for directories, or `false` for
	//   things that don't exist.



	module.exports = glob

	var fs = __webpack_require__(197)
	, minimatch = __webpack_require__(12)
	, Minimatch = minimatch.Minimatch
	, inherits = __webpack_require__(198)
	, EE = __webpack_require__(11).EventEmitter
	, path = __webpack_require__(6)
	, isDir = {}
	, assert = __webpack_require__(30).ok

	function glob (pattern, options, cb) {
	  if (typeof options === "function") cb = options, options = {}
	  if (!options) options = {}

	  if (typeof options === "number") {
	    deprecated()
	    return
	  }

	  var g = new Glob(pattern, options, cb)
	  return g.sync ? g.found : g
	}

	glob.fnmatch = deprecated

	function deprecated () {
	  throw new Error("glob's interface has changed. Please see the docs.")
	}

	glob.sync = globSync
	function globSync (pattern, options) {
	  if (typeof options === "number") {
	    deprecated()
	    return
	  }

	  options = options || {}
	  options.sync = true
	  return glob(pattern, options)
	}


	glob.Glob = Glob
	inherits(Glob, EE)
	function Glob (pattern, options, cb) {
	  if (!(this instanceof Glob)) {
	    return new Glob(pattern, options, cb)
	  }

	  if (typeof cb === "function") {
	    this.on("error", cb)
	    this.on("end", function (matches) {
	      cb(null, matches)
	    })
	  }

	  options = options || {}

	  this.EOF = {}
	  this._emitQueue = []

	  this.maxDepth = options.maxDepth || 1000
	  this.maxLength = options.maxLength || Infinity
	  this.statCache = options.statCache || {}

	  this.changedCwd = false
	  var cwd = process.cwd()
	  if (!options.hasOwnProperty("cwd")) this.cwd = cwd
	  else {
	    this.cwd = options.cwd
	    this.changedCwd = path.resolve(options.cwd) !== cwd
	  }

	  this.root = options.root || path.resolve(this.cwd, "/")
	  this.root = path.resolve(this.root)
	  if (process.platform === "win32")
	    this.root = this.root.replace(/\\/g, "/")

	  this.nomount = !!options.nomount

	  if (!pattern) {
	    throw new Error("must provide pattern")
	  }

	  // base-matching: just use globstar for that.
	  if (options.matchBase && -1 === pattern.indexOf("/")) {
	    if (options.noglobstar) {
	      throw new Error("base matching requires globstar")
	    }
	    pattern = "**/" + pattern
	  }

	  this.strict = options.strict !== false
	  this.dot = !!options.dot
	  this.mark = !!options.mark
	  this.sync = !!options.sync
	  this.nounique = !!options.nounique
	  this.nonull = !!options.nonull
	  this.nosort = !!options.nosort
	  this.nocase = !!options.nocase
	  this.stat = !!options.stat

	  this.debug = !!options.debug || !!options.globDebug
	  if (this.debug)
	    this.log = console.error

	  this.silent = !!options.silent

	  var mm = this.minimatch = new Minimatch(pattern, options)
	  this.options = mm.options
	  pattern = this.pattern = mm.pattern

	  this.error = null
	  this.aborted = false

	  EE.call(this)

	  // process each pattern in the minimatch set
	  var n = this.minimatch.set.length

	  // The matches are stored as {<filename>: true,...} so that
	  // duplicates are automagically pruned.
	  // Later, we do an Object.keys() on these.
	  // Keep them as a list so we can fill in when nonull is set.
	  this.matches = new Array(n)

	  this.minimatch.set.forEach(iterator.bind(this))
	  function iterator (pattern, i, set) {
	    this._process(pattern, 0, i, function (er) {
	      if (er) this.emit("error", er)
	      if (-- n <= 0) this._finish()
	    })
	  }
	}

	Glob.prototype.log = function () {}

	Glob.prototype._finish = function () {
	  assert(this instanceof Glob)

	  var nou = this.nounique
	  , all = nou ? [] : {}

	  for (var i = 0, l = this.matches.length; i < l; i ++) {
	    var matches = this.matches[i]
	    this.log("matches[%d] =", i, matches)
	    // do like the shell, and spit out the literal glob
	    if (!matches) {
	      if (this.nonull) {
	        var literal = this.minimatch.globSet[i]
	        if (nou) all.push(literal)
	        else all[literal] = true
	      }
	    } else {
	      // had matches
	      var m = Object.keys(matches)
	      if (nou) all.push.apply(all, m)
	      else m.forEach(function (m) {
	        all[m] = true
	      })
	    }
	  }

	  if (!nou) all = Object.keys(all)

	  if (!this.nosort) {
	    all = all.sort(this.nocase ? alphasorti : alphasort)
	  }

	  if (this.mark) {
	    // at *some* point we statted all of these
	    all = all.map(function (m) {
	      var sc = this.statCache[m]
	      if (!sc)
	        return m
	      var isDir = (Array.isArray(sc) || sc === 2)
	      if (isDir && m.slice(-1) !== "/") {
	        return m + "/"
	      }
	      if (!isDir && m.slice(-1) === "/") {
	        return m.replace(/\/+$/, "")
	      }
	      return m
	    }, this)
	  }

	  this.log("emitting end", all)

	  this.EOF = this.found = all
	  this.emitMatch(this.EOF)
	}

	function alphasorti (a, b) {
	  a = a.toLowerCase()
	  b = b.toLowerCase()
	  return alphasort(a, b)
	}

	function alphasort (a, b) {
	  return a > b ? 1 : a < b ? -1 : 0
	}

	Glob.prototype.abort = function () {
	  this.aborted = true
	  this.emit("abort")
	}

	Glob.prototype.pause = function () {
	  if (this.paused) return
	  if (this.sync)
	    this.emit("error", new Error("Can't pause/resume sync glob"))
	  this.paused = true
	  this.emit("pause")
	}

	Glob.prototype.resume = function () {
	  if (!this.paused) return
	  if (this.sync)
	    this.emit("error", new Error("Can't pause/resume sync glob"))
	  this.paused = false
	  this.emit("resume")
	  this._processEmitQueue()
	  //process.nextTick(this.emit.bind(this, "resume"))
	}

	Glob.prototype.emitMatch = function (m) {
	  this._emitQueue.push(m)
	  this._processEmitQueue()
	}

	Glob.prototype._processEmitQueue = function (m) {
	  while (!this._processingEmitQueue &&
	         !this.paused) {
	    this._processingEmitQueue = true
	    var m = this._emitQueue.shift()
	    if (!m) {
	      this._processingEmitQueue = false
	      break
	    }

	    this.log('emit!', m === this.EOF ? "end" : "match")

	    this.emit(m === this.EOF ? "end" : "match", m)
	    this._processingEmitQueue = false
	  }
	}

	Glob.prototype._process = function (pattern, depth, index, cb_) {
	  assert(this instanceof Glob)

	  var cb = function cb (er, res) {
	    assert(this instanceof Glob)
	    if (this.paused) {
	      if (!this._processQueue) {
	        this._processQueue = []
	        this.once("resume", function () {
	          var q = this._processQueue
	          this._processQueue = null
	          q.forEach(function (cb) { cb() })
	        })
	      }
	      this._processQueue.push(cb_.bind(this, er, res))
	    } else {
	      cb_.call(this, er, res)
	    }
	  }.bind(this)

	  if (this.aborted) return cb()

	  if (depth > this.maxDepth) return cb()

	  // Get the first [n] parts of pattern that are all strings.
	  var n = 0
	  while (typeof pattern[n] === "string") {
	    n ++
	  }
	  // now n is the index of the first one that is *not* a string.

	  // see if there's anything else
	  var prefix
	  switch (n) {
	    // if not, then this is rather simple
	    case pattern.length:
	      prefix = pattern.join("/")
	      this._stat(prefix, function (exists, isDir) {
	        // either it's there, or it isn't.
	        // nothing more to do, either way.
	        if (exists) {
	          if (prefix && isAbsolute(prefix) && !this.nomount) {
		    if (prefix.charAt(0) === "/") {
	              prefix = path.join(this.root, prefix)
		    } else {
		      prefix = path.resolve(this.root, prefix)
		    }
	          }

	          if (process.platform === "win32")
	            prefix = prefix.replace(/\\/g, "/")

	          this.matches[index] = this.matches[index] || {}
	          this.matches[index][prefix] = true
	          this.emitMatch(prefix)
	        }
	        return cb()
	      })
	      return

	    case 0:
	      // pattern *starts* with some non-trivial item.
	      // going to readdir(cwd), but not include the prefix in matches.
	      prefix = null
	      break

	    default:
	      // pattern has some string bits in the front.
	      // whatever it starts with, whether that's "absolute" like /foo/bar,
	      // or "relative" like "../baz"
	      prefix = pattern.slice(0, n)
	      prefix = prefix.join("/")
	      break
	  }

	  // get the list of entries.
	  var read
	  if (prefix === null) read = "."
	  else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
	    if (!prefix || !isAbsolute(prefix)) {
	      prefix = path.join("/", prefix)
	    }
	    read = prefix = path.resolve(prefix)

	    // if (process.platform === "win32")
	    //   read = prefix = prefix.replace(/^[a-zA-Z]:|\\/g, "/")

	    this.log('absolute: ', prefix, this.root, pattern, read)
	  } else {
	    read = prefix
	  }

	  this.log('readdir(%j)', read, this.cwd, this.root)

	  return this._readdir(read, function (er, entries) {
	    if (er) {
	      // not a directory!
	      // this means that, whatever else comes after this, it can never match
	      return cb()
	    }

	    // globstar is special
	    if (pattern[n] === minimatch.GLOBSTAR) {
	      // test without the globstar, and with every child both below
	      // and replacing the globstar.
	      var s = [ pattern.slice(0, n).concat(pattern.slice(n + 1)) ]
	      entries.forEach(function (e) {
	        if (e.charAt(0) === "." && !this.dot) return
	        // instead of the globstar
	        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1)))
	        // below the globstar
	        s.push(pattern.slice(0, n).concat(e).concat(pattern.slice(n)))
	      }, this)

	      // now asyncForEach over this
	      var l = s.length
	      , errState = null
	      s.forEach(function (gsPattern) {
	        this._process(gsPattern, depth + 1, index, function (er) {
	          if (errState) return
	          if (er) return cb(errState = er)
	          if (--l <= 0) return cb()
	        })
	      }, this)

	      return
	    }

	    // not a globstar
	    // It will only match dot entries if it starts with a dot, or if
	    // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
	    var pn = pattern[n]
	    if (typeof pn === "string") {
	      var found = entries.indexOf(pn) !== -1
	      entries = found ? entries[pn] : []
	    } else {
	      var rawGlob = pattern[n]._glob
	      , dotOk = this.dot || rawGlob.charAt(0) === "."

	      entries = entries.filter(function (e) {
	        return (e.charAt(0) !== "." || dotOk) &&
	               (typeof pattern[n] === "string" && e === pattern[n] ||
	                e.match(pattern[n]))
	      })
	    }

	    // If n === pattern.length - 1, then there's no need for the extra stat
	    // *unless* the user has specified "mark" or "stat" explicitly.
	    // We know that they exist, since the readdir returned them.
	    if (n === pattern.length - 1 &&
	        !this.mark &&
	        !this.stat) {
	      entries.forEach(function (e) {
	        if (prefix) {
	          if (prefix !== "/") e = prefix + "/" + e
	          else e = prefix + e
	        }
	        if (e.charAt(0) === "/" && !this.nomount) {
	          e = path.join(this.root, e)
	        }

	        if (process.platform === "win32")
	          e = e.replace(/\\/g, "/")

	        this.matches[index] = this.matches[index] || {}
	        this.matches[index][e] = true
	        this.emitMatch(e)
	      }, this)
	      return cb.call(this)
	    }


	    // now test all the remaining entries as stand-ins for that part
	    // of the pattern.
	    var l = entries.length
	    , errState = null
	    if (l === 0) return cb() // no matches possible
	    entries.forEach(function (e) {
	      var p = pattern.slice(0, n).concat(e).concat(pattern.slice(n + 1))
	      this._process(p, depth + 1, index, function (er) {
	        if (errState) return
	        if (er) return cb(errState = er)
	        if (--l === 0) return cb.call(this)
	      })
	    }, this)
	  })

	}

	Glob.prototype._stat = function (f, cb) {
	  assert(this instanceof Glob)
	  var abs = f
	  if (f.charAt(0) === "/") {
	    abs = path.join(this.root, f)
	  } else if (this.changedCwd) {
	    abs = path.resolve(this.cwd, f)
	  }
	  this.log('stat', [this.cwd, f, '=', abs])
	  if (f.length > this.maxLength) {
	    var er = new Error("Path name too long")
	    er.code = "ENAMETOOLONG"
	    er.path = f
	    return this._afterStat(f, abs, cb, er)
	  }

	  if (this.statCache.hasOwnProperty(f)) {
	    var exists = this.statCache[f]
	    , isDir = exists && (Array.isArray(exists) || exists === 2)
	    if (this.sync) return cb.call(this, !!exists, isDir)
	    return process.nextTick(cb.bind(this, !!exists, isDir))
	  }

	  if (this.sync) {
	    var er, stat
	    try {
	      stat = fs.statSync(abs)
	    } catch (e) {
	      er = e
	    }
	    this._afterStat(f, abs, cb, er, stat)
	  } else {
	    fs.stat(abs, this._afterStat.bind(this, f, abs, cb))
	  }
	}

	Glob.prototype._afterStat = function (f, abs, cb, er, stat) {
	  var exists
	  assert(this instanceof Glob)

	  if (abs.slice(-1) === "/" && stat && !stat.isDirectory()) {
	    this.log("should be ENOTDIR, fake it")

	    er = new Error("ENOTDIR, not a directory '" + abs + "'")
	    er.path = abs
	    er.code = "ENOTDIR"
	    stat = null
	  }

	  if (er || !stat) {
	    exists = false
	  } else {
	    exists = stat.isDirectory() ? 2 : 1
	  }
	  this.statCache[f] = this.statCache[f] || exists
	  cb.call(this, !!exists, exists === 2)
	}

	Glob.prototype._readdir = function (f, cb) {
	  assert(this instanceof Glob)
	  var abs = f
	  if (f.charAt(0) === "/") {
	    abs = path.join(this.root, f)
	  } else if (isAbsolute(f)) {
	    abs = f
	  } else if (this.changedCwd) {
	    abs = path.resolve(this.cwd, f)
	  }

	  this.log('readdir', [this.cwd, f, abs])
	  if (f.length > this.maxLength) {
	    var er = new Error("Path name too long")
	    er.code = "ENAMETOOLONG"
	    er.path = f
	    return this._afterReaddir(f, abs, cb, er)
	  }

	  if (this.statCache.hasOwnProperty(f)) {
	    var c = this.statCache[f]
	    if (Array.isArray(c)) {
	      if (this.sync) return cb.call(this, null, c)
	      return process.nextTick(cb.bind(this, null, c))
	    }

	    if (!c || c === 1) {
	      // either ENOENT or ENOTDIR
	      var code = c ? "ENOTDIR" : "ENOENT"
	      , er = new Error((c ? "Not a directory" : "Not found") + ": " + f)
	      er.path = f
	      er.code = code
	      this.log(f, er)
	      if (this.sync) return cb.call(this, er)
	      return process.nextTick(cb.bind(this, er))
	    }

	    // at this point, c === 2, meaning it's a dir, but we haven't
	    // had to read it yet, or c === true, meaning it's *something*
	    // but we don't have any idea what.  Need to read it, either way.
	  }

	  if (this.sync) {
	    var er, entries
	    try {
	      entries = fs.readdirSync(abs)
	    } catch (e) {
	      er = e
	    }
	    return this._afterReaddir(f, abs, cb, er, entries)
	  }

	  fs.readdir(abs, this._afterReaddir.bind(this, f, abs, cb))
	}

	Glob.prototype._afterReaddir = function (f, abs, cb, er, entries) {
	  assert(this instanceof Glob)
	  if (entries && !er) {
	    this.statCache[f] = entries
	    // if we haven't asked to stat everything for suresies, then just
	    // assume that everything in there exists, so we can avoid
	    // having to stat it a second time.  This also gets us one step
	    // further into ELOOP territory.
	    if (!this.mark && !this.stat) {
	      entries.forEach(function (e) {
	        if (f === "/") e = f + e
	        else e = f + "/" + e
	        this.statCache[e] = true
	      }, this)
	    }

	    return cb.call(this, er, entries)
	  }

	  // now handle errors, and cache the information
	  if (er) switch (er.code) {
	    case "ENOTDIR": // totally normal. means it *does* exist.
	      this.statCache[f] = 1
	      return cb.call(this, er)
	    case "ENOENT": // not terribly unusual
	    case "ELOOP":
	    case "ENAMETOOLONG":
	    case "UNKNOWN":
	      this.statCache[f] = false
	      return cb.call(this, er)
	    default: // some unusual error.  Treat as failure.
	      this.statCache[f] = false
	      if (this.strict) this.emit("error", er)
	      if (!this.silent) console.error("glob error", er)
	      return cb.call(this, er)
	  }
	}

	var isAbsolute = process.platform === "win32" ? absWin : absUnix

	function absWin (p) {
	  if (absUnix(p)) return true
	  // pull off the device/UNC bit from a windows path.
	  // from node's lib/path.js
	  var splitDeviceRe =
	      /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/
	    , result = splitDeviceRe.exec(p)
	    , device = result[1] || ''
	    , isUnc = device && device.charAt(1) !== ':'
	    , isAbsolute = !!result[2] || isUnc // UNC paths are always absolute

	  return isAbsolute
	}

	function absUnix (p) {
	  return p.charAt(0) === "/" || p === ""
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// this keeps a queue of opened file descriptors, and will make
	// fs operations wait until some have closed before trying to open more.

	var fs = exports = module.exports = {}
	fs._originalFs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	Object.getOwnPropertyNames(fs._originalFs).forEach(function(prop) {
	  var desc = Object.getOwnPropertyDescriptor(fs._originalFs, prop)
	  Object.defineProperty(fs, prop, desc)
	})

	var queue = []
	  , constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	fs._curOpen = 0

	fs.MIN_MAX_OPEN = 64
	fs.MAX_OPEN = 1024

	// prevent EMFILE errors
	function OpenReq (path, flags, mode, cb) {
	  this.path = path
	  this.flags = flags
	  this.mode = mode
	  this.cb = cb
	}

	function noop () {}

	fs.open = gracefulOpen

	function gracefulOpen (path, flags, mode, cb) {
	  if (typeof mode === "function") cb = mode, mode = null
	  if (typeof cb !== "function") cb = noop

	  if (fs._curOpen >= fs.MAX_OPEN) {
	    queue.push(new OpenReq(path, flags, mode, cb))
	    setTimeout(flush)
	    return
	  }
	  open(path, flags, mode, function (er, fd) {
	    if (er && er.code === "EMFILE" && fs._curOpen > fs.MIN_MAX_OPEN) {
	      // that was too many.  reduce max, get back in queue.
	      // this should only happen once in a great while, and only
	      // if the ulimit -n is set lower than 1024.
	      fs.MAX_OPEN = fs._curOpen - 1
	      return fs.open(path, flags, mode, cb)
	    }
	    cb(er, fd)
	  })
	}

	function open (path, flags, mode, cb) {
	  cb = cb || noop
	  fs._curOpen ++
	  fs._originalFs.open.call(fs, path, flags, mode, function (er, fd) {
	    if (er) onclose()
	    cb(er, fd)
	  })
	}

	fs.openSync = function (path, flags, mode) {
	  var ret
	  ret = fs._originalFs.openSync.call(fs, path, flags, mode)
	  fs._curOpen ++
	  return ret
	}

	function onclose () {
	  fs._curOpen --
	  flush()
	}

	function flush () {
	  while (fs._curOpen < fs.MAX_OPEN) {
	    var req = queue.shift()
	    if (!req) return
	    switch (req.constructor.name) {
	      case 'OpenReq':
	        open(req.path, req.flags || "r", req.mode || 0777, req.cb)
	        break
	      case 'ReaddirReq':
	        readdir(req.path, req.cb)
	        break
	      case 'ReadFileReq':
	        readFile(req.path, req.options, req.cb)
	        break
	      case 'WriteFileReq':
	        writeFile(req.path, req.data, req.options, req.cb)
	        break
	      default:
	        throw new Error('Unknown req type: ' + req.constructor.name)
	    }
	  }
	}

	fs.close = function (fd, cb) {
	  cb = cb || noop
	  fs._originalFs.close.call(fs, fd, function (er) {
	    onclose()
	    cb(er)
	  })
	}

	fs.closeSync = function (fd) {
	  try {
	    return fs._originalFs.closeSync.call(fs, fd)
	  } finally {
	    onclose()
	  }
	}


	// readdir takes a fd as well.
	// however, the sync version closes it right away, so
	// there's no need to wrap.
	// It would be nice to catch when it throws an EMFILE,
	// but that's relatively rare anyway.

	fs.readdir = gracefulReaddir

	function gracefulReaddir (path, cb) {
	  if (fs._curOpen >= fs.MAX_OPEN) {
	    queue.push(new ReaddirReq(path, cb))
	    setTimeout(flush)
	    return
	  }

	  readdir(path, function (er, files) {
	    if (er && er.code === "EMFILE" && fs._curOpen > fs.MIN_MAX_OPEN) {
	      fs.MAX_OPEN = fs._curOpen - 1
	      return fs.readdir(path, cb)
	    }
	    cb(er, files)
	  })
	}

	function readdir (path, cb) {
	  cb = cb || noop
	  fs._curOpen ++
	  fs._originalFs.readdir.call(fs, path, function (er, files) {
	    onclose()
	    cb(er, files)
	  })
	}

	function ReaddirReq (path, cb) {
	  this.path = path
	  this.cb = cb
	}


	fs.readFile = gracefulReadFile

	function gracefulReadFile(path, options, cb) {
	  if (typeof options === "function") cb = options, options = null
	  if (typeof cb !== "function") cb = noop

	  if (fs._curOpen >= fs.MAX_OPEN) {
	    queue.push(new ReadFileReq(path, options, cb))
	    setTimeout(flush)
	    return
	  }

	  readFile(path, options, function (er, data) {
	    if (er && er.code === "EMFILE" && fs._curOpen > fs.MIN_MAX_OPEN) {
	      fs.MAX_OPEN = fs._curOpen - 1
	      return fs.readFile(path, options, cb)
	    }
	    cb(er, data)
	  })
	}

	function readFile (path, options, cb) {
	  cb = cb || noop
	  fs._curOpen ++
	  fs._originalFs.readFile.call(fs, path, options, function (er, data) {
	    onclose()
	    cb(er, data)
	  })
	}

	function ReadFileReq (path, options, cb) {
	  this.path = path
	  this.options = options
	  this.cb = cb
	}




	fs.writeFile = gracefulWriteFile

	function gracefulWriteFile(path, data, options, cb) {
	  if (typeof options === "function") cb = options, options = null
	  if (typeof cb !== "function") cb = noop

	  if (fs._curOpen >= fs.MAX_OPEN) {
	    queue.push(new WriteFileReq(path, data, options, cb))
	    setTimeout(flush)
	    return
	  }

	  writeFile(path, data, options, function (er) {
	    if (er && er.code === "EMFILE" && fs._curOpen > fs.MIN_MAX_OPEN) {
	      fs.MAX_OPEN = fs._curOpen - 1
	      return fs.writeFile(path, data, options, cb)
	    }
	    cb(er)
	  })
	}

	function writeFile (path, data, options, cb) {
	  cb = cb || noop
	  fs._curOpen ++
	  fs._originalFs.writeFile.call(fs, path, data, options, function (er) {
	    onclose()
	    cb(er)
	  })
	}

	function WriteFileReq (path, data, options, cb) {
	  this.path = path
	  this.data = data
	  this.options = options
	  this.cb = cb
	}


	// (re-)implement some things that are known busted or missing.

	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	// lchmod, broken prior to 0.6.2
	// back-port the fix here.
	if (constants.hasOwnProperty('O_SYMLINK') &&
	    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var err, err2
	    try {
	      var ret = fs.fchmodSync(fd, mode)
	    } catch (er) {
	      err = er
	    }
	    try {
	      fs.closeSync(fd)
	    } catch (er) {
	      err2 = er
	    }
	    if (err || err2) throw (err || err2)
	    return ret
	  }
	}


	// lutimes implementation, or no-op
	if (!fs.lutimes) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	        , err
	        , err2
	        , ret

	      try {
	        var ret = fs.futimesSync(fd, at, mt)
	      } catch (er) {
	        err = er
	      }
	      try {
	        fs.closeSync(fd)
	      } catch (er) {
	        err2 = er
	      }
	      if (err || err2) throw (err || err2)
	      return ret
	    }

	  } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
	    // maybe utimensat will be bound soonish?
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
	    }

	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}


	// https://github.com/isaacs/node-graceful-fs/issues/4
	// Chown should not fail on einval or eperm if non-root.

	fs.chown = chownFix(fs.chown)
	fs.fchown = chownFix(fs.fchown)
	fs.lchown = chownFix(fs.lchown)

	fs.chownSync = chownFixSync(fs.chownSync)
	fs.fchownSync = chownFixSync(fs.fchownSync)
	fs.lchownSync = chownFixSync(fs.lchownSync)

	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}

	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}

	function chownErOk (er) {
	  // if there's no getuid, or if getuid() is something other than 0,
	  // and the error is EINVAL or EPERM, then just ignore it.
	  // This specific case is a silent failure in cp, install, tar,
	  // and most other unix tools that manage permissions.
	  // When running as root, or if other types of errors are encountered,
	  // then it's strict.
	  if (!er || (!process.getuid || process.getuid() !== 0)
	      && (er.code === "EINVAL" || er.code === "EPERM")) return true
	}


	// if lchmod/lchown do not exist, then make them no-ops
	if (!fs.lchmod) {
	  fs.lchmod = function (path, mode, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchmodSync = function () {}
	}
	if (!fs.lchown) {
	  fs.lchown = function (path, uid, gid, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchownSync = function () {}
	}



	// on Windows, A/V software can lock the directory, causing this
	// to fail with an EACCES or EPERM if the directory contains newly
	// created files.  Try again on failure, for up to 1 second.
	if (process.platform === "win32") {
	  var rename_ = fs.rename
	  fs.rename = function rename (from, to, cb) {
	    var start = Date.now()
	    rename_(from, to, function CB (er) {
	      if (er
	          && (er.code === "EACCES" || er.code === "EPERM")
	          && Date.now() - start < 1000) {
	        return rename_(from, to, CB)
	      }
	      cb(er)
	    })
	  }
	}


	// if read() returns EAGAIN, then just try it again.
	var read = fs.read
	fs.read = function (fd, buffer, offset, length, position, callback_) {
	  var callback
	  if (callback_ && typeof callback_ === 'function') {
	    var eagCounter = 0
	    callback = function (er, _, __) {
	      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        return read.call(fs, fd, buffer, offset, length, position, callback)
	      }
	      callback_.apply(this, arguments)
	    }
	  }
	  return read.call(fs, fd, buffer, offset, length, position, callback)
	}

	var readSync = fs.readSync
	fs.readSync = function (fd, buffer, offset, length, position) {
	  var eagCounter = 0
	  while (true) {
	    try {
	      return readSync.call(fs, fd, buffer, offset, length, position)
	    } catch (er) {
	      if (er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        continue
	      }
	      throw er
	    }
	  }
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 198 */
/***/ function(module, exports) {

	module.exports = inherits

	function inherits (c, p, proto) {
	  proto = proto || {}
	  var e = {}
	  ;[c.prototype, proto].forEach(function (s) {
	    Object.getOwnPropertyNames(s).forEach(function (k) {
	      e[k] = Object.getOwnPropertyDescriptor(s, k)
	    })
	  })
	  c.prototype = Object.create(p.prototype, e)
	  c.super = p
	}

	//function Child () {
	//  Child.super.call(this)
	//  console.error([this
	//                ,this.constructor
	//                ,this.constructor === Child
	//                ,this.constructor.super === Parent
	//                ,Object.getPrototypeOf(this) === Child.prototype
	//                ,Object.getPrototypeOf(Object.getPrototypeOf(this))
	//                 === Parent.prototype
	//                ,this instanceof Child
	//                ,this instanceof Parent])
	//}
	//function Parent () {}
	//inherits(Child, Parent)
	//new Child


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global, setImmediate) {/**
	 * @license
	 * Lo-Dash 1.0.2 (Custom Build) <http://lodash.com/>
	 * Build: `lodash -o ./dist/lodash.compat.js`
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.4.4 <http://underscorejs.org/>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
	 * Available under MIT license <http://lodash.com/license>
	 */
	;(function(window, undefined) {

	  /** Detect free variable `exports` */
	  var freeExports = typeof exports == 'object' && exports;

	  /** Detect free variable `module` */
	  var freeModule = typeof module == 'object' && module && module.exports == freeExports && module;

	  /** Detect free variable `global` and use it as `window` */
	  var freeGlobal = typeof global == 'object' && global;
	  if (freeGlobal.global === freeGlobal) {
	    window = freeGlobal;
	  }

	  /** Used for array and object method references */
	  var arrayRef = [],
	      objectRef = {};

	  /** Used to generate unique IDs */
	  var idCounter = 0;

	  /** Used internally to indicate various things */
	  var indicatorObject = objectRef;

	  /** Used by `cachedContains` as the default size when optimizations are enabled for large arrays */
	  var largeArraySize = 30;

	  /** Used to restore the original `_` reference in `noConflict` */
	  var oldDash = window._;

	  /** Used to match HTML entities */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g;

	  /** Used to match empty string literals in compiled template source */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match regexp flags from their coerced string values */
	  var reFlags = /\w*$/;

	  /** Used to detect if a method is native */
	  var reNative = RegExp('^' +
	    (objectRef.valueOf + '')
	      .replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
	      .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
	  );

	  /**
	   * Used to match ES6 template delimiters
	   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match "interpolate" template delimiters */
	  var reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to ensure capturing order of template delimiters */
	  var reNoMatch = /($^)/;

	  /** Used to match HTML characters */
	  var reUnescapedHtml = /[&<>"']/g;

	  /** Used to match unescaped characters in compiled string literals */
	  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

	  /** Used to fix the JScript [[DontEnum]] bug */
	  var shadowed = [
	    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
	    'toLocaleString', 'toString', 'valueOf'
	  ];

	  /** Used to make template sourceURLs easier to identify */
	  var templateCounter = 0;

	  /** Native method shortcuts */
	  var ceil = Math.ceil,
	      concat = arrayRef.concat,
	      floor = Math.floor,
	      getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
	      hasOwnProperty = objectRef.hasOwnProperty,
	      push = arrayRef.push,
	      toString = objectRef.toString;

	  /* Native method shortcuts for methods with the same name as other `lodash` methods */
	  var nativeBind = reNative.test(nativeBind = slice.bind) && nativeBind,
	      nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
	      nativeIsFinite = window.isFinite,
	      nativeIsNaN = window.isNaN,
	      nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
	      nativeMax = Math.max,
	      nativeMin = Math.min,
	      nativeRandom = Math.random;

	  /** `Object#toString` result shortcuts */
	  var argsClass = '[object Arguments]',
	      arrayClass = '[object Array]',
	      boolClass = '[object Boolean]',
	      dateClass = '[object Date]',
	      funcClass = '[object Function]',
	      numberClass = '[object Number]',
	      objectClass = '[object Object]',
	      regexpClass = '[object RegExp]',
	      stringClass = '[object String]';

	  /** Detect various environments */
	  var isIeOpera = !!window.attachEvent,
	      isV8 = nativeBind && !/\n|true/.test(nativeBind + isIeOpera);

	  /* Detect if `Function#bind` exists and is inferred to be fast (all but V8) */
	  var isBindFast = nativeBind && !isV8;

	  /* Detect if `Object.keys` exists and is inferred to be fast (IE, Opera, V8) */
	  var isKeysFast = nativeKeys && (isIeOpera || isV8);

	  /**
	   * Detect the JScript [[DontEnum]] bug:
	   *
	   * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
	   * made non-enumerable as well.
	   */
	  var hasDontEnumBug;

	  /**
	   * Detect if a `prototype` properties are enumerable by default:
	   *
	   * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
	   * (if the prototype or a property on the prototype has been set)
	   * incorrectly sets a function's `prototype` property [[Enumerable]]
	   * value to `true`.
	   */
	  var hasEnumPrototype;

	  /** Detect if own properties are iterated after inherited properties (IE < 9) */
	  var iteratesOwnLast;

	  /**
	   * Detect if `Array#shift` and `Array#splice` augment array-like objects
	   * incorrectly:
	   *
	   * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
	   * and `splice()` functions that fail to remove the last element, `value[0]`,
	   * of array-like objects even though the `length` property is set to `0`.
	   * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
	   * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
	   */
	  var hasObjectSpliceBug = (hasObjectSpliceBug = { '0': 1, 'length': 1 },
	    arrayRef.splice.call(hasObjectSpliceBug, 0, 1), hasObjectSpliceBug[0]);

	  /** Detect if `arguments` object indexes are non-enumerable (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1) */
	  var nonEnumArgs = true;

	  (function() {
	    var props = [];
	    function ctor() { this.x = 1; }
	    ctor.prototype = { 'valueOf': 1, 'y': 1 };
	    for (var prop in new ctor) { props.push(prop); }
	    for (prop in arguments) { nonEnumArgs = !prop; }

	    hasDontEnumBug = !/valueOf/.test(props);
	    hasEnumPrototype = ctor.propertyIsEnumerable('prototype');
	    iteratesOwnLast = props[0] != 'x';
	  }(1));

	  /** Detect if `arguments` objects are `Object` objects (all but Opera < 10.5) */
	  var argsAreObjects = arguments.constructor == Object;

	  /** Detect if `arguments` objects [[Class]] is unresolvable (Firefox < 4, IE < 9) */
	  var noArgsClass = !isArguments(arguments);

	  /**
	   * Detect lack of support for accessing string characters by index:
	   *
	   * IE < 8 can't access characters by index and IE 8 can only access
	   * characters by index on string literals.
	   */
	  var noCharByIndex = ('x'[0] + Object('x')[0]) != 'xx';

	  /**
	   * Detect if a DOM node's [[Class]] is unresolvable (IE < 9)
	   * and that the JS engine won't error when attempting to coerce an object to
	   * a string without a `toString` function.
	   */
	  try {
	    var noNodeClass = toString.call(document) == objectClass && !({ 'toString': 0 } + '');
	  } catch(e) { }

	  /** Used to identify object classifications that `_.clone` supports */
	  var cloneableClasses = {};
	  cloneableClasses[funcClass] = false;
	  cloneableClasses[argsClass] = cloneableClasses[arrayClass] =
	  cloneableClasses[boolClass] = cloneableClasses[dateClass] =
	  cloneableClasses[numberClass] = cloneableClasses[objectClass] =
	  cloneableClasses[regexpClass] = cloneableClasses[stringClass] = true;

	  /** Used to lookup a built-in constructor by [[Class]] */
	  var ctorByClass = {};
	  ctorByClass[arrayClass] = Array;
	  ctorByClass[boolClass] = Boolean;
	  ctorByClass[dateClass] = Date;
	  ctorByClass[objectClass] = Object;
	  ctorByClass[numberClass] = Number;
	  ctorByClass[regexpClass] = RegExp;
	  ctorByClass[stringClass] = String;

	  /** Used to determine if values are of the language type Object */
	  var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	  };

	  /** Used to escape characters for inclusion in compiled string literals */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\t': 't',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates a `lodash` object, that wraps the given `value`, to enable method
	   * chaining.
	   *
	   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
	   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
	   * and `unshift`
	   *
	   * The chainable wrapper functions are:
	   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`, `compose`,
	   * `concat`, `countBy`, `debounce`, `defaults`, `defer`, `delay`, `difference`,
	   * `filter`, `flatten`, `forEach`, `forIn`, `forOwn`, `functions`, `groupBy`,
	   * `initial`, `intersection`, `invert`, `invoke`, `keys`, `map`, `max`, `memoize`,
	   * `merge`, `min`, `object`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
	   * `pick`, `pluck`, `push`, `range`, `reject`, `rest`, `reverse`, `shuffle`,
	   * `slice`, `sort`, `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`,
	   * `union`, `uniq`, `unshift`, `values`, `where`, `without`, `wrap`, and `zip`
	   *
	   * The non-chainable wrapper functions are:
	   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `has`, `identity`,
	   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`, `isEmpty`,
	   * `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`, `isObject`,
	   * `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`, `lastIndexOf`,
	   * `mixin`, `noConflict`, `pop`, `random`, `reduce`, `reduceRight`, `result`,
	   * `shift`, `size`, `some`, `sortedIndex`, `template`, `unescape`, and `uniqueId`
	   *
	   * The wrapper functions `first` and `last` return wrapped values when `n` is
	   * passed, otherwise they return unwrapped values.
	   *
	   * @name _
	   * @constructor
	   * @category Chaining
	   * @param {Mixed} value The value to wrap in a `lodash` instance.
	   * @returns {Object} Returns a `lodash` instance.
	   */
	  function lodash(value) {
	    // exit early if already wrapped, even if wrapped by a different `lodash` constructor
	    if (value && typeof value == 'object' && value.__wrapped__) {
	      return value;
	    }
	    // allow invoking `lodash` without the `new` operator
	    if (!(this instanceof lodash)) {
	      return new lodash(value);
	    }
	    this.__wrapped__ = value;
	  }

	  /**
	   * By default, the template delimiters used by Lo-Dash are similar to those in
	   * embedded Ruby (ERB). Change the following template settings to use alternative
	   * delimiters.
	   *
	   * @static
	   * @memberOf _
	   * @type Object
	   */
	  lodash.templateSettings = {

	    /**
	     * Used to detect `data` property values to be HTML-escaped.
	     *
	     * @memberOf _.templateSettings
	     * @type RegExp
	     */
	    'escape': /<%-([\s\S]+?)%>/g,

	    /**
	     * Used to detect code to be evaluated.
	     *
	     * @memberOf _.templateSettings
	     * @type RegExp
	     */
	    'evaluate': /<%([\s\S]+?)%>/g,

	    /**
	     * Used to detect `data` property values to inject.
	     *
	     * @memberOf _.templateSettings
	     * @type RegExp
	     */
	    'interpolate': reInterpolate,

	    /**
	     * Used to reference the data object in the template text.
	     *
	     * @memberOf _.templateSettings
	     * @type String
	     */
	    'variable': '',

	    /**
	     * Used to import variables into the compiled template.
	     *
	     * @memberOf _.templateSettings
	     * @type Object
	     */
	    'imports': {

	      /**
	       * A reference to the `lodash` function.
	       *
	       * @memberOf _.templateSettings.imports
	       * @type Function
	       */
	      '_': lodash
	    }
	  };

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The template used to create iterator functions.
	   *
	   * @private
	   * @param {Obect} data The data object used to populate the text.
	   * @returns {String} Returns the interpolated text.
	   */
	  var iteratorTemplate = function(obj) {
	    
	    var __p = 'var index, iterable = ' +
	    (obj.firstArg ) +
	    ', result = iterable;\nif (!iterable) return result;\n' +
	    (obj.top ) +
	    ';\n';
	     if (obj.arrays) {
	    __p += 'var length = iterable.length; index = -1;\nif (' +
	    (obj.arrays ) +
	    ') {  ';
	     if (obj.noCharByIndex) {
	    __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
	     } ;
	    __p += '\n  while (++index < length) {\n    ' +
	    (obj.loop ) +
	    '\n  }\n}\nelse {  ';
	      } else if (obj.nonEnumArgs) {
	    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' +
	    (obj.loop ) +
	    '\n    }\n  } else {  ';
	     } ;
	    
	     if (obj.hasEnumPrototype) {
	    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
	     } ;
	    
	     if (obj.isKeysFast && obj.useHas) {
	    __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] ? nativeKeys(iterable) : [],\n      length = ownProps.length;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n    ';
	     if (obj.hasEnumPrototype) {
	    __p += 'if (!(skipProto && index == \'prototype\')) {\n  ';
	     } ;
	    __p += 
	    (obj.loop ) +
	    '';
	     if (obj.hasEnumPrototype) {
	    __p += '}\n';
	     } ;
	    __p += '  }  ';
	     } else {
	    __p += '\n  for (index in iterable) {';
	        if (obj.hasEnumPrototype || obj.useHas) {
	    __p += '\n    if (';
	          if (obj.hasEnumPrototype) {
	    __p += '!(skipProto && index == \'prototype\')';
	     }      if (obj.hasEnumPrototype && obj.useHas) {
	    __p += ' && ';
	     }      if (obj.useHas) {
	    __p += 'hasOwnProperty.call(iterable, index)';
	     }    ;
	    __p += ') {    ';
	     } ;
	    __p += 
	    (obj.loop ) +
	    ';    ';
	     if (obj.hasEnumPrototype || obj.useHas) {
	    __p += '\n    }';
	     } ;
	    __p += '\n  }  ';
	     } ;
	    
	     if (obj.hasDontEnumBug) {
	    __p += '\n\n  var ctor = iterable.constructor;\n    ';
	     for (var k = 0; k < 7; k++) {
	    __p += '\n  index = \'' +
	    (obj.shadowed[k] ) +
	    '\';\n  if (';
	          if (obj.shadowed[k] == 'constructor') {
	    __p += '!(ctor && ctor.prototype === iterable) && ';
	          } ;
	    __p += 'hasOwnProperty.call(iterable, index)) {\n    ' +
	    (obj.loop ) +
	    '\n  }    ';
	     } ;
	    
	     } ;
	    
	     if (obj.arrays || obj.nonEnumArgs) {
	    __p += '\n}';
	     } ;
	    __p += 
	    (obj.bottom ) +
	    ';\nreturn result';
	    
	    
	    return __p
	  };

	  /** Reusable iterator options for `assign` and `defaults` */
	  var defaultsIteratorOptions = {
	    'args': 'object, source, guard',
	    'top':
	      'var args = arguments,\n' +
	      '    argsIndex = 0,\n' +
	      "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" +
	      'while (++argsIndex < argsLength) {\n' +
	      '  iterable = args[argsIndex];\n' +
	      '  if (iterable && objectTypes[typeof iterable]) {',
	    'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
	    'bottom': '  }\n}'
	  };

	  /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
	  var eachIteratorOptions = {
	    'args': 'collection, callback, thisArg',
	    'top': "callback = callback && typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg)",
	    'arrays': "typeof length == 'number'",
	    'loop': 'if (callback(iterable[index], index, collection) === false) return result'
	  };

	  /** Reusable iterator options for `forIn` and `forOwn` */
	  var forOwnIteratorOptions = {
	    'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
	    'arrays': false
	  };

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates a function optimized to search large arrays for a given `value`,
	   * starting at `fromIndex`, using strict equality for comparisons, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to search.
	   * @param {Mixed} value The value to search for.
	   * @param {Number} [fromIndex=0] The index to search from.
	   * @param {Number} [largeSize=30] The length at which an array is considered large.
	   * @returns {Boolean} Returns `true`, if `value` is found, else `false`.
	   */
	  function cachedContains(array, fromIndex, largeSize) {
	    fromIndex || (fromIndex = 0);

	    var length = array.length,
	        isLarge = (length - fromIndex) >= (largeSize || largeArraySize);

	    if (isLarge) {
	      var cache = {},
	          index = fromIndex - 1;

	      while (++index < length) {
	        // manually coerce `value` to a string because `hasOwnProperty`, in some
	        // older versions of Firefox, coerces objects incorrectly
	        var key = array[index] + '';
	        (hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = [])).push(array[index]);
	      }
	    }
	    return function(value) {
	      if (isLarge) {
	        var key = value + '';
	        return hasOwnProperty.call(cache, key) && indexOf(cache[key], value) > -1;
	      }
	      return indexOf(array, value, fromIndex) > -1;
	    }
	  }

	  /**
	   * Used by `_.max` and `_.min` as the default `callback` when a given
	   * `collection` is a string value.
	   *
	   * @private
	   * @param {String} value The character to inspect.
	   * @returns {Number} Returns the code unit of given character.
	   */
	  function charAtCallback(value) {
	    return value.charCodeAt(0);
	  }

	  /**
	   * Used by `sortBy` to compare transformed `collection` values, stable sorting
	   * them in ascending order.
	   *
	   * @private
	   * @param {Object} a The object to compare to `b`.
	   * @param {Object} b The object to compare to `a`.
	   * @returns {Number} Returns the sort order indicator of `1` or `-1`.
	   */
	  function compareAscending(a, b) {
	    var ai = a.index,
	        bi = b.index;

	    a = a.criteria;
	    b = b.criteria;

	    // ensure a stable sort in V8 and other engines
	    // http://code.google.com/p/v8/issues/detail?id=90
	    if (a !== b) {
	      if (a > b || typeof a == 'undefined') {
	        return 1;
	      }
	      if (a < b || typeof b == 'undefined') {
	        return -1;
	      }
	    }
	    return ai < bi ? -1 : 1;
	  }

	  /**
	   * Creates a function that, when called, invokes `func` with the `this` binding
	   * of `thisArg` and prepends any `partialArgs` to the arguments passed to the
	   * bound function.
	   *
	   * @private
	   * @param {Function|String} func The function to bind or the method name.
	   * @param {Mixed} [thisArg] The `this` binding of `func`.
	   * @param {Array} partialArgs An array of arguments to be partially applied.
	   * @param {Object} [rightIndicator] Used to indicate partially applying arguments from the right.
	   * @returns {Function} Returns the new bound function.
	   */
	  function createBound(func, thisArg, partialArgs, rightIndicator) {
	    var isFunc = isFunction(func),
	        isPartial = !partialArgs,
	        key = thisArg;

	    // juggle arguments
	    if (isPartial) {
	      partialArgs = thisArg;
	    }
	    if (!isFunc) {
	      thisArg = func;
	    }

	    function bound() {
	      // `Function#bind` spec
	      // http://es5.github.com/#x15.3.4.5
	      var args = arguments,
	          thisBinding = isPartial ? this : thisArg;

	      if (!isFunc) {
	        func = thisArg[key];
	      }
	      if (partialArgs.length) {
	        args = args.length
	          ? (args = slice(args), rightIndicator ? args.concat(partialArgs) : partialArgs.concat(args))
	          : partialArgs;
	      }
	      if (this instanceof bound) {
	        // ensure `new bound` is an instance of `bound` and `func`
	        noop.prototype = func.prototype;
	        thisBinding = new noop;
	        noop.prototype = null;

	        // mimic the constructor's `return` behavior
	        // http://es5.github.com/#x13.2.2
	        var result = func.apply(thisBinding, args);
	        return isObject(result) ? result : thisBinding;
	      }
	      return func.apply(thisBinding, args);
	    }
	    return bound;
	  }

	  /**
	   * Produces a callback bound to an optional `thisArg`. If `func` is a property
	   * name, the created callback will return the property value for a given element.
	   * If `func` is an object, the created callback will return `true` for elements
	   * that contain the equivalent object properties, otherwise it will return `false`.
	   *
	   * @private
	   * @param {Mixed} [func=identity] The value to convert to a callback.
	   * @param {Mixed} [thisArg] The `this` binding of the created callback.
	   * @param {Number} [argCount=3] The number of arguments the callback accepts.
	   * @returns {Function} Returns a callback function.
	   */
	  function createCallback(func, thisArg, argCount) {
	    if (func == null) {
	      return identity;
	    }
	    var type = typeof func;
	    if (type != 'function') {
	      if (type != 'object') {
	        return function(object) {
	          return object[func];
	        };
	      }
	      var props = keys(func);
	      return function(object) {
	        var length = props.length,
	            result = false;
	        while (length--) {
	          if (!(result = isEqual(object[props[length]], func[props[length]], indicatorObject))) {
	            break;
	          }
	        }
	        return result;
	      };
	    }
	    if (typeof thisArg != 'undefined') {
	      if (argCount === 1) {
	        return function(value) {
	          return func.call(thisArg, value);
	        };
	      }
	      if (argCount === 2) {
	        return function(a, b) {
	          return func.call(thisArg, a, b);
	        };
	      }
	      if (argCount === 4) {
	        return function(accumulator, value, index, object) {
	          return func.call(thisArg, accumulator, value, index, object);
	        };
	      }
	      return function(value, index, object) {
	        return func.call(thisArg, value, index, object);
	      };
	    }
	    return func;
	  }

	  /**
	   * Creates compiled iteration functions.
	   *
	   * @private
	   * @param {Object} [options1, options2, ...] The compile options object(s).
	   *  arrays - A string of code to determine if the iterable is an array or array-like.
	   *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.
	   *  args - A string of comma separated arguments the iteration function will accept.
	   *  top - A string of code to execute before the iteration branches.
	   *  loop - A string of code to execute in the object loop.
	   *  bottom - A string of code to execute after the iteration branches.
	   *
	   * @returns {Function} Returns the compiled function.
	   */
	  function createIterator() {
	    var data = {
	      // support properties
	      'hasDontEnumBug': hasDontEnumBug,
	      'hasEnumPrototype': hasEnumPrototype,
	      'isKeysFast': isKeysFast,
	      'nonEnumArgs': nonEnumArgs,
	      'noCharByIndex': noCharByIndex,
	      'shadowed': shadowed,

	      // iterator options
	      'arrays': 'isArray(iterable)',
	      'bottom': '',
	      'loop': '',
	      'top': '',
	      'useHas': true
	    };

	    // merge options into a template data object
	    for (var object, index = 0; object = arguments[index]; index++) {
	      for (var key in object) {
	        data[key] = object[key];
	      }
	    }
	    var args = data.args;
	    data.firstArg = /^[^,]+/.exec(args)[0];

	    // create the function factory
	    var factory = Function(
	        'createCallback, hasOwnProperty, isArguments, isArray, isString, ' +
	        'objectTypes, nativeKeys',
	      'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}'
	    );
	    // return the compiled function
	    return factory(
	      createCallback, hasOwnProperty, isArguments, isArray, isString,
	      objectTypes, nativeKeys
	    );
	  }

	  /**
	   * A function compiled to iterate `arguments` objects, arrays, objects, and
	   * strings consistenly across environments, executing the `callback` for each
	   * element in the `collection`. The `callback` is bound to `thisArg` and invoked
	   * with three arguments; (value, index|key, collection). Callbacks may exit
	   * iteration early by explicitly returning `false`.
	   *
	   * @private
	   * @type Function
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array|Object|String} Returns `collection`.
	   */
	  var each = createIterator(eachIteratorOptions);

	  /**
	   * Used by `template` to escape characters for inclusion in compiled
	   * string literals.
	   *
	   * @private
	   * @param {String} match The matched character to escape.
	   * @returns {String} Returns the escaped character.
	   */
	  function escapeStringChar(match) {
	    return '\\' + stringEscapes[match];
	  }

	  /**
	   * Used by `escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {String} match The matched character to escape.
	   * @returns {String} Returns the escaped character.
	   */
	  function escapeHtmlChar(match) {
	    return htmlEscapes[match];
	  }

	  /**
	   * Checks if `value` is a DOM node in IE < 9.
	   *
	   * @private
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true` if the `value` is a DOM node, else `false`.
	   */
	  function isNode(value) {
	    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
	    // methods that are `typeof` "string" and still can coerce nodes to strings
	    return typeof value.toString != 'function' && typeof (value + '') == 'string';
	  }

	  /**
	   * A no-operation function.
	   *
	   * @private
	   */
	  function noop() {
	    // no operation performed
	  }

	  /**
	   * Slices the `collection` from the `start` index up to, but not including,
	   * the `end` index.
	   *
	   * Note: This function is used, instead of `Array#slice`, to support node lists
	   * in IE < 9 and to ensure dense arrays are returned.
	   *
	   * @private
	   * @param {Array|Object|String} collection The collection to slice.
	   * @param {Number} start The start index.
	   * @param {Number} end The end index.
	   * @returns {Array} Returns the new array.
	   */
	  function slice(array, start, end) {
	    start || (start = 0);
	    if (typeof end == 'undefined') {
	      end = array ? array.length : 0;
	    }
	    var index = -1,
	        length = end - start || 0,
	        result = Array(length < 0 ? 0 : length);

	    while (++index < length) {
	      result[index] = array[start + index];
	    }
	    return result;
	  }

	  /**
	   * Used by `unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {String} match The matched character to unescape.
	   * @returns {String} Returns the unescaped character.
	   */
	  function unescapeHtmlChar(match) {
	    return htmlUnescapes[match];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Checks if `value` is an `arguments` object.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is an `arguments` object, else `false`.
	   * @example
	   *
	   * (function() { return _.isArguments(arguments); })(1, 2, 3);
	   * // => true
	   *
	   * _.isArguments([1, 2, 3]);
	   * // => false
	   */
	  function isArguments(value) {
	    return toString.call(value) == argsClass;
	  }
	  // fallback for browsers that can't detect `arguments` objects by [[Class]]
	  if (noArgsClass) {
	    isArguments = function(value) {
	      return value ? hasOwnProperty.call(value, 'callee') : false;
	    };
	  }

	  /**
	   * Iterates over `object`'s own and inherited enumerable properties, executing
	   * the `callback` for each property. The `callback` is bound to `thisArg` and
	   * invoked with three arguments; (value, key, object). Callbacks may exit iteration
	   * early by explicitly returning `false`.
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @category Objects
	   * @param {Object} object The object to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns `object`.
	   * @example
	   *
	   * function Dog(name) {
	   *   this.name = name;
	   * }
	   *
	   * Dog.prototype.bark = function() {
	   *   alert('Woof, woof!');
	   * };
	   *
	   * _.forIn(new Dog('Dagny'), function(value, key) {
	   *   alert(key);
	   * });
	   * // => alerts 'name' and 'bark' (order is not guaranteed)
	   */
	  var forIn = createIterator(eachIteratorOptions, forOwnIteratorOptions, {
	    'useHas': false
	  });

	  /**
	   * Iterates over an object's own enumerable properties, executing the `callback`
	   * for each property. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
	   * returning `false`.
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @category Objects
	   * @param {Object} object The object to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns `object`.
	   * @example
	   *
	   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
	   *   alert(key);
	   * });
	   * // => alerts '0', '1', and 'length' (order is not guaranteed)
	   */
	  var forOwn = createIterator(eachIteratorOptions, forOwnIteratorOptions);

	  /**
	   * Checks if `value` is an array.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is an array, else `false`.
	   * @example
	   *
	   * (function() { return _.isArray(arguments); })();
	   * // => false
	   *
	   * _.isArray([1, 2, 3]);
	   * // => true
	   */
	  var isArray = nativeIsArray || function(value) {
	    // `instanceof` may cause a memory leak in IE 7 if `value` is a host object
	    // http://ajaxian.com/archives/working-aroung-the-instanceof-memory-leak
	    return (argsAreObjects && value instanceof Array) || toString.call(value) == arrayClass;
	  };

	  /**
	   * Creates an array composed of the own enumerable property names of `object`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The object to inspect.
	   * @returns {Array} Returns a new array of property names.
	   * @example
	   *
	   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
	   * // => ['one', 'two', 'three'] (order is not guaranteed)
	   */
	  var keys = !nativeKeys ? shimKeys : function(object) {
	    if (!isObject(object)) {
	      return [];
	    }
	    if ((hasEnumPrototype && typeof object == 'function') ||
	        (nonEnumArgs && object.length && isArguments(object))) {
	      return shimKeys(object);
	    }
	    return nativeKeys(object);
	  };

	  /**
	   * A fallback implementation of `isPlainObject` that checks if a given `value`
	   * is an object created by the `Object` constructor, assuming objects created
	   * by the `Object` constructor have no inherited enumerable properties and that
	   * there are no `Object.prototype` extensions.
	   *
	   * @private
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
	   */
	  function shimIsPlainObject(value) {
	    // avoid non-objects and false positives for `arguments` objects
	    var result = false;
	    if (!(value && typeof value == 'object') || isArguments(value)) {
	      return result;
	    }
	    // check that the constructor is `Object` (i.e. `Object instanceof Object`)
	    var ctor = value.constructor;
	    if ((!isFunction(ctor) && (!noNodeClass || !isNode(value))) || ctor instanceof ctor) {
	      // IE < 9 iterates inherited properties before own properties. If the first
	      // iterated property is an object's own property then there are no inherited
	      // enumerable properties.
	      if (iteratesOwnLast) {
	        forIn(value, function(value, key, object) {
	          result = !hasOwnProperty.call(object, key);
	          return false;
	        });
	        return result === false;
	      }
	      // In most environments an object's own properties are iterated before
	      // its inherited properties. If the last iterated property is an object's
	      // own property then there are no inherited enumerable properties.
	      forIn(value, function(value, key) {
	        result = key;
	      });
	      return result === false || hasOwnProperty.call(value, result);
	    }
	    return result;
	  }

	  /**
	   * A fallback implementation of `Object.keys` that produces an array of the
	   * given object's own enumerable property names.
	   *
	   * @private
	   * @param {Object} object The object to inspect.
	   * @returns {Array} Returns a new array of property names.
	   */
	  function shimKeys(object) {
	    var result = [];
	    forOwn(object, function(value, key) {
	      result.push(key);
	    });
	    return result;
	  }

	  /**
	   * Used to convert characters to HTML entities:
	   *
	   * Though the `>` character is escaped for symmetry, characters like `>` and `/`
	   * don't require escaping in HTML and have no special meaning unless they're part
	   * of a tag or an unquoted attribute value.
	   * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
	   */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to convert HTML entities to characters */
	  var htmlUnescapes = invert(htmlEscapes);

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object. Subsequent sources will overwrite propery assignments of previous
	   * sources. If a `callback` function is passed, it will be executed to produce
	   * the assigned values. The `callback` is bound to `thisArg` and invoked with
	   * two arguments; (objectValue, sourceValue).
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @alias extend
	   * @category Objects
	   * @param {Object} object The destination object.
	   * @param {Object} [source1, source2, ...] The source objects.
	   * @param {Function} [callback] The function to customize assigning values.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns the destination object.
	   * @example
	   *
	   * _.assign({ 'name': 'moe' }, { 'age': 40 });
	   * // => { 'name': 'moe', 'age': 40 }
	   *
	   * var defaults = _.partialRight(_.assign, function(a, b) {
	   *   return typeof a == 'undefined' ? b : a;
	   * });
	   *
	   * var food = { 'name': 'apple' };
	   * defaults(food, { 'name': 'banana', 'type': 'fruit' });
	   * // => { 'name': 'apple', 'type': 'fruit' }
	   */
	  var assign = createIterator(defaultsIteratorOptions, {
	    'top':
	      defaultsIteratorOptions.top.replace(';',
	        ';\n' +
	        "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" +
	        '  var callback = createCallback(args[--argsLength - 1], args[argsLength--], 2);\n' +
	        "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" +
	        '  callback = args[--argsLength];\n' +
	        '}'
	      ),
	    'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
	  });

	  /**
	   * Creates a clone of `value`. If `deep` is `true`, nested objects will also
	   * be cloned, otherwise they will be assigned by reference. If a `callback`
	   * function is passed, it will be executed to produce the cloned values. If
	   * `callback` returns `undefined`, cloning will be handled by the method instead.
	   * The `callback` is bound to `thisArg` and invoked with one argument; (value).
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to clone.
	   * @param {Boolean} [deep=false] A flag to indicate a deep clone.
	   * @param {Function} [callback] The function to customize cloning values.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
	   * @param- {Array} [stackB=[]] Internally used to associate clones with source counterparts.
	   * @returns {Mixed} Returns the cloned `value`.
	   * @example
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * var shallow = _.clone(stooges);
	   * shallow[0] === stooges[0];
	   * // => true
	   *
	   * var deep = _.clone(stooges, true);
	   * deep[0] === stooges[0];
	   * // => false
	   *
	   * _.mixin({
	   *   'clone': _.partialRight(_.clone, function(value) {
	   *     return _.isElement(value) ? value.cloneNode(false) : undefined;
	   *   })
	   * });
	   *
	   * var clone = _.clone(document.body);
	   * clone.childNodes.length;
	   * // => 0
	   */
	  function clone(value, deep, callback, thisArg, stackA, stackB) {
	    var result = value;

	    // allows working with "Collections" methods without using their `callback`
	    // argument, `index|key`, for this method's `callback`
	    if (typeof deep == 'function') {
	      thisArg = callback;
	      callback = deep;
	      deep = false;
	    }
	    if (typeof callback == 'function') {
	      callback = typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg, 1);
	      result = callback(result);

	      var done = typeof result != 'undefined';
	      if (!done) {
	        result = value;
	      }
	    }
	    // inspect [[Class]]
	    var isObj = isObject(result);
	    if (isObj) {
	      var className = toString.call(result);
	      if (!cloneableClasses[className] || (noNodeClass && isNode(result))) {
	        return result;
	      }
	      var isArr = isArray(result);
	    }
	    // shallow clone
	    if (!isObj || !deep) {
	      return isObj && !done
	        ? (isArr ? slice(result) : assign({}, result))
	        : result;
	    }
	    var ctor = ctorByClass[className];
	    switch (className) {
	      case boolClass:
	      case dateClass:
	        return done ? result : new ctor(+result);

	      case numberClass:
	      case stringClass:
	        return done ? result : new ctor(result);

	      case regexpClass:
	        return done ? result : ctor(result.source, reFlags.exec(result));
	    }
	    // check for circular references and return corresponding clone
	    stackA || (stackA = []);
	    stackB || (stackB = []);

	    var length = stackA.length;
	    while (length--) {
	      if (stackA[length] == value) {
	        return stackB[length];
	      }
	    }
	    // init cloned object
	    if (!done) {
	      result = isArr ? ctor(result.length) : {};

	      // add array properties assigned by `RegExp#exec`
	      if (isArr) {
	        if (hasOwnProperty.call(value, 'index')) {
	          result.index = value.index;
	        }
	        if (hasOwnProperty.call(value, 'input')) {
	          result.input = value.input;
	        }
	      }
	    }
	    // add the source value to the stack of traversed objects
	    // and associate it with its clone
	    stackA.push(value);
	    stackB.push(result);

	    // recursively populate clone (susceptible to call stack limits)
	    (isArr ? forEach : forOwn)(done ? result : value, function(objValue, key) {
	      result[key] = clone(objValue, deep, callback, undefined, stackA, stackB);
	    });

	    return result;
	  }

	  /**
	   * Creates a deep clone of `value`. If a `callback` function is passed, it will
	   * be executed to produce the cloned values. If `callback` returns the value it
	   * was passed, cloning will be handled by the method instead. The `callback` is
	   * bound to `thisArg` and invoked with one argument; (value).
	   *
	   * Note: This function is loosely based on the structured clone algorithm. Functions
	   * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
	   * objects created by constructors other than `Object` are cloned to plain `Object` objects.
	   * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to deep clone.
	   * @param {Function} [callback] The function to customize cloning values.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the deep cloned `value`.
	   * @example
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * var deep = _.cloneDeep(stooges);
	   * deep[0] === stooges[0];
	   * // => false
	   *
	   * var view = {
	   *   'label': 'docs',
	   *   'node': element
	   * };
	   *
	   * var clone = _.cloneDeep(view, function(value) {
	   *   return _.isElement(value) ? value.cloneNode(true) : value;
	   * });
	   *
	   * clone.node == view.node;
	   * // => false
	   */
	  function cloneDeep(value, callback, thisArg) {
	    return clone(value, true, callback, thisArg);
	  }

	  /**
	   * Assigns own enumerable properties of source object(s) to the destination
	   * object for all destination properties that resolve to `undefined`. Once a
	   * property is set, additional defaults of the same property will be ignored.
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @category Objects
	   * @param {Object} object The destination object.
	   * @param {Object} [source1, source2, ...] The source objects.
	   * @param- {Object} [guard] Internally used to allow working with `_.reduce`
	   *  without using its callback's `key` and `object` arguments as sources.
	   * @returns {Object} Returns the destination object.
	   * @example
	   *
	   * var food = { 'name': 'apple' };
	   * _.defaults(food, { 'name': 'banana', 'type': 'fruit' });
	   * // => { 'name': 'apple', 'type': 'fruit' }
	   */
	  var defaults = createIterator(defaultsIteratorOptions);

	  /**
	   * Creates a sorted array of all enumerable properties, own and inherited,
	   * of `object` that have function values.
	   *
	   * @static
	   * @memberOf _
	   * @alias methods
	   * @category Objects
	   * @param {Object} object The object to inspect.
	   * @returns {Array} Returns a new array of property names that have function values.
	   * @example
	   *
	   * _.functions(_);
	   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
	   */
	  function functions(object) {
	    var result = [];
	    forIn(object, function(value, key) {
	      if (isFunction(value)) {
	        result.push(key);
	      }
	    });
	    return result.sort();
	  }

	  /**
	   * Checks if the specified object `property` exists and is a direct property,
	   * instead of an inherited property.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The object to check.
	   * @param {String} property The property to check for.
	   * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
	   * @example
	   *
	   * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
	   * // => true
	   */
	  function has(object, property) {
	    return object ? hasOwnProperty.call(object, property) : false;
	  }

	  /**
	   * Creates an object composed of the inverted keys and values of the given `object`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The object to invert.
	   * @returns {Object} Returns the created inverted object.
	   * @example
	   *
	   *  _.invert({ 'first': 'moe', 'second': 'larry' });
	   * // => { 'moe': 'first', 'larry': 'second' } (order is not guaranteed)
	   */
	  function invert(object) {
	    var index = -1,
	        props = keys(object),
	        length = props.length,
	        result = {};

	    while (++index < length) {
	      var key = props[index];
	      result[object[key]] = key;
	    }
	    return result;
	  }

	  /**
	   * Checks if `value` is a boolean value.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a boolean value, else `false`.
	   * @example
	   *
	   * _.isBoolean(null);
	   * // => false
	   */
	  function isBoolean(value) {
	    return value === true || value === false || toString.call(value) == boolClass;
	  }

	  /**
	   * Checks if `value` is a date.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a date, else `false`.
	   * @example
	   *
	   * _.isDate(new Date);
	   * // => true
	   */
	  function isDate(value) {
	    return value instanceof Date || toString.call(value) == dateClass;
	  }

	  /**
	   * Checks if `value` is a DOM element.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a DOM element, else `false`.
	   * @example
	   *
	   * _.isElement(document.body);
	   * // => true
	   */
	  function isElement(value) {
	    return value ? value.nodeType === 1 : false;
	  }

	  /**
	   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
	   * length of `0` and objects with no own enumerable properties are considered
	   * "empty".
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Array|Object|String} value The value to inspect.
	   * @returns {Boolean} Returns `true`, if the `value` is empty, else `false`.
	   * @example
	   *
	   * _.isEmpty([1, 2, 3]);
	   * // => false
	   *
	   * _.isEmpty({});
	   * // => true
	   *
	   * _.isEmpty('');
	   * // => true
	   */
	  function isEmpty(value) {
	    var result = true;
	    if (!value) {
	      return result;
	    }
	    var className = toString.call(value),
	        length = value.length;

	    if ((className == arrayClass || className == stringClass ||
	        className == argsClass || (noArgsClass && isArguments(value))) ||
	        (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
	      return !length;
	    }
	    forOwn(value, function() {
	      return (result = false);
	    });
	    return result;
	  }

	  /**
	   * Performs a deep comparison between two values to determine if they are
	   * equivalent to each other. If `callback` is passed, it will be executed to
	   * compare values. If `callback` returns `undefined`, comparisons will be handled
	   * by the method instead. The `callback` is bound to `thisArg` and invoked with
	   * two arguments; (a, b).
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} a The value to compare.
	   * @param {Mixed} b The other value to compare.
	   * @param {Function} [callback] The function to customize comparing values.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @param- {Object} [stackA=[]] Internally used track traversed `a` objects.
	   * @param- {Object} [stackB=[]] Internally used track traversed `b` objects.
	   * @returns {Boolean} Returns `true`, if the values are equvalent, else `false`.
	   * @example
	   *
	   * var moe = { 'name': 'moe', 'age': 40 };
	   * var copy = { 'name': 'moe', 'age': 40 };
	   *
	   * moe == copy;
	   * // => false
	   *
	   * _.isEqual(moe, copy);
	   * // => true
	   *
	   * var words = ['hello', 'goodbye'];
	   * var otherWords = ['hi', 'goodbye'];
	   *
	   * _.isEqual(words, otherWords, function(a, b) {
	   *   var reGreet = /^(?:hello|hi)$/i,
	   *       aGreet = _.isString(a) && reGreet.test(a),
	   *       bGreet = _.isString(b) && reGreet.test(b);
	   *
	   *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
	   * });
	   * // => true
	   */
	  function isEqual(a, b, callback, thisArg, stackA, stackB) {
	    // used to indicate that when comparing objects, `a` has at least the properties of `b`
	    var whereIndicator = callback === indicatorObject;
	    if (callback && !whereIndicator) {
	      callback = typeof thisArg == 'undefined' ? callback : createCallback(callback, thisArg, 2);
	      var result = callback(a, b);
	      if (typeof result != 'undefined') {
	        return !!result;
	      }
	    }
	    // exit early for identical values
	    if (a === b) {
	      // treat `+0` vs. `-0` as not equal
	      return a !== 0 || (1 / a == 1 / b);
	    }
	    var type = typeof a,
	        otherType = typeof b;

	    // exit early for unlike primitive values
	    if (a === a &&
	        (!a || (type != 'function' && type != 'object')) &&
	        (!b || (otherType != 'function' && otherType != 'object'))) {
	      return false;
	    }
	    // exit early for `null` and `undefined`, avoiding ES3's Function#call behavior
	    // http://es5.github.com/#x15.3.4.4
	    if (a == null || b == null) {
	      return a === b;
	    }
	    // compare [[Class]] names
	    var className = toString.call(a),
	        otherClass = toString.call(b);

	    if (className == argsClass) {
	      className = objectClass;
	    }
	    if (otherClass == argsClass) {
	      otherClass = objectClass;
	    }
	    if (className != otherClass) {
	      return false;
	    }
	    switch (className) {
	      case boolClass:
	      case dateClass:
	        // coerce dates and booleans to numbers, dates to milliseconds and booleans
	        // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
	        return +a == +b;

	      case numberClass:
	        // treat `NaN` vs. `NaN` as equal
	        return a != +a
	          ? b != +b
	          // but treat `+0` vs. `-0` as not equal
	          : (a == 0 ? (1 / a == 1 / b) : a == +b);

	      case regexpClass:
	      case stringClass:
	        // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
	        // treat string primitives and their corresponding object instances as equal
	        return a == b + '';
	    }
	    var isArr = className == arrayClass;
	    if (!isArr) {
	      // unwrap any `lodash` wrapped values
	      if (a.__wrapped__ || b.__wrapped__) {
	        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b, callback, thisArg, stackA, stackB);
	      }
	      // exit for functions and DOM nodes
	      if (className != objectClass || (noNodeClass && (isNode(a) || isNode(b)))) {
	        return false;
	      }
	      // in older versions of Opera, `arguments` objects have `Array` constructors
	      var ctorA = !argsAreObjects && isArguments(a) ? Object : a.constructor,
	          ctorB = !argsAreObjects && isArguments(b) ? Object : b.constructor;

	      // non `Object` object instances with different constructors are not equal
	      if (ctorA != ctorB && !(
	            isFunction(ctorA) && ctorA instanceof ctorA &&
	            isFunction(ctorB) && ctorB instanceof ctorB
	          )) {
	        return false;
	      }
	    }
	    // assume cyclic structures are equal
	    // the algorithm for detecting cyclic structures is adapted from ES 5.1
	    // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
	    stackA || (stackA = []);
	    stackB || (stackB = []);

	    var length = stackA.length;
	    while (length--) {
	      if (stackA[length] == a) {
	        return stackB[length] == b;
	      }
	    }
	    var size = 0;
	    result = true;

	    // add `a` and `b` to the stack of traversed objects
	    stackA.push(a);
	    stackB.push(b);

	    // recursively compare objects and arrays (susceptible to call stack limits)
	    if (isArr) {
	      length = a.length;
	      size = b.length;

	      // compare lengths to determine if a deep comparison is necessary
	      result = size == a.length;
	      if (!result && !whereIndicator) {
	        return result;
	      }
	      // deep compare the contents, ignoring non-numeric properties
	      while (size--) {
	        var index = length,
	            value = b[size];

	        if (whereIndicator) {
	          while (index--) {
	            if ((result = isEqual(a[index], value, callback, thisArg, stackA, stackB))) {
	              break;
	            }
	          }
	        } else if (!(result = isEqual(a[size], value, callback, thisArg, stackA, stackB))) {
	          break;
	        }
	      }
	      return result;
	    }
	    // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
	    // which, in this case, is more costly
	    forIn(b, function(value, key, b) {
	      if (hasOwnProperty.call(b, key)) {
	        // count the number of properties.
	        size++;
	        // deep compare each property value.
	        return (result = hasOwnProperty.call(a, key) && isEqual(a[key], value, callback, thisArg, stackA, stackB));
	      }
	    });

	    if (result && !whereIndicator) {
	      // ensure both objects have the same number of properties
	      forIn(a, function(value, key, a) {
	        if (hasOwnProperty.call(a, key)) {
	          // `size` will be `-1` if `a` has more properties than `b`
	          return (result = --size > -1);
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Checks if `value` is, or can be coerced to, a finite number.
	   *
	   * Note: This is not the same as native `isFinite`, which will return true for
	   * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is finite, else `false`.
	   * @example
	   *
	   * _.isFinite(-101);
	   * // => true
	   *
	   * _.isFinite('10');
	   * // => true
	   *
	   * _.isFinite(true);
	   * // => false
	   *
	   * _.isFinite('');
	   * // => false
	   *
	   * _.isFinite(Infinity);
	   * // => false
	   */
	  function isFinite(value) {
	    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
	  }

	  /**
	   * Checks if `value` is a function.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a function, else `false`.
	   * @example
	   *
	   * _.isFunction(_);
	   * // => true
	   */
	  function isFunction(value) {
	    return typeof value == 'function';
	  }
	  // fallback for older versions of Chrome and Safari
	  if (isFunction(/x/)) {
	    isFunction = function(value) {
	      return value instanceof Function || toString.call(value) == funcClass;
	    };
	  }

	  /**
	   * Checks if `value` is the language type of Object.
	   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is an object, else `false`.
	   * @example
	   *
	   * _.isObject({});
	   * // => true
	   *
	   * _.isObject([1, 2, 3]);
	   * // => true
	   *
	   * _.isObject(1);
	   * // => false
	   */
	  function isObject(value) {
	    // check if the value is the ECMAScript language type of Object
	    // http://es5.github.com/#x8
	    // and avoid a V8 bug
	    // http://code.google.com/p/v8/issues/detail?id=2291
	    return value ? objectTypes[typeof value] : false;
	  }

	  /**
	   * Checks if `value` is `NaN`.
	   *
	   * Note: This is not the same as native `isNaN`, which will return `true` for
	   * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is `NaN`, else `false`.
	   * @example
	   *
	   * _.isNaN(NaN);
	   * // => true
	   *
	   * _.isNaN(new Number(NaN));
	   * // => true
	   *
	   * isNaN(undefined);
	   * // => true
	   *
	   * _.isNaN(undefined);
	   * // => false
	   */
	  function isNaN(value) {
	    // `NaN` as a primitive is the only value that is not equal to itself
	    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
	    return isNumber(value) && value != +value
	  }

	  /**
	   * Checks if `value` is `null`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is `null`, else `false`.
	   * @example
	   *
	   * _.isNull(null);
	   * // => true
	   *
	   * _.isNull(undefined);
	   * // => false
	   */
	  function isNull(value) {
	    return value === null;
	  }

	  /**
	   * Checks if `value` is a number.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a number, else `false`.
	   * @example
	   *
	   * _.isNumber(8.4 * 5);
	   * // => true
	   */
	  function isNumber(value) {
	    return typeof value == 'number' || toString.call(value) == numberClass;
	  }

	  /**
	   * Checks if a given `value` is an object created by the `Object` constructor.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if `value` is a plain object, else `false`.
	   * @example
	   *
	   * function Stooge(name, age) {
	   *   this.name = name;
	   *   this.age = age;
	   * }
	   *
	   * _.isPlainObject(new Stooge('moe', 40));
	   * // => false
	   *
	   * _.isPlainObject([1, 2, 3]);
	   * // => false
	   *
	   * _.isPlainObject({ 'name': 'moe', 'age': 40 });
	   * // => true
	   */
	  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
	    if (!(value && typeof value == 'object')) {
	      return false;
	    }
	    var valueOf = value.valueOf,
	        objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

	    return objProto
	      ? value == objProto || (getPrototypeOf(value) == objProto && !isArguments(value))
	      : shimIsPlainObject(value);
	  };

	  /**
	   * Checks if `value` is a regular expression.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a regular expression, else `false`.
	   * @example
	   *
	   * _.isRegExp(/moe/);
	   * // => true
	   */
	  function isRegExp(value) {
	    return value instanceof RegExp || toString.call(value) == regexpClass;
	  }

	  /**
	   * Checks if `value` is a string.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is a string, else `false`.
	   * @example
	   *
	   * _.isString('moe');
	   * // => true
	   */
	  function isString(value) {
	    return typeof value == 'string' || toString.call(value) == stringClass;
	  }

	  /**
	   * Checks if `value` is `undefined`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Mixed} value The value to check.
	   * @returns {Boolean} Returns `true`, if the `value` is `undefined`, else `false`.
	   * @example
	   *
	   * _.isUndefined(void 0);
	   * // => true
	   */
	  function isUndefined(value) {
	    return typeof value == 'undefined';
	  }

	  /**
	   * Recursively merges own enumerable properties of the source object(s), that
	   * don't resolve to `undefined`, into the destination object. Subsequent sources
	   * will overwrite propery assignments of previous sources. If a `callback` function
	   * is passed, it will be executed to produce the merged values of the destination
	   * and source properties. If `callback` returns `undefined`, merging will be
	   * handled by the method instead. The `callback` is bound to `thisArg` and
	   * invoked with two arguments; (objectValue, sourceValue).
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The destination object.
	   * @param {Object} [source1, source2, ...] The source objects.
	   * @param {Function} [callback] The function to customize merging properties.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @param- {Object} [deepIndicator] Internally used to indicate that `stackA`
	   *  and `stackB` are arrays of traversed objects instead of source objects.
	   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
	   * @param- {Array} [stackB=[]] Internally used to associate values with their
	   *  source counterparts.
	   * @returns {Object} Returns the destination object.
	   * @example
	   *
	   * var names = {
	   *   'stooges': [
	   *     { 'name': 'moe' },
	   *     { 'name': 'larry' }
	   *   ]
	   * };
	   *
	   * var ages = {
	   *   'stooges': [
	   *     { 'age': 40 },
	   *     { 'age': 50 }
	   *   ]
	   * };
	   *
	   * _.merge(names, ages);
	   * // => { 'stooges': [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }] }
	   *
	   * var food = {
	   *   'fruits': ['apple'],
	   *   'vegetables': ['beet']
	   * };
	   *
	   * var otherFood = {
	   *   'fruits': ['banana'],
	   *   'vegetables': ['carrot']
	   * };
	   *
	   * _.merge(food, otherFood, function(a, b) {
	   *   return _.isArray(a) ? a.concat(b) : undefined;
	   * });
	   * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
	   */
	  function merge(object, source, deepIndicator) {
	    var args = arguments,
	        index = 0,
	        length = 2;

	    if (!isObject(object)) {
	      return object;
	    }
	    if (deepIndicator === indicatorObject) {
	      var callback = args[3],
	          stackA = args[4],
	          stackB = args[5];
	    } else {
	      stackA = [];
	      stackB = [];

	      // allows working with `_.reduce` and `_.reduceRight` without
	      // using their `callback` arguments, `index|key` and `collection`
	      if (typeof deepIndicator != 'number') {
	        length = args.length;
	      }
	      if (length > 3 && typeof args[length - 2] == 'function') {
	        callback = createCallback(args[--length - 1], args[length--], 2);
	      } else if (length > 2 && typeof args[length - 1] == 'function') {
	        callback = args[--length];
	      }
	    }
	    while (++index < length) {
	      (isArray(args[index]) ? forEach : forOwn)(args[index], function(source, key) {
	        var found,
	            isArr,
	            result = source,
	            value = object[key];

	        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
	          // avoid merging previously merged cyclic sources
	          var stackLength = stackA.length;
	          while (stackLength--) {
	            if ((found = stackA[stackLength] == source)) {
	              value = stackB[stackLength];
	              break;
	            }
	          }
	          if (!found) {
	            value = isArr
	              ? (isArray(value) ? value : [])
	              : (isPlainObject(value) ? value : {});

	            if (callback) {
	              result = callback(value, source);
	              if (typeof result != 'undefined') {
	                value = result;
	              }
	            }
	            // add `source` and associated `value` to the stack of traversed objects
	            stackA.push(source);
	            stackB.push(value);

	            // recursively merge objects and arrays (susceptible to call stack limits)
	            if (!callback) {
	              value = merge(value, source, indicatorObject, callback, stackA, stackB);
	            }
	          }
	        }
	        else {
	          if (callback) {
	            result = callback(value, source);
	            if (typeof result == 'undefined') {
	              result = source;
	            }
	          }
	          if (typeof result != 'undefined') {
	            value = result;
	          }
	        }
	        object[key] = value;
	      });
	    }
	    return object;
	  }

	  /**
	   * Creates a shallow clone of `object` excluding the specified properties.
	   * Property names may be specified as individual arguments or as arrays of
	   * property names. If a `callback` function is passed, it will be executed
	   * for each property in the `object`, omitting the properties `callback`
	   * returns truthy for. The `callback` is bound to `thisArg` and invoked
	   * with three arguments; (value, key, object).
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The source object.
	   * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
	   *  or the function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns an object without the omitted properties.
	   * @example
	   *
	   * _.omit({ 'name': 'moe', 'age': 40 }, 'age');
	   * // => { 'name': 'moe' }
	   *
	   * _.omit({ 'name': 'moe', 'age': 40 }, function(value) {
	   *   return typeof value == 'number';
	   * });
	   * // => { 'name': 'moe' }
	   */
	  function omit(object, callback, thisArg) {
	    var isFunc = typeof callback == 'function',
	        result = {};

	    if (isFunc) {
	      callback = createCallback(callback, thisArg);
	    } else {
	      var props = concat.apply(arrayRef, arguments);
	    }
	    forIn(object, function(value, key, object) {
	      if (isFunc
	            ? !callback(value, key, object)
	            : indexOf(props, key, 1) < 0
	          ) {
	        result[key] = value;
	      }
	    });
	    return result;
	  }

	  /**
	   * Creates a two dimensional array of the given object's key-value pairs,
	   * i.e. `[[key1, value1], [key2, value2]]`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The object to inspect.
	   * @returns {Array} Returns new array of key-value pairs.
	   * @example
	   *
	   * _.pairs({ 'moe': 30, 'larry': 40 });
	   * // => [['moe', 30], ['larry', 40]] (order is not guaranteed)
	   */
	  function pairs(object) {
	    var index = -1,
	        props = keys(object),
	        length = props.length,
	        result = Array(length);

	    while (++index < length) {
	      var key = props[index];
	      result[index] = [key, object[key]];
	    }
	    return result;
	  }

	  /**
	   * Creates a shallow clone of `object` composed of the specified properties.
	   * Property names may be specified as individual arguments or as arrays of property
	   * names. If `callback` is passed, it will be executed for each property in the
	   * `object`, picking the properties `callback` returns truthy for. The `callback`
	   * is bound to `thisArg` and invoked with three arguments; (value, key, object).
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The source object.
	   * @param {Array|Function|String} callback|[prop1, prop2, ...] The function called
	   *  per iteration or properties to pick, either as individual arguments or arrays.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns an object composed of the picked properties.
	   * @example
	   *
	   * _.pick({ 'name': 'moe', '_userid': 'moe1' }, 'name');
	   * // => { 'name': 'moe' }
	   *
	   * _.pick({ 'name': 'moe', '_userid': 'moe1' }, function(value, key) {
	   *   return key.charAt(0) != '_';
	   * });
	   * // => { 'name': 'moe' }
	   */
	  function pick(object, callback, thisArg) {
	    var result = {};
	    if (typeof callback != 'function') {
	      var index = 0,
	          props = concat.apply(arrayRef, arguments),
	          length = isObject(object) ? props.length : 0;

	      while (++index < length) {
	        var key = props[index];
	        if (key in object) {
	          result[key] = object[key];
	        }
	      }
	    } else {
	      callback = createCallback(callback, thisArg);
	      forIn(object, function(value, key, object) {
	        if (callback(value, key, object)) {
	          result[key] = value;
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Creates an array composed of the own enumerable property values of `object`.
	   *
	   * @static
	   * @memberOf _
	   * @category Objects
	   * @param {Object} object The object to inspect.
	   * @returns {Array} Returns a new array of property values.
	   * @example
	   *
	   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
	   * // => [1, 2, 3]
	   */
	  function values(object) {
	    var index = -1,
	        props = keys(object),
	        length = props.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = object[props[index]];
	    }
	    return result;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates an array of elements from the specified indexes, or keys, of the
	   * `collection`. Indexes may be specified as individual arguments or as arrays
	   * of indexes.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Array|Number|String} [index1, index2, ...] The indexes of
	   *  `collection` to retrieve, either as individual arguments or arrays.
	   * @returns {Array} Returns a new array of elements corresponding to the
	   *  provided indexes.
	   * @example
	   *
	   * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
	   * // => ['a', 'c', 'e']
	   *
	   * _.at(['moe', 'larry', 'curly'], 0, 2);
	   * // => ['moe', 'curly']
	   */
	  function at(collection) {
	    var index = -1,
	        props = concat.apply(arrayRef, slice(arguments, 1)),
	        length = props.length,
	        result = Array(length);

	    if (noCharByIndex && isString(collection)) {
	      collection = collection.split('');
	    }
	    while(++index < length) {
	      result[index] = collection[props[index]];
	    }
	    return result;
	  }

	  /**
	   * Checks if a given `target` element is present in a `collection` using strict
	   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
	   * as the offset from the end of the collection.
	   *
	   * @static
	   * @memberOf _
	   * @alias include
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Mixed} target The value to check for.
	   * @param {Number} [fromIndex=0] The index to search from.
	   * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
	   * @example
	   *
	   * _.contains([1, 2, 3], 1);
	   * // => true
	   *
	   * _.contains([1, 2, 3], 1, 2);
	   * // => false
	   *
	   * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
	   * // => true
	   *
	   * _.contains('curly', 'ur');
	   * // => true
	   */
	  function contains(collection, target, fromIndex) {
	    var index = -1,
	        length = collection ? collection.length : 0,
	        result = false;

	    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
	    if (typeof length == 'number') {
	      result = (isString(collection)
	        ? collection.indexOf(target, fromIndex)
	        : indexOf(collection, target, fromIndex)
	      ) > -1;
	    } else {
	      each(collection, function(value) {
	        if (++index >= fromIndex) {
	          return !(result = value === target);
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Creates an object composed of keys returned from running each element of the
	   * `collection` through the given `callback`. The corresponding value of each key
	   * is the number of times the key was returned by the `callback`. The `callback`
	   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns the composed aggregate object.
	   * @example
	   *
	   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
	   * // => { '4': 1, '6': 2 }
	   *
	   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	   * // => { '4': 1, '6': 2 }
	   *
	   * _.countBy(['one', 'two', 'three'], 'length');
	   * // => { '3': 2, '5': 1 }
	   */
	  function countBy(collection, callback, thisArg) {
	    var result = {};
	    callback = createCallback(callback, thisArg);

	    forEach(collection, function(value, key, collection) {
	      key = callback(value, key, collection) + '';
	      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
	    });
	    return result;
	  }

	  /**
	   * Checks if the `callback` returns a truthy value for **all** elements of a
	   * `collection`. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias all
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Boolean} Returns `true` if all elements pass the callback check,
	   *  else `false`.
	   * @example
	   *
	   * _.every([true, 1, null, 'yes'], Boolean);
	   * // => false
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.every(stooges, 'age');
	   * // => true
	   *
	   * // using "_.where" callback shorthand
	   * _.every(stooges, { 'age': 50 });
	   * // => false
	   */
	  function every(collection, callback, thisArg) {
	    var result = true;
	    callback = createCallback(callback, thisArg);

	    if (isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        if (!(result = !!callback(collection[index], index, collection))) {
	          break;
	        }
	      }
	    } else {
	      each(collection, function(value, index, collection) {
	        return (result = !!callback(value, index, collection));
	      });
	    }
	    return result;
	  }

	  /**
	   * Examines each element in a `collection`, returning an array of all elements
	   * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
	   * invoked with three arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias select
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a new array of elements that passed the callback check.
	   * @example
	   *
	   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	   * // => [2, 4, 6]
	   *
	   * var food = [
	   *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
	   *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.filter(food, 'organic');
	   * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
	   *
	   * // using "_.where" callback shorthand
	   * _.filter(food, { 'type': 'fruit' });
	   * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
	   */
	  function filter(collection, callback, thisArg) {
	    var result = [];
	    callback = createCallback(callback, thisArg);

	    if (isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        var value = collection[index];
	        if (callback(value, index, collection)) {
	          result.push(value);
	        }
	      }
	    } else {
	      each(collection, function(value, index, collection) {
	        if (callback(value, index, collection)) {
	          result.push(value);
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Examines each element in a `collection`, returning the first that the `callback`
	   * returns truthy for. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias detect
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the element that passed the callback check,
	   *  else `undefined`.
	   * @example
	   *
	   * var even = _.find([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	   * // => 2
	   *
	   * var food = [
	   *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
	   *   { 'name': 'banana', 'organic': true,  'type': 'fruit' },
	   *   { 'name': 'beet',   'organic': false, 'type': 'vegetable' },
	   *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.where" callback shorthand
	   * var veggie = _.find(food, { 'type': 'vegetable' });
	   * // => { 'name': 'beet', 'organic': false, 'type': 'vegetable' }
	   *
	   * // using "_.pluck" callback shorthand
	   * var healthy = _.find(food, 'organic');
	   * // => { 'name': 'banana', 'organic': true, 'type': 'fruit' }
	   */
	  function find(collection, callback, thisArg) {
	    var result;
	    callback = createCallback(callback, thisArg);

	    forEach(collection, function(value, index, collection) {
	      if (callback(value, index, collection)) {
	        result = value;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * Iterates over a `collection`, executing the `callback` for each element in
	   * the `collection`. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, index|key, collection). Callbacks may exit iteration early
	   * by explicitly returning `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias each
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array|Object|String} Returns `collection`.
	   * @example
	   *
	   * _([1, 2, 3]).forEach(alert).join(',');
	   * // => alerts each number and returns '1,2,3'
	   *
	   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
	   * // => alerts each number value (order is not guaranteed)
	   */
	  function forEach(collection, callback, thisArg) {
	    if (callback && typeof thisArg == 'undefined' && isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        if (callback(collection[index], index, collection) === false) {
	          break;
	        }
	      }
	    } else {
	      each(collection, callback, thisArg);
	    }
	    return collection;
	  }

	  /**
	   * Creates an object composed of keys returned from running each element of the
	   * `collection` through the `callback`. The corresponding value of each key is
	   * an array of elements passed to `callback` that returned the key. The `callback`
	   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Object} Returns the composed aggregate object.
	   * @example
	   *
	   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
	   * // => { '4': [4.2], '6': [6.1, 6.4] }
	   *
	   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
	   * // => { '4': [4.2], '6': [6.1, 6.4] }
	   *
	   * // using "_.pluck" callback shorthand
	   * _.groupBy(['one', 'two', 'three'], 'length');
	   * // => { '3': ['one', 'two'], '5': ['three'] }
	   */
	  function groupBy(collection, callback, thisArg) {
	    var result = {};
	    callback = createCallback(callback, thisArg);

	    forEach(collection, function(value, key, collection) {
	      key = callback(value, key, collection) + '';
	      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
	    });
	    return result;
	  }

	  /**
	   * Invokes the method named by `methodName` on each element in the `collection`,
	   * returning an array of the results of each invoked method. Additional arguments
	   * will be passed to each invoked method. If `methodName` is a function, it will
	   * be invoked for, and `this` bound to, each element in the `collection`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|String} methodName The name of the method to invoke or
	   *  the function invoked per iteration.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
	   * @returns {Array} Returns a new array of the results of each invoked method.
	   * @example
	   *
	   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
	   * // => [[1, 5, 7], [1, 2, 3]]
	   *
	   * _.invoke([123, 456], String.prototype.split, '');
	   * // => [['1', '2', '3'], ['4', '5', '6']]
	   */
	  function invoke(collection, methodName) {
	    var args = slice(arguments, 2),
	        index = -1,
	        isFunc = typeof methodName == 'function',
	        length = collection ? collection.length : 0,
	        result = Array(typeof length == 'number' ? length : 0);

	    forEach(collection, function(value) {
	      result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
	    });
	    return result;
	  }

	  /**
	   * Creates an array of values by running each element in the `collection`
	   * through the `callback`. The `callback` is bound to `thisArg` and invoked with
	   * three arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias collect
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a new array of the results of each `callback` execution.
	   * @example
	   *
	   * _.map([1, 2, 3], function(num) { return num * 3; });
	   * // => [3, 6, 9]
	   *
	   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
	   * // => [3, 6, 9] (order is not guaranteed)
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.map(stooges, 'name');
	   * // => ['moe', 'larry']
	   */
	  function map(collection, callback, thisArg) {
	    var index = -1,
	        length = collection ? collection.length : 0,
	        result = Array(typeof length == 'number' ? length : 0);

	    callback = createCallback(callback, thisArg);
	    if (isArray(collection)) {
	      while (++index < length) {
	        result[index] = callback(collection[index], index, collection);
	      }
	    } else {
	      each(collection, function(value, key, collection) {
	        result[++index] = callback(value, key, collection);
	      });
	    }
	    return result;
	  }

	  /**
	   * Retrieves the maximum value of an `array`. If `callback` is passed,
	   * it will be executed for each value in the `array` to generate the
	   * criterion by which the value is ranked. The `callback` is bound to
	   * `thisArg` and invoked with three arguments; (value, index, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the maximum value.
	   * @example
	   *
	   * _.max([4, 2, 8, 6]);
	   * // => 8
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * _.max(stooges, function(stooge) { return stooge.age; });
	   * // => { 'name': 'larry', 'age': 50 };
	   *
	   * // using "_.pluck" callback shorthand
	   * _.max(stooges, 'age');
	   * // => { 'name': 'larry', 'age': 50 };
	   */
	  function max(collection, callback, thisArg) {
	    var computed = -Infinity,
	        result = computed;

	    if (!callback && isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        var value = collection[index];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      callback = !callback && isString(collection)
	        ? charAtCallback
	        : createCallback(callback, thisArg);

	      each(collection, function(value, index, collection) {
	        var current = callback(value, index, collection);
	        if (current > computed) {
	          computed = current;
	          result = value;
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Retrieves the minimum value of an `array`. If `callback` is passed,
	   * it will be executed for each value in the `array` to generate the
	   * criterion by which the value is ranked. The `callback` is bound to `thisArg`
	   * and invoked with three arguments; (value, index, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the minimum value.
	   * @example
	   *
	   * _.min([4, 2, 8, 6]);
	   * // => 2
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * _.min(stooges, function(stooge) { return stooge.age; });
	   * // => { 'name': 'moe', 'age': 40 };
	   *
	   * // using "_.pluck" callback shorthand
	   * _.min(stooges, 'age');
	   * // => { 'name': 'moe', 'age': 40 };
	   */
	  function min(collection, callback, thisArg) {
	    var computed = Infinity,
	        result = computed;

	    if (!callback && isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        var value = collection[index];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      callback = !callback && isString(collection)
	        ? charAtCallback
	        : createCallback(callback, thisArg);

	      each(collection, function(value, index, collection) {
	        var current = callback(value, index, collection);
	        if (current < computed) {
	          computed = current;
	          result = value;
	        }
	      });
	    }
	    return result;
	  }

	  /**
	   * Retrieves the value of a specified property from all elements in the `collection`.
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {String} property The property to pluck.
	   * @returns {Array} Returns a new array of property values.
	   * @example
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * _.pluck(stooges, 'name');
	   * // => ['moe', 'larry']
	   */
	  var pluck = map;

	  /**
	   * Reduces a `collection` to a value that is the accumulated result of running
	   * each element in the `collection` through the `callback`, where each successive
	   * `callback` execution consumes the return value of the previous execution.
	   * If `accumulator` is not passed, the first element of the `collection` will be
	   * used as the initial `accumulator` value. The `callback` is bound to `thisArg`
	   * and invoked with four arguments; (accumulator, value, index|key, collection).
	   *
	   * @static
	   * @memberOf _
	   * @alias foldl, inject
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [accumulator] Initial value of the accumulator.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the accumulated value.
	   * @example
	   *
	   * var sum = _.reduce([1, 2, 3], function(sum, num) {
	   *   return sum + num;
	   * });
	   * // => 6
	   *
	   * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
	   *   result[key] = num * 3;
	   *   return result;
	   * }, {});
	   * // => { 'a': 3, 'b': 6, 'c': 9 }
	   */
	  function reduce(collection, callback, accumulator, thisArg) {
	    var noaccum = arguments.length < 3;
	    callback = createCallback(callback, thisArg, 4);

	    if (isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      if (noaccum) {
	        accumulator = collection[++index];
	      }
	      while (++index < length) {
	        accumulator = callback(accumulator, collection[index], index, collection);
	      }
	    } else {
	      each(collection, function(value, index, collection) {
	        accumulator = noaccum
	          ? (noaccum = false, value)
	          : callback(accumulator, value, index, collection)
	      });
	    }
	    return accumulator;
	  }

	  /**
	   * This method is similar to `_.reduce`, except that it iterates over a
	   * `collection` from right to left.
	   *
	   * @static
	   * @memberOf _
	   * @alias foldr
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function} [callback=identity] The function called per iteration.
	   * @param {Mixed} [accumulator] Initial value of the accumulator.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the accumulated value.
	   * @example
	   *
	   * var list = [[0, 1], [2, 3], [4, 5]];
	   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
	   * // => [4, 5, 2, 3, 0, 1]
	   */
	  function reduceRight(collection, callback, accumulator, thisArg) {
	    var iterable = collection,
	        length = collection ? collection.length : 0,
	        noaccum = arguments.length < 3;

	    if (typeof length != 'number') {
	      var props = keys(collection);
	      length = props.length;
	    } else if (noCharByIndex && isString(collection)) {
	      iterable = collection.split('');
	    }
	    callback = createCallback(callback, thisArg, 4);
	    forEach(collection, function(value, index, collection) {
	      index = props ? props[--length] : --length;
	      accumulator = noaccum
	        ? (noaccum = false, iterable[index])
	        : callback(accumulator, iterable[index], index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The opposite of `_.filter`, this method returns the elements of a
	   * `collection` that `callback` does **not** return truthy for.
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a new array of elements that did **not** pass the
	   *  callback check.
	   * @example
	   *
	   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
	   * // => [1, 3, 5]
	   *
	   * var food = [
	   *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
	   *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.reject(food, 'organic');
	   * // => [{ 'name': 'apple', 'organic': false, 'type': 'fruit' }]
	   *
	   * // using "_.where" callback shorthand
	   * _.reject(food, { 'type': 'fruit' });
	   * // => [{ 'name': 'carrot', 'organic': true, 'type': 'vegetable' }]
	   */
	  function reject(collection, callback, thisArg) {
	    callback = createCallback(callback, thisArg);
	    return filter(collection, function(value, index, collection) {
	      return !callback(value, index, collection);
	    });
	  }

	  /**
	   * Creates an array of shuffled `array` values, using a version of the
	   * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to shuffle.
	   * @returns {Array} Returns a new shuffled collection.
	   * @example
	   *
	   * _.shuffle([1, 2, 3, 4, 5, 6]);
	   * // => [4, 1, 6, 3, 5, 2]
	   */
	  function shuffle(collection) {
	    var index = -1,
	        length = collection ? collection.length : 0,
	        result = Array(typeof length == 'number' ? length : 0);

	    forEach(collection, function(value) {
	      var rand = floor(nativeRandom() * (++index + 1));
	      result[index] = result[rand];
	      result[rand] = value;
	    });
	    return result;
	  }

	  /**
	   * Gets the size of the `collection` by returning `collection.length` for arrays
	   * and array-like objects or the number of own enumerable properties for objects.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to inspect.
	   * @returns {Number} Returns `collection.length` or number of own enumerable properties.
	   * @example
	   *
	   * _.size([1, 2]);
	   * // => 2
	   *
	   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
	   * // => 3
	   *
	   * _.size('curly');
	   * // => 5
	   */
	  function size(collection) {
	    var length = collection ? collection.length : 0;
	    return typeof length == 'number' ? length : keys(collection).length;
	  }

	  /**
	   * Checks if the `callback` returns a truthy value for **any** element of a
	   * `collection`. The function returns as soon as it finds passing value, and
	   * does not iterate over the entire `collection`. The `callback` is bound to
	   * `thisArg` and invoked with three arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias any
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Boolean} Returns `true` if any element passes the callback check,
	   *  else `false`.
	   * @example
	   *
	   * _.some([null, 0, 'yes', false], Boolean);
	   * // => true
	   *
	   * var food = [
	   *   { 'name': 'apple',  'organic': false, 'type': 'fruit' },
	   *   { 'name': 'carrot', 'organic': true,  'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.some(food, 'organic');
	   * // => true
	   *
	   * // using "_.where" callback shorthand
	   * _.some(food, { 'type': 'meat' });
	   * // => false
	   */
	  function some(collection, callback, thisArg) {
	    var result;
	    callback = createCallback(callback, thisArg);

	    if (isArray(collection)) {
	      var index = -1,
	          length = collection.length;

	      while (++index < length) {
	        if ((result = callback(collection[index], index, collection))) {
	          break;
	        }
	      }
	    } else {
	      each(collection, function(value, index, collection) {
	        return !(result = callback(value, index, collection));
	      });
	    }
	    return !!result;
	  }

	  /**
	   * Creates an array of elements, sorted in ascending order by the results of
	   * running each element in the `collection` through the `callback`. This method
	   * performs a stable sort, that is, it will preserve the original sort order of
	   * equal elements. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, index|key, collection).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a new array of sorted elements.
	   * @example
	   *
	   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
	   * // => [3, 1, 2]
	   *
	   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
	   * // => [3, 1, 2]
	   *
	   * // using "_.pluck" callback shorthand
	   * _.sortBy(['banana', 'strawberry', 'apple'], 'length');
	   * // => ['apple', 'banana', 'strawberry']
	   */
	  function sortBy(collection, callback, thisArg) {
	    var index = -1,
	        length = collection ? collection.length : 0,
	        result = Array(typeof length == 'number' ? length : 0);

	    callback = createCallback(callback, thisArg);
	    forEach(collection, function(value, key, collection) {
	      result[++index] = {
	        'criteria': callback(value, key, collection),
	        'index': index,
	        'value': value
	      };
	    });

	    length = result.length;
	    result.sort(compareAscending);
	    while (length--) {
	      result[length] = result[length].value;
	    }
	    return result;
	  }

	  /**
	   * Converts the `collection` to an array.
	   *
	   * @static
	   * @memberOf _
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to convert.
	   * @returns {Array} Returns the new converted array.
	   * @example
	   *
	   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
	   * // => [2, 3, 4]
	   */
	  function toArray(collection) {
	    if (collection && typeof collection.length == 'number') {
	      return noCharByIndex && isString(collection)
	        ? collection.split('')
	        : slice(collection);
	    }
	    return values(collection);
	  }

	  /**
	   * Examines each element in a `collection`, returning an array of all elements
	   * that have the given `properties`. When checking `properties`, this method
	   * performs a deep comparison between values to determine if they are equivalent
	   * to each other.
	   *
	   * @static
	   * @memberOf _
	   * @type Function
	   * @category Collections
	   * @param {Array|Object|String} collection The collection to iterate over.
	   * @param {Object} properties The object of property values to filter by.
	   * @returns {Array} Returns a new array of elements that have the given `properties`.
	   * @example
	   *
	   * var stooges = [
	   *   { 'name': 'moe', 'age': 40 },
	   *   { 'name': 'larry', 'age': 50 }
	   * ];
	   *
	   * _.where(stooges, { 'age': 40 });
	   * // => [{ 'name': 'moe', 'age': 40 }]
	   */
	  var where = filter;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates an array with all falsey values of `array` removed. The values
	   * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to compact.
	   * @returns {Array} Returns a new filtered array.
	   * @example
	   *
	   * _.compact([0, 1, false, 2, '', 3]);
	   * // => [1, 2, 3]
	   */
	  function compact(array) {
	    var index = -1,
	        length = array ? array.length : 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value) {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Creates an array of `array` elements not present in the other arrays
	   * using strict equality for comparisons, i.e. `===`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to process.
	   * @param {Array} [array1, array2, ...] Arrays to check.
	   * @returns {Array} Returns a new array of `array` elements not present in the
	   *  other arrays.
	   * @example
	   *
	   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
	   * // => [1, 3, 4]
	   */
	  function difference(array) {
	    var index = -1,
	        length = array ? array.length : 0,
	        flattened = concat.apply(arrayRef, arguments),
	        contains = cachedContains(flattened, length),
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (!contains(value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Gets the first element of the `array`. If a number `n` is passed, the first
	   * `n` elements of the `array` are returned. If a `callback` function is passed,
	   * the first elements the `callback` returns truthy for are returned. The `callback`
	   * is bound to `thisArg` and invoked with three arguments; (value, index, array).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias head, take
	   * @category Arrays
	   * @param {Array} array The array to query.
	   * @param {Function|Object|Number|String} [callback|n] The function called
	   *  per element or the number of elements to return. If a property name or
	   *  object is passed, it will be used to create a "_.pluck" or "_.where"
	   *  style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the first element(s) of `array`.
	   * @example
	   *
	   * _.first([1, 2, 3]);
	   * // => 1
	   *
	   * _.first([1, 2, 3], 2);
	   * // => [1, 2]
	   *
	   * _.first([1, 2, 3], function(num) {
	   *   return num < 3;
	   * });
	   * // => [1, 2]
	   *
	   * var food = [
	   *   { 'name': 'banana', 'organic': true },
	   *   { 'name': 'beet',   'organic': false },
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.first(food, 'organic');
	   * // => [{ 'name': 'banana', 'organic': true }]
	   *
	   * var food = [
	   *   { 'name': 'apple',  'type': 'fruit' },
	   *   { 'name': 'banana', 'type': 'fruit' },
	   *   { 'name': 'beet',   'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.where" callback shorthand
	   * _.first(food, { 'type': 'fruit' });
	   * // => [{ 'name': 'apple', 'type': 'fruit' }, { 'name': 'banana', 'type': 'fruit' }]
	   */
	  function first(array, callback, thisArg) {
	    if (array) {
	      var n = 0,
	          length = array.length;

	      if (typeof callback != 'number' && callback != null) {
	        var index = -1;
	        callback = createCallback(callback, thisArg);
	        while (++index < length && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array[0];
	        }
	      }
	      return slice(array, 0, nativeMin(nativeMax(0, n), length));
	    }
	  }

	  /**
	   * Flattens a nested array (the nesting can be to any depth). If `shallow` is
	   * truthy, `array` will only be flattened a single level.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to compact.
	   * @param {Boolean} shallow A flag to indicate only flattening a single level.
	   * @returns {Array} Returns a new flattened array.
	   * @example
	   *
	   * _.flatten([1, [2], [3, [[4]]]]);
	   * // => [1, 2, 3, 4];
	   *
	   * _.flatten([1, [2], [3, [[4]]]], true);
	   * // => [1, 2, 3, [[4]]];
	   */
	  function flatten(array, shallow) {
	    var index = -1,
	        length = array ? array.length : 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];

	      // recursively flatten arrays (susceptible to call stack limits)
	      if (isArray(value)) {
	        push.apply(result, shallow ? value : flatten(value));
	      } else {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Gets the index at which the first occurrence of `value` is found using
	   * strict equality for comparisons, i.e. `===`. If the `array` is already
	   * sorted, passing `true` for `fromIndex` will run a faster binary search.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to search.
	   * @param {Mixed} value The value to search for.
	   * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
	   *  perform a binary search on a sorted `array`.
	   * @returns {Number} Returns the index of the matched value or `-1`.
	   * @example
	   *
	   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
	   * // => 1
	   *
	   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
	   * // => 4
	   *
	   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
	   * // => 2
	   */
	  function indexOf(array, value, fromIndex) {
	    var index = -1,
	        length = array ? array.length : 0;

	    if (typeof fromIndex == 'number') {
	      index = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;
	    } else if (fromIndex) {
	      index = sortedIndex(array, value);
	      return array[index] === value ? index : -1;
	    }
	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Gets all but the last element of `array`. If a number `n` is passed, the
	   * last `n` elements are excluded from the result. If a `callback` function
	   * is passed, the last elements the `callback` returns truthy for are excluded
	   * from the result. The `callback` is bound to `thisArg` and invoked with three
	   * arguments; (value, index, array).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to query.
	   * @param {Function|Object|Number|String} [callback|n=1] The function called
	   *  per element or the number of elements to exclude. If a property name or
	   *  object is passed, it will be used to create a "_.pluck" or "_.where"
	   *  style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a slice of `array`.
	   * @example
	   *
	   * _.initial([1, 2, 3]);
	   * // => [1, 2]
	   *
	   * _.initial([1, 2, 3], 2);
	   * // => [1]
	   *
	   * _.initial([1, 2, 3], function(num) {
	   *   return num > 1;
	   * });
	   * // => [1]
	   *
	   * var food = [
	   *   { 'name': 'beet',   'organic': false },
	   *   { 'name': 'carrot', 'organic': true }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.initial(food, 'organic');
	   * // => [{ 'name': 'beet',   'organic': false }]
	   *
	   * var food = [
	   *   { 'name': 'banana', 'type': 'fruit' },
	   *   { 'name': 'beet',   'type': 'vegetable' },
	   *   { 'name': 'carrot', 'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.where" callback shorthand
	   * _.initial(food, { 'type': 'vegetable' });
	   * // => [{ 'name': 'banana', 'type': 'fruit' }]
	   */
	  function initial(array, callback, thisArg) {
	    if (!array) {
	      return [];
	    }
	    var n = 0,
	        length = array.length;

	    if (typeof callback != 'number' && callback != null) {
	      var index = length;
	      callback = createCallback(callback, thisArg);
	      while (index-- && callback(array[index], index, array)) {
	        n++;
	      }
	    } else {
	      n = (callback == null || thisArg) ? 1 : callback || n;
	    }
	    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
	  }

	  /**
	   * Computes the intersection of all the passed-in arrays using strict equality
	   * for comparisons, i.e. `===`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} [array1, array2, ...] Arrays to process.
	   * @returns {Array} Returns a new array of unique elements that are present
	   *  in **all** of the arrays.
	   * @example
	   *
	   * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
	   * // => [1, 2]
	   */
	  function intersection(array) {
	    var args = arguments,
	        argsLength = args.length,
	        cache = { '0': {} },
	        index = -1,
	        length = array ? array.length : 0,
	        isLarge = length >= 100,
	        result = [],
	        seen = result;

	    outer:
	    while (++index < length) {
	      var value = array[index];
	      if (isLarge) {
	        var key = value + '';
	        var inited = hasOwnProperty.call(cache[0], key)
	          ? !(seen = cache[0][key])
	          : (seen = cache[0][key] = []);
	      }
	      if (inited || indexOf(seen, value) < 0) {
	        if (isLarge) {
	          seen.push(value);
	        }
	        var argsIndex = argsLength;
	        while (--argsIndex) {
	          if (!(cache[argsIndex] || (cache[argsIndex] = cachedContains(args[argsIndex], 0, 100)))(value)) {
	            continue outer;
	          }
	        }
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Gets the last element of the `array`. If a number `n` is passed, the last
	   * `n` elements of the `array` are returned. If a `callback` function is passed,
	   * the last elements the `callback` returns truthy for are returned. The `callback`
	   * is bound to `thisArg` and invoked with three arguments; (value, index, array).
	   *
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to query.
	   * @param {Function|Object|Number|String} [callback|n] The function called
	   *  per element or the number of elements to return. If a property name or
	   *  object is passed, it will be used to create a "_.pluck" or "_.where"
	   *  style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Mixed} Returns the last element(s) of `array`.
	   * @example
	   *
	   * _.last([1, 2, 3]);
	   * // => 3
	   *
	   * _.last([1, 2, 3], 2);
	   * // => [2, 3]
	   *
	   * _.last([1, 2, 3], function(num) {
	   *   return num > 1;
	   * });
	   * // => [2, 3]
	   *
	   * var food = [
	   *   { 'name': 'beet',   'organic': false },
	   *   { 'name': 'carrot', 'organic': true }
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.last(food, 'organic');
	   * // => [{ 'name': 'carrot', 'organic': true }]
	   *
	   * var food = [
	   *   { 'name': 'banana', 'type': 'fruit' },
	   *   { 'name': 'beet',   'type': 'vegetable' },
	   *   { 'name': 'carrot', 'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.where" callback shorthand
	   * _.last(food, { 'type': 'vegetable' });
	   * // => [{ 'name': 'beet', 'type': 'vegetable' }, { 'name': 'carrot', 'type': 'vegetable' }]
	   */
	  function last(array, callback, thisArg) {
	    if (array) {
	      var n = 0,
	          length = array.length;

	      if (typeof callback != 'number' && callback != null) {
	        var index = length;
	        callback = createCallback(callback, thisArg);
	        while (index-- && callback(array[index], index, array)) {
	          n++;
	        }
	      } else {
	        n = callback;
	        if (n == null || thisArg) {
	          return array[length - 1];
	        }
	      }
	      return slice(array, nativeMax(0, length - n));
	    }
	  }

	  /**
	   * Gets the index at which the last occurrence of `value` is found using strict
	   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
	   * as the offset from the end of the collection.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to search.
	   * @param {Mixed} value The value to search for.
	   * @param {Number} [fromIndex=array.length-1] The index to search from.
	   * @returns {Number} Returns the index of the matched value or `-1`.
	   * @example
	   *
	   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
	   * // => 4
	   *
	   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
	   * // => 1
	   */
	  function lastIndexOf(array, value, fromIndex) {
	    var index = array ? array.length : 0;
	    if (typeof fromIndex == 'number') {
	      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
	    }
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * Creates an object composed from arrays of `keys` and `values`. Pass either
	   * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
	   * two arrays, one of `keys` and one of corresponding `values`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} keys The array of keys.
	   * @param {Array} [values=[]] The array of values.
	   * @returns {Object} Returns an object composed of the given keys and
	   *  corresponding values.
	   * @example
	   *
	   * _.object(['moe', 'larry'], [30, 40]);
	   * // => { 'moe': 30, 'larry': 40 }
	   */
	  function object(keys, values) {
	    var index = -1,
	        length = keys ? keys.length : 0,
	        result = {};

	    while (++index < length) {
	      var key = keys[index];
	      if (values) {
	        result[key] = values[index];
	      } else {
	        result[key[0]] = key[1];
	      }
	    }
	    return result;
	  }

	  /**
	   * Creates an array of numbers (positive and/or negative) progressing from
	   * `start` up to but not including `end`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Number} [start=0] The start of the range.
	   * @param {Number} end The end of the range.
	   * @param {Number} [step=1] The value to increment or descrement by.
	   * @returns {Array} Returns a new range array.
	   * @example
	   *
	   * _.range(10);
	   * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
	   *
	   * _.range(1, 11);
	   * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
	   *
	   * _.range(0, 30, 5);
	   * // => [0, 5, 10, 15, 20, 25]
	   *
	   * _.range(0, -10, -1);
	   * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
	   *
	   * _.range(0);
	   * // => []
	   */
	  function range(start, end, step) {
	    start = +start || 0;
	    step = +step || 1;

	    if (end == null) {
	      end = start;
	      start = 0;
	    }
	    // use `Array(length)` so V8 will avoid the slower "dictionary" mode
	    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
	    var index = -1,
	        length = nativeMax(0, ceil((end - start) / step)),
	        result = Array(length);

	    while (++index < length) {
	      result[index] = start;
	      start += step;
	    }
	    return result;
	  }

	  /**
	   * The opposite of `_.initial`, this method gets all but the first value of `array`.
	   * If a number `n` is passed, the first `n` values are excluded from the result.
	   * If a `callback` function is passed, the first elements the `callback` returns
	   * truthy for are excluded from the result. The `callback` is bound to `thisArg`
	   * and invoked with three arguments; (value, index, array).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias drop, tail
	   * @category Arrays
	   * @param {Array} array The array to query.
	   * @param {Function|Object|Number|String} [callback|n=1] The function called
	   *  per element or the number of elements to exclude. If a property name or
	   *  object is passed, it will be used to create a "_.pluck" or "_.where"
	   *  style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a slice of `array`.
	   * @example
	   *
	   * _.rest([1, 2, 3]);
	   * // => [2, 3]
	   *
	   * _.rest([1, 2, 3], 2);
	   * // => [3]
	   *
	   * _.rest([1, 2, 3], function(num) {
	   *   return num < 3;
	   * });
	   * // => [3]
	   *
	   * var food = [
	   *   { 'name': 'banana', 'organic': true },
	   *   { 'name': 'beet',   'organic': false },
	   * ];
	   *
	   * // using "_.pluck" callback shorthand
	   * _.rest(food, 'organic');
	   * // => [{ 'name': 'beet', 'organic': false }]
	   *
	   * var food = [
	   *   { 'name': 'apple',  'type': 'fruit' },
	   *   { 'name': 'banana', 'type': 'fruit' },
	   *   { 'name': 'beet',   'type': 'vegetable' }
	   * ];
	   *
	   * // using "_.where" callback shorthand
	   * _.rest(food, { 'type': 'fruit' });
	   * // => [{ 'name': 'beet', 'type': 'vegetable' }]
	   */
	  function rest(array, callback, thisArg) {
	    if (typeof callback != 'number' && callback != null) {
	      var n = 0,
	          index = -1,
	          length = array ? array.length : 0;

	      callback = createCallback(callback, thisArg);
	      while (++index < length && callback(array[index], index, array)) {
	        n++;
	      }
	    } else {
	      n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
	    }
	    return slice(array, n);
	  }

	  /**
	   * Uses a binary search to determine the smallest index at which the `value`
	   * should be inserted into `array` in order to maintain the sort order of the
	   * sorted `array`. If `callback` is passed, it will be executed for `value` and
	   * each element in `array` to compute their sort ranking. The `callback` is
	   * bound to `thisArg` and invoked with one argument; (value).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to iterate over.
	   * @param {Mixed} value The value to evaluate.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Number} Returns the index at which the value should be inserted
	   *  into `array`.
	   * @example
	   *
	   * _.sortedIndex([20, 30, 50], 40);
	   * // => 2
	   *
	   * // using "_.pluck" callback shorthand
	   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
	   * // => 2
	   *
	   * var dict = {
	   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
	   * };
	   *
	   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	   *   return dict.wordToNumber[word];
	   * });
	   * // => 2
	   *
	   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
	   *   return this.wordToNumber[word];
	   * }, dict);
	   * // => 2
	   */
	  function sortedIndex(array, value, callback, thisArg) {
	    var low = 0,
	        high = array ? array.length : low;

	    // explicitly reference `identity` for better inlining in Firefox
	    callback = callback ? createCallback(callback, thisArg, 1) : identity;
	    value = callback(value);

	    while (low < high) {
	      var mid = (low + high) >>> 1;
	      callback(array[mid]) < value
	        ? low = mid + 1
	        : high = mid;
	    }
	    return low;
	  }

	  /**
	   * Computes the union of the passed-in arrays using strict equality for
	   * comparisons, i.e. `===`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} [array1, array2, ...] Arrays to process.
	   * @returns {Array} Returns a new array of unique values, in order, that are
	   *  present in one or more of the arrays.
	   * @example
	   *
	   * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
	   * // => [1, 2, 3, 101, 10]
	   */
	  function union() {
	    return uniq(concat.apply(arrayRef, arguments));
	  }

	  /**
	   * Creates a duplicate-value-free version of the `array` using strict equality
	   * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
	   * for `isSorted` will run a faster algorithm. If `callback` is passed, each
	   * element of `array` is passed through a callback` before uniqueness is computed.
	   * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
	   *
	   * If a property name is passed for `callback`, the created "_.pluck" style
	   * callback will return the property value of the given element.
	   *
	   * If an object is passed for `callback`, the created "_.where" style callback
	   * will return `true` for elements that have the propeties of the given object,
	   * else `false`.
	   *
	   * @static
	   * @memberOf _
	   * @alias unique
	   * @category Arrays
	   * @param {Array} array The array to process.
	   * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
	   * @param {Function|Object|String} [callback=identity] The function called per
	   *  iteration. If a property name or object is passed, it will be used to create
	   *  a "_.pluck" or "_.where" style callback, respectively.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a duplicate-value-free array.
	   * @example
	   *
	   * _.uniq([1, 2, 1, 3, 1]);
	   * // => [1, 2, 3]
	   *
	   * _.uniq([1, 1, 2, 2, 3], true);
	   * // => [1, 2, 3]
	   *
	   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return Math.floor(num); });
	   * // => [1, 2, 3]
	   *
	   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return this.floor(num); }, Math);
	   * // => [1, 2, 3]
	   *
	   * // using "_.pluck" callback shorthand
	   * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	   * // => [{ 'x': 1 }, { 'x': 2 }]
	   */
	  function uniq(array, isSorted, callback, thisArg) {
	    var index = -1,
	        length = array ? array.length : 0,
	        result = [],
	        seen = result;

	    // juggle arguments
	    if (typeof isSorted == 'function') {
	      thisArg = callback;
	      callback = isSorted;
	      isSorted = false;
	    }
	    // init value cache for large arrays
	    var isLarge = !isSorted && length >= 75;
	    if (isLarge) {
	      var cache = {};
	    }
	    if (callback) {
	      seen = [];
	      callback = createCallback(callback, thisArg);
	    }
	    while (++index < length) {
	      var value = array[index],
	          computed = callback ? callback(value, index, array) : value;

	      if (isLarge) {
	        var key = computed + '';
	        var inited = hasOwnProperty.call(cache, key)
	          ? !(seen = cache[key])
	          : (seen = cache[key] = []);
	      }
	      if (isSorted
	            ? !index || seen[seen.length - 1] !== computed
	            : inited || indexOf(seen, computed) < 0
	          ) {
	        if (callback || isLarge) {
	          seen.push(computed);
	        }
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Creates an array with all occurrences of the passed values removed using
	   * strict equality for comparisons, i.e. `===`.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} array The array to filter.
	   * @param {Mixed} [value1, value2, ...] Values to remove.
	   * @returns {Array} Returns a new filtered array.
	   * @example
	   *
	   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
	   * // => [2, 3, 4]
	   */
	  function without(array) {
	    var index = -1,
	        length = array ? array.length : 0,
	        contains = cachedContains(arguments, 1),
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (!contains(value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  }

	  /**
	   * Groups the elements of each array at their corresponding indexes. Useful for
	   * separate data sources that are coordinated through matching array indexes.
	   * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
	   * in a similar fashion.
	   *
	   * @static
	   * @memberOf _
	   * @category Arrays
	   * @param {Array} [array1, array2, ...] Arrays to process.
	   * @returns {Array} Returns a new array of grouped elements.
	   * @example
	   *
	   * _.zip(['moe', 'larry'], [30, 40], [true, false]);
	   * // => [['moe', 30, true], ['larry', 40, false]]
	   */
	  function zip(array) {
	    var index = -1,
	        length = array ? max(pluck(arguments, 'length')) : 0,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = pluck(arguments, index);
	    }
	    return result;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Creates a function that is restricted to executing `func` only after it is
	   * called `n` times. The `func` is executed with the `this` binding of the
	   * created function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Number} n The number of times the function must be called before
	   * it is executed.
	   * @param {Function} func The function to restrict.
	   * @returns {Function} Returns the new restricted function.
	   * @example
	   *
	   * var renderNotes = _.after(notes.length, render);
	   * _.forEach(notes, function(note) {
	   *   note.asyncSave({ 'success': renderNotes });
	   * });
	   * // `renderNotes` is run once, after all notes have saved
	   */
	  function after(n, func) {
	    if (n < 1) {
	      return func();
	    }
	    return function() {
	      if (--n < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  }

	  /**
	   * Creates a function that, when called, invokes `func` with the `this`
	   * binding of `thisArg` and prepends any additional `bind` arguments to those
	   * passed to the bound function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to bind.
	   * @param {Mixed} [thisArg] The `this` binding of `func`.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
	   * @returns {Function} Returns the new bound function.
	   * @example
	   *
	   * var func = function(greeting) {
	   *   return greeting + ' ' + this.name;
	   * };
	   *
	   * func = _.bind(func, { 'name': 'moe' }, 'hi');
	   * func();
	   * // => 'hi moe'
	   */
	  function bind(func, thisArg) {
	    // use `Function#bind` if it exists and is fast
	    // (in V8 `Function#bind` is slower except when partially applied)
	    return isBindFast || (nativeBind && arguments.length > 2)
	      ? nativeBind.call.apply(nativeBind, arguments)
	      : createBound(func, thisArg, slice(arguments, 2));
	  }

	  /**
	   * Binds methods on `object` to `object`, overwriting the existing method.
	   * Method names may be specified as individual arguments or as arrays of method
	   * names. If no method names are provided, all the function properties of `object`
	   * will be bound.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Object} object The object to bind and assign the bound methods to.
	   * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
	   * @returns {Object} Returns `object`.
	   * @example
	   *
	   * var view = {
	   *  'label': 'docs',
	   *  'onClick': function() { alert('clicked ' + this.label); }
	   * };
	   *
	   * _.bindAll(view);
	   * jQuery('#docs').on('click', view.onClick);
	   * // => alerts 'clicked docs', when the button is clicked
	   */
	  function bindAll(object) {
	    var funcs = concat.apply(arrayRef, arguments),
	        index = funcs.length > 1 ? 0 : (funcs = functions(object), -1),
	        length = funcs.length;

	    while (++index < length) {
	      var key = funcs[index];
	      object[key] = bind(object[key], object);
	    }
	    return object;
	  }

	  /**
	   * Creates a function that, when called, invokes the method at `object[key]`
	   * and prepends any additional `bindKey` arguments to those passed to the bound
	   * function. This method differs from `_.bind` by allowing bound functions to
	   * reference methods that will be redefined or don't yet exist.
	   * See http://michaux.ca/articles/lazy-function-definition-pattern.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Object} object The object the method belongs to.
	   * @param {String} key The key of the method.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
	   * @returns {Function} Returns the new bound function.
	   * @example
	   *
	   * var object = {
	   *   'name': 'moe',
	   *   'greet': function(greeting) {
	   *     return greeting + ' ' + this.name;
	   *   }
	   * };
	   *
	   * var func = _.bindKey(object, 'greet', 'hi');
	   * func();
	   * // => 'hi moe'
	   *
	   * object.greet = function(greeting) {
	   *   return greeting + ', ' + this.name + '!';
	   * };
	   *
	   * func();
	   * // => 'hi, moe!'
	   */
	  function bindKey(object, key) {
	    return createBound(object, key, slice(arguments, 2));
	  }

	  /**
	   * Creates a function that is the composition of the passed functions,
	   * where each function consumes the return value of the function that follows.
	   * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
	   * Each function is executed with the `this` binding of the composed function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} [func1, func2, ...] Functions to compose.
	   * @returns {Function} Returns the new composed function.
	   * @example
	   *
	   * var greet = function(name) { return 'hi ' + name; };
	   * var exclaim = function(statement) { return statement + '!'; };
	   * var welcome = _.compose(exclaim, greet);
	   * welcome('moe');
	   * // => 'hi moe!'
	   */
	  function compose() {
	    var funcs = arguments;
	    return function() {
	      var args = arguments,
	          length = funcs.length;

	      while (length--) {
	        args = [funcs[length].apply(this, args)];
	      }
	      return args[0];
	    };
	  }

	  /**
	   * Creates a function that will delay the execution of `func` until after
	   * `wait` milliseconds have elapsed since the last time it was invoked. Pass
	   * `true` for `immediate` to cause debounce to invoke `func` on the leading,
	   * instead of the trailing, edge of the `wait` timeout. Subsequent calls to
	   * the debounced function will return the result of the last `func` call.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to debounce.
	   * @param {Number} wait The number of milliseconds to delay.
	   * @param {Boolean} immediate A flag to indicate execution is on the leading
	   *  edge of the timeout.
	   * @returns {Function} Returns the new debounced function.
	   * @example
	   *
	   * var lazyLayout = _.debounce(calculateLayout, 300);
	   * jQuery(window).on('resize', lazyLayout);
	   */
	  function debounce(func, wait, immediate) {
	    var args,
	        result,
	        thisArg,
	        timeoutId;

	    function delayed() {
	      timeoutId = null;
	      if (!immediate) {
	        result = func.apply(thisArg, args);
	      }
	    }
	    return function() {
	      var isImmediate = immediate && !timeoutId;
	      args = arguments;
	      thisArg = this;

	      clearTimeout(timeoutId);
	      timeoutId = setTimeout(delayed, wait);

	      if (isImmediate) {
	        result = func.apply(thisArg, args);
	      }
	      return result;
	    };
	  }

	  /**
	   * Executes the `func` function after `wait` milliseconds. Additional arguments
	   * will be passed to `func` when it is invoked.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to delay.
	   * @param {Number} wait The number of milliseconds to delay execution.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
	   * @returns {Number} Returns the `setTimeout` timeout id.
	   * @example
	   *
	   * var log = _.bind(console.log, console);
	   * _.delay(log, 1000, 'logged later');
	   * // => 'logged later' (Appears after one second.)
	   */
	  function delay(func, wait) {
	    var args = slice(arguments, 2);
	    return setTimeout(function() { func.apply(undefined, args); }, wait);
	  }

	  /**
	   * Defers executing the `func` function until the current call stack has cleared.
	   * Additional arguments will be passed to `func` when it is invoked.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to defer.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
	   * @returns {Number} Returns the `setTimeout` timeout id.
	   * @example
	   *
	   * _.defer(function() { alert('deferred'); });
	   * // returns from the function before `alert` is called
	   */
	  function defer(func) {
	    var args = slice(arguments, 1);
	    return setTimeout(function() { func.apply(undefined, args); }, 1);
	  }
	  // use `setImmediate` if it's available in Node.js
	  if (isV8 && freeModule && typeof setImmediate == 'function') {
	    defer = bind(setImmediate, window);
	  }

	  /**
	   * Creates a function that memoizes the result of `func`. If `resolver` is
	   * passed, it will be used to determine the cache key for storing the result
	   * based on the arguments passed to the memoized function. By default, the first
	   * argument passed to the memoized function is used as the cache key. The `func`
	   * is executed with the `this` binding of the memoized function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to have its output memoized.
	   * @param {Function} [resolver] A function used to resolve the cache key.
	   * @returns {Function} Returns the new memoizing function.
	   * @example
	   *
	   * var fibonacci = _.memoize(function(n) {
	   *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
	   * });
	   */
	  function memoize(func, resolver) {
	    var cache = {};
	    return function() {
	      var key = (resolver ? resolver.apply(this, arguments) : arguments[0]) + '';
	      return hasOwnProperty.call(cache, key)
	        ? cache[key]
	        : (cache[key] = func.apply(this, arguments));
	    };
	  }

	  /**
	   * Creates a function that is restricted to execute `func` once. Repeat calls to
	   * the function will return the value of the first call. The `func` is executed
	   * with the `this` binding of the created function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to restrict.
	   * @returns {Function} Returns the new restricted function.
	   * @example
	   *
	   * var initialize = _.once(createApplication);
	   * initialize();
	   * initialize();
	   * // `initialize` executes `createApplication` once
	   */
	  function once(func) {
	    var ran,
	        result;

	    return function() {
	      if (ran) {
	        return result;
	      }
	      ran = true;
	      result = func.apply(this, arguments);

	      // clear the `func` variable so the function may be garbage collected
	      func = null;
	      return result;
	    };
	  }

	  /**
	   * Creates a function that, when called, invokes `func` with any additional
	   * `partial` arguments prepended to those passed to the new function. This
	   * method is similar to `_.bind`, except it does **not** alter the `this` binding.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to partially apply arguments to.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
	   * @returns {Function} Returns the new partially applied function.
	   * @example
	   *
	   * var greet = function(greeting, name) { return greeting + ' ' + name; };
	   * var hi = _.partial(greet, 'hi');
	   * hi('moe');
	   * // => 'hi moe'
	   */
	  function partial(func) {
	    return createBound(func, slice(arguments, 1));
	  }

	  /**
	   * This method is similar to `_.partial`, except that `partial` arguments are
	   * appended to those passed to the new function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to partially apply arguments to.
	   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
	   * @returns {Function} Returns the new partially applied function.
	   * @example
	   *
	   * var defaultsDeep = _.partialRight(_.merge, _.defaults);
	   *
	   * var options = {
	   *   'variable': 'data',
	   *   'imports': { 'jq': $ }
	   * };
	   *
	   * defaultsDeep(options, _.templateSettings);
	   *
	   * options.variable
	   * // => 'data'
	   *
	   * options.imports
	   * // => { '_': _, 'jq': $ }
	   */
	  function partialRight(func) {
	    return createBound(func, slice(arguments, 1), null, indicatorObject);
	  }

	  /**
	   * Creates a function that, when executed, will only call the `func`
	   * function at most once per every `wait` milliseconds. If the throttled
	   * function is invoked more than once during the `wait` timeout, `func` will
	   * also be called on the trailing edge of the timeout. Subsequent calls to the
	   * throttled function will return the result of the last `func` call.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Function} func The function to throttle.
	   * @param {Number} wait The number of milliseconds to throttle executions to.
	   * @returns {Function} Returns the new throttled function.
	   * @example
	   *
	   * var throttled = _.throttle(updatePosition, 100);
	   * jQuery(window).on('scroll', throttled);
	   */
	  function throttle(func, wait) {
	    var args,
	        result,
	        thisArg,
	        timeoutId,
	        lastCalled = 0;

	    function trailingCall() {
	      lastCalled = new Date;
	      timeoutId = null;
	      result = func.apply(thisArg, args);
	    }
	    return function() {
	      var now = new Date,
	          remaining = wait - (now - lastCalled);

	      args = arguments;
	      thisArg = this;

	      if (remaining <= 0) {
	        clearTimeout(timeoutId);
	        timeoutId = null;
	        lastCalled = now;
	        result = func.apply(thisArg, args);
	      }
	      else if (!timeoutId) {
	        timeoutId = setTimeout(trailingCall, remaining);
	      }
	      return result;
	    };
	  }

	  /**
	   * Creates a function that passes `value` to the `wrapper` function as its
	   * first argument. Additional arguments passed to the function are appended
	   * to those passed to the `wrapper` function. The `wrapper` is executed with
	   * the `this` binding of the created function.
	   *
	   * @static
	   * @memberOf _
	   * @category Functions
	   * @param {Mixed} value The value to wrap.
	   * @param {Function} wrapper The wrapper function.
	   * @returns {Function} Returns the new function.
	   * @example
	   *
	   * var hello = function(name) { return 'hello ' + name; };
	   * hello = _.wrap(hello, function(func) {
	   *   return 'before, ' + func('moe') + ', after';
	   * });
	   * hello();
	   * // => 'before, hello moe, after'
	   */
	  function wrap(value, wrapper) {
	    return function() {
	      var args = [value];
	      push.apply(args, arguments);
	      return wrapper.apply(this, args);
	    };
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
	   * corresponding HTML entities.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {String} string The string to escape.
	   * @returns {String} Returns the escaped string.
	   * @example
	   *
	   * _.escape('Moe, Larry & Curly');
	   * // => 'Moe, Larry &amp; Curly'
	   */
	  function escape(string) {
	    return string == null ? '' : (string + '').replace(reUnescapedHtml, escapeHtmlChar);
	  }

	  /**
	   * This function returns the first argument passed to it.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Mixed} value Any value.
	   * @returns {Mixed} Returns `value`.
	   * @example
	   *
	   * var moe = { 'name': 'moe' };
	   * moe === _.identity(moe);
	   * // => true
	   */
	  function identity(value) {
	    return value;
	  }

	  /**
	   * Adds functions properties of `object` to the `lodash` function and chainable
	   * wrapper.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Object} object The object of function properties to add to `lodash`.
	   * @example
	   *
	   * _.mixin({
	   *   'capitalize': function(string) {
	   *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
	   *   }
	   * });
	   *
	   * _.capitalize('moe');
	   * // => 'Moe'
	   *
	   * _('moe').capitalize();
	   * // => 'Moe'
	   */
	  function mixin(object) {
	    forEach(functions(object), function(methodName) {
	      var func = lodash[methodName] = object[methodName];

	      lodash.prototype[methodName] = function() {
	        var args = [this.__wrapped__];
	        push.apply(args, arguments);
	        return new lodash(func.apply(lodash, args));
	      };
	    });
	  }

	  /**
	   * Reverts the '_' variable to its previous value and returns a reference to
	   * the `lodash` function.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @returns {Function} Returns the `lodash` function.
	   * @example
	   *
	   * var lodash = _.noConflict();
	   */
	  function noConflict() {
	    window._ = oldDash;
	    return this;
	  }

	  /**
	   * Produces a random number between `min` and `max` (inclusive). If only one
	   * argument is passed, a number between `0` and the given number will be returned.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Number} [min=0] The minimum possible value.
	   * @param {Number} [max=1] The maximum possible value.
	   * @returns {Number} Returns a random number.
	   * @example
	   *
	   * _.random(0, 5);
	   * // => a number between 0 and 5
	   *
	   * _.random(5);
	   * // => also a number between 0 and 5
	   */
	  function random(min, max) {
	    if (min == null && max == null) {
	      max = 1;
	    }
	    min = +min || 0;
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + floor(nativeRandom() * ((+max || 0) - min + 1));
	  }

	  /**
	   * Resolves the value of `property` on `object`. If `property` is a function,
	   * it will be invoked and its result returned, else the property value is
	   * returned. If `object` is falsey, then `null` is returned.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Object} object The object to inspect.
	   * @param {String} property The property to get the value of.
	   * @returns {Mixed} Returns the resolved value.
	   * @example
	   *
	   * var object = {
	   *   'cheese': 'crumpets',
	   *   'stuff': function() {
	   *     return 'nonsense';
	   *   }
	   * };
	   *
	   * _.result(object, 'cheese');
	   * // => 'crumpets'
	   *
	   * _.result(object, 'stuff');
	   * // => 'nonsense'
	   */
	  function result(object, property) {
	    var value = object ? object[property] : undefined;
	    return isFunction(value) ? object[property]() : value;
	  }

	  /**
	   * A micro-templating method that handles arbitrary delimiters, preserves
	   * whitespace, and correctly escapes quotes within interpolated code.
	   *
	   * Note: In the development build, `_.template` utilizes sourceURLs for easier
	   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	   *
	   * Note: Lo-Dash may be used in Chrome extensions by either creating a `lodash csp`
	   * build and using precompiled templates, or loading Lo-Dash in a sandbox.
	   *
	   * For more information on precompiling templates see:
	   * http://lodash.com/#custom-builds
	   *
	   * For more information on Chrome extension sandboxes see:
	   * http://developer.chrome.com/stable/extensions/sandboxingEval.html
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {String} text The template text.
	   * @param {Obect} data The data object used to populate the text.
	   * @param {Object} options The options object.
	   *  escape - The "escape" delimiter regexp.
	   *  evaluate - The "evaluate" delimiter regexp.
	   *  interpolate - The "interpolate" delimiter regexp.
	   *  sourceURL - The sourceURL of the template's compiled source.
	   *  variable - The data object variable name.
	   *
	   * @returns {Function|String} Returns a compiled function when no `data` object
	   *  is given, else it returns the interpolated text.
	   * @example
	   *
	   * // using a compiled template
	   * var compiled = _.template('hello <%= name %>');
	   * compiled({ 'name': 'moe' });
	   * // => 'hello moe'
	   *
	   * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
	   * _.template(list, { 'people': ['moe', 'larry'] });
	   * // => '<li>moe</li><li>larry</li>'
	   *
	   * // using the "escape" delimiter to escape HTML in data property values
	   * _.template('<b><%- value %></b>', { 'value': '<script>' });
	   * // => '<b>&lt;script&gt;</b>'
	   *
	   * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
	   * _.template('hello ${ name }', { 'name': 'curly' });
	   * // => 'hello curly'
	   *
	   * // using the internal `print` function in "evaluate" delimiters
	   * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
	   * // => 'hello stooge!'
	   *
	   * // using custom template delimiters
	   * _.templateSettings = {
	   *   'interpolate': /{{([\s\S]+?)}}/g
	   * };
	   *
	   * _.template('hello {{ name }}!', { 'name': 'mustache' });
	   * // => 'hello mustache!'
	   *
	   * // using the `sourceURL` option to specify a custom sourceURL for the template
	   * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
	   * compiled(data);
	   * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	   *
	   * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	   * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
	   * compiled.source;
	   * // => function(data) {
	   *   var __t, __p = '', __e = _.escape;
	   *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
	   *   return __p;
	   * }
	   *
	   * // using the `source` property to inline compiled templates for meaningful
	   * // line numbers in error messages and a stack trace
	   * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	   *   var JST = {\
	   *     "main": ' + _.template(mainText).source + '\
	   *   };\
	   * ');
	   */
	  function template(text, data, options) {
	    // based on John Resig's `tmpl` implementation
	    // http://ejohn.org/blog/javascript-micro-templating/
	    // and Laura Doktorova's doT.js
	    // https://github.com/olado/doT
	    var settings = lodash.templateSettings;
	    text || (text = '');

	    // avoid missing dependencies when `iteratorTemplate` is not defined
	    options = defaults({}, options, settings);

	    var imports = defaults({}, options.imports, settings.imports),
	        importsKeys = keys(imports),
	        importsValues = values(imports);

	    var isEvaluating,
	        index = 0,
	        interpolate = options.interpolate || reNoMatch,
	        source = "__p += '";

	    // compile regexp to match each delimiter
	    var reDelimiters = RegExp(
	      (options.escape || reNoMatch).source + '|' +
	      interpolate.source + '|' +
	      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	      (options.evaluate || reNoMatch).source + '|$'
	    , 'g');

	    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	      interpolateValue || (interpolateValue = esTemplateValue);

	      // escape characters that cannot be included in string literals
	      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	      // replace delimiters with snippets
	      if (escapeValue) {
	        source += "' +\n__e(" + escapeValue + ") +\n'";
	      }
	      if (evaluateValue) {
	        isEvaluating = true;
	        source += "';\n" + evaluateValue + ";\n__p += '";
	      }
	      if (interpolateValue) {
	        source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	      }
	      index = offset + match.length;

	      // the JS engine embedded in Adobe products requires returning the `match`
	      // string in order to produce the correct `offset` value
	      return match;
	    });

	    source += "';\n";

	    // if `variable` is not specified and the template contains "evaluate"
	    // delimiters, wrap a with-statement around the generated code to add the
	    // data object to the top of the scope chain
	    var variable = options.variable,
	        hasVariable = variable;

	    if (!hasVariable) {
	      variable = 'obj';
	      source = 'with (' + variable + ') {\n' + source + '\n}\n';
	    }
	    // cleanup code by stripping empty strings
	    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	      .replace(reEmptyStringMiddle, '$1')
	      .replace(reEmptyStringTrailing, '$1;');

	    // frame code as the function body
	    source = 'function(' + variable + ') {\n' +
	      (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
	      "var __t, __p = '', __e = _.escape" +
	      (isEvaluating
	        ? ', __j = Array.prototype.join;\n' +
	          "function print() { __p += __j.call(arguments, '') }\n"
	        : ';\n'
	      ) +
	      source +
	      'return __p\n}';

	    // Use a sourceURL for easier debugging and wrap in a multi-line comment to
	    // avoid issues with Narwhal, IE conditional compilation, and the JS engine
	    // embedded in Adobe products.
	    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
	    var sourceURL = '\n/*\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']') + '\n*/';

	    try {
	      var result = Function(importsKeys, 'return ' + source + sourceURL).apply(undefined, importsValues);
	    } catch(e) {
	      e.source = source;
	      throw e;
	    }
	    if (data) {
	      return result(data);
	    }
	    // provide the compiled function's source via its `toString` method, in
	    // supported environments, or the `source` property as a convenience for
	    // inlining compiled templates during the build process
	    result.source = source;
	    return result;
	  }

	  /**
	   * Executes the `callback` function `n` times, returning an array of the results
	   * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
	   * with one argument; (index).
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {Number} n The number of times to execute the callback.
	   * @param {Function} callback The function called per iteration.
	   * @param {Mixed} [thisArg] The `this` binding of `callback`.
	   * @returns {Array} Returns a new array of the results of each `callback` execution.
	   * @example
	   *
	   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
	   * // => [3, 6, 4]
	   *
	   * _.times(3, function(n) { mage.castSpell(n); });
	   * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
	   *
	   * _.times(3, function(n) { this.cast(n); }, mage);
	   * // => also calls `mage.castSpell(n)` three times
	   */
	  function times(n, callback, thisArg) {
	    n = +n || 0;
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = callback.call(thisArg, index);
	    }
	    return result;
	  }

	  /**
	   * The opposite of `_.escape`, this method converts the HTML entities
	   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
	   * corresponding characters.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {String} string The string to unescape.
	   * @returns {String} Returns the unescaped string.
	   * @example
	   *
	   * _.unescape('Moe, Larry &amp; Curly');
	   * // => 'Moe, Larry & Curly'
	   */
	  function unescape(string) {
	    return string == null ? '' : (string + '').replace(reEscapedHtml, unescapeHtmlChar);
	  }

	  /**
	   * Generates a unique ID. If `prefix` is passed, the ID will be appended to it.
	   *
	   * @static
	   * @memberOf _
	   * @category Utilities
	   * @param {String} [prefix] The value to prefix the ID with.
	   * @returns {String} Returns the unique ID.
	   * @example
	   *
	   * _.uniqueId('contact_');
	   * // => 'contact_104'
	   *
	   * _.uniqueId();
	   * // => '105'
	   */
	  function uniqueId(prefix) {
	    var id = ++idCounter;
	    return (prefix == null ? '' : prefix + '') + id;
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Invokes `interceptor` with the `value` as the first argument, and then
	   * returns `value`. The purpose of this method is to "tap into" a method chain,
	   * in order to perform operations on intermediate results within the chain.
	   *
	   * @static
	   * @memberOf _
	   * @category Chaining
	   * @param {Mixed} value The value to pass to `interceptor`.
	   * @param {Function} interceptor The function to invoke.
	   * @returns {Mixed} Returns `value`.
	   * @example
	   *
	   * _([1, 2, 3, 4])
	   *  .filter(function(num) { return num % 2 == 0; })
	   *  .tap(alert)
	   *  .map(function(num) { return num * num; })
	   *  .value();
	   * // => // [2, 4] (alerted)
	   * // => [4, 16]
	   */
	  function tap(value, interceptor) {
	    interceptor(value);
	    return value;
	  }

	  /**
	   * Produces the `toString` result of the wrapped value.
	   *
	   * @name toString
	   * @memberOf _
	   * @category Chaining
	   * @returns {String} Returns the string result.
	   * @example
	   *
	   * _([1, 2, 3]).toString();
	   * // => '1,2,3'
	   */
	  function wrapperToString() {
	    return this.__wrapped__ + '';
	  }

	  /**
	   * Extracts the wrapped value.
	   *
	   * @name valueOf
	   * @memberOf _
	   * @alias value
	   * @category Chaining
	   * @returns {Mixed} Returns the wrapped value.
	   * @example
	   *
	   * _([1, 2, 3]).valueOf();
	   * // => [1, 2, 3]
	   */
	  function wrapperValueOf() {
	    return this.__wrapped__;
	  }

	  /*--------------------------------------------------------------------------*/

	  // add functions that return wrapped values when chaining
	  lodash.after = after;
	  lodash.assign = assign;
	  lodash.at = at;
	  lodash.bind = bind;
	  lodash.bindAll = bindAll;
	  lodash.bindKey = bindKey;
	  lodash.compact = compact;
	  lodash.compose = compose;
	  lodash.countBy = countBy;
	  lodash.debounce = debounce;
	  lodash.defaults = defaults;
	  lodash.defer = defer;
	  lodash.delay = delay;
	  lodash.difference = difference;
	  lodash.filter = filter;
	  lodash.flatten = flatten;
	  lodash.forEach = forEach;
	  lodash.forIn = forIn;
	  lodash.forOwn = forOwn;
	  lodash.functions = functions;
	  lodash.groupBy = groupBy;
	  lodash.initial = initial;
	  lodash.intersection = intersection;
	  lodash.invert = invert;
	  lodash.invoke = invoke;
	  lodash.keys = keys;
	  lodash.map = map;
	  lodash.max = max;
	  lodash.memoize = memoize;
	  lodash.merge = merge;
	  lodash.min = min;
	  lodash.object = object;
	  lodash.omit = omit;
	  lodash.once = once;
	  lodash.pairs = pairs;
	  lodash.partial = partial;
	  lodash.partialRight = partialRight;
	  lodash.pick = pick;
	  lodash.pluck = pluck;
	  lodash.range = range;
	  lodash.reject = reject;
	  lodash.rest = rest;
	  lodash.shuffle = shuffle;
	  lodash.sortBy = sortBy;
	  lodash.tap = tap;
	  lodash.throttle = throttle;
	  lodash.times = times;
	  lodash.toArray = toArray;
	  lodash.union = union;
	  lodash.uniq = uniq;
	  lodash.values = values;
	  lodash.where = where;
	  lodash.without = without;
	  lodash.wrap = wrap;
	  lodash.zip = zip;

	  // add aliases
	  lodash.collect = map;
	  lodash.drop = rest;
	  lodash.each = forEach;
	  lodash.extend = assign;
	  lodash.methods = functions;
	  lodash.select = filter;
	  lodash.tail = rest;
	  lodash.unique = uniq;

	  // add functions to `lodash.prototype`
	  mixin(lodash);

	  /*--------------------------------------------------------------------------*/

	  // add functions that return unwrapped values when chaining
	  lodash.clone = clone;
	  lodash.cloneDeep = cloneDeep;
	  lodash.contains = contains;
	  lodash.escape = escape;
	  lodash.every = every;
	  lodash.find = find;
	  lodash.has = has;
	  lodash.identity = identity;
	  lodash.indexOf = indexOf;
	  lodash.isArguments = isArguments;
	  lodash.isArray = isArray;
	  lodash.isBoolean = isBoolean;
	  lodash.isDate = isDate;
	  lodash.isElement = isElement;
	  lodash.isEmpty = isEmpty;
	  lodash.isEqual = isEqual;
	  lodash.isFinite = isFinite;
	  lodash.isFunction = isFunction;
	  lodash.isNaN = isNaN;
	  lodash.isNull = isNull;
	  lodash.isNumber = isNumber;
	  lodash.isObject = isObject;
	  lodash.isPlainObject = isPlainObject;
	  lodash.isRegExp = isRegExp;
	  lodash.isString = isString;
	  lodash.isUndefined = isUndefined;
	  lodash.lastIndexOf = lastIndexOf;
	  lodash.mixin = mixin;
	  lodash.noConflict = noConflict;
	  lodash.random = random;
	  lodash.reduce = reduce;
	  lodash.reduceRight = reduceRight;
	  lodash.result = result;
	  lodash.size = size;
	  lodash.some = some;
	  lodash.sortedIndex = sortedIndex;
	  lodash.template = template;
	  lodash.unescape = unescape;
	  lodash.uniqueId = uniqueId;

	  // add aliases
	  lodash.all = every;
	  lodash.any = some;
	  lodash.detect = find;
	  lodash.foldl = reduce;
	  lodash.foldr = reduceRight;
	  lodash.include = contains;
	  lodash.inject = reduce;

	  forOwn(lodash, function(func, methodName) {
	    if (!lodash.prototype[methodName]) {
	      lodash.prototype[methodName] = function() {
	        var args = [this.__wrapped__];
	        push.apply(args, arguments);
	        return func.apply(lodash, args);
	      };
	    }
	  });

	  /*--------------------------------------------------------------------------*/

	  // add functions capable of returning wrapped and unwrapped values when chaining
	  lodash.first = first;
	  lodash.last = last;

	  // add aliases
	  lodash.take = first;
	  lodash.head = first;

	  forOwn(lodash, function(func, methodName) {
	    if (!lodash.prototype[methodName]) {
	      lodash.prototype[methodName]= function(callback, thisArg) {
	        var result = func(this.__wrapped__, callback, thisArg);
	        return callback == null || (thisArg && typeof callback != 'function')
	          ? result
	          : new lodash(result);
	      };
	    }
	  });

	  /*--------------------------------------------------------------------------*/

	  /**
	   * The semantic version number.
	   *
	   * @static
	   * @memberOf _
	   * @type String
	   */
	  lodash.VERSION = '1.0.2';

	  // add "Chaining" functions to the wrapper
	  lodash.prototype.toString = wrapperToString;
	  lodash.prototype.value = wrapperValueOf;
	  lodash.prototype.valueOf = wrapperValueOf;

	  // add `Array` functions that return unwrapped values
	  each(['join', 'pop', 'shift'], function(methodName) {
	    var func = arrayRef[methodName];
	    lodash.prototype[methodName] = function() {
	      return func.apply(this.__wrapped__, arguments);
	    };
	  });

	  // add `Array` functions that return the wrapped value
	  each(['push', 'reverse', 'sort', 'unshift'], function(methodName) {
	    var func = arrayRef[methodName];
	    lodash.prototype[methodName] = function() {
	      func.apply(this.__wrapped__, arguments);
	      return this;
	    };
	  });

	  // add `Array` functions that return new wrapped values
	  each(['concat', 'slice', 'splice'], function(methodName) {
	    var func = arrayRef[methodName];
	    lodash.prototype[methodName] = function() {
	      return new lodash(func.apply(this.__wrapped__, arguments));
	    };
	  });

	  // avoid array-like object bugs with `Array#shift` and `Array#splice`
	  // in Firefox < 10 and IE < 9
	  if (hasObjectSpliceBug) {
	    each(['pop', 'shift', 'splice'], function(methodName) {
	      var func = arrayRef[methodName],
	          isSplice = methodName == 'splice';

	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            result = func.apply(value, arguments);

	        if (value.length === 0) {
	          delete value[0];
	        }
	        return isSplice ? new lodash(result) : result;
	      };
	    });
	  }

	  /*--------------------------------------------------------------------------*/

	  // expose Lo-Dash
	  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
	  if (true) {
	    // Expose Lo-Dash to the global object even when an AMD loader is present in
	    // case Lo-Dash was injected by a third-party script and not intended to be
	    // loaded as a module. The global assignment can be reverted in the Lo-Dash
	    // module via its `noConflict()` method.
	    window._ = lodash;

	    // define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return lodash;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // check for `exports` after `define` in case a build optimizer adds an `exports` object
	  else if (freeExports) {
	    // in Node.js or RingoJS v0.8.0+
	    if (freeModule) {
	      (freeModule.exports = lodash)._ = lodash;
	    }
	    // in Narwhal or RingoJS v0.7.0-
	    else {
	      freeExports._ = lodash;
	    }
	  }
	  else {
	    // in a browser or Rhino
	    window._ = lodash;
	  }
	}(this));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module), (function() { return this; }()), __webpack_require__(34).setImmediate))

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./minimatch": 12,
		"./minimatch.js": 12,
		"./test/basic": 57,
		"./test/basic.js": 57,
		"./test/brace-expand": 58,
		"./test/brace-expand.js": 58,
		"./test/caching": 59,
		"./test/caching.js": 59,
		"./test/defaults": 60,
		"./test/defaults.js": 60,
		"./test/extglob-ending-with-state-char": 61,
		"./test/extglob-ending-with-state-char.js": 61
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 200;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var format = __webpack_require__(9).format;

	var sparkles = __webpack_require__(77);

	var levels = [
	  'debug',
	  'info',
	  'warn',
	  'error'
	];

	function getLogger(namespace){
	  var logger = sparkles(namespace);

	  levels.forEach(function(level){
	    logger[level] = makeLogLevel(level);
	  });

	  return logger;
	}

	function makeLogLevel(level){
	  return function(msg){
	    if(typeof msg === 'string'){
	      msg = format.apply(null, arguments);
	    }

	    this.emit(level, msg);
	  };
	}

	module.exports = getLogger;


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = {
	  File: __webpack_require__(214),
	  replaceExtension: __webpack_require__(72),
	  colors: __webpack_require__(37),
	  date: __webpack_require__(176),
	  log: __webpack_require__(210),
	  template: __webpack_require__(212),
	  env: __webpack_require__(206),
	  beep: __webpack_require__(135),
	  noop: __webpack_require__(211),
	  isStream: __webpack_require__(209),
	  isBuffer: __webpack_require__(207),
	  isNull: __webpack_require__(208),
	  linefeed: '\n',
	  combine: __webpack_require__(205),
	  buffer: __webpack_require__(204),
	  PluginError: __webpack_require__(203)
	};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	var util = __webpack_require__(9);
	var arrayDiffer = __webpack_require__(126);
	var arrayUniq = __webpack_require__(127);
	var chalk = __webpack_require__(37);
	var objectAssign = __webpack_require__(213);

	var nonEnumberableProperties = ['name', 'message', 'stack'];
	var propertiesNotToDisplay = nonEnumberableProperties.concat(['plugin', 'showStack', 'showProperties', '__safety', '_stack']);

	// wow what a clusterfuck
	var parseOptions = function(plugin, message, opt) {
	  opt = opt || {};
	  if (typeof plugin === 'object') {
	    opt = plugin;
	  } else {
	    if (message instanceof Error) {
	      opt.error = message;
	    } else if (typeof message === 'object') {
	      opt = message;
	    } else {
	      opt.message = message;
	    }
	    opt.plugin = plugin;
	  }

	  return objectAssign({
	    showStack: false,
	    showProperties: true
	  }, opt);
	};

	function PluginError(plugin, message, opt) {
	  if (!(this instanceof PluginError)) throw new Error('Call PluginError using new');

	  Error.call(this);

	  var options = parseOptions(plugin, message, opt);
	  var self = this;

	  // if options has an error, grab details from it
	  if (options.error) {
	    // These properties are not enumerable, so we have to add them explicitly.
	    arrayUniq(Object.keys(options.error).concat(nonEnumberableProperties))
	      .forEach(function(prop) {
	        self[prop] = options.error[prop];
	      });
	  }

	  var properties = ['name', 'message', 'fileName', 'lineNumber', 'stack', 'showStack', 'showProperties', 'plugin'];

	  // options object can override
	  properties.forEach(function(prop) {
	    if (prop in options) this[prop] = options[prop];
	  }, this);

	  // defaults
	  if (!this.name) this.name = 'Error';

	  if (!this.stack) {
	    // Error.captureStackTrace appends a stack property which relies on the toString method of the object it is applied to.
	    // Since we are using our own toString method which controls when to display the stack trace if we don't go through this
	    // safety object, then we'll get stack overflow problems.
	    var safety = {
	      toString: function() {
	        return this._messageWithDetails() + '\nStack:';
	      }.bind(this)
	    };
	    Error.captureStackTrace(safety, arguments.callee || this.constructor);
	    this.__safety = safety;
	  }

	  if (!this.plugin) throw new Error('Missing plugin name');
	  if (!this.message) throw new Error('Missing error message');
	}

	util.inherits(PluginError, Error);

	PluginError.prototype._messageWithDetails = function() {
	  var messageWithDetails = 'Message:\n    ' + this.message;
	  var details = this._messageDetails();

	  if (details !== '') {
	    messageWithDetails += '\n' + details;
	  }

	  return messageWithDetails;
	};

	PluginError.prototype._messageDetails = function() {
	  if (!this.showProperties) {
	    return '';
	  }

	  var properties = arrayDiffer(Object.keys(this), propertiesNotToDisplay);

	  if (properties.length === 0) {
	    return '';
	  }

	  var self = this;
	  properties = properties.map(function stringifyProperty(prop) {
	    return '    ' + prop + ': ' + self[prop];
	  });

	  return 'Details:\n' + properties.join('\n');
	};

	PluginError.prototype.toString = function () {
	  var sig = chalk.red(this.name) + ' in plugin \'' + chalk.cyan(this.plugin) + '\'';
	  var detailsWithStack = function(stack) {
	    return this._messageWithDetails() + '\nStack:\n' + stack;
	  }.bind(this);

	  var msg;
	  if (this.showStack) {
	    if (this.__safety) { // There is no wrapped error, use the stack captured in the PluginError ctor
	      msg = this.__safety.stack;
	    } else if (this._stack) {
	      msg = detailsWithStack(this._stack);
	    } else { // Stack from wrapped error
	      msg = detailsWithStack(this.stack);
	    }
	  } else {
	    msg = this._messageWithDetails();
	  }

	  return sig + '\n' + msg;
	};

	module.exports = PluginError;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	var through = __webpack_require__(62);

	module.exports = function(fn) {
	  var buf = [];
	  var end = function(cb) {
	    this.push(buf);
	    cb();
	    if(fn) fn(null, buf);
	  };
	  var push = function(data, enc, cb) {
	    buf.push(data);
	    cb();
	  };
	  return through.obj(push, end);
	};


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	var pipeline = __webpack_require__(265);

	module.exports = function(){
	  var args = arguments;
	  if (args.length === 1 && Array.isArray(args[0])) {
	    args = args[0];
	  }
	  return function(){
	    return pipeline.apply(pipeline, args);
	  };
	};


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var parseArgs = __webpack_require__(264);
	var argv = parseArgs(process.argv.slice(2));

	module.exports = argv;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	var buf = __webpack_require__(2);
	var Buffer = buf.Buffer;

	// could use Buffer.isBuffer but this is the same exact thing...
	module.exports = function(o) {
	  return typeof o === 'object' && o instanceof Buffer;
	};


/***/ },
/* 208 */
/***/ function(module, exports) {

	module.exports = function(v) {
	  return v === null;
	};


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(3).Stream;

	module.exports = function(o) {
	  return !!o && o instanceof Stream;
	};


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	var hasGulplog = __webpack_require__(223);

	module.exports = function(){
	  if(hasGulplog()){
	    // specifically deferring loading here to keep from registering it globally
	    var gulplog = __webpack_require__(220);
	    gulplog.info.apply(gulplog, arguments);
	  } else {
	    // specifically defering loading because it might not be used
	    var fancylog = __webpack_require__(186);
	    fancylog.apply(null, arguments);
	  }
	  return this;
	};


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	var through = __webpack_require__(62);

	module.exports = function () {
	  return through.obj();
	};


/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	var template = __webpack_require__(262);
	var reEscape = __webpack_require__(254);
	var reEvaluate = __webpack_require__(255);
	var reInterpolate = __webpack_require__(41);

	var forcedSettings = {
	  escape: reEscape,
	  evaluate: reEvaluate,
	  interpolate: reInterpolate
	};

	module.exports = function(tmpl, data) {
	  var fn = template(tmpl, forcedSettings);

	  var wrapped = function(o) {
	    if (typeof o === 'undefined' || typeof o.file === 'undefined') {
	      throw new Error('Failed to provide the current file as "file" to the template');
	    }
	    return fn(o);
	  };

	  return (data ? wrapped(data) : wrapped);
	};


/***/ },
/* 213 */
/***/ function(module, exports) {

	'use strict';
	var propIsEnumerable = Object.prototype.propertyIsEnumerable;

	function ToObject(val) {
		if (val == null) {
			throw new TypeError('Object.assign cannot be called with null or undefined');
		}

		return Object(val);
	}

	function ownEnumerableKeys(obj) {
		var keys = Object.getOwnPropertyNames(obj);

		if (Object.getOwnPropertySymbols) {
			keys = keys.concat(Object.getOwnPropertySymbols(obj));
		}

		return keys.filter(function (key) {
			return propIsEnumerable.call(obj, key);
		});
	}

	module.exports = Object.assign || function (target, source) {
		var from;
		var keys;
		var to = ToObject(target);

		for (var s = 1; s < arguments.length; s++) {
			from = arguments[s];
			keys = ownEnumerableKeys(Object(from));

			for (var i = 0; i < keys.length; i++) {
				to[keys[i]] = from[keys[i]];
			}
		}

		return to;
	};


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(6);
	var clone = __webpack_require__(48);
	var cloneStats = __webpack_require__(47);
	var cloneBuffer = __webpack_require__(215);
	var isBuffer = __webpack_require__(217);
	var isStream = __webpack_require__(63);
	var isNull = __webpack_require__(218);
	var inspectStream = __webpack_require__(216);
	var Stream = __webpack_require__(3);
	var replaceExt = __webpack_require__(72);

	function File(file) {
	  if (!file) file = {};

	  // record path change
	  var history = file.path ? [file.path] : file.history;
	  this.history = history || [];

	  this.cwd = file.cwd || process.cwd();
	  this.base = file.base || this.cwd;

	  // stat = files stats object
	  this.stat = file.stat || null;

	  // contents = stream, buffer, or null if not read
	  this.contents = file.contents || null;

	  this._isVinyl = true;
	}

	File.prototype.isBuffer = function() {
	  return isBuffer(this.contents);
	};

	File.prototype.isStream = function() {
	  return isStream(this.contents);
	};

	File.prototype.isNull = function() {
	  return isNull(this.contents);
	};

	// TODO: should this be moved to vinyl-fs?
	File.prototype.isDirectory = function() {
	  return this.isNull() && this.stat && this.stat.isDirectory();
	};

	File.prototype.clone = function(opt) {
	  if (typeof opt === 'boolean') {
	    opt = {
	      deep: opt,
	      contents: true
	    };
	  } else if (!opt) {
	    opt = {
	      deep: true,
	      contents: true
	    };
	  } else {
	    opt.deep = opt.deep === true;
	    opt.contents = opt.contents !== false;
	  }

	  // clone our file contents
	  var contents;
	  if (this.isStream()) {
	    contents = this.contents.pipe(new Stream.PassThrough());
	    this.contents = this.contents.pipe(new Stream.PassThrough());
	  } else if (this.isBuffer()) {
	    contents = opt.contents ? cloneBuffer(this.contents) : this.contents;
	  }

	  var file = new File({
	    cwd: this.cwd,
	    base: this.base,
	    stat: (this.stat ? cloneStats(this.stat) : null),
	    history: this.history.slice(),
	    contents: contents
	  });

	  // clone our custom properties
	  Object.keys(this).forEach(function(key) {
	    // ignore built-in fields
	    if (key === '_contents' || key === 'stat' ||
	      key === 'history' || key === 'path' ||
	      key === 'base' || key === 'cwd') {
	      return;
	    }
	    file[key] = opt.deep ? clone(this[key], true) : this[key];
	  }, this);
	  return file;
	};

	File.prototype.pipe = function(stream, opt) {
	  if (!opt) opt = {};
	  if (typeof opt.end === 'undefined') opt.end = true;

	  if (this.isStream()) {
	    return this.contents.pipe(stream, opt);
	  }
	  if (this.isBuffer()) {
	    if (opt.end) {
	      stream.end(this.contents);
	    } else {
	      stream.write(this.contents);
	    }
	    return stream;
	  }

	  // isNull
	  if (opt.end) stream.end();
	  return stream;
	};

	File.prototype.inspect = function() {
	  var inspect = [];

	  // use relative path if possible
	  var filePath = (this.base && this.path) ? this.relative : this.path;

	  if (filePath) {
	    inspect.push('"'+filePath+'"');
	  }

	  if (this.isBuffer()) {
	    inspect.push(this.contents.inspect());
	  }

	  if (this.isStream()) {
	    inspect.push(inspectStream(this.contents));
	  }

	  return '<File '+inspect.join(' ')+'>';
	};

	File.isVinyl = function(file) {
	  return file && file._isVinyl === true;
	};

	// virtual attributes
	// or stuff with extra logic
	Object.defineProperty(File.prototype, 'contents', {
	  get: function() {
	    return this._contents;
	  },
	  set: function(val) {
	    if (!isBuffer(val) && !isStream(val) && !isNull(val)) {
	      throw new Error('File.contents can only be a Buffer, a Stream, or null.');
	    }
	    this._contents = val;
	  }
	});

	// TODO: should this be moved to vinyl-fs?
	Object.defineProperty(File.prototype, 'relative', {
	  get: function() {
	    if (!this.base) throw new Error('No base specified! Can not get relative.');
	    if (!this.path) throw new Error('No path specified! Can not get relative.');
	    return path.relative(this.base, this.path);
	  },
	  set: function() {
	    throw new Error('File.relative is generated from the base and path attributes. Do not modify it.');
	  }
	});

	Object.defineProperty(File.prototype, 'dirname', {
	  get: function() {
	    if (!this.path) throw new Error('No path specified! Can not get dirname.');
	    return path.dirname(this.path);
	  },
	  set: function(dirname) {
	    if (!this.path) throw new Error('No path specified! Can not set dirname.');
	    this.path = path.join(dirname, path.basename(this.path));
	  }
	});

	Object.defineProperty(File.prototype, 'basename', {
	  get: function() {
	    if (!this.path) throw new Error('No path specified! Can not get basename.');
	    return path.basename(this.path);
	  },
	  set: function(basename) {
	    if (!this.path) throw new Error('No path specified! Can not set basename.');
	    this.path = path.join(path.dirname(this.path), basename);
	  }
	});

	Object.defineProperty(File.prototype, 'extname', {
	  get: function() {
	    if (!this.path) throw new Error('No path specified! Can not get extname.');
	    return path.extname(this.path);
	  },
	  set: function(extname) {
	    if (!this.path) throw new Error('No path specified! Can not set extname.');
	    this.path = replaceExt(this.path, extname);
	  }
	});

	Object.defineProperty(File.prototype, 'path', {
	  get: function() {
	    return this.history[this.history.length - 1];
	  },
	  set: function(path) {
	    if (typeof path !== 'string') throw new Error('path should be string');

	    // record history only when path changed
	    if (path && path !== this.path) {
	      this.history.push(path);
	    }
	  }
	});

	module.exports = File;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(2).Buffer;

	module.exports = function(buf) {
	  var out = new Buffer(buf.length);
	  buf.copy(out);
	  return out;
	};


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	var isStream = __webpack_require__(63);

	module.exports = function(stream) {
	  if (!isStream(stream)) return;

	  var streamType = stream.constructor.name;
	  // avoid StreamStream
	  if (streamType === 'Stream') streamType = '';

	  return '<'+streamType+'Stream>';
	};


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(2).Buffer.isBuffer;


/***/ },
/* 218 */
/***/ function(module, exports) {

	module.exports = function(v) {
	  return v === null;
	};


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var util = __webpack_require__(9);
	var Orchestrator = __webpack_require__(268);
	var gutil = __webpack_require__(202);
	var deprecated = __webpack_require__(177);
	var vfs = __webpack_require__(303);

	function Gulp() {
	  Orchestrator.call(this);
	}
	util.inherits(Gulp, Orchestrator);

	Gulp.prototype.task = Gulp.prototype.add;
	Gulp.prototype.run = function() {
	  // `run()` is deprecated as of 3.5 and will be removed in 4.0
	  // Use task dependencies instead

	  // Impose our opinion of "default" tasks onto orchestrator
	  var tasks = arguments.length ? arguments : ['default'];

	  this.start.apply(this, tasks);
	};

	Gulp.prototype.src = vfs.src;
	Gulp.prototype.dest = vfs.dest;
	Gulp.prototype.watch = function(glob, opt, fn) {
	  if (typeof opt === 'function' || Array.isArray(opt)) {
	    fn = opt;
	    opt = null;
	  }

	  // Array of tasks given
	  if (Array.isArray(fn)) {
	    return vfs.watch(glob, opt, function() {
	      this.start.apply(this, fn);
	    }.bind(this));
	  }

	  return vfs.watch(glob, opt, fn);
	};

	// Let people use this class from our instance
	Gulp.prototype.Gulp = Gulp;

	// Deprecations
	deprecated.field('gulp.env has been deprecated. ' +
	  'Use your own CLI parser instead. ' +
	  'We recommend using yargs or minimist.',
	  console.warn,
	  Gulp.prototype,
	  'env',
	  gutil.env
	);

	Gulp.prototype.run = deprecated.method('gulp.run() has been deprecated. ' +
	  'Use task dependencies or gulp.watch task triggering instead.',
	  console.warn,
	  Gulp.prototype.run
	);

	var inst = new Gulp();
	module.exports = inst;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var getLogger = __webpack_require__(201);

	var logger = getLogger('gulplog');

	module.exports = logger;


/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(222);
	var re = new RegExp(ansiRegex().source); // remove the `g` flag
	module.exports = re.test.bind(re);


/***/ },
/* 222 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
	};


/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var sparkles = __webpack_require__(77);

	function hasGulplog(){
	  return sparkles.exists('gulplog');
	}

	module.exports = hasGulplog;


/***/ },
/* 224 */
/***/ function(module, exports) {

	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
	  var e, m
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var nBits = -7
	  var i = isLE ? (nBytes - 1) : 0
	  var d = isLE ? -1 : 1
	  var s = buffer[offset + i]

	  i += d

	  e = s & ((1 << (-nBits)) - 1)
	  s >>= (-nBits)
	  nBits += eLen
	  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  m = e & ((1 << (-nBits)) - 1)
	  e >>= (-nBits)
	  nBits += mLen
	  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

	  if (e === 0) {
	    e = 1 - eBias
	  } else if (e === eMax) {
	    return m ? NaN : ((s ? -1 : 1) * Infinity)
	  } else {
	    m = m + Math.pow(2, mLen)
	    e = e - eBias
	  }
	  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}

	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
	  var e, m, c
	  var eLen = nBytes * 8 - mLen - 1
	  var eMax = (1 << eLen) - 1
	  var eBias = eMax >> 1
	  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
	  var i = isLE ? 0 : (nBytes - 1)
	  var d = isLE ? 1 : -1
	  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

	  value = Math.abs(value)

	  if (isNaN(value) || value === Infinity) {
	    m = isNaN(value) ? 1 : 0
	    e = eMax
	  } else {
	    e = Math.floor(Math.log(value) / Math.LN2)
	    if (value * (c = Math.pow(2, -e)) < 1) {
	      e--
	      c *= 2
	    }
	    if (e + eBias >= 1) {
	      value += rt / c
	    } else {
	      value += rt * Math.pow(2, 1 - eBias)
	    }
	    if (value * c >= 2) {
	      e++
	      c /= 2
	    }

	    if (e + eBias >= eMax) {
	      m = 0
	      e = eMax
	    } else if (e + eBias >= 1) {
	      m = (value * c - 1) * Math.pow(2, mLen)
	      e = e + eBias
	    } else {
	      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
	      e = 0
	    }
	  }

	  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

	  e = (e << mLen) | m
	  eLen += mLen
	  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

	  buffer[offset + i - d] |= s * 128
	}


/***/ },
/* 225 */
/***/ function(module, exports) {

	
	var indexOf = [].indexOf;

	module.exports = function(arr, obj){
	  if (indexOf) return arr.indexOf(obj);
	  for (var i = 0; i < arr.length; ++i) {
	    if (arr[i] === obj) return i;
	  }
	  return -1;
	};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var wrappy = __webpack_require__(46)
	var reqs = Object.create(null)
	var once = __webpack_require__(68)

	module.exports = wrappy(inflight)

	function inflight (key, cb) {
	  if (reqs[key]) {
	    reqs[key].push(cb)
	    return null
	  } else {
	    reqs[key] = [cb]
	    return makeres(key)
	  }
	}

	function makeres (key) {
	  return once(function RES () {
	    var cbs = reqs[key]
	    var len = cbs.length
	    var args = slice(arguments)

	    // XXX It's somewhat ambiguous whether a new callback added in this
	    // pass should be queued for later execution if something in the
	    // list of callbacks throws, or if it should just be discarded.
	    // However, it's such an edge case that it hardly matters, and either
	    // choice is likely as surprising as the other.
	    // As it happens, we do go ahead and schedule it for later execution.
	    try {
	      for (var i = 0; i < len; i++) {
	        cbs[i].apply(null, args)
	      }
	    } finally {
	      if (cbs.length > len) {
	        // added more in the interim.
	        // de-zalgo, just in case, but don't call again.
	        cbs.splice(0, len)
	        process.nextTick(function () {
	          RES.apply(null, args)
	        })
	      } else {
	        delete reqs[key]
	      }
	    }
	  })
	}

	function slice (args) {
	  var length = args.length
	  var array = []

	  for (var i = 0; i < length; i++) array[i] = args[i]
	  return array
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 227 */
/***/ function(module, exports) {

	
	exports = module.exports = function(bytes)
	{
	    var i = 0;
	    while(i < bytes.length)
	    {
	        if(     (// ASCII
	                    bytes[i] == 0x09 ||
	                    bytes[i] == 0x0A ||
	                    bytes[i] == 0x0D ||
	                    (0x20 <= bytes[i] && bytes[i] <= 0x7E)
	                )
	          ) {
	              i += 1;
	              continue;
	          }

	        if(     (// non-overlong 2-byte
	                    (0xC2 <= bytes[i] && bytes[i] <= 0xDF) &&
	                    (0x80 <= bytes[i+1] && bytes[i+1] <= 0xBF)
	                )
	          ) {
	              i += 2;
	              continue;
	          }

	        if(     (// excluding overlongs
	                    bytes[i] == 0xE0 &&
	                    (0xA0 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
	                    (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF)
	                ) ||
	                (// straight 3-byte
	                 ((0xE1 <= bytes[i] && bytes[i] <= 0xEC) ||
	                  bytes[i] == 0xEE ||
	                  bytes[i] == 0xEF) &&
	                 (0x80 <= bytes[i + 1] && bytes[i+1] <= 0xBF) &&
	                 (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
	                ) ||
	                (// excluding surrogates
	                 bytes[i] == 0xED &&
	                 (0x80 <= bytes[i+1] && bytes[i+1] <= 0x9F) &&
	                 (0x80 <= bytes[i+2] && bytes[i+2] <= 0xBF)
	                )
	          ) {
	              i += 3;
	              continue;
	          }

	        if(     (// planes 1-3
	                    bytes[i] == 0xF0 &&
	                    (0x90 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
	                    (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
	                    (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
	                ) ||
	                (// planes 4-15
	                 (0xF1 <= bytes[i] && bytes[i] <= 0xF3) &&
	                 (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0xBF) &&
	                 (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
	                 (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
	                ) ||
	                (// plane 16
	                 bytes[i] == 0xF4 &&
	                 (0x80 <= bytes[i + 1] && bytes[i + 1] <= 0x8F) &&
	                 (0x80 <= bytes[i + 2] && bytes[i + 2] <= 0xBF) &&
	                 (0x80 <= bytes[i + 3] && bytes[i + 3] <= 0xBF)
	                )
	          ) {
	              i += 4;
	              continue;
	          }

	        return false;
	    }

	    return true;
	}


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var yaml = __webpack_require__(229);


	module.exports = yaml;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var loader = __webpack_require__(231);
	var dumper = __webpack_require__(230);


	function deprecated(name) {
	  return function () {
	    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
	  };
	}


	module.exports.Type                = __webpack_require__(5);
	module.exports.Schema              = __webpack_require__(21);
	module.exports.FAILSAFE_SCHEMA     = __webpack_require__(40);
	module.exports.JSON_SCHEMA         = __webpack_require__(66);
	module.exports.CORE_SCHEMA         = __webpack_require__(65);
	module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(27);
	module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(32);
	module.exports.load                = loader.load;
	module.exports.loadAll             = loader.loadAll;
	module.exports.safeLoad            = loader.safeLoad;
	module.exports.safeLoadAll         = loader.safeLoadAll;
	module.exports.dump                = dumper.dump;
	module.exports.safeDump            = dumper.safeDump;
	module.exports.YAMLException       = __webpack_require__(26);

	// Deprecated schema names from JS-YAML 2.0.x
	module.exports.MINIMAL_SCHEMA = __webpack_require__(40);
	module.exports.SAFE_SCHEMA    = __webpack_require__(27);
	module.exports.DEFAULT_SCHEMA = __webpack_require__(32);

	// Deprecated functions from JS-YAML 1.x.x
	module.exports.scan           = deprecated('scan');
	module.exports.parse          = deprecated('parse');
	module.exports.compose        = deprecated('compose');
	module.exports.addConstructor = deprecated('addConstructor');


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*eslint-disable no-use-before-define*/

	var common              = __webpack_require__(20);
	var YAMLException       = __webpack_require__(26);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(32);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(27);

	var _toString       = Object.prototype.toString;
	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	var CHAR_TAB                  = 0x09; /* Tab */
	var CHAR_LINE_FEED            = 0x0A; /* LF */
	var CHAR_SPACE                = 0x20; /* Space */
	var CHAR_EXCLAMATION          = 0x21; /* ! */
	var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
	var CHAR_SHARP                = 0x23; /* # */
	var CHAR_PERCENT              = 0x25; /* % */
	var CHAR_AMPERSAND            = 0x26; /* & */
	var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
	var CHAR_ASTERISK             = 0x2A; /* * */
	var CHAR_COMMA                = 0x2C; /* , */
	var CHAR_MINUS                = 0x2D; /* - */
	var CHAR_COLON                = 0x3A; /* : */
	var CHAR_GREATER_THAN         = 0x3E; /* > */
	var CHAR_QUESTION             = 0x3F; /* ? */
	var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
	var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
	var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
	var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
	var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
	var CHAR_VERTICAL_LINE        = 0x7C; /* | */
	var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

	var ESCAPE_SEQUENCES = {};

	ESCAPE_SEQUENCES[0x00]   = '\\0';
	ESCAPE_SEQUENCES[0x07]   = '\\a';
	ESCAPE_SEQUENCES[0x08]   = '\\b';
	ESCAPE_SEQUENCES[0x09]   = '\\t';
	ESCAPE_SEQUENCES[0x0A]   = '\\n';
	ESCAPE_SEQUENCES[0x0B]   = '\\v';
	ESCAPE_SEQUENCES[0x0C]   = '\\f';
	ESCAPE_SEQUENCES[0x0D]   = '\\r';
	ESCAPE_SEQUENCES[0x1B]   = '\\e';
	ESCAPE_SEQUENCES[0x22]   = '\\"';
	ESCAPE_SEQUENCES[0x5C]   = '\\\\';
	ESCAPE_SEQUENCES[0x85]   = '\\N';
	ESCAPE_SEQUENCES[0xA0]   = '\\_';
	ESCAPE_SEQUENCES[0x2028] = '\\L';
	ESCAPE_SEQUENCES[0x2029] = '\\P';

	var DEPRECATED_BOOLEANS_SYNTAX = [
	  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
	  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
	];

	function compileStyleMap(schema, map) {
	  var result, keys, index, length, tag, style, type;

	  if (map === null) return {};

	  result = {};
	  keys = Object.keys(map);

	  for (index = 0, length = keys.length; index < length; index += 1) {
	    tag = keys[index];
	    style = String(map[tag]);

	    if (tag.slice(0, 2) === '!!') {
	      tag = 'tag:yaml.org,2002:' + tag.slice(2);
	    }

	    type = schema.compiledTypeMap[tag];

	    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
	      style = type.styleAliases[style];
	    }

	    result[tag] = style;
	  }

	  return result;
	}

	function encodeHex(character) {
	  var string, handle, length;

	  string = character.toString(16).toUpperCase();

	  if (character <= 0xFF) {
	    handle = 'x';
	    length = 2;
	  } else if (character <= 0xFFFF) {
	    handle = 'u';
	    length = 4;
	  } else if (character <= 0xFFFFFFFF) {
	    handle = 'U';
	    length = 8;
	  } else {
	    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
	  }

	  return '\\' + handle + common.repeat('0', length - string.length) + string;
	}

	function State(options) {
	  this.schema       = options['schema'] || DEFAULT_FULL_SCHEMA;
	  this.indent       = Math.max(1, (options['indent'] || 2));
	  this.skipInvalid  = options['skipInvalid'] || false;
	  this.flowLevel    = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
	  this.styleMap     = compileStyleMap(this.schema, options['styles'] || null);
	  this.sortKeys     = options['sortKeys'] || false;
	  this.lineWidth    = options['lineWidth'] || 80;
	  this.noRefs       = options['noRefs'] || false;
	  this.noCompatMode = options['noCompatMode'] || false;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.explicitTypes = this.schema.compiledExplicit;

	  this.tag = null;
	  this.result = '';

	  this.duplicates = [];
	  this.usedDuplicates = null;
	}

	// Indents every line in a string. Empty lines (\n only) are not indented.
	function indentString(string, spaces) {
	  var ind = common.repeat(' ', spaces),
	      position = 0,
	      next = -1,
	      result = '',
	      line,
	      length = string.length;

	  while (position < length) {
	    next = string.indexOf('\n', position);
	    if (next === -1) {
	      line = string.slice(position);
	      position = length;
	    } else {
	      line = string.slice(position, next + 1);
	      position = next + 1;
	    }

	    if (line.length && line !== '\n') result += ind;

	    result += line;
	  }

	  return result;
	}

	function generateNextLine(state, level) {
	  return '\n' + common.repeat(' ', state.indent * level);
	}

	function testImplicitResolving(state, str) {
	  var index, length, type;

	  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
	    type = state.implicitTypes[index];

	    if (type.resolve(str)) {
	      return true;
	    }
	  }

	  return false;
	}

	// [33] s-white ::= s-space | s-tab
	function isWhitespace(c) {
	  return c === CHAR_SPACE || c === CHAR_TAB;
	}

	// Returns true if the character can be printed without escaping.
	// From YAML 1.2: "any allowed characters known to be non-printable
	// should also be escaped. [However,] This isn’t mandatory"
	// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
	function isPrintable(c) {
	  return  (0x00020 <= c && c <= 0x00007E)
	      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
	      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
	      ||  (0x10000 <= c && c <= 0x10FFFF);
	}

	// Simplified test for values allowed after the first character in plain style.
	function isPlainSafe(c) {
	  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
	  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
	  return isPrintable(c) && c !== 0xFEFF
	    // - c-flow-indicator
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // - ":" - "#"
	    && c !== CHAR_COLON
	    && c !== CHAR_SHARP;
	}

	// Simplified test for values allowed as the first character in plain style.
	function isPlainSafeFirst(c) {
	  // Uses a subset of ns-char - c-indicator
	  // where ns-char = nb-char - s-white.
	  return isPrintable(c) && c !== 0xFEFF
	    && !isWhitespace(c) // - s-white
	    // - (c-indicator ::=
	    // “-” | “?” | “:” | “,” | “[” | “]” | “{” | “}”
	    && c !== CHAR_MINUS
	    && c !== CHAR_QUESTION
	    && c !== CHAR_COLON
	    && c !== CHAR_COMMA
	    && c !== CHAR_LEFT_SQUARE_BRACKET
	    && c !== CHAR_RIGHT_SQUARE_BRACKET
	    && c !== CHAR_LEFT_CURLY_BRACKET
	    && c !== CHAR_RIGHT_CURLY_BRACKET
	    // | “#” | “&” | “*” | “!” | “|” | “>” | “'” | “"”
	    && c !== CHAR_SHARP
	    && c !== CHAR_AMPERSAND
	    && c !== CHAR_ASTERISK
	    && c !== CHAR_EXCLAMATION
	    && c !== CHAR_VERTICAL_LINE
	    && c !== CHAR_GREATER_THAN
	    && c !== CHAR_SINGLE_QUOTE
	    && c !== CHAR_DOUBLE_QUOTE
	    // | “%” | “@” | “`”)
	    && c !== CHAR_PERCENT
	    && c !== CHAR_COMMERCIAL_AT
	    && c !== CHAR_GRAVE_ACCENT;
	}

	var STYLE_PLAIN   = 1,
	    STYLE_SINGLE  = 2,
	    STYLE_LITERAL = 3,
	    STYLE_FOLDED  = 4,
	    STYLE_DOUBLE  = 5;

	// Determines which scalar styles are possible and returns the preferred style.
	// lineWidth = -1 => no limit.
	// Pre-conditions: str.length > 0.
	// Post-conditions:
	//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
	//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
	//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
	function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
	  var i;
	  var char;
	  var hasLineBreak = false;
	  var hasFoldableLine = false; // only checked if shouldTrackWidth
	  var shouldTrackWidth = lineWidth !== -1;
	  var previousLineBreak = -1; // count the first line correctly
	  var plain = isPlainSafeFirst(string.charCodeAt(0))
	          && !isWhitespace(string.charCodeAt(string.length - 1));

	  if (singleLineOnly) {
	    // Case: no block styles.
	    // Check for disallowed characters to rule out plain and single.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char);
	    }
	  } else {
	    // Case: block styles permitted.
	    for (i = 0; i < string.length; i++) {
	      char = string.charCodeAt(i);
	      if (char === CHAR_LINE_FEED) {
	        hasLineBreak = true;
	        // Check if any line can be folded.
	        if (shouldTrackWidth) {
	          hasFoldableLine = hasFoldableLine ||
	            // Foldable line = too long, and not more-indented.
	            (i - previousLineBreak - 1 > lineWidth &&
	             string[previousLineBreak + 1] !== ' ');
	          previousLineBreak = i;
	        }
	      } else if (!isPrintable(char)) {
	        return STYLE_DOUBLE;
	      }
	      plain = plain && isPlainSafe(char);
	    }
	    // in case the end is missing a \n
	    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
	      (i - previousLineBreak - 1 > lineWidth &&
	       string[previousLineBreak + 1] !== ' '));
	  }
	  // Although every style can represent \n without escaping, prefer block styles
	  // for multiline, since they're more readable and they don't add empty lines.
	  // Also prefer folding a super-long line.
	  if (!hasLineBreak && !hasFoldableLine) {
	    // Strings interpretable as another type have to be quoted;
	    // e.g. the string 'true' vs. the boolean true.
	    return plain && !testAmbiguousType(string)
	      ? STYLE_PLAIN : STYLE_SINGLE;
	  }
	  // Edge case: block indentation indicator can only have one digit.
	  if (string[0] === ' ' && indentPerLevel > 9) {
	    return STYLE_DOUBLE;
	  }
	  // At this point we know block styles are valid.
	  // Prefer literal style unless we want to fold.
	  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
	}

	// Note: line breaking/folding is implemented for only the folded style.
	// NB. We drop the last trailing newline (if any) of a returned block scalar
	//  since the dumper adds its own newline. This always works:
	//    • No ending newline => unaffected; already using strip "-" chomping.
	//    • Ending newline    => removed then restored.
	//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
	function writeScalar(state, string, level, iskey) {
	  state.dump = (function () {
	    if (string.length === 0) {
	      return "''";
	    }
	    if (!state.noCompatMode &&
	        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
	      return "'" + string + "'";
	    }

	    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
	    // As indentation gets deeper, let the width decrease monotonically
	    // to the lower bound min(state.lineWidth, 40).
	    // Note that this implies
	    //  state.lineWidth ≤ 40 + state.indent: width is fixed at the lower bound.
	    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
	    // This behaves better than a constant minimum width which disallows narrower options,
	    // or an indent threshold which causes the width to suddenly increase.
	    var lineWidth = state.lineWidth === -1
	      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

	    // Without knowing if keys are implicit/explicit, assume implicit for safety.
	    var singleLineOnly = iskey
	      // No block styles in flow mode.
	      || (state.flowLevel > -1 && level >= state.flowLevel);
	    function testAmbiguity(string) {
	      return testImplicitResolving(state, string);
	    }

	    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
	      case STYLE_PLAIN:
	        return string;
	      case STYLE_SINGLE:
	        return "'" + string.replace(/'/g, "''") + "'";
	      case STYLE_LITERAL:
	        return '|' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(string, indent));
	      case STYLE_FOLDED:
	        return '>' + blockHeader(string, state.indent)
	          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
	      case STYLE_DOUBLE:
	        return '"' + escapeString(string, lineWidth) + '"';
	      default:
	        throw new YAMLException('impossible error: invalid scalar style');
	    }
	  }());
	}

	// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
	function blockHeader(string, indentPerLevel) {
	  var indentIndicator = (string[0] === ' ') ? String(indentPerLevel) : '';

	  // note the special case: the string '\n' counts as a "trailing" empty line.
	  var clip =          string[string.length - 1] === '\n';
	  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
	  var chomp = keep ? '+' : (clip ? '' : '-');

	  return indentIndicator + chomp + '\n';
	}

	// (See the note for writeScalar.)
	function dropEndingNewline(string) {
	  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
	}

	// Note: a long line without a suitable break point will exceed the width limit.
	// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
	function foldString(string, width) {
	  // In folded style, $k$ consecutive newlines output as $k+1$ newlines—
	  // unless they're before or after a more-indented line, or at the very
	  // beginning or end, in which case $k$ maps to $k$.
	  // Therefore, parse each chunk as newline(s) followed by a content line.
	  var lineRe = /(\n+)([^\n]*)/g;

	  // first line (possibly an empty line)
	  var result = (function () {
	    var nextLF = string.indexOf('\n');
	    nextLF = nextLF !== -1 ? nextLF : string.length;
	    lineRe.lastIndex = nextLF;
	    return foldLine(string.slice(0, nextLF), width);
	  }());
	  // If we haven't reached the first content line yet, don't add an extra \n.
	  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
	  var moreIndented;

	  // rest of the lines
	  var match;
	  while ((match = lineRe.exec(string))) {
	    var prefix = match[1], line = match[2];
	    moreIndented = (line[0] === ' ');
	    result += prefix
	      + (!prevMoreIndented && !moreIndented && line !== ''
	        ? '\n' : '')
	      + foldLine(line, width);
	    prevMoreIndented = moreIndented;
	  }

	  return result;
	}

	// Greedy line breaking.
	// Picks the longest line under the limit each time,
	// otherwise settles for the shortest line over the limit.
	// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
	function foldLine(line, width) {
	  if (line === '' || line[0] === ' ') return line;

	  // Since a more-indented line adds a \n, breaks can't be followed by a space.
	  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
	  var match;
	  // start is an inclusive index. end, curr, and next are exclusive.
	  var start = 0, end, curr = 0, next = 0;
	  var result = '';

	  // Invariants: 0 <= start <= length-1.
	  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
	  // Inside the loop:
	  //   A match implies length >= 2, so curr and next are <= length-2.
	  while ((match = breakRe.exec(line))) {
	    next = match.index;
	    // maintain invariant: curr - start <= width
	    if (next - start > width) {
	      end = (curr > start) ? curr : next; // derive end <= length-2
	      result += '\n' + line.slice(start, end);
	      // skip the space that was output as \n
	      start = end + 1;                    // derive start <= length-1
	    }
	    curr = next;
	  }

	  // By the invariants, start <= length-1, so there is something left over.
	  // It is either the whole string or a part starting from non-whitespace.
	  result += '\n';
	  // Insert a break if the remainder is too long and there is a break available.
	  if (line.length - start > width && curr > start) {
	    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
	  } else {
	    result += line.slice(start);
	  }

	  return result.slice(1); // drop extra \n joiner
	}

	// Escapes a double-quoted string.
	function escapeString(string) {
	  var result = '';
	  var char;
	  var escapeSeq;

	  for (var i = 0; i < string.length; i++) {
	    char = string.charCodeAt(i);
	    escapeSeq = ESCAPE_SEQUENCES[char];
	    result += !escapeSeq && isPrintable(char)
	      ? string[i]
	      : escapeSeq || encodeHex(char);
	  }

	  return result;
	}

	function writeFlowSequence(state, level, object) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level, object[index], false, false)) {
	      if (index !== 0) _result += ', ';
	      _result += state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = '[' + _result + ']';
	}

	function writeBlockSequence(state, level, object, compact) {
	  var _result = '',
	      _tag    = state.tag,
	      index,
	      length;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    // Write only valid elements.
	    if (writeNode(state, level + 1, object[index], true, true)) {
	      if (!compact || index !== 0) {
	        _result += generateNextLine(state, level);
	      }
	      _result += '- ' + state.dump;
	    }
	  }

	  state.tag = _tag;
	  state.dump = _result || '[]'; // Empty sequence if no valid values.
	}

	function writeFlowMapping(state, level, object) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      pairBuffer;

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (index !== 0) pairBuffer += ', ';

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level, objectKey, false, false)) {
	      continue; // Skip this pair because of invalid key;
	    }

	    if (state.dump.length > 1024) pairBuffer += '? ';

	    pairBuffer += state.dump + ': ';

	    if (!writeNode(state, level, objectValue, false, false)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = '{' + _result + '}';
	}

	function writeBlockMapping(state, level, object, compact) {
	  var _result       = '',
	      _tag          = state.tag,
	      objectKeyList = Object.keys(object),
	      index,
	      length,
	      objectKey,
	      objectValue,
	      explicitPair,
	      pairBuffer;

	  // Allow sorting keys so that the output file is deterministic
	  if (state.sortKeys === true) {
	    // Default sorting
	    objectKeyList.sort();
	  } else if (typeof state.sortKeys === 'function') {
	    // Custom sort function
	    objectKeyList.sort(state.sortKeys);
	  } else if (state.sortKeys) {
	    // Something is wrong
	    throw new YAMLException('sortKeys must be a boolean or a function');
	  }

	  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	    pairBuffer = '';

	    if (!compact || index !== 0) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    objectKey = objectKeyList[index];
	    objectValue = object[objectKey];

	    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
	      continue; // Skip this pair because of invalid key.
	    }

	    explicitPair = (state.tag !== null && state.tag !== '?') ||
	                   (state.dump && state.dump.length > 1024);

	    if (explicitPair) {
	      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	        pairBuffer += '?';
	      } else {
	        pairBuffer += '? ';
	      }
	    }

	    pairBuffer += state.dump;

	    if (explicitPair) {
	      pairBuffer += generateNextLine(state, level);
	    }

	    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
	      continue; // Skip this pair because of invalid value.
	    }

	    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
	      pairBuffer += ':';
	    } else {
	      pairBuffer += ': ';
	    }

	    pairBuffer += state.dump;

	    // Both key and value are valid.
	    _result += pairBuffer;
	  }

	  state.tag = _tag;
	  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
	}

	function detectType(state, object, explicit) {
	  var _result, typeList, index, length, type, style;

	  typeList = explicit ? state.explicitTypes : state.implicitTypes;

	  for (index = 0, length = typeList.length; index < length; index += 1) {
	    type = typeList[index];

	    if ((type.instanceOf  || type.predicate) &&
	        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
	        (!type.predicate  || type.predicate(object))) {

	      state.tag = explicit ? type.tag : '?';

	      if (type.represent) {
	        style = state.styleMap[type.tag] || type.defaultStyle;

	        if (_toString.call(type.represent) === '[object Function]') {
	          _result = type.represent(object, style);
	        } else if (_hasOwnProperty.call(type.represent, style)) {
	          _result = type.represent[style](object, style);
	        } else {
	          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
	        }

	        state.dump = _result;
	      }

	      return true;
	    }
	  }

	  return false;
	}

	// Serializes `object` and writes it to global `result`.
	// Returns true on success, or false on invalid object.
	//
	function writeNode(state, level, object, block, compact, iskey) {
	  state.tag = null;
	  state.dump = object;

	  if (!detectType(state, object, false)) {
	    detectType(state, object, true);
	  }

	  var type = _toString.call(state.dump);

	  if (block) {
	    block = (state.flowLevel < 0 || state.flowLevel > level);
	  }

	  var objectOrArray = type === '[object Object]' || type === '[object Array]',
	      duplicateIndex,
	      duplicate;

	  if (objectOrArray) {
	    duplicateIndex = state.duplicates.indexOf(object);
	    duplicate = duplicateIndex !== -1;
	  }

	  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
	    compact = false;
	  }

	  if (duplicate && state.usedDuplicates[duplicateIndex]) {
	    state.dump = '*ref_' + duplicateIndex;
	  } else {
	    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
	      state.usedDuplicates[duplicateIndex] = true;
	    }
	    if (type === '[object Object]') {
	      if (block && (Object.keys(state.dump).length !== 0)) {
	        writeBlockMapping(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowMapping(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object Array]') {
	      if (block && (state.dump.length !== 0)) {
	        writeBlockSequence(state, level, state.dump, compact);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + state.dump;
	        }
	      } else {
	        writeFlowSequence(state, level, state.dump);
	        if (duplicate) {
	          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
	        }
	      }
	    } else if (type === '[object String]') {
	      if (state.tag !== '?') {
	        writeScalar(state, state.dump, level, iskey);
	      }
	    } else {
	      if (state.skipInvalid) return false;
	      throw new YAMLException('unacceptable kind of an object to dump ' + type);
	    }

	    if (state.tag !== null && state.tag !== '?') {
	      state.dump = '!<' + state.tag + '> ' + state.dump;
	    }
	  }

	  return true;
	}

	function getDuplicateReferences(object, state) {
	  var objects = [],
	      duplicatesIndexes = [],
	      index,
	      length;

	  inspectNode(object, objects, duplicatesIndexes);

	  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
	    state.duplicates.push(objects[duplicatesIndexes[index]]);
	  }
	  state.usedDuplicates = new Array(length);
	}

	function inspectNode(object, objects, duplicatesIndexes) {
	  var objectKeyList,
	      index,
	      length;

	  if (object !== null && typeof object === 'object') {
	    index = objects.indexOf(object);
	    if (index !== -1) {
	      if (duplicatesIndexes.indexOf(index) === -1) {
	        duplicatesIndexes.push(index);
	      }
	    } else {
	      objects.push(object);

	      if (Array.isArray(object)) {
	        for (index = 0, length = object.length; index < length; index += 1) {
	          inspectNode(object[index], objects, duplicatesIndexes);
	        }
	      } else {
	        objectKeyList = Object.keys(object);

	        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
	          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
	        }
	      }
	    }
	  }
	}

	function dump(input, options) {
	  options = options || {};

	  var state = new State(options);

	  if (!state.noRefs) getDuplicateReferences(input, state);

	  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

	  return '';
	}

	function safeDump(input, options) {
	  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}

	module.exports.dump     = dump;
	module.exports.safeDump = safeDump;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/*eslint-disable max-len,no-use-before-define*/

	var common              = __webpack_require__(20);
	var YAMLException       = __webpack_require__(26);
	var Mark                = __webpack_require__(232);
	var DEFAULT_SAFE_SCHEMA = __webpack_require__(27);
	var DEFAULT_FULL_SCHEMA = __webpack_require__(32);


	var _hasOwnProperty = Object.prototype.hasOwnProperty;


	var CONTEXT_FLOW_IN   = 1;
	var CONTEXT_FLOW_OUT  = 2;
	var CONTEXT_BLOCK_IN  = 3;
	var CONTEXT_BLOCK_OUT = 4;


	var CHOMPING_CLIP  = 1;
	var CHOMPING_STRIP = 2;
	var CHOMPING_KEEP  = 3;


	var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
	var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
	var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
	var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


	function is_EOL(c) {
	  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
	}

	function is_WHITE_SPACE(c) {
	  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
	}

	function is_WS_OR_EOL(c) {
	  return (c === 0x09/* Tab */) ||
	         (c === 0x20/* Space */) ||
	         (c === 0x0A/* LF */) ||
	         (c === 0x0D/* CR */);
	}

	function is_FLOW_INDICATOR(c) {
	  return c === 0x2C/* , */ ||
	         c === 0x5B/* [ */ ||
	         c === 0x5D/* ] */ ||
	         c === 0x7B/* { */ ||
	         c === 0x7D/* } */;
	}

	function fromHexCode(c) {
	  var lc;

	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  /*eslint-disable no-bitwise*/
	  lc = c | 0x20;

	  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
	    return lc - 0x61 + 10;
	  }

	  return -1;
	}

	function escapedHexLen(c) {
	  if (c === 0x78/* x */) { return 2; }
	  if (c === 0x75/* u */) { return 4; }
	  if (c === 0x55/* U */) { return 8; }
	  return 0;
	}

	function fromDecimalCode(c) {
	  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
	    return c - 0x30;
	  }

	  return -1;
	}

	function simpleEscapeSequence(c) {
	  return (c === 0x30/* 0 */) ? '\x00' :
	        (c === 0x61/* a */) ? '\x07' :
	        (c === 0x62/* b */) ? '\x08' :
	        (c === 0x74/* t */) ? '\x09' :
	        (c === 0x09/* Tab */) ? '\x09' :
	        (c === 0x6E/* n */) ? '\x0A' :
	        (c === 0x76/* v */) ? '\x0B' :
	        (c === 0x66/* f */) ? '\x0C' :
	        (c === 0x72/* r */) ? '\x0D' :
	        (c === 0x65/* e */) ? '\x1B' :
	        (c === 0x20/* Space */) ? ' ' :
	        (c === 0x22/* " */) ? '\x22' :
	        (c === 0x2F/* / */) ? '/' :
	        (c === 0x5C/* \ */) ? '\x5C' :
	        (c === 0x4E/* N */) ? '\x85' :
	        (c === 0x5F/* _ */) ? '\xA0' :
	        (c === 0x4C/* L */) ? '\u2028' :
	        (c === 0x50/* P */) ? '\u2029' : '';
	}

	function charFromCodepoint(c) {
	  if (c <= 0xFFFF) {
	    return String.fromCharCode(c);
	  }
	  // Encode UTF-16 surrogate pair
	  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
	  return String.fromCharCode(((c - 0x010000) >> 10) + 0xD800,
	                             ((c - 0x010000) & 0x03FF) + 0xDC00);
	}

	var simpleEscapeCheck = new Array(256); // integer, for fast access
	var simpleEscapeMap = new Array(256);
	for (var i = 0; i < 256; i++) {
	  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
	  simpleEscapeMap[i] = simpleEscapeSequence(i);
	}


	function State(input, options) {
	  this.input = input;

	  this.filename  = options['filename']  || null;
	  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
	  this.onWarning = options['onWarning'] || null;
	  this.legacy    = options['legacy']    || false;
	  this.json      = options['json']      || false;
	  this.listener  = options['listener']  || null;

	  this.implicitTypes = this.schema.compiledImplicit;
	  this.typeMap       = this.schema.compiledTypeMap;

	  this.length     = input.length;
	  this.position   = 0;
	  this.line       = 0;
	  this.lineStart  = 0;
	  this.lineIndent = 0;

	  this.documents = [];

	  /*
	  this.version;
	  this.checkLineBreaks;
	  this.tagMap;
	  this.anchorMap;
	  this.tag;
	  this.anchor;
	  this.kind;
	  this.result;*/

	}


	function generateError(state, message) {
	  return new YAMLException(
	    message,
	    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
	}

	function throwError(state, message) {
	  throw generateError(state, message);
	}

	function throwWarning(state, message) {
	  if (state.onWarning) {
	    state.onWarning.call(null, generateError(state, message));
	  }
	}


	var directiveHandlers = {

	  YAML: function handleYamlDirective(state, name, args) {

	    var match, major, minor;

	    if (state.version !== null) {
	      throwError(state, 'duplication of %YAML directive');
	    }

	    if (args.length !== 1) {
	      throwError(state, 'YAML directive accepts exactly one argument');
	    }

	    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

	    if (match === null) {
	      throwError(state, 'ill-formed argument of the YAML directive');
	    }

	    major = parseInt(match[1], 10);
	    minor = parseInt(match[2], 10);

	    if (major !== 1) {
	      throwError(state, 'unacceptable YAML version of the document');
	    }

	    state.version = args[0];
	    state.checkLineBreaks = (minor < 2);

	    if (minor !== 1 && minor !== 2) {
	      throwWarning(state, 'unsupported YAML version of the document');
	    }
	  },

	  TAG: function handleTagDirective(state, name, args) {

	    var handle, prefix;

	    if (args.length !== 2) {
	      throwError(state, 'TAG directive accepts exactly two arguments');
	    }

	    handle = args[0];
	    prefix = args[1];

	    if (!PATTERN_TAG_HANDLE.test(handle)) {
	      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
	    }

	    if (_hasOwnProperty.call(state.tagMap, handle)) {
	      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
	    }

	    if (!PATTERN_TAG_URI.test(prefix)) {
	      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
	    }

	    state.tagMap[handle] = prefix;
	  }
	};


	function captureSegment(state, start, end, checkJson) {
	  var _position, _length, _character, _result;

	  if (start < end) {
	    _result = state.input.slice(start, end);

	    if (checkJson) {
	      for (_position = 0, _length = _result.length;
	           _position < _length;
	           _position += 1) {
	        _character = _result.charCodeAt(_position);
	        if (!(_character === 0x09 ||
	              (0x20 <= _character && _character <= 0x10FFFF))) {
	          throwError(state, 'expected valid JSON character');
	        }
	      }
	    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
	      throwError(state, 'the stream contains non-printable characters');
	    }

	    state.result += _result;
	  }
	}

	function mergeMappings(state, destination, source, overridableKeys) {
	  var sourceKeys, key, index, quantity;

	  if (!common.isObject(source)) {
	    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
	  }

	  sourceKeys = Object.keys(source);

	  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
	    key = sourceKeys[index];

	    if (!_hasOwnProperty.call(destination, key)) {
	      destination[key] = source[key];
	      overridableKeys[key] = true;
	    }
	  }
	}

	function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode) {
	  var index, quantity;

	  keyNode = String(keyNode);

	  if (_result === null) {
	    _result = {};
	  }

	  if (keyTag === 'tag:yaml.org,2002:merge') {
	    if (Array.isArray(valueNode)) {
	      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
	        mergeMappings(state, _result, valueNode[index], overridableKeys);
	      }
	    } else {
	      mergeMappings(state, _result, valueNode, overridableKeys);
	    }
	  } else {
	    if (!state.json &&
	        !_hasOwnProperty.call(overridableKeys, keyNode) &&
	        _hasOwnProperty.call(_result, keyNode)) {
	      throwError(state, 'duplicated mapping key');
	    }
	    _result[keyNode] = valueNode;
	    delete overridableKeys[keyNode];
	  }

	  return _result;
	}

	function readLineBreak(state) {
	  var ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x0A/* LF */) {
	    state.position++;
	  } else if (ch === 0x0D/* CR */) {
	    state.position++;
	    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
	      state.position++;
	    }
	  } else {
	    throwError(state, 'a line break is expected');
	  }

	  state.line += 1;
	  state.lineStart = state.position;
	}

	function skipSeparationSpace(state, allowComments, checkIndent) {
	  var lineBreaks = 0,
	      ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    while (is_WHITE_SPACE(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (allowComments && ch === 0x23/* # */) {
	      do {
	        ch = state.input.charCodeAt(++state.position);
	      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
	    }

	    if (is_EOL(ch)) {
	      readLineBreak(state);

	      ch = state.input.charCodeAt(state.position);
	      lineBreaks++;
	      state.lineIndent = 0;

	      while (ch === 0x20/* Space */) {
	        state.lineIndent++;
	        ch = state.input.charCodeAt(++state.position);
	      }
	    } else {
	      break;
	    }
	  }

	  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
	    throwWarning(state, 'deficient indentation');
	  }

	  return lineBreaks;
	}

	function testDocumentSeparator(state) {
	  var _position = state.position,
	      ch;

	  ch = state.input.charCodeAt(_position);

	  // Condition state.position === state.lineStart is tested
	  // in parent on each call, for efficiency. No needs to test here again.
	  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
	      ch === state.input.charCodeAt(_position + 1) &&
	      ch === state.input.charCodeAt(_position + 2)) {

	    _position += 3;

	    ch = state.input.charCodeAt(_position);

	    if (ch === 0 || is_WS_OR_EOL(ch)) {
	      return true;
	    }
	  }

	  return false;
	}

	function writeFoldedLines(state, count) {
	  if (count === 1) {
	    state.result += ' ';
	  } else if (count > 1) {
	    state.result += common.repeat('\n', count - 1);
	  }
	}


	function readPlainScalar(state, nodeIndent, withinFlowCollection) {
	  var preceding,
	      following,
	      captureStart,
	      captureEnd,
	      hasPendingContent,
	      _line,
	      _lineStart,
	      _lineIndent,
	      _kind = state.kind,
	      _result = state.result,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (is_WS_OR_EOL(ch)      ||
	      is_FLOW_INDICATOR(ch) ||
	      ch === 0x23/* # */    ||
	      ch === 0x26/* & */    ||
	      ch === 0x2A/* * */    ||
	      ch === 0x21/* ! */    ||
	      ch === 0x7C/* | */    ||
	      ch === 0x3E/* > */    ||
	      ch === 0x27/* ' */    ||
	      ch === 0x22/* " */    ||
	      ch === 0x25/* % */    ||
	      ch === 0x40/* @ */    ||
	      ch === 0x60/* ` */) {
	    return false;
	  }

	  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
	    following = state.input.charCodeAt(state.position + 1);

	    if (is_WS_OR_EOL(following) ||
	        withinFlowCollection && is_FLOW_INDICATOR(following)) {
	      return false;
	    }
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  captureStart = captureEnd = state.position;
	  hasPendingContent = false;

	  while (ch !== 0) {
	    if (ch === 0x3A/* : */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following) ||
	          withinFlowCollection && is_FLOW_INDICATOR(following)) {
	        break;
	      }

	    } else if (ch === 0x23/* # */) {
	      preceding = state.input.charCodeAt(state.position - 1);

	      if (is_WS_OR_EOL(preceding)) {
	        break;
	      }

	    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
	               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
	      break;

	    } else if (is_EOL(ch)) {
	      _line = state.line;
	      _lineStart = state.lineStart;
	      _lineIndent = state.lineIndent;
	      skipSeparationSpace(state, false, -1);

	      if (state.lineIndent >= nodeIndent) {
	        hasPendingContent = true;
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      } else {
	        state.position = captureEnd;
	        state.line = _line;
	        state.lineStart = _lineStart;
	        state.lineIndent = _lineIndent;
	        break;
	      }
	    }

	    if (hasPendingContent) {
	      captureSegment(state, captureStart, captureEnd, false);
	      writeFoldedLines(state, state.line - _line);
	      captureStart = captureEnd = state.position;
	      hasPendingContent = false;
	    }

	    if (!is_WHITE_SPACE(ch)) {
	      captureEnd = state.position + 1;
	    }

	    ch = state.input.charCodeAt(++state.position);
	  }

	  captureSegment(state, captureStart, captureEnd, false);

	  if (state.result) {
	    return true;
	  }

	  state.kind = _kind;
	  state.result = _result;
	  return false;
	}

	function readSingleQuotedScalar(state, nodeIndent) {
	  var ch,
	      captureStart, captureEnd;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x27/* ' */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x27/* ' */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (ch === 0x27/* ' */) {
	        captureStart = captureEnd = state.position;
	        state.position++;
	      } else {
	        return true;
	      }

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a single quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a single quoted scalar');
	}

	function readDoubleQuotedScalar(state, nodeIndent) {
	  var captureStart,
	      captureEnd,
	      hexLength,
	      hexResult,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x22/* " */) {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';
	  state.position++;
	  captureStart = captureEnd = state.position;

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    if (ch === 0x22/* " */) {
	      captureSegment(state, captureStart, state.position, true);
	      state.position++;
	      return true;

	    } else if (ch === 0x5C/* \ */) {
	      captureSegment(state, captureStart, state.position, true);
	      ch = state.input.charCodeAt(++state.position);

	      if (is_EOL(ch)) {
	        skipSeparationSpace(state, false, nodeIndent);

	        // TODO: rework to inline fn with no type cast?
	      } else if (ch < 256 && simpleEscapeCheck[ch]) {
	        state.result += simpleEscapeMap[ch];
	        state.position++;

	      } else if ((tmp = escapedHexLen(ch)) > 0) {
	        hexLength = tmp;
	        hexResult = 0;

	        for (; hexLength > 0; hexLength--) {
	          ch = state.input.charCodeAt(++state.position);

	          if ((tmp = fromHexCode(ch)) >= 0) {
	            hexResult = (hexResult << 4) + tmp;

	          } else {
	            throwError(state, 'expected hexadecimal character');
	          }
	        }

	        state.result += charFromCodepoint(hexResult);

	        state.position++;

	      } else {
	        throwError(state, 'unknown escape sequence');
	      }

	      captureStart = captureEnd = state.position;

	    } else if (is_EOL(ch)) {
	      captureSegment(state, captureStart, captureEnd, true);
	      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
	      captureStart = captureEnd = state.position;

	    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
	      throwError(state, 'unexpected end of the document within a double quoted scalar');

	    } else {
	      state.position++;
	      captureEnd = state.position;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a double quoted scalar');
	}

	function readFlowCollection(state, nodeIndent) {
	  var readNext = true,
	      _line,
	      _tag     = state.tag,
	      _result,
	      _anchor  = state.anchor,
	      following,
	      terminator,
	      isPair,
	      isExplicitPair,
	      isMapping,
	      overridableKeys = {},
	      keyNode,
	      keyTag,
	      valueNode,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x5B/* [ */) {
	    terminator = 0x5D;/* ] */
	    isMapping = false;
	    _result = [];
	  } else if (ch === 0x7B/* { */) {
	    terminator = 0x7D;/* } */
	    isMapping = true;
	    _result = {};
	  } else {
	    return false;
	  }

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(++state.position);

	  while (ch !== 0) {
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === terminator) {
	      state.position++;
	      state.tag = _tag;
	      state.anchor = _anchor;
	      state.kind = isMapping ? 'mapping' : 'sequence';
	      state.result = _result;
	      return true;
	    } else if (!readNext) {
	      throwError(state, 'missed comma between flow collection entries');
	    }

	    keyTag = keyNode = valueNode = null;
	    isPair = isExplicitPair = false;

	    if (ch === 0x3F/* ? */) {
	      following = state.input.charCodeAt(state.position + 1);

	      if (is_WS_OR_EOL(following)) {
	        isPair = isExplicitPair = true;
	        state.position++;
	        skipSeparationSpace(state, true, nodeIndent);
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	    keyTag = state.tag;
	    keyNode = state.result;
	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
	      isPair = true;
	      ch = state.input.charCodeAt(++state.position);
	      skipSeparationSpace(state, true, nodeIndent);
	      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
	      valueNode = state.result;
	    }

	    if (isMapping) {
	      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
	    } else if (isPair) {
	      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
	    } else {
	      _result.push(keyNode);
	    }

	    skipSeparationSpace(state, true, nodeIndent);

	    ch = state.input.charCodeAt(state.position);

	    if (ch === 0x2C/* , */) {
	      readNext = true;
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      readNext = false;
	    }
	  }

	  throwError(state, 'unexpected end of the stream within a flow collection');
	}

	function readBlockScalar(state, nodeIndent) {
	  var captureStart,
	      folding,
	      chomping       = CHOMPING_CLIP,
	      didReadContent = false,
	      detectedIndent = false,
	      textIndent     = nodeIndent,
	      emptyLines     = 0,
	      atMoreIndented = false,
	      tmp,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch === 0x7C/* | */) {
	    folding = false;
	  } else if (ch === 0x3E/* > */) {
	    folding = true;
	  } else {
	    return false;
	  }

	  state.kind = 'scalar';
	  state.result = '';

	  while (ch !== 0) {
	    ch = state.input.charCodeAt(++state.position);

	    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
	      if (CHOMPING_CLIP === chomping) {
	        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
	      } else {
	        throwError(state, 'repeat of a chomping mode identifier');
	      }

	    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
	      if (tmp === 0) {
	        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
	      } else if (!detectedIndent) {
	        textIndent = nodeIndent + tmp - 1;
	        detectedIndent = true;
	      } else {
	        throwError(state, 'repeat of an indentation width identifier');
	      }

	    } else {
	      break;
	    }
	  }

	  if (is_WHITE_SPACE(ch)) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (is_WHITE_SPACE(ch));

	    if (ch === 0x23/* # */) {
	      do { ch = state.input.charCodeAt(++state.position); }
	      while (!is_EOL(ch) && (ch !== 0));
	    }
	  }

	  while (ch !== 0) {
	    readLineBreak(state);
	    state.lineIndent = 0;

	    ch = state.input.charCodeAt(state.position);

	    while ((!detectedIndent || state.lineIndent < textIndent) &&
	           (ch === 0x20/* Space */)) {
	      state.lineIndent++;
	      ch = state.input.charCodeAt(++state.position);
	    }

	    if (!detectedIndent && state.lineIndent > textIndent) {
	      textIndent = state.lineIndent;
	    }

	    if (is_EOL(ch)) {
	      emptyLines++;
	      continue;
	    }

	    // End of the scalar.
	    if (state.lineIndent < textIndent) {

	      // Perform the chomping.
	      if (chomping === CHOMPING_KEEP) {
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	      } else if (chomping === CHOMPING_CLIP) {
	        if (didReadContent) { // i.e. only if the scalar is not empty.
	          state.result += '\n';
	        }
	      }

	      // Break this `while` cycle and go to the funciton's epilogue.
	      break;
	    }

	    // Folded style: use fancy rules to handle line breaks.
	    if (folding) {

	      // Lines starting with white space characters (more-indented lines) are not folded.
	      if (is_WHITE_SPACE(ch)) {
	        atMoreIndented = true;
	        // except for the first content line (cf. Example 8.1)
	        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

	      // End of more-indented block.
	      } else if (atMoreIndented) {
	        atMoreIndented = false;
	        state.result += common.repeat('\n', emptyLines + 1);

	      // Just one line break - perceive as the same line.
	      } else if (emptyLines === 0) {
	        if (didReadContent) { // i.e. only if we have already read some scalar content.
	          state.result += ' ';
	        }

	      // Several line breaks - perceive as different lines.
	      } else {
	        state.result += common.repeat('\n', emptyLines);
	      }

	    // Literal style: just add exact number of line breaks between content lines.
	    } else {
	      // Keep all line breaks except the header line break.
	      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
	    }

	    didReadContent = true;
	    detectedIndent = true;
	    emptyLines = 0;
	    captureStart = state.position;

	    while (!is_EOL(ch) && (ch !== 0)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    captureSegment(state, captureStart, state.position, false);
	  }

	  return true;
	}

	function readBlockSequence(state, nodeIndent) {
	  var _line,
	      _tag      = state.tag,
	      _anchor   = state.anchor,
	      _result   = [],
	      following,
	      detected  = false,
	      ch;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {

	    if (ch !== 0x2D/* - */) {
	      break;
	    }

	    following = state.input.charCodeAt(state.position + 1);

	    if (!is_WS_OR_EOL(following)) {
	      break;
	    }

	    detected = true;
	    state.position++;

	    if (skipSeparationSpace(state, true, -1)) {
	      if (state.lineIndent <= nodeIndent) {
	        _result.push(null);
	        ch = state.input.charCodeAt(state.position);
	        continue;
	      }
	    }

	    _line = state.line;
	    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
	    _result.push(state.result);
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
	      throwError(state, 'bad indentation of a sequence entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'sequence';
	    state.result = _result;
	    return true;
	  }
	  return false;
	}

	function readBlockMapping(state, nodeIndent, flowIndent) {
	  var following,
	      allowCompact,
	      _line,
	      _tag          = state.tag,
	      _anchor       = state.anchor,
	      _result       = {},
	      overridableKeys = {},
	      keyTag        = null,
	      keyNode       = null,
	      valueNode     = null,
	      atExplicitKey = false,
	      detected      = false,
	      ch;

	  if (state.anchor !== null) {
	    state.anchorMap[state.anchor] = _result;
	  }

	  ch = state.input.charCodeAt(state.position);

	  while (ch !== 0) {
	    following = state.input.charCodeAt(state.position + 1);
	    _line = state.line; // Save the current line.

	    //
	    // Explicit notation case. There are two separate blocks:
	    // first for the key (denoted by "?") and second for the value (denoted by ":")
	    //
	    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

	      if (ch === 0x3F/* ? */) {
	        if (atExplicitKey) {
	          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	          keyTag = keyNode = valueNode = null;
	        }

	        detected = true;
	        atExplicitKey = true;
	        allowCompact = true;

	      } else if (atExplicitKey) {
	        // i.e. 0x3A/* : */ === character after the explicit key.
	        atExplicitKey = false;
	        allowCompact = true;

	      } else {
	        throwError(state, 'incomplete explicit mapping pair; a key node is missed');
	      }

	      state.position += 1;
	      ch = following;

	    //
	    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
	    //
	    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

	      if (state.line === _line) {
	        ch = state.input.charCodeAt(state.position);

	        while (is_WHITE_SPACE(ch)) {
	          ch = state.input.charCodeAt(++state.position);
	        }

	        if (ch === 0x3A/* : */) {
	          ch = state.input.charCodeAt(++state.position);

	          if (!is_WS_OR_EOL(ch)) {
	            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
	          }

	          if (atExplicitKey) {
	            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	            keyTag = keyNode = valueNode = null;
	          }

	          detected = true;
	          atExplicitKey = false;
	          allowCompact = false;
	          keyTag = state.tag;
	          keyNode = state.result;

	        } else if (detected) {
	          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

	        } else {
	          state.tag = _tag;
	          state.anchor = _anchor;
	          return true; // Keep the result of `composeNode`.
	        }

	      } else if (detected) {
	        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

	      } else {
	        state.tag = _tag;
	        state.anchor = _anchor;
	        return true; // Keep the result of `composeNode`.
	      }

	    } else {
	      break; // Reading is done. Go to the epilogue.
	    }

	    //
	    // Common reading code for both explicit and implicit notations.
	    //
	    if (state.line === _line || state.lineIndent > nodeIndent) {
	      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
	        if (atExplicitKey) {
	          keyNode = state.result;
	        } else {
	          valueNode = state.result;
	        }
	      }

	      if (!atExplicitKey) {
	        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
	        keyTag = keyNode = valueNode = null;
	      }

	      skipSeparationSpace(state, true, -1);
	      ch = state.input.charCodeAt(state.position);
	    }

	    if (state.lineIndent > nodeIndent && (ch !== 0)) {
	      throwError(state, 'bad indentation of a mapping entry');
	    } else if (state.lineIndent < nodeIndent) {
	      break;
	    }
	  }

	  //
	  // Epilogue.
	  //

	  // Special case: last mapping's node contains only the key in explicit notation.
	  if (atExplicitKey) {
	    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
	  }

	  // Expose the resulting mapping.
	  if (detected) {
	    state.tag = _tag;
	    state.anchor = _anchor;
	    state.kind = 'mapping';
	    state.result = _result;
	  }

	  return detected;
	}

	function readTagProperty(state) {
	  var _position,
	      isVerbatim = false,
	      isNamed    = false,
	      tagHandle,
	      tagName,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x21/* ! */) return false;

	  if (state.tag !== null) {
	    throwError(state, 'duplication of a tag property');
	  }

	  ch = state.input.charCodeAt(++state.position);

	  if (ch === 0x3C/* < */) {
	    isVerbatim = true;
	    ch = state.input.charCodeAt(++state.position);

	  } else if (ch === 0x21/* ! */) {
	    isNamed = true;
	    tagHandle = '!!';
	    ch = state.input.charCodeAt(++state.position);

	  } else {
	    tagHandle = '!';
	  }

	  _position = state.position;

	  if (isVerbatim) {
	    do { ch = state.input.charCodeAt(++state.position); }
	    while (ch !== 0 && ch !== 0x3E/* > */);

	    if (state.position < state.length) {
	      tagName = state.input.slice(_position, state.position);
	      ch = state.input.charCodeAt(++state.position);
	    } else {
	      throwError(state, 'unexpected end of the stream within a verbatim tag');
	    }
	  } else {
	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

	      if (ch === 0x21/* ! */) {
	        if (!isNamed) {
	          tagHandle = state.input.slice(_position - 1, state.position + 1);

	          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
	            throwError(state, 'named tag handle cannot contain such characters');
	          }

	          isNamed = true;
	          _position = state.position + 1;
	        } else {
	          throwError(state, 'tag suffix cannot contain exclamation marks');
	        }
	      }

	      ch = state.input.charCodeAt(++state.position);
	    }

	    tagName = state.input.slice(_position, state.position);

	    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
	      throwError(state, 'tag suffix cannot contain flow indicator characters');
	    }
	  }

	  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
	    throwError(state, 'tag name cannot contain such characters: ' + tagName);
	  }

	  if (isVerbatim) {
	    state.tag = tagName;

	  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
	    state.tag = state.tagMap[tagHandle] + tagName;

	  } else if (tagHandle === '!') {
	    state.tag = '!' + tagName;

	  } else if (tagHandle === '!!') {
	    state.tag = 'tag:yaml.org,2002:' + tagName;

	  } else {
	    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
	  }

	  return true;
	}

	function readAnchorProperty(state) {
	  var _position,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x26/* & */) return false;

	  if (state.anchor !== null) {
	    throwError(state, 'duplication of an anchor property');
	  }

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an anchor node must contain at least one character');
	  }

	  state.anchor = state.input.slice(_position, state.position);
	  return true;
	}

	function readAlias(state) {
	  var _position, alias,
	      ch;

	  ch = state.input.charCodeAt(state.position);

	  if (ch !== 0x2A/* * */) return false;

	  ch = state.input.charCodeAt(++state.position);
	  _position = state.position;

	  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
	    ch = state.input.charCodeAt(++state.position);
	  }

	  if (state.position === _position) {
	    throwError(state, 'name of an alias node must contain at least one character');
	  }

	  alias = state.input.slice(_position, state.position);

	  if (!state.anchorMap.hasOwnProperty(alias)) {
	    throwError(state, 'unidentified alias "' + alias + '"');
	  }

	  state.result = state.anchorMap[alias];
	  skipSeparationSpace(state, true, -1);
	  return true;
	}

	function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
	  var allowBlockStyles,
	      allowBlockScalars,
	      allowBlockCollections,
	      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
	      atNewLine  = false,
	      hasContent = false,
	      typeIndex,
	      typeQuantity,
	      type,
	      flowIndent,
	      blockIndent;

	  if (state.listener !== null) {
	    state.listener('open', state);
	  }

	  state.tag    = null;
	  state.anchor = null;
	  state.kind   = null;
	  state.result = null;

	  allowBlockStyles = allowBlockScalars = allowBlockCollections =
	    CONTEXT_BLOCK_OUT === nodeContext ||
	    CONTEXT_BLOCK_IN  === nodeContext;

	  if (allowToSeek) {
	    if (skipSeparationSpace(state, true, -1)) {
	      atNewLine = true;

	      if (state.lineIndent > parentIndent) {
	        indentStatus = 1;
	      } else if (state.lineIndent === parentIndent) {
	        indentStatus = 0;
	      } else if (state.lineIndent < parentIndent) {
	        indentStatus = -1;
	      }
	    }
	  }

	  if (indentStatus === 1) {
	    while (readTagProperty(state) || readAnchorProperty(state)) {
	      if (skipSeparationSpace(state, true, -1)) {
	        atNewLine = true;
	        allowBlockCollections = allowBlockStyles;

	        if (state.lineIndent > parentIndent) {
	          indentStatus = 1;
	        } else if (state.lineIndent === parentIndent) {
	          indentStatus = 0;
	        } else if (state.lineIndent < parentIndent) {
	          indentStatus = -1;
	        }
	      } else {
	        allowBlockCollections = false;
	      }
	    }
	  }

	  if (allowBlockCollections) {
	    allowBlockCollections = atNewLine || allowCompact;
	  }

	  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
	    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
	      flowIndent = parentIndent;
	    } else {
	      flowIndent = parentIndent + 1;
	    }

	    blockIndent = state.position - state.lineStart;

	    if (indentStatus === 1) {
	      if (allowBlockCollections &&
	          (readBlockSequence(state, blockIndent) ||
	           readBlockMapping(state, blockIndent, flowIndent)) ||
	          readFlowCollection(state, flowIndent)) {
	        hasContent = true;
	      } else {
	        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
	            readSingleQuotedScalar(state, flowIndent) ||
	            readDoubleQuotedScalar(state, flowIndent)) {
	          hasContent = true;

	        } else if (readAlias(state)) {
	          hasContent = true;

	          if (state.tag !== null || state.anchor !== null) {
	            throwError(state, 'alias node should not have any properties');
	          }

	        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
	          hasContent = true;

	          if (state.tag === null) {
	            state.tag = '?';
	          }
	        }

	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else if (indentStatus === 0) {
	      // Special case: block sequences are allowed to have same indentation level as the parent.
	      // http://www.yaml.org/spec/1.2/spec.html#id2799784
	      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
	    }
	  }

	  if (state.tag !== null && state.tag !== '!') {
	    if (state.tag === '?') {
	      for (typeIndex = 0, typeQuantity = state.implicitTypes.length;
	           typeIndex < typeQuantity;
	           typeIndex += 1) {
	        type = state.implicitTypes[typeIndex];

	        // Implicit resolving is not allowed for non-scalar types, and '?'
	        // non-specific tag is only assigned to plain scalars. So, it isn't
	        // needed to check for 'kind' conformity.

	        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
	          state.result = type.construct(state.result);
	          state.tag = type.tag;
	          if (state.anchor !== null) {
	            state.anchorMap[state.anchor] = state.result;
	          }
	          break;
	        }
	      }
	    } else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
	      type = state.typeMap[state.tag];

	      if (state.result !== null && type.kind !== state.kind) {
	        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
	      }

	      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
	        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
	      } else {
	        state.result = type.construct(state.result);
	        if (state.anchor !== null) {
	          state.anchorMap[state.anchor] = state.result;
	        }
	      }
	    } else {
	      throwError(state, 'unknown tag !<' + state.tag + '>');
	    }
	  }

	  if (state.listener !== null) {
	    state.listener('close', state);
	  }
	  return state.tag !== null ||  state.anchor !== null || hasContent;
	}

	function readDocument(state) {
	  var documentStart = state.position,
	      _position,
	      directiveName,
	      directiveArgs,
	      hasDirectives = false,
	      ch;

	  state.version = null;
	  state.checkLineBreaks = state.legacy;
	  state.tagMap = {};
	  state.anchorMap = {};

	  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
	    skipSeparationSpace(state, true, -1);

	    ch = state.input.charCodeAt(state.position);

	    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
	      break;
	    }

	    hasDirectives = true;
	    ch = state.input.charCodeAt(++state.position);
	    _position = state.position;

	    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	      ch = state.input.charCodeAt(++state.position);
	    }

	    directiveName = state.input.slice(_position, state.position);
	    directiveArgs = [];

	    if (directiveName.length < 1) {
	      throwError(state, 'directive name must not be less than one character in length');
	    }

	    while (ch !== 0) {
	      while (is_WHITE_SPACE(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      if (ch === 0x23/* # */) {
	        do { ch = state.input.charCodeAt(++state.position); }
	        while (ch !== 0 && !is_EOL(ch));
	        break;
	      }

	      if (is_EOL(ch)) break;

	      _position = state.position;

	      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
	        ch = state.input.charCodeAt(++state.position);
	      }

	      directiveArgs.push(state.input.slice(_position, state.position));
	    }

	    if (ch !== 0) readLineBreak(state);

	    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
	      directiveHandlers[directiveName](state, directiveName, directiveArgs);
	    } else {
	      throwWarning(state, 'unknown document directive "' + directiveName + '"');
	    }
	  }

	  skipSeparationSpace(state, true, -1);

	  if (state.lineIndent === 0 &&
	      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
	      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
	    state.position += 3;
	    skipSeparationSpace(state, true, -1);

	  } else if (hasDirectives) {
	    throwError(state, 'directives end mark is expected');
	  }

	  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
	  skipSeparationSpace(state, true, -1);

	  if (state.checkLineBreaks &&
	      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
	    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
	  }

	  state.documents.push(state.result);

	  if (state.position === state.lineStart && testDocumentSeparator(state)) {

	    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
	      state.position += 3;
	      skipSeparationSpace(state, true, -1);
	    }
	    return;
	  }

	  if (state.position < (state.length - 1)) {
	    throwError(state, 'end of the stream or a document separator is expected');
	  } else {
	    return;
	  }
	}


	function loadDocuments(input, options) {
	  input = String(input);
	  options = options || {};

	  if (input.length !== 0) {

	    // Add tailing `\n` if not exists
	    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
	        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
	      input += '\n';
	    }

	    // Strip BOM
	    if (input.charCodeAt(0) === 0xFEFF) {
	      input = input.slice(1);
	    }
	  }

	  var state = new State(input, options);

	  // Use 0 as string terminator. That significantly simplifies bounds check.
	  state.input += '\0';

	  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
	    state.lineIndent += 1;
	    state.position += 1;
	  }

	  while (state.position < (state.length - 1)) {
	    readDocument(state);
	  }

	  return state.documents;
	}


	function loadAll(input, iterator, options) {
	  var documents = loadDocuments(input, options), index, length;

	  for (index = 0, length = documents.length; index < length; index += 1) {
	    iterator(documents[index]);
	  }
	}


	function load(input, options) {
	  var documents = loadDocuments(input, options);

	  if (documents.length === 0) {
	    /*eslint-disable no-undefined*/
	    return undefined;
	  } else if (documents.length === 1) {
	    return documents[0];
	  }
	  throw new YAMLException('expected a single document in the stream, but found more');
	}


	function safeLoadAll(input, output, options) {
	  loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}


	function safeLoad(input, options) {
	  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
	}


	module.exports.loadAll     = loadAll;
	module.exports.load        = load;
	module.exports.safeLoadAll = safeLoadAll;
	module.exports.safeLoad    = safeLoad;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';


	var common = __webpack_require__(20);


	function Mark(name, buffer, position, line, column) {
	  this.name     = name;
	  this.buffer   = buffer;
	  this.position = position;
	  this.line     = line;
	  this.column   = column;
	}


	Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
	  var head, start, tail, end, snippet;

	  if (!this.buffer) return null;

	  indent = indent || 4;
	  maxLength = maxLength || 75;

	  head = '';
	  start = this.position;

	  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
	    start -= 1;
	    if (this.position - start > (maxLength / 2 - 1)) {
	      head = ' ... ';
	      start += 5;
	      break;
	    }
	  }

	  tail = '';
	  end = this.position;

	  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
	    end += 1;
	    if (end - this.position > (maxLength / 2 - 1)) {
	      tail = ' ... ';
	      end -= 5;
	      break;
	    }
	  }

	  snippet = this.buffer.slice(start, end);

	  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
	         common.repeat(' ', indent + this.position - start + head.length) + '^';
	};


	Mark.prototype.toString = function toString(compact) {
	  var snippet, where = '';

	  if (this.name) {
	    where += 'in "' + this.name + '" ';
	  }

	  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

	  if (!compact) {
	    snippet = this.getSnippet();

	    if (snippet) {
	      where += ':\n' + snippet;
	    }
	  }

	  return where;
	};


	module.exports = Mark;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var require;'use strict';

	/*eslint-disable no-bitwise*/

	var NodeBuffer;

	try {
	  // A trick for browserified version, to not include `Buffer` shim
	  var _require = require;
	  NodeBuffer = __webpack_require__(2).Buffer;
	} catch (__) {}

	var Type       = __webpack_require__(5);


	// [ 64, 65, 66 ] -> [ padding, CR, LF ]
	var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


	function resolveYamlBinary(data) {
	  if (data === null) return false;

	  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

	  // Convert one by one.
	  for (idx = 0; idx < max; idx++) {
	    code = map.indexOf(data.charAt(idx));

	    // Skip CR/LF
	    if (code > 64) continue;

	    // Fail on illegal characters
	    if (code < 0) return false;

	    bitlen += 6;
	  }

	  // If there are any bits left, source was corrupted
	  return (bitlen % 8) === 0;
	}

	function constructYamlBinary(data) {
	  var idx, tailbits,
	      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
	      max = input.length,
	      map = BASE64_MAP,
	      bits = 0,
	      result = [];

	  // Collect by 6*4 bits (3 bytes)

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 4 === 0) && idx) {
	      result.push((bits >> 16) & 0xFF);
	      result.push((bits >> 8) & 0xFF);
	      result.push(bits & 0xFF);
	    }

	    bits = (bits << 6) | map.indexOf(input.charAt(idx));
	  }

	  // Dump tail

	  tailbits = (max % 4) * 6;

	  if (tailbits === 0) {
	    result.push((bits >> 16) & 0xFF);
	    result.push((bits >> 8) & 0xFF);
	    result.push(bits & 0xFF);
	  } else if (tailbits === 18) {
	    result.push((bits >> 10) & 0xFF);
	    result.push((bits >> 2) & 0xFF);
	  } else if (tailbits === 12) {
	    result.push((bits >> 4) & 0xFF);
	  }

	  // Wrap into Buffer for NodeJS and leave Array for browser
	  if (NodeBuffer) return new NodeBuffer(result);

	  return result;
	}

	function representYamlBinary(object /*, style*/) {
	  var result = '', bits = 0, idx, tail,
	      max = object.length,
	      map = BASE64_MAP;

	  // Convert every three bytes to 4 ASCII characters.

	  for (idx = 0; idx < max; idx++) {
	    if ((idx % 3 === 0) && idx) {
	      result += map[(bits >> 18) & 0x3F];
	      result += map[(bits >> 12) & 0x3F];
	      result += map[(bits >> 6) & 0x3F];
	      result += map[bits & 0x3F];
	    }

	    bits = (bits << 8) + object[idx];
	  }

	  // Dump tail

	  tail = max % 3;

	  if (tail === 0) {
	    result += map[(bits >> 18) & 0x3F];
	    result += map[(bits >> 12) & 0x3F];
	    result += map[(bits >> 6) & 0x3F];
	    result += map[bits & 0x3F];
	  } else if (tail === 2) {
	    result += map[(bits >> 10) & 0x3F];
	    result += map[(bits >> 4) & 0x3F];
	    result += map[(bits << 2) & 0x3F];
	    result += map[64];
	  } else if (tail === 1) {
	    result += map[(bits >> 2) & 0x3F];
	    result += map[(bits << 4) & 0x3F];
	    result += map[64];
	    result += map[64];
	  }

	  return result;
	}

	function isBinary(object) {
	  return NodeBuffer && NodeBuffer.isBuffer(object);
	}

	module.exports = new Type('tag:yaml.org,2002:binary', {
	  kind: 'scalar',
	  resolve: resolveYamlBinary,
	  construct: constructYamlBinary,
	  predicate: isBinary,
	  represent: representYamlBinary
	});


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	function resolveYamlBoolean(data) {
	  if (data === null) return false;

	  var max = data.length;

	  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
	         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
	}

	function constructYamlBoolean(data) {
	  return data === 'true' ||
	         data === 'True' ||
	         data === 'TRUE';
	}

	function isBoolean(object) {
	  return Object.prototype.toString.call(object) === '[object Boolean]';
	}

	module.exports = new Type('tag:yaml.org,2002:bool', {
	  kind: 'scalar',
	  resolve: resolveYamlBoolean,
	  construct: constructYamlBoolean,
	  predicate: isBoolean,
	  represent: {
	    lowercase: function (object) { return object ? 'true' : 'false'; },
	    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
	    camelcase: function (object) { return object ? 'True' : 'False'; }
	  },
	  defaultStyle: 'lowercase'
	});


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var common = __webpack_require__(20);
	var Type   = __webpack_require__(5);

	var YAML_FLOAT_PATTERN = new RegExp(
	  '^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
	  '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
	  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
	  '|[-+]?\\.(?:inf|Inf|INF)' +
	  '|\\.(?:nan|NaN|NAN))$');

	function resolveYamlFloat(data) {
	  if (data === null) return false;

	  if (!YAML_FLOAT_PATTERN.test(data)) return false;

	  return true;
	}

	function constructYamlFloat(data) {
	  var value, sign, base, digits;

	  value  = data.replace(/_/g, '').toLowerCase();
	  sign   = value[0] === '-' ? -1 : 1;
	  digits = [];

	  if ('+-'.indexOf(value[0]) >= 0) {
	    value = value.slice(1);
	  }

	  if (value === '.inf') {
	    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

	  } else if (value === '.nan') {
	    return NaN;

	  } else if (value.indexOf(':') >= 0) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseFloat(v, 10));
	    });

	    value = 0.0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += d * base;
	      base *= 60;
	    });

	    return sign * value;

	  }
	  return sign * parseFloat(value, 10);
	}


	var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

	function representYamlFloat(object, style) {
	  var res;

	  if (isNaN(object)) {
	    switch (style) {
	      case 'lowercase': return '.nan';
	      case 'uppercase': return '.NAN';
	      case 'camelcase': return '.NaN';
	    }
	  } else if (Number.POSITIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '.inf';
	      case 'uppercase': return '.INF';
	      case 'camelcase': return '.Inf';
	    }
	  } else if (Number.NEGATIVE_INFINITY === object) {
	    switch (style) {
	      case 'lowercase': return '-.inf';
	      case 'uppercase': return '-.INF';
	      case 'camelcase': return '-.Inf';
	    }
	  } else if (common.isNegativeZero(object)) {
	    return '-0.0';
	  }

	  res = object.toString(10);

	  // JS stringifier can build scientific format without dots: 5e-100,
	  // while YAML requres dot: 5.e-100. Fix it with simple hack

	  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
	}

	function isFloat(object) {
	  return (Object.prototype.toString.call(object) === '[object Number]') &&
	         (object % 1 !== 0 || common.isNegativeZero(object));
	}

	module.exports = new Type('tag:yaml.org,2002:float', {
	  kind: 'scalar',
	  resolve: resolveYamlFloat,
	  construct: constructYamlFloat,
	  predicate: isFloat,
	  represent: representYamlFloat,
	  defaultStyle: 'lowercase'
	});


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var common = __webpack_require__(20);
	var Type   = __webpack_require__(5);

	function isHexCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
	         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
	         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
	}

	function isOctCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
	}

	function isDecCode(c) {
	  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
	}

	function resolveYamlInteger(data) {
	  if (data === null) return false;

	  var max = data.length,
	      index = 0,
	      hasDigits = false,
	      ch;

	  if (!max) return false;

	  ch = data[index];

	  // sign
	  if (ch === '-' || ch === '+') {
	    ch = data[++index];
	  }

	  if (ch === '0') {
	    // 0
	    if (index + 1 === max) return true;
	    ch = data[++index];

	    // base 2, base 8, base 16

	    if (ch === 'b') {
	      // base 2
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (ch !== '0' && ch !== '1') return false;
	        hasDigits = true;
	      }
	      return hasDigits;
	    }


	    if (ch === 'x') {
	      // base 16
	      index++;

	      for (; index < max; index++) {
	        ch = data[index];
	        if (ch === '_') continue;
	        if (!isHexCode(data.charCodeAt(index))) return false;
	        hasDigits = true;
	      }
	      return hasDigits;
	    }

	    // base 8
	    for (; index < max; index++) {
	      ch = data[index];
	      if (ch === '_') continue;
	      if (!isOctCode(data.charCodeAt(index))) return false;
	      hasDigits = true;
	    }
	    return hasDigits;
	  }

	  // base 10 (except 0) or base 60

	  for (; index < max; index++) {
	    ch = data[index];
	    if (ch === '_') continue;
	    if (ch === ':') break;
	    if (!isDecCode(data.charCodeAt(index))) {
	      return false;
	    }
	    hasDigits = true;
	  }

	  if (!hasDigits) return false;

	  // if !base60 - done;
	  if (ch !== ':') return true;

	  // base60 almost not used, no needs to optimize
	  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
	}

	function constructYamlInteger(data) {
	  var value = data, sign = 1, ch, base, digits = [];

	  if (value.indexOf('_') !== -1) {
	    value = value.replace(/_/g, '');
	  }

	  ch = value[0];

	  if (ch === '-' || ch === '+') {
	    if (ch === '-') sign = -1;
	    value = value.slice(1);
	    ch = value[0];
	  }

	  if (value === '0') return 0;

	  if (ch === '0') {
	    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
	    if (value[1] === 'x') return sign * parseInt(value, 16);
	    return sign * parseInt(value, 8);
	  }

	  if (value.indexOf(':') !== -1) {
	    value.split(':').forEach(function (v) {
	      digits.unshift(parseInt(v, 10));
	    });

	    value = 0;
	    base = 1;

	    digits.forEach(function (d) {
	      value += (d * base);
	      base *= 60;
	    });

	    return sign * value;

	  }

	  return sign * parseInt(value, 10);
	}

	function isInteger(object) {
	  return (Object.prototype.toString.call(object)) === '[object Number]' &&
	         (object % 1 === 0 && !common.isNegativeZero(object));
	}

	module.exports = new Type('tag:yaml.org,2002:int', {
	  kind: 'scalar',
	  resolve: resolveYamlInteger,
	  construct: constructYamlInteger,
	  predicate: isInteger,
	  represent: {
	    binary:      function (object) { return '0b' + object.toString(2); },
	    octal:       function (object) { return '0'  + object.toString(8); },
	    decimal:     function (object) { return        object.toString(10); },
	    hexadecimal: function (object) { return '0x' + object.toString(16).toUpperCase(); }
	  },
	  defaultStyle: 'decimal',
	  styleAliases: {
	    binary:      [ 2,  'bin' ],
	    octal:       [ 8,  'oct' ],
	    decimal:     [ 10, 'dec' ],
	    hexadecimal: [ 16, 'hex' ]
	  }
	});


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	var require;'use strict';

	var esprima;

	// Browserified version does not have esprima
	//
	// 1. For node.js just require module as deps
	// 2. For browser try to require mudule via external AMD system.
	//    If not found - try to fallback to window.esprima. If not
	//    found too - then fail to parse.
	//
	try {
	  // workaround to exclude package from browserify list.
	  var _require = require;
	  esprima = __webpack_require__(185);
	} catch (_) {
	  /*global window */
	  if (typeof window !== 'undefined') esprima = window.esprima;
	}

	var Type = __webpack_require__(5);

	function resolveJavascriptFunction(data) {
	  if (data === null) return false;

	  try {
	    var source = '(' + data + ')',
	        ast    = esprima.parse(source, { range: true });

	    if (ast.type                    !== 'Program'             ||
	        ast.body.length             !== 1                     ||
	        ast.body[0].type            !== 'ExpressionStatement' ||
	        ast.body[0].expression.type !== 'FunctionExpression') {
	      return false;
	    }

	    return true;
	  } catch (err) {
	    return false;
	  }
	}

	function constructJavascriptFunction(data) {
	  /*jslint evil:true*/

	  var source = '(' + data + ')',
	      ast    = esprima.parse(source, { range: true }),
	      params = [],
	      body;

	  if (ast.type                    !== 'Program'             ||
	      ast.body.length             !== 1                     ||
	      ast.body[0].type            !== 'ExpressionStatement' ||
	      ast.body[0].expression.type !== 'FunctionExpression') {
	    throw new Error('Failed to resolve function');
	  }

	  ast.body[0].expression.params.forEach(function (param) {
	    params.push(param.name);
	  });

	  body = ast.body[0].expression.body.range;

	  // Esprima's ranges include the first '{' and the last '}' characters on
	  // function expressions. So cut them out.
	  /*eslint-disable no-new-func*/
	  return new Function(params, source.slice(body[0] + 1, body[1] - 1));
	}

	function representJavascriptFunction(object /*, style*/) {
	  return object.toString();
	}

	function isFunction(object) {
	  return Object.prototype.toString.call(object) === '[object Function]';
	}

	module.exports = new Type('tag:yaml.org,2002:js/function', {
	  kind: 'scalar',
	  resolve: resolveJavascriptFunction,
	  construct: constructJavascriptFunction,
	  predicate: isFunction,
	  represent: representJavascriptFunction
	});


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	function resolveJavascriptRegExp(data) {
	  if (data === null) return false;
	  if (data.length === 0) return false;

	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // if regexp starts with '/' it can have modifiers and must be properly closed
	  // `/foo/gim` - modifiers tail can be maximum 3 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];

	    if (modifiers.length > 3) return false;
	    // if expression starts with /, is should be properly terminated
	    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
	  }

	  return true;
	}

	function constructJavascriptRegExp(data) {
	  var regexp = data,
	      tail   = /\/([gim]*)$/.exec(data),
	      modifiers = '';

	  // `/foo/gim` - tail can be maximum 4 chars
	  if (regexp[0] === '/') {
	    if (tail) modifiers = tail[1];
	    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
	  }

	  return new RegExp(regexp, modifiers);
	}

	function representJavascriptRegExp(object /*, style*/) {
	  var result = '/' + object.source + '/';

	  if (object.global) result += 'g';
	  if (object.multiline) result += 'm';
	  if (object.ignoreCase) result += 'i';

	  return result;
	}

	function isRegExp(object) {
	  return Object.prototype.toString.call(object) === '[object RegExp]';
	}

	module.exports = new Type('tag:yaml.org,2002:js/regexp', {
	  kind: 'scalar',
	  resolve: resolveJavascriptRegExp,
	  construct: constructJavascriptRegExp,
	  predicate: isRegExp,
	  represent: representJavascriptRegExp
	});


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	function resolveJavascriptUndefined() {
	  return true;
	}

	function constructJavascriptUndefined() {
	  /*eslint-disable no-undefined*/
	  return undefined;
	}

	function representJavascriptUndefined() {
	  return '';
	}

	function isUndefined(object) {
	  return typeof object === 'undefined';
	}

	module.exports = new Type('tag:yaml.org,2002:js/undefined', {
	  kind: 'scalar',
	  resolve: resolveJavascriptUndefined,
	  construct: constructJavascriptUndefined,
	  predicate: isUndefined,
	  represent: representJavascriptUndefined
	});


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	module.exports = new Type('tag:yaml.org,2002:map', {
	  kind: 'mapping',
	  construct: function (data) { return data !== null ? data : {}; }
	});


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	function resolveYamlMerge(data) {
	  return data === '<<' || data === null;
	}

	module.exports = new Type('tag:yaml.org,2002:merge', {
	  kind: 'scalar',
	  resolve: resolveYamlMerge
	});


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	function resolveYamlNull(data) {
	  if (data === null) return true;

	  var max = data.length;

	  return (max === 1 && data === '~') ||
	         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
	}

	function constructYamlNull() {
	  return null;
	}

	function isNull(object) {
	  return object === null;
	}

	module.exports = new Type('tag:yaml.org,2002:null', {
	  kind: 'scalar',
	  resolve: resolveYamlNull,
	  construct: constructYamlNull,
	  predicate: isNull,
	  represent: {
	    canonical: function () { return '~';    },
	    lowercase: function () { return 'null'; },
	    uppercase: function () { return 'NULL'; },
	    camelcase: function () { return 'Null'; }
	  },
	  defaultStyle: 'lowercase'
	});


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	var _hasOwnProperty = Object.prototype.hasOwnProperty;
	var _toString       = Object.prototype.toString;

	function resolveYamlOmap(data) {
	  if (data === null) return true;

	  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
	      object = data;

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];
	    pairHasKey = false;

	    if (_toString.call(pair) !== '[object Object]') return false;

	    for (pairKey in pair) {
	      if (_hasOwnProperty.call(pair, pairKey)) {
	        if (!pairHasKey) pairHasKey = true;
	        else return false;
	      }
	    }

	    if (!pairHasKey) return false;

	    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
	    else return false;
	  }

	  return true;
	}

	function constructYamlOmap(data) {
	  return data !== null ? data : [];
	}

	module.exports = new Type('tag:yaml.org,2002:omap', {
	  kind: 'sequence',
	  resolve: resolveYamlOmap,
	  construct: constructYamlOmap
	});


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	var _toString = Object.prototype.toString;

	function resolveYamlPairs(data) {
	  if (data === null) return true;

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    if (_toString.call(pair) !== '[object Object]') return false;

	    keys = Object.keys(pair);

	    if (keys.length !== 1) return false;

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return true;
	}

	function constructYamlPairs(data) {
	  if (data === null) return [];

	  var index, length, pair, keys, result,
	      object = data;

	  result = new Array(object.length);

	  for (index = 0, length = object.length; index < length; index += 1) {
	    pair = object[index];

	    keys = Object.keys(pair);

	    result[index] = [ keys[0], pair[keys[0]] ];
	  }

	  return result;
	}

	module.exports = new Type('tag:yaml.org,2002:pairs', {
	  kind: 'sequence',
	  resolve: resolveYamlPairs,
	  construct: constructYamlPairs
	});


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	module.exports = new Type('tag:yaml.org,2002:seq', {
	  kind: 'sequence',
	  construct: function (data) { return data !== null ? data : []; }
	});


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	var _hasOwnProperty = Object.prototype.hasOwnProperty;

	function resolveYamlSet(data) {
	  if (data === null) return true;

	  var key, object = data;

	  for (key in object) {
	    if (_hasOwnProperty.call(object, key)) {
	      if (object[key] !== null) return false;
	    }
	  }

	  return true;
	}

	function constructYamlSet(data) {
	  return data !== null ? data : {};
	}

	module.exports = new Type('tag:yaml.org,2002:set', {
	  kind: 'mapping',
	  resolve: resolveYamlSet,
	  construct: constructYamlSet
	});


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	module.exports = new Type('tag:yaml.org,2002:str', {
	  kind: 'scalar',
	  construct: function (data) { return data !== null ? data : ''; }
	});


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Type = __webpack_require__(5);

	var YAML_DATE_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9])'                    + // [2] month
	  '-([0-9][0-9])$');                   // [3] day

	var YAML_TIMESTAMP_REGEXP = new RegExp(
	  '^([0-9][0-9][0-9][0-9])'          + // [1] year
	  '-([0-9][0-9]?)'                   + // [2] month
	  '-([0-9][0-9]?)'                   + // [3] day
	  '(?:[Tt]|[ \\t]+)'                 + // ...
	  '([0-9][0-9]?)'                    + // [4] hour
	  ':([0-9][0-9])'                    + // [5] minute
	  ':([0-9][0-9])'                    + // [6] second
	  '(?:\\.([0-9]*))?'                 + // [7] fraction
	  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
	  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

	function resolveYamlTimestamp(data) {
	  if (data === null) return false;
	  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
	  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
	  return false;
	}

	function constructYamlTimestamp(data) {
	  var match, year, month, day, hour, minute, second, fraction = 0,
	      delta = null, tz_hour, tz_minute, date;

	  match = YAML_DATE_REGEXP.exec(data);
	  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

	  if (match === null) throw new Error('Date resolve error');

	  // match: [1] year [2] month [3] day

	  year = +(match[1]);
	  month = +(match[2]) - 1; // JS month starts with 0
	  day = +(match[3]);

	  if (!match[4]) { // no hour
	    return new Date(Date.UTC(year, month, day));
	  }

	  // match: [4] hour [5] minute [6] second [7] fraction

	  hour = +(match[4]);
	  minute = +(match[5]);
	  second = +(match[6]);

	  if (match[7]) {
	    fraction = match[7].slice(0, 3);
	    while (fraction.length < 3) { // milli-seconds
	      fraction += '0';
	    }
	    fraction = +fraction;
	  }

	  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

	  if (match[9]) {
	    tz_hour = +(match[10]);
	    tz_minute = +(match[11] || 0);
	    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
	    if (match[9] === '-') delta = -delta;
	  }

	  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

	  if (delta) date.setTime(date.getTime() - delta);

	  return date;
	}

	function representYamlTimestamp(object /*, style*/) {
	  return object.toISOString();
	}

	module.exports = new Type('tag:yaml.org,2002:timestamp', {
	  kind: 'scalar',
	  resolve: resolveYamlTimestamp,
	  construct: constructYamlTimestamp,
	  instanceOf: Date,
	  represent: representYamlTimestamp
	});


/***/ },
/* 249 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property names to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @returns {Object} Returns `object`.
	 */
	function baseCopy(source, props, object) {
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];
	    object[key] = source[key];
	  }
	  return object;
	}

	module.exports = baseCopy;


/***/ },
/* 250 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` or `undefined` values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  return value == null ? '' : (value + '');
	}

	module.exports = baseToString;


/***/ },
/* 251 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * returned by `keysFunc`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  var index = -1,
	      length = props.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = object[props[index]];
	  }
	  return result;
	}

	module.exports = baseValues;


/***/ },
/* 252 */
/***/ function(module, exports) {

	/**
	 * lodash 3.9.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = getNative;


/***/ },
/* 253 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.9 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/**
	 * Used as the [maximum length](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if the provided arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	      ? (isArrayLike(object) && isIndex(index, object.length))
	      : (type == 'string' && index in object)) {
	    var other = object[index];
	    return value === value ? (value === other) : (other !== other);
	  }
	  return false;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	module.exports = isIterateeCall;


/***/ },
/* 254 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to match template delimiters. */
	var reEscape = /<%-([\s\S]+?)%>/g;

	module.exports = reEscape;


/***/ },
/* 255 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.7.0 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to match template delimiters. */
	var reEvaluate = /<%([\s\S]+?)%>/g;

	module.exports = reEvaluate;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(module, global) {/**
	 * lodash 3.0.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used to determine if values are of the language type `Object`. */
	var objectTypes = {
	  'function': true,
	  'object': true
	};

	/** Detect free variable `exports`. */
	var freeExports = (objectTypes[typeof exports] && exports && !exports.nodeType)
	  ? exports
	  : undefined;

	/** Detect free variable `module`. */
	var freeModule = (objectTypes[typeof module] && module && !module.nodeType)
	  ? module
	  : undefined;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = checkGlobal(freeExports && freeModule && typeof global == 'object' && global);

	/** Detect free variable `self`. */
	var freeSelf = checkGlobal(objectTypes[typeof self] && self);

	/** Detect free variable `window`. */
	var freeWindow = checkGlobal(objectTypes[typeof window] && window);

	/** Detect `this` as the global object. */
	var thisGlobal = checkGlobal(objectTypes[typeof this] && this);

	/**
	 * Used as a reference to the global object.
	 *
	 * The `this` value is used if it's the global object to avoid Greasemonkey's
	 * restricted `window` object, otherwise the `window` object is used.
	 */
	var root = freeGlobal ||
	  ((freeWindow !== (thisGlobal && thisGlobal.window)) && freeWindow) ||
	    freeSelf || thisGlobal || Function('return this')();

	/**
	 * Checks if `value` is a global object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
	 */
	function checkGlobal(value) {
	  return (value && value.Object === Object) ? value : null;
	}

	module.exports = root;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(35)(module), (function() { return this; }())))

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.2.0 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var root = __webpack_require__(256);

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"'`]/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;',
	  '`': '&#96;'
	};

	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	function escapeHtmlChar(chr) {
	  return htmlEscapes[chr];
	}

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var Symbol = root.Symbol;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol ? Symbol.prototype : undefined,
	    symbolToString = Symbol ? symbolProto.toString : undefined;

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && objectToString.call(value) == symbolTag);
	}

	/**
	 * Converts `value` to a string if it's not one. An empty string is returned
	 * for `null` and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (value == null) {
	    return '';
	  }
	  if (isSymbol(value)) {
	    return Symbol ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Converts the characters "&", "<", ">", '"', "'", and "\`" in `string` to
	 * their corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional
	 * characters use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value.
	 * See [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * Backticks are escaped because in IE < 9, they can break out of
	 * attribute values or HTML comments. See [#59](https://html5sec.org/#59),
	 * [#102](https://html5sec.org/#102), [#108](https://html5sec.org/#108), and
	 * [#133](https://html5sec.org/#133) of the [HTML5 Security Cheatsheet](https://html5sec.org/)
	 * for more details.
	 *
	 * When working with HTML you should always [quote attribute values](http://wonko.com/post/html-escaping)
	 * to reduce XSS vectors.
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbles'
	 */
	function escape(string) {
	  string = toString(string);
	  return (string && reHasUnescapedHtml.test(string))
	    ? string.replace(reUnescapedHtml, escapeHtmlChar)
	    : string;
	}

	module.exports = escape;


/***/ },
/* 258 */
/***/ function(module, exports) {

	/**
	 * lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]';

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	module.exports = isArguments;


/***/ },
/* 259 */
/***/ function(module, exports) {

	/**
	 * lodash 3.0.4 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** `Object#toString` result references. */
	var arrayTag = '[object Array]',
	    funcTag = '[object Function]';

	/** Used to detect host constructors (Safari > 5). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var fnToString = Function.prototype.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  fnToString.call(hasOwnProperty).replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeIsArray = getNative(Array, 'isArray');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = object == null ? undefined : object[key];
	  return isNative(value) ? value : undefined;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(function() { return arguments; }());
	 * // => false
	 */
	var isArray = nativeIsArray || function(value) {
	  return isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag;
	};

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in older versions of Chrome and Safari which return 'function' for regexes
	  // and Safari 8 equivalents which return 'object' for typed array constructors.
	  return isObject(value) && objToString.call(value) == funcTag;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is a native function.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (value == null) {
	    return false;
	  }
	  if (isFunction(value)) {
	    return reIsNative.test(fnToString.call(value));
	  }
	  return isObjectLike(value) && reIsHostCtor.test(value);
	}

	module.exports = isArray;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var getNative = __webpack_require__(252),
	    isArguments = __webpack_require__(258),
	    isArray = __webpack_require__(259);

	/** Used to detect unsigned integer values. */
	var reIsUint = /^\d+$/;

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeKeys = getNative(Object, 'keys');

	/**
	 * Used as the [maximum length](http://ecma-international.org/ecma-262/6.0/#sec-number.max_safe_integer)
	 * of an array-like value.
	 */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * Gets the "length" property value of `object`.
	 *
	 * **Note:** This function is used to avoid a [JIT bug](https://bugs.webkit.org/show_bug.cgi?id=142792)
	 * that affects Safari on at least iOS 8.1-8.3 ARM64.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {*} Returns the "length" value.
	 */
	var getLength = baseProperty('length');

	/**
	 * Checks if `value` is array-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 */
	function isArrayLike(value) {
	  return value != null && isLength(getLength(value));
	}

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  value = (typeof value == 'number' || reIsUint.test(value)) ? +value : -1;
	  length = length == null ? MAX_SAFE_INTEGER : length;
	  return value > -1 && value % 1 == 0 && value < length;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This function is based on [`ToLength`](http://ecma-international.org/ecma-262/6.0/#sec-tolength).
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 */
	function isLength(value) {
	  return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * A fallback implementation of `Object.keys` which creates an array of the
	 * own enumerable property names of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function shimKeys(object) {
	  var props = keysIn(object),
	      propsLength = props.length,
	      length = propsLength && object.length;

	  var allowIndexes = !!length && isLength(length) &&
	    (isArray(object) || isArguments(object));

	  var index = -1,
	      result = [];

	  while (++index < propsLength) {
	    var key = props[index];
	    if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
	 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(1);
	 * // => false
	 */
	function isObject(value) {
	  // Avoid a V8 JIT bug in Chrome 19-20.
	  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/6.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	var keys = !nativeKeys ? shimKeys : function(object) {
	  var Ctor = object == null ? undefined : object.constructor;
	  if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
	      (typeof object != 'function' && isArrayLike(object))) {
	    return shimKeys(object);
	  }
	  return isObject(object) ? nativeKeys(object) : [];
	};

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn(object) {
	  if (object == null) {
	    return [];
	  }
	  if (!isObject(object)) {
	    object = Object(object);
	  }
	  var length = object.length;
	  length = (length && isLength(length) &&
	    (isArray(object) || isArguments(object)) && length) || 0;

	  var Ctor = object.constructor,
	      index = -1,
	      isProto = typeof Ctor == 'function' && Ctor.prototype === object,
	      result = Array(length),
	      skipIndexes = length > 0;

	  while (++index < length) {
	    result[index] = (index + '');
	  }
	  for (var key in object) {
	    if (!(skipIndexes && isIndex(key, length)) &&
	        !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	module.exports = keys;


/***/ },
/* 261 */
/***/ function(module, exports) {

	/**
	 * lodash 3.6.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */

	/** Used as the `TypeError` message for "Functions" methods. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/* Native method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as an array.
	 *
	 * **Note:** This method is based on the [rest parameter](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.restParam(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function restParam(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  start = nativeMax(start === undefined ? (func.length - 1) : (+start || 0), 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax(args.length - start, 0),
	        rest = Array(length);

	    while (++index < length) {
	      rest[index] = args[start + index];
	    }
	    switch (start) {
	      case 0: return func.call(this, rest);
	      case 1: return func.call(this, args[0], rest);
	      case 2: return func.call(this, args[0], args[1], rest);
	    }
	    var otherArgs = Array(start + 1);
	    index = -1;
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = rest;
	    return func.apply(this, otherArgs);
	  };
	}

	module.exports = restParam;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.6.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern modularize exports="npm" -o ./`
	 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var baseCopy = __webpack_require__(249),
	    baseToString = __webpack_require__(250),
	    baseValues = __webpack_require__(251),
	    isIterateeCall = __webpack_require__(253),
	    reInterpolate = __webpack_require__(41),
	    keys = __webpack_require__(260),
	    restParam = __webpack_require__(261),
	    templateSettings = __webpack_require__(263);

	/** `Object#toString` result references. */
	var errorTag = '[object Error]';

	/** Used to match empty string literals in compiled template source. */
	var reEmptyStringLeading = /\b__p \+= '';/g,
	    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	/** Used to match [ES template delimiters](http://ecma-international.org/ecma-262/6.0/#sec-template-literal-lexical-components). */
	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	/** Used to ensure capturing order of template delimiters. */
	var reNoMatch = /($^)/;

	/** Used to match unescaped characters in compiled string literals. */
	var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	/** Used to escape characters for inclusion in compiled string literals. */
	var stringEscapes = {
	  '\\': '\\',
	  "'": "'",
	  '\n': 'n',
	  '\r': 'r',
	  '\u2028': 'u2028',
	  '\u2029': 'u2029'
	};

	/**
	 * Used by `_.template` to escape characters for inclusion in compiled string literals.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	function escapeStringChar(chr) {
	  return '\\' + stringEscapes[chr];
	}

	/**
	 * Checks if `value` is object-like.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/** Used for native method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objToString = objectProto.toString;

	/**
	 * Used by `_.template` to customize its `_.assign` use.
	 *
	 * **Note:** This function is like `assignDefaults` except that it ignores
	 * inherited property values when checking if a property is `undefined`.
	 *
	 * @private
	 * @param {*} objectValue The destination object property value.
	 * @param {*} sourceValue The source object property value.
	 * @param {string} key The key associated with the object and source values.
	 * @param {Object} object The destination object.
	 * @returns {*} Returns the value to assign to the destination object.
	 */
	function assignOwnDefaults(objectValue, sourceValue, key, object) {
	  return (objectValue === undefined || !hasOwnProperty.call(object, key))
	    ? sourceValue
	    : objectValue;
	}

	/**
	 * A specialized version of `_.assign` for customizing assigned values without
	 * support for argument juggling, multiple sources, and `this` binding `customizer`
	 * functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 */
	function assignWith(object, source, customizer) {
	  var index = -1,
	      props = keys(source),
	      length = props.length;

	  while (++index < length) {
	    var key = props[index],
	        value = object[key],
	        result = customizer(value, source[key], key, object, source);

	    if ((result === result ? (result !== value) : (value === value)) ||
	        (value === undefined && !(key in object))) {
	      object[key] = result;
	    }
	  }
	  return object;
	}

	/**
	 * The base implementation of `_.assign` without support for argument juggling,
	 * multiple sources, and `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return source == null
	    ? object
	    : baseCopy(source, keys(source), object);
	}

	/**
	 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	 * `SyntaxError`, `TypeError`, or `URIError` object.
	 *
	 * @static
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	 * @example
	 *
	 * _.isError(new Error);
	 * // => true
	 *
	 * _.isError(Error);
	 * // => false
	 */
	function isError(value) {
	  return isObjectLike(value) && typeof value.message == 'string' && objToString.call(value) == errorTag;
	}

	/**
	 * Creates a compiled template function that can interpolate data properties
	 * in "interpolate" delimiters, HTML-escape interpolated data properties in
	 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	 * properties may be accessed as free variables in the template. If a setting
	 * object is provided it takes precedence over `_.templateSettings` values.
	 *
	 * **Note:** In the development build `_.template` utilizes
	 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	 * for easier debugging.
	 *
	 * For more information on precompiling templates see
	 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	 *
	 * For more information on Chrome extension sandboxes see
	 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	 *
	 * @static
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The template string.
	 * @param {Object} [options] The options object.
	 * @param {RegExp} [options.escape] The HTML "escape" delimiter.
	 * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
	 * @param {Object} [options.imports] An object to import into the template as free variables.
	 * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
	 * @param {string} [options.sourceURL] The sourceURL of the template's compiled source.
	 * @param {string} [options.variable] The data object variable name.
	 * @param- {Object} [otherOptions] Enables the legacy `options` param signature.
	 * @returns {Function} Returns the compiled template function.
	 * @example
	 *
	 * // using the "interpolate" delimiter to create a compiled template
	 * var compiled = _.template('hello <%= user %>!');
	 * compiled({ 'user': 'fred' });
	 * // => 'hello fred!'
	 *
	 * // using the HTML "escape" delimiter to escape data property values
	 * var compiled = _.template('<b><%- value %></b>');
	 * compiled({ 'value': '<script>' });
	 * // => '<b>&lt;script&gt;</b>'
	 *
	 * // using the "evaluate" delimiter to execute JavaScript and generate HTML
	 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // using the internal `print` function in "evaluate" delimiters
	 * var compiled = _.template('<% print("hello " + user); %>!');
	 * compiled({ 'user': 'barney' });
	 * // => 'hello barney!'
	 *
	 * // using the ES delimiter as an alternative to the default "interpolate" delimiter
	 * var compiled = _.template('hello ${ user }!');
	 * compiled({ 'user': 'pebbles' });
	 * // => 'hello pebbles!'
	 *
	 * // using custom template delimiters
	 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	 * var compiled = _.template('hello {{ user }}!');
	 * compiled({ 'user': 'mustache' });
	 * // => 'hello mustache!'
	 *
	 * // using backslashes to treat delimiters as plain text
	 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	 * compiled({ 'value': 'ignored' });
	 * // => '<%- value %>'
	 *
	 * // using the `imports` option to import `jQuery` as `jq`
	 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // using the `sourceURL` option to specify a custom sourceURL for the template
	 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	 * compiled(data);
	 * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
	 *
	 * // using the `variable` option to ensure a with-statement isn't used in the compiled template
	 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	 * compiled.source;
	 * // => function(data) {
	 * //   var __t, __p = '';
	 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	 * //   return __p;
	 * // }
	 *
	 * // using the `source` property to inline compiled templates for meaningful
	 * // line numbers in error messages and a stack trace
	 * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
	 *   var JST = {\
	 *     "main": ' + _.template(mainText).source + '\
	 *   };\
	 * ');
	 */
	function template(string, options, otherOptions) {
	  // Based on John Resig's `tmpl` implementation (http://ejohn.org/blog/javascript-micro-templating/)
	  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	  var settings = templateSettings.imports._.templateSettings || templateSettings;

	  if (otherOptions && isIterateeCall(string, options, otherOptions)) {
	    options = otherOptions = undefined;
	  }
	  string = baseToString(string);
	  options = assignWith(baseAssign({}, otherOptions || options), settings, assignOwnDefaults);

	  var imports = assignWith(baseAssign({}, options.imports), settings.imports, assignOwnDefaults),
	      importsKeys = keys(imports),
	      importsValues = baseValues(imports, importsKeys);

	  var isEscaping,
	      isEvaluating,
	      index = 0,
	      interpolate = options.interpolate || reNoMatch,
	      source = "__p += '";

	  // Compile the regexp to match each delimiter.
	  var reDelimiters = RegExp(
	    (options.escape || reNoMatch).source + '|' +
	    interpolate.source + '|' +
	    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	    (options.evaluate || reNoMatch).source + '|$'
	  , 'g');

	  // Use a sourceURL for easier debugging.
	  var sourceURL = 'sourceURL' in options ? '//# sourceURL=' + options.sourceURL + '\n' : '';

	  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	    interpolateValue || (interpolateValue = esTemplateValue);

	    // Escape characters that can't be included in string literals.
	    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	    // Replace delimiters with snippets.
	    if (escapeValue) {
	      isEscaping = true;
	      source += "' +\n__e(" + escapeValue + ") +\n'";
	    }
	    if (evaluateValue) {
	      isEvaluating = true;
	      source += "';\n" + evaluateValue + ";\n__p += '";
	    }
	    if (interpolateValue) {
	      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	    }
	    index = offset + match.length;

	    // The JS engine embedded in Adobe products requires returning the `match`
	    // string in order to produce the correct `offset` value.
	    return match;
	  });

	  source += "';\n";

	  // If `variable` is not specified wrap a with-statement around the generated
	  // code to add the data object to the top of the scope chain.
	  var variable = options.variable;
	  if (!variable) {
	    source = 'with (obj) {\n' + source + '\n}\n';
	  }
	  // Cleanup code by stripping empty strings.
	  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	    .replace(reEmptyStringMiddle, '$1')
	    .replace(reEmptyStringTrailing, '$1;');

	  // Frame code as the function body.
	  source = 'function(' + (variable || 'obj') + ') {\n' +
	    (variable
	      ? ''
	      : 'obj || (obj = {});\n'
	    ) +
	    "var __t, __p = ''" +
	    (isEscaping
	       ? ', __e = _.escape'
	       : ''
	    ) +
	    (isEvaluating
	      ? ', __j = Array.prototype.join;\n' +
	        "function print() { __p += __j.call(arguments, '') }\n"
	      : ';\n'
	    ) +
	    source +
	    'return __p\n}';

	  var result = attempt(function() {
	    return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
	  });

	  // Provide the compiled function's source by its `toString` method or
	  // the `source` property as a convenience for inlining compiled templates.
	  result.source = source;
	  if (isError(result)) {
	    throw result;
	  }
	  return result;
	}

	/**
	 * Attempts to invoke `func`, returning either the result or the caught error
	 * object. Any additional arguments are provided to `func` when it is invoked.
	 *
	 * @static
	 * @memberOf _
	 * @category Utility
	 * @param {Function} func The function to attempt.
	 * @returns {*} Returns the `func` result or error object.
	 * @example
	 *
	 * // avoid throwing errors for invalid selectors
	 * var elements = _.attempt(function(selector) {
	 *   return document.querySelectorAll(selector);
	 * }, '>_>');
	 *
	 * if (_.isError(elements)) {
	 *   elements = [];
	 * }
	 */
	var attempt = restParam(function(func, args) {
	  try {
	    return func.apply(undefined, args);
	  } catch(e) {
	    return isError(e) ? e : new Error(e);
	  }
	});

	module.exports = template;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * lodash 3.1.1 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="npm" -o ./`
	 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */
	var escape = __webpack_require__(257),
	    reInterpolate = __webpack_require__(41);

	/** Used to match template delimiters. */
	var reEscape = /<%-([\s\S]+?)%>/g,
	    reEvaluate = /<%([\s\S]+?)%>/g;

	/**
	 * By default, the template delimiters used by lodash are like those in
	 * embedded Ruby (ERB). Change the following template settings to use
	 * alternative delimiters.
	 *
	 * @static
	 * @memberOf _
	 * @type Object
	 */
	var templateSettings = {

	  /**
	   * Used to detect `data` property values to be HTML-escaped.
	   *
	   * @memberOf _.templateSettings
	   * @type RegExp
	   */
	  'escape': reEscape,

	  /**
	   * Used to detect code to be evaluated.
	   *
	   * @memberOf _.templateSettings
	   * @type RegExp
	   */
	  'evaluate': reEvaluate,

	  /**
	   * Used to detect `data` property values to inject.
	   *
	   * @memberOf _.templateSettings
	   * @type RegExp
	   */
	  'interpolate': reInterpolate,

	  /**
	   * Used to reference the data object in the template text.
	   *
	   * @memberOf _.templateSettings
	   * @type string
	   */
	  'variable': '',

	  /**
	   * Used to import variables into the compiled template.
	   *
	   * @memberOf _.templateSettings
	   * @type Object
	   */
	  'imports': {

	    /**
	     * A reference to the `lodash` function.
	     *
	     * @memberOf _.templateSettings.imports
	     * @type Function
	     */
	    '_': { 'escape': escape }
	  }
	};

	module.exports = templateSettings;


/***/ },
/* 264 */
/***/ function(module, exports) {

	module.exports = function (args, opts) {
	    if (!opts) opts = {};
	    
	    var flags = { bools : {}, strings : {}, unknownFn: null };

	    if (typeof opts['unknown'] === 'function') {
	        flags.unknownFn = opts['unknown'];
	    }

	    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
	      flags.allBools = true;
	    } else {
	      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
	          flags.bools[key] = true;
	      });
	    }
	    
	    var aliases = {};
	    Object.keys(opts.alias || {}).forEach(function (key) {
	        aliases[key] = [].concat(opts.alias[key]);
	        aliases[key].forEach(function (x) {
	            aliases[x] = [key].concat(aliases[key].filter(function (y) {
	                return x !== y;
	            }));
	        });
	    });

	    [].concat(opts.string).filter(Boolean).forEach(function (key) {
	        flags.strings[key] = true;
	        if (aliases[key]) {
	            flags.strings[aliases[key]] = true;
	        }
	     });

	    var defaults = opts['default'] || {};
	    
	    var argv = { _ : [] };
	    Object.keys(flags.bools).forEach(function (key) {
	        setArg(key, defaults[key] === undefined ? false : defaults[key]);
	    });
	    
	    var notFlags = [];

	    if (args.indexOf('--') !== -1) {
	        notFlags = args.slice(args.indexOf('--')+1);
	        args = args.slice(0, args.indexOf('--'));
	    }

	    function argDefined(key, arg) {
	        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
	            flags.strings[key] || flags.bools[key] || aliases[key];
	    }

	    function setArg (key, val, arg) {
	        if (arg && flags.unknownFn && !argDefined(key, arg)) {
	            if (flags.unknownFn(arg) === false) return;
	        }

	        var value = !flags.strings[key] && isNumber(val)
	            ? Number(val) : val
	        ;
	        setKey(argv, key.split('.'), value);
	        
	        (aliases[key] || []).forEach(function (x) {
	            setKey(argv, x.split('.'), value);
	        });
	    }

	    function setKey (obj, keys, value) {
	        var o = obj;
	        keys.slice(0,-1).forEach(function (key) {
	            if (o[key] === undefined) o[key] = {};
	            o = o[key];
	        });

	        var key = keys[keys.length - 1];
	        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
	            o[key] = value;
	        }
	        else if (Array.isArray(o[key])) {
	            o[key].push(value);
	        }
	        else {
	            o[key] = [ o[key], value ];
	        }
	    }
	    
	    function aliasIsBoolean(key) {
	      return aliases[key].some(function (x) {
	          return flags.bools[x];
	      });
	    }

	    for (var i = 0; i < args.length; i++) {
	        var arg = args[i];
	        
	        if (/^--.+=/.test(arg)) {
	            // Using [\s\S] instead of . because js doesn't support the
	            // 'dotall' regex modifier. See:
	            // http://stackoverflow.com/a/1068308/13216
	            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
	            var key = m[1];
	            var value = m[2];
	            if (flags.bools[key]) {
	                value = value !== 'false';
	            }
	            setArg(key, value, arg);
	        }
	        else if (/^--no-.+/.test(arg)) {
	            var key = arg.match(/^--no-(.+)/)[1];
	            setArg(key, false, arg);
	        }
	        else if (/^--.+/.test(arg)) {
	            var key = arg.match(/^--(.+)/)[1];
	            var next = args[i + 1];
	            if (next !== undefined && !/^-/.test(next)
	            && !flags.bools[key]
	            && !flags.allBools
	            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
	                setArg(key, next, arg);
	                i++;
	            }
	            else if (/^(true|false)$/.test(next)) {
	                setArg(key, next === 'true', arg);
	                i++;
	            }
	            else {
	                setArg(key, flags.strings[key] ? '' : true, arg);
	            }
	        }
	        else if (/^-[^-]+/.test(arg)) {
	            var letters = arg.slice(1,-1).split('');
	            
	            var broken = false;
	            for (var j = 0; j < letters.length; j++) {
	                var next = arg.slice(j+2);
	                
	                if (next === '-') {
	                    setArg(letters[j], next, arg)
	                    continue;
	                }
	                
	                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
	                    setArg(letters[j], next.split('=')[1], arg);
	                    broken = true;
	                    break;
	                }
	                
	                if (/[A-Za-z]/.test(letters[j])
	                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
	                    setArg(letters[j], next, arg);
	                    broken = true;
	                    break;
	                }
	                
	                if (letters[j+1] && letters[j+1].match(/\W/)) {
	                    setArg(letters[j], arg.slice(j+2), arg);
	                    broken = true;
	                    break;
	                }
	                else {
	                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
	                }
	            }
	            
	            var key = arg.slice(-1)[0];
	            if (!broken && key !== '-') {
	                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
	                && !flags.bools[key]
	                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
	                    setArg(key, args[i+1], arg);
	                    i++;
	                }
	                else if (args[i+1] && /true|false/.test(args[i+1])) {
	                    setArg(key, args[i+1] === 'true', arg);
	                    i++;
	                }
	                else {
	                    setArg(key, flags.strings[key] ? '' : true, arg);
	                }
	            }
	        }
	        else {
	            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
	                argv._.push(
	                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
	                );
	            }
	            if (opts.stopEarly) {
	                argv._.push.apply(argv._, args.slice(i + 1));
	                break;
	            }
	        }
	    }
	    
	    Object.keys(defaults).forEach(function (key) {
	        if (!hasKey(argv, key.split('.'))) {
	            setKey(argv, key.split('.'), defaults[key]);
	            
	            (aliases[key] || []).forEach(function (x) {
	                setKey(argv, x.split('.'), defaults[key]);
	            });
	        }
	    });
	    
	    if (opts['--']) {
	        argv['--'] = new Array();
	        notFlags.forEach(function(key) {
	            argv['--'].push(key);
	        });
	    }
	    else {
	        notFlags.forEach(function(key) {
	            argv._.push(key);
	        });
	    }

	    return argv;
	};

	function hasKey (obj, keys) {
	    var o = obj;
	    keys.slice(0,-1).forEach(function (key) {
	        o = (o[key] || {});
	    });

	    var key = keys[keys.length - 1];
	    return key in o;
	}

	function isNumber (x) {
	    if (typeof x === 'number') return true;
	    if (/^0x[0-9a-f]+$/i.test(x)) return true;
	    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
	}



/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	
	/**
	 * Module dependencies.
	 */

	var duplexer = __webpack_require__(178);
	var Stream = __webpack_require__(3);

	/**
	 * Slice reference.
	 */

	var slice = [].slice;

	/**
	 * Duplexer options.
	 */

	var opts = {
	  bubbleErrors: false
	};

	/**
	 * Expose `pipe`.
	 */

	module.exports = pipe;

	/**
	 * Pipe.
	 *
	 * @param {Stream,...,[Function]}
	 * @return {Stream}
	 * @api public
	 */

	function pipe(){
	  if (arguments.length == 1) return arguments[0];
	  var streams = slice.call(arguments);
	  var cb;
	  if ('function' == typeof streams[streams.length - 1]) {
	    cb = streams.splice(-1)[0];
	  }
	  var first = streams[0];
	  var last = streams[streams.length - 1];
	  var ret;
	  
	  if (first.writable && last.readable) ret = duplexer(opts, first, last);
	  else if (first.writable) ret = first;
	  else if (last.readable) ret = last;
	  else ret = new Stream;
	  
	  streams.forEach(function(stream, i){
	    var next = streams[i+1];
	    if (next) stream.pipe(next);
	    if (stream != ret) stream.on('error', ret.emit.bind(ret, 'error'));
	  });

	  if (cb) {
	    var ended = false;
	    ret.on('error', end);
	    last.on('finish', end);
	    function end(err){
	      if (ended) return;
	      ended = true;
	      cb(err);
	    }
	  }

	  return ret;
	}



/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./index": 42,
		"./index.js": 42
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 266;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	/*! Browser bundle of nunjucks 2.5.2  */
	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["nunjucks"] = factory();
		else
			root["nunjucks"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lib = __webpack_require__(1);
		var env = __webpack_require__(2);
		var Loader = __webpack_require__(15);
		var loaders = __webpack_require__(14);
		var precompile = __webpack_require__(3);

		module.exports = {};
		module.exports.Environment = env.Environment;
		module.exports.Template = env.Template;

		module.exports.Loader = Loader;
		module.exports.FileSystemLoader = loaders.FileSystemLoader;
		module.exports.PrecompiledLoader = loaders.PrecompiledLoader;
		module.exports.WebLoader = loaders.WebLoader;

		module.exports.compiler = __webpack_require__(7);
		module.exports.parser = __webpack_require__(8);
		module.exports.lexer = __webpack_require__(9);
		module.exports.runtime = __webpack_require__(12);
		module.exports.lib = lib;
		module.exports.nodes = __webpack_require__(10);

		module.exports.installJinjaCompat = __webpack_require__(18);

		// A single instance of an environment, since this is so commonly used

		var e;
		module.exports.configure = function(templatesPath, opts) {
		    opts = opts || {};
		    if(lib.isObject(templatesPath)) {
		        opts = templatesPath;
		        templatesPath = null;
		    }

		    var TemplateLoader;
		    if(loaders.FileSystemLoader) {
		        TemplateLoader = new loaders.FileSystemLoader(templatesPath, {
		            watch: opts.watch,
		            noCache: opts.noCache
		        });
		    }
		    else if(loaders.WebLoader) {
		        TemplateLoader = new loaders.WebLoader(templatesPath, {
		            useCache: opts.web && opts.web.useCache,
		            async: opts.web && opts.web.async
		        });
		    }

		    e = new env.Environment(TemplateLoader, opts);

		    if(opts && opts.express) {
		        e.express(opts.express);
		    }

		    return e;
		};

		module.exports.compile = function(src, env, path, eagerCompile) {
		    if(!e) {
		        module.exports.configure();
		    }
		    return new module.exports.Template(src, env, path, eagerCompile);
		};

		module.exports.render = function(name, ctx, cb) {
		    if(!e) {
		        module.exports.configure();
		    }

		    return e.render(name, ctx, cb);
		};

		module.exports.renderString = function(src, ctx, cb) {
		    if(!e) {
		        module.exports.configure();
		    }

		    return e.renderString(src, ctx, cb);
		};

		if(precompile) {
		    module.exports.precompile = precompile.precompile;
		    module.exports.precompileString = precompile.precompileString;
		}


	/***/ },
	/* 1 */
	/***/ function(module, exports) {

		'use strict';

		var ArrayProto = Array.prototype;
		var ObjProto = Object.prototype;

		var escapeMap = {
		    '&': '&amp;',
		    '"': '&quot;',
		    '\'': '&#39;',
		    '<': '&lt;',
		    '>': '&gt;'
		};

		var escapeRegex = /[&"'<>]/g;

		var lookupEscape = function(ch) {
		    return escapeMap[ch];
		};

		var exports = module.exports = {};

		exports.prettifyError = function(path, withInternals, err) {
		    // jshint -W022
		    // http://jslinterrors.com/do-not-assign-to-the-exception-parameter
		    if (!err.Update) {
		        // not one of ours, cast it
		        err = new exports.TemplateError(err);
		    }
		    err.Update(path);

		    // Unless they marked the dev flag, show them a trace from here
		    if (!withInternals) {
		        var old = err;
		        err = new Error(old.message);
		        err.name = old.name;
		    }

		    return err;
		};

		exports.TemplateError = function(message, lineno, colno) {
		    var err = this;

		    if (message instanceof Error) { // for casting regular js errors
		        err = message;
		        message = message.name + ': ' + message.message;

		        try {
		            if(err.name = '') {}
		        }
		        catch(e) {
		            // If we can't set the name of the error object in this
		            // environment, don't use it
		            err = this;
		        }
		    } else {
		        if(Error.captureStackTrace) {
		            Error.captureStackTrace(err);
		        }
		    }

		    err.name = 'Template render error';
		    err.message = message;
		    err.lineno = lineno;
		    err.colno = colno;
		    err.firstUpdate = true;

		    err.Update = function(path) {
		        var message = '(' + (path || 'unknown path') + ')';

		        // only show lineno + colno next to path of template
		        // where error occurred
		        if (this.firstUpdate) {
		            if(this.lineno && this.colno) {
		                message += ' [Line ' + this.lineno + ', Column ' + this.colno + ']';
		            }
		            else if(this.lineno) {
		                message += ' [Line ' + this.lineno + ']';
		            }
		        }

		        message += '\n ';
		        if (this.firstUpdate) {
		            message += ' ';
		        }

		        this.message = message + (this.message || '');
		        this.firstUpdate = false;
		        return this;
		    };

		    return err;
		};

		exports.TemplateError.prototype = Error.prototype;

		exports.escape = function(val) {
		  return val.replace(escapeRegex, lookupEscape);
		};

		exports.isFunction = function(obj) {
		    return ObjProto.toString.call(obj) === '[object Function]';
		};

		exports.isArray = Array.isArray || function(obj) {
		    return ObjProto.toString.call(obj) === '[object Array]';
		};

		exports.isString = function(obj) {
		    return ObjProto.toString.call(obj) === '[object String]';
		};

		exports.isObject = function(obj) {
		    return ObjProto.toString.call(obj) === '[object Object]';
		};

		exports.groupBy = function(obj, val) {
		    var result = {};
		    var iterator = exports.isFunction(val) ? val : function(obj) { return obj[val]; };
		    for(var i=0; i<obj.length; i++) {
		        var value = obj[i];
		        var key = iterator(value, i);
		        (result[key] || (result[key] = [])).push(value);
		    }
		    return result;
		};

		exports.toArray = function(obj) {
		    return Array.prototype.slice.call(obj);
		};

		exports.without = function(array) {
		    var result = [];
		    if (!array) {
		        return result;
		    }
		    var index = -1,
		    length = array.length,
		    contains = exports.toArray(arguments).slice(1);

		    while(++index < length) {
		        if(exports.indexOf(contains, array[index]) === -1) {
		            result.push(array[index]);
		        }
		    }
		    return result;
		};

		exports.extend = function(obj, obj2) {
		    for(var k in obj2) {
		        obj[k] = obj2[k];
		    }
		    return obj;
		};

		exports.repeat = function(char_, n) {
		    var str = '';
		    for(var i=0; i<n; i++) {
		        str += char_;
		    }
		    return str;
		};

		exports.each = function(obj, func, context) {
		    if(obj == null) {
		        return;
		    }

		    if(ArrayProto.each && obj.each === ArrayProto.each) {
		        obj.forEach(func, context);
		    }
		    else if(obj.length === +obj.length) {
		        for(var i=0, l=obj.length; i<l; i++) {
		            func.call(context, obj[i], i, obj);
		        }
		    }
		};

		exports.map = function(obj, func) {
		    var results = [];
		    if(obj == null) {
		        return results;
		    }

		    if(ArrayProto.map && obj.map === ArrayProto.map) {
		        return obj.map(func);
		    }

		    for(var i=0; i<obj.length; i++) {
		        results[results.length] = func(obj[i], i);
		    }

		    if(obj.length === +obj.length) {
		        results.length = obj.length;
		    }

		    return results;
		};

		exports.asyncIter = function(arr, iter, cb) {
		    var i = -1;

		    function next() {
		        i++;

		        if(i < arr.length) {
		            iter(arr[i], i, next, cb);
		        }
		        else {
		            cb();
		        }
		    }

		    next();
		};

		exports.asyncFor = function(obj, iter, cb) {
		    var keys = exports.keys(obj);
		    var len = keys.length;
		    var i = -1;

		    function next() {
		        i++;
		        var k = keys[i];

		        if(i < len) {
		            iter(k, obj[k], i, len, next);
		        }
		        else {
		            cb();
		        }
		    }

		    next();
		};

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf#Polyfill
		exports.indexOf = Array.prototype.indexOf ?
		    function (arr, searchElement, fromIndex) {
		        return Array.prototype.indexOf.call(arr, searchElement, fromIndex);
		    } :
		    function (arr, searchElement, fromIndex) {
		        var length = this.length >>> 0; // Hack to convert object.length to a UInt32

		        fromIndex = +fromIndex || 0;

		        if(Math.abs(fromIndex) === Infinity) {
		            fromIndex = 0;
		        }

		        if(fromIndex < 0) {
		            fromIndex += length;
		            if (fromIndex < 0) {
		                fromIndex = 0;
		            }
		        }

		        for(;fromIndex < length; fromIndex++) {
		            if (arr[fromIndex] === searchElement) {
		                return fromIndex;
		            }
		        }

		        return -1;
		    };

		if(!Array.prototype.map) {
		    Array.prototype.map = function() {
		        throw new Error('map is unimplemented for this js engine');
		    };
		}

		exports.keys = function(obj) {
		    if(Object.prototype.keys) {
		        return obj.keys();
		    }
		    else {
		        var keys = [];
		        for(var k in obj) {
		            if(obj.hasOwnProperty(k)) {
		                keys.push(k);
		            }
		        }
		        return keys;
		    }
		};

		exports.inOperator = function (key, val) {
		    if (exports.isArray(val)) {
		        return exports.indexOf(val, key) !== -1;
		    } else if (exports.isObject(val)) {
		        return key in val;
		    } else if (exports.isString(val)) {
		        return val.indexOf(key) !== -1;
		    } else {
		        throw new Error('Cannot use "in" operator to search for "'
		            + key + '" in unexpected types.');
		    }
		};


	/***/ },
	/* 2 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var path = __webpack_require__(3);
		var asap = __webpack_require__(4);
		var lib = __webpack_require__(1);
		var Obj = __webpack_require__(6);
		var compiler = __webpack_require__(7);
		var builtin_filters = __webpack_require__(13);
		var builtin_loaders = __webpack_require__(14);
		var runtime = __webpack_require__(12);
		var globals = __webpack_require__(17);
		var Frame = runtime.Frame;
		var Template;

		// Unconditionally load in this loader, even if no other ones are
		// included (possible in the slim browser build)
		builtin_loaders.PrecompiledLoader = __webpack_require__(16);

		// If the user is using the async API, *always* call it
		// asynchronously even if the template was synchronous.
		function callbackAsap(cb, err, res) {
		    asap(function() { cb(err, res); });
		}

		var Environment = Obj.extend({
		    init: function(loaders, opts) {
		        // The dev flag determines the trace that'll be shown on errors.
		        // If set to true, returns the full trace from the error point,
		        // otherwise will return trace starting from Template.render
		        // (the full trace from within nunjucks may confuse developers using
		        //  the library)
		        // defaults to false
		        opts = this.opts = opts || {};
		        this.opts.dev = !!opts.dev;

		        // The autoescape flag sets global autoescaping. If true,
		        // every string variable will be escaped by default.
		        // If false, strings can be manually escaped using the `escape` filter.
		        // defaults to true
		        this.opts.autoescape = opts.autoescape != null ? opts.autoescape : true;

		        // If true, this will make the system throw errors if trying
		        // to output a null or undefined value
		        this.opts.throwOnUndefined = !!opts.throwOnUndefined;
		        this.opts.trimBlocks = !!opts.trimBlocks;
		        this.opts.lstripBlocks = !!opts.lstripBlocks;

		        this.loaders = [];

		        if(!loaders) {
		            // The filesystem loader is only available server-side
		            if(builtin_loaders.FileSystemLoader) {
		                this.loaders = [new builtin_loaders.FileSystemLoader('views')];
		            }
		            else if(builtin_loaders.WebLoader) {
		                this.loaders = [new builtin_loaders.WebLoader('/views')];
		            }
		        }
		        else {
		            this.loaders = lib.isArray(loaders) ? loaders : [loaders];
		        }

		        // It's easy to use precompiled templates: just include them
		        // before you configure nunjucks and this will automatically
		        // pick it up and use it
		        if((true) && window.nunjucksPrecompiled) {
		            this.loaders.unshift(
		                new builtin_loaders.PrecompiledLoader(window.nunjucksPrecompiled)
		            );
		        }

		        this.initCache();

		        this.globals = globals();
		        this.filters = {};
		        this.asyncFilters = [];
		        this.extensions = {};
		        this.extensionsList = [];

		        for(var name in builtin_filters) {
		            this.addFilter(name, builtin_filters[name]);
		        }
		    },

		    initCache: function() {
		        // Caching and cache busting
		        lib.each(this.loaders, function(loader) {
		            loader.cache = {};

		            if(typeof loader.on === 'function') {
		                loader.on('update', function(template) {
		                    loader.cache[template] = null;
		                });
		            }
		        });
		    },

		    addExtension: function(name, extension) {
		        extension._name = name;
		        this.extensions[name] = extension;
		        this.extensionsList.push(extension);
		        return this;
		    },

		    removeExtension: function(name) {
		        var extension = this.getExtension(name);
		        if (!extension) return;

		        this.extensionsList = lib.without(this.extensionsList, extension);
		        delete this.extensions[name];
		    },

		    getExtension: function(name) {
		        return this.extensions[name];
		    },

		    hasExtension: function(name) {
		        return !!this.extensions[name];
		    },

		    addGlobal: function(name, value) {
		        this.globals[name] = value;
		        return this;
		    },

		    getGlobal: function(name) {
		        if(typeof this.globals[name] === 'undefined') {
		            throw new Error('global not found: ' + name);
		        }
		        return this.globals[name];
		    },

		    addFilter: function(name, func, async) {
		        var wrapped = func;

		        if(async) {
		            this.asyncFilters.push(name);
		        }
		        this.filters[name] = wrapped;
		        return this;
		    },

		    getFilter: function(name) {
		        if(!this.filters[name]) {
		            throw new Error('filter not found: ' + name);
		        }
		        return this.filters[name];
		    },

		    resolveTemplate: function(loader, parentName, filename) {
		        var isRelative = (loader.isRelative && parentName)? loader.isRelative(filename) : false;
		        return (isRelative && loader.resolve)? loader.resolve(parentName, filename) : filename;
		    },

		    getTemplate: function(name, eagerCompile, parentName, ignoreMissing, cb) {
		        var that = this;
		        var tmpl = null;
		        if(name && name.raw) {
		            // this fixes autoescape for templates referenced in symbols
		            name = name.raw;
		        }

		        if(lib.isFunction(parentName)) {
		            cb = parentName;
		            parentName = null;
		            eagerCompile = eagerCompile || false;
		        }

		        if(lib.isFunction(eagerCompile)) {
		            cb = eagerCompile;
		            eagerCompile = false;
		        }

		        if (name instanceof Template) {
		             tmpl = name;
		        }
		        else if(typeof name !== 'string') {
		            throw new Error('template names must be a string: ' + name);
		        }
		        else {
		            for (var i = 0; i < this.loaders.length; i++) {
		                var _name = this.resolveTemplate(this.loaders[i], parentName, name);
		                tmpl = this.loaders[i].cache[_name];
		                if (tmpl) break;
		            }
		        }

		        if(tmpl) {
		            if(eagerCompile) {
		                tmpl.compile();
		            }

		            if(cb) {
		                cb(null, tmpl);
		            }
		            else {
		                return tmpl;
		            }
		        } else {
		            var syncResult;
		            var _this = this;

		            var createTemplate = function(err, info) {
		                if(!info && !err) {
		                    if(!ignoreMissing) {
		                        err = new Error('template not found: ' + name);
		                    }
		                }

		                if (err) {
		                    if(cb) {
		                        cb(err);
		                    }
		                    else {
		                        throw err;
		                    }
		                }
		                else {
		                    var tmpl;
		                    if(info) {
		                        tmpl = new Template(info.src, _this,
		                                            info.path, eagerCompile);

		                        if(!info.noCache) {
		                            info.loader.cache[name] = tmpl;
		                        }
		                    }
		                    else {
		                        tmpl = new Template('', _this,
		                                            '', eagerCompile);
		                    }

		                    if(cb) {
		                        cb(null, tmpl);
		                    }
		                    else {
		                        syncResult = tmpl;
		                    }
		                }
		            };

		            lib.asyncIter(this.loaders, function(loader, i, next, done) {
		                function handle(err, src) {
		                    if(err) {
		                        done(err);
		                    }
		                    else if(src) {
		                        src.loader = loader;
		                        done(null, src);
		                    }
		                    else {
		                        next();
		                    }
		                }

		                // Resolve name relative to parentName
		                name = that.resolveTemplate(loader, parentName, name);

		                if(loader.async) {
		                    loader.getSource(name, handle);
		                }
		                else {
		                    handle(null, loader.getSource(name));
		                }
		            }, createTemplate);

		            return syncResult;
		        }
		    },

		    express: function(app) {
		        var env = this;

		        function NunjucksView(name, opts) {
		            this.name          = name;
		            this.path          = name;
		            this.defaultEngine = opts.defaultEngine;
		            this.ext           = path.extname(name);
		            if (!this.ext && !this.defaultEngine) throw new Error('No default engine was specified and no extension was provided.');
		            if (!this.ext) this.name += (this.ext = ('.' !== this.defaultEngine[0] ? '.' : '') + this.defaultEngine);
		        }

		        NunjucksView.prototype.render = function(opts, cb) {
		          env.render(this.name, opts, cb);
		        };

		        app.set('view', NunjucksView);
		        app.set('nunjucksEnv', this);
		        return this;
		    },

		    render: function(name, ctx, cb) {
		        if(lib.isFunction(ctx)) {
		            cb = ctx;
		            ctx = null;
		        }

		        // We support a synchronous API to make it easier to migrate
		        // existing code to async. This works because if you don't do
		        // anything async work, the whole thing is actually run
		        // synchronously.
		        var syncResult = null;

		        this.getTemplate(name, function(err, tmpl) {
		            if(err && cb) {
		                callbackAsap(cb, err);
		            }
		            else if(err) {
		                throw err;
		            }
		            else {
		                syncResult = tmpl.render(ctx, cb);
		            }
		        });

		        return syncResult;
		    },

		    renderString: function(src, ctx, opts, cb) {
		        if(lib.isFunction(opts)) {
		            cb = opts;
		            opts = {};
		        }
		        opts = opts || {};

		        var tmpl = new Template(src, this, opts.path);
		        return tmpl.render(ctx, cb);
		    }
		});

		var Context = Obj.extend({
		    init: function(ctx, blocks, env) {
		        // Has to be tied to an environment so we can tap into its globals.
		        this.env = env || new Environment();

		        // Make a duplicate of ctx
		        this.ctx = {};
		        for(var k in ctx) {
		            if(ctx.hasOwnProperty(k)) {
		                this.ctx[k] = ctx[k];
		            }
		        }

		        this.blocks = {};
		        this.exported = [];

		        for(var name in blocks) {
		            this.addBlock(name, blocks[name]);
		        }
		    },

		    lookup: function(name) {
		        // This is one of the most called functions, so optimize for
		        // the typical case where the name isn't in the globals
		        if(name in this.env.globals && !(name in this.ctx)) {
		            return this.env.globals[name];
		        }
		        else {
		            return this.ctx[name];
		        }
		    },

		    setVariable: function(name, val) {
		        this.ctx[name] = val;
		    },

		    getVariables: function() {
		        return this.ctx;
		    },

		    addBlock: function(name, block) {
		        this.blocks[name] = this.blocks[name] || [];
		        this.blocks[name].push(block);
		        return this;
		    },

		    getBlock: function(name) {
		        if(!this.blocks[name]) {
		            throw new Error('unknown block "' + name + '"');
		        }

		        return this.blocks[name][0];
		    },

		    getSuper: function(env, name, block, frame, runtime, cb) {
		        var idx = lib.indexOf(this.blocks[name] || [], block);
		        var blk = this.blocks[name][idx + 1];
		        var context = this;

		        if(idx === -1 || !blk) {
		            throw new Error('no super block available for "' + name + '"');
		        }

		        blk(env, context, frame, runtime, cb);
		    },

		    addExport: function(name) {
		        this.exported.push(name);
		    },

		    getExported: function() {
		        var exported = {};
		        for(var i=0; i<this.exported.length; i++) {
		            var name = this.exported[i];
		            exported[name] = this.ctx[name];
		        }
		        return exported;
		    }
		});

		Template = Obj.extend({
		    init: function (src, env, path, eagerCompile) {
		        this.env = env || new Environment();

		        if(lib.isObject(src)) {
		            switch(src.type) {
		            case 'code': this.tmplProps = src.obj; break;
		            case 'string': this.tmplStr = src.obj; break;
		            }
		        }
		        else if(lib.isString(src)) {
		            this.tmplStr = src;
		        }
		        else {
		            throw new Error('src must be a string or an object describing ' +
		                            'the source');
		        }

		        this.path = path;

		        if(eagerCompile) {
		            var _this = this;
		            try {
		                _this._compile();
		            }
		            catch(err) {
		                throw lib.prettifyError(this.path, this.env.opts.dev, err);
		            }
		        }
		        else {
		            this.compiled = false;
		        }
		    },

		    render: function(ctx, parentFrame, cb) {
		        if (typeof ctx === 'function') {
		            cb = ctx;
		            ctx = {};
		        }
		        else if (typeof parentFrame === 'function') {
		            cb = parentFrame;
		            parentFrame = null;
		        }

		        var forceAsync = true;
		        if(parentFrame) {
		            // If there is a frame, we are being called from internal
		            // code of another template, and the internal system
		            // depends on the sync/async nature of the parent template
		            // to be inherited, so force an async callback
		            forceAsync = false;
		        }

		        var _this = this;
		        // Catch compile errors for async rendering
		        try {
		            _this.compile();
		        } catch (_err) {
		            var err = lib.prettifyError(this.path, this.env.opts.dev, _err);
		            if (cb) return callbackAsap(cb, err);
		            else throw err;
		        }

		        var context = new Context(ctx || {}, _this.blocks, _this.env);
		        var frame = parentFrame ? parentFrame.push(true) : new Frame();
		        frame.topLevel = true;
		        var syncResult = null;

		        _this.rootRenderFunc(
		            _this.env,
		            context,
		            frame || new Frame(),
		            runtime,
		            function(err, res) {
		                if(err) {
		                    err = lib.prettifyError(_this.path, _this.env.opts.dev, err);
		                }

		                if(cb) {
		                    if(forceAsync) {
		                        callbackAsap(cb, err, res);
		                    }
		                    else {
		                        cb(err, res);
		                    }
		                }
		                else {
		                    if(err) { throw err; }
		                    syncResult = res;
		                }
		            }
		        );

		        return syncResult;
		    },


		    getExported: function(ctx, parentFrame, cb) {
		        if (typeof ctx === 'function') {
		            cb = ctx;
		            ctx = {};
		        }

		        if (typeof parentFrame === 'function') {
		            cb = parentFrame;
		            parentFrame = null;
		        }

		        // Catch compile errors for async rendering
		        try {
		            this.compile();
		        } catch (e) {
		            if (cb) return cb(e);
		            else throw e;
		        }

		        var frame = parentFrame ? parentFrame.push() : new Frame();
		        frame.topLevel = true;

		        // Run the rootRenderFunc to populate the context with exported vars
		        var context = new Context(ctx || {}, this.blocks, this.env);
		        this.rootRenderFunc(this.env,
		                            context,
		                            frame,
		                            runtime,
		                            function(err) {
		        		        if ( err ) {
		        			    cb(err, null);
		        		        } else {
		        			    cb(null, context.getExported());
		        		        }
		                            });
		    },

		    compile: function() {
		        if(!this.compiled) {
		            this._compile();
		        }
		    },

		    _compile: function() {
		        var props;

		        if(this.tmplProps) {
		            props = this.tmplProps;
		        }
		        else {
		            var source = compiler.compile(this.tmplStr,
		                                          this.env.asyncFilters,
		                                          this.env.extensionsList,
		                                          this.path,
		                                          this.env.opts);

		            /* jslint evil: true */
		            var func = new Function(source);
		            props = func();
		        }

		        this.blocks = this._getBlocks(props);
		        this.rootRenderFunc = props.root;
		        this.compiled = true;
		    },

		    _getBlocks: function(props) {
		        var blocks = {};

		        for(var k in props) {
		            if(k.slice(0, 2) === 'b_') {
		                blocks[k.slice(2)] = props[k];
		            }
		        }

		        return blocks;
		    }
		});

		module.exports = {
		    Environment: Environment,
		    Template: Template
		};


	/***/ },
	/* 3 */
	/***/ function(module, exports) {

		

	/***/ },
	/* 4 */
	/***/ function(module, exports, __webpack_require__) {

		"use strict";

		// rawAsap provides everything we need except exception management.
		var rawAsap = __webpack_require__(5);
		// RawTasks are recycled to reduce GC churn.
		var freeTasks = [];
		// We queue errors to ensure they are thrown in right order (FIFO).
		// Array-as-queue is good enough here, since we are just dealing with exceptions.
		var pendingErrors = [];
		var requestErrorThrow = rawAsap.makeRequestCallFromTimer(throwFirstError);

		function throwFirstError() {
		    if (pendingErrors.length) {
		        throw pendingErrors.shift();
		    }
		}

		/**
		 * Calls a task as soon as possible after returning, in its own event, with priority
		 * over other events like animation, reflow, and repaint. An error thrown from an
		 * event will not interrupt, nor even substantially slow down the processing of
		 * other events, but will be rather postponed to a lower priority event.
		 * @param {{call}} task A callable object, typically a function that takes no
		 * arguments.
		 */
		module.exports = asap;
		function asap(task) {
		    var rawTask;
		    if (freeTasks.length) {
		        rawTask = freeTasks.pop();
		    } else {
		        rawTask = new RawTask();
		    }
		    rawTask.task = task;
		    rawAsap(rawTask);
		}

		// We wrap tasks with recyclable task objects.  A task object implements
		// `call`, just like a function.
		function RawTask() {
		    this.task = null;
		}

		// The sole purpose of wrapping the task is to catch the exception and recycle
		// the task object after its single use.
		RawTask.prototype.call = function () {
		    try {
		        this.task.call();
		    } catch (error) {
		        if (asap.onerror) {
		            // This hook exists purely for testing purposes.
		            // Its name will be periodically randomized to break any code that
		            // depends on its existence.
		            asap.onerror(error);
		        } else {
		            // In a web browser, exceptions are not fatal. However, to avoid
		            // slowing down the queue of pending tasks, we rethrow the error in a
		            // lower priority turn.
		            pendingErrors.push(error);
		            requestErrorThrow();
		        }
		    } finally {
		        this.task = null;
		        freeTasks[freeTasks.length] = this;
		    }
		};


	/***/ },
	/* 5 */
	/***/ function(module, exports) {

		/* WEBPACK VAR INJECTION */(function(global) {"use strict";

		// Use the fastest means possible to execute a task in its own turn, with
		// priority over other events including IO, animation, reflow, and redraw
		// events in browsers.
		//
		// An exception thrown by a task will permanently interrupt the processing of
		// subsequent tasks. The higher level `asap` function ensures that if an
		// exception is thrown by a task, that the task queue will continue flushing as
		// soon as possible, but if you use `rawAsap` directly, you are responsible to
		// either ensure that no exceptions are thrown from your task, or to manually
		// call `rawAsap.requestFlush` if an exception is thrown.
		module.exports = rawAsap;
		function rawAsap(task) {
		    if (!queue.length) {
		        requestFlush();
		        flushing = true;
		    }
		    // Equivalent to push, but avoids a function call.
		    queue[queue.length] = task;
		}

		var queue = [];
		// Once a flush has been requested, no further calls to `requestFlush` are
		// necessary until the next `flush` completes.
		var flushing = false;
		// `requestFlush` is an implementation-specific method that attempts to kick
		// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
		// the event queue before yielding to the browser's own event loop.
		var requestFlush;
		// The position of the next task to execute in the task queue. This is
		// preserved between calls to `flush` so that it can be resumed if
		// a task throws an exception.
		var index = 0;
		// If a task schedules additional tasks recursively, the task queue can grow
		// unbounded. To prevent memory exhaustion, the task queue will periodically
		// truncate already-completed tasks.
		var capacity = 1024;

		// The flush function processes all tasks that have been scheduled with
		// `rawAsap` unless and until one of those tasks throws an exception.
		// If a task throws an exception, `flush` ensures that its state will remain
		// consistent and will resume where it left off when called again.
		// However, `flush` does not make any arrangements to be called again if an
		// exception is thrown.
		function flush() {
		    while (index < queue.length) {
		        var currentIndex = index;
		        // Advance the index before calling the task. This ensures that we will
		        // begin flushing on the next task the task throws an error.
		        index = index + 1;
		        queue[currentIndex].call();
		        // Prevent leaking memory for long chains of recursive calls to `asap`.
		        // If we call `asap` within tasks scheduled by `asap`, the queue will
		        // grow, but to avoid an O(n) walk for every task we execute, we don't
		        // shift tasks off the queue after they have been executed.
		        // Instead, we periodically shift 1024 tasks off the queue.
		        if (index > capacity) {
		            // Manually shift all values starting at the index back to the
		            // beginning of the queue.
		            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
		                queue[scan] = queue[scan + index];
		            }
		            queue.length -= index;
		            index = 0;
		        }
		    }
		    queue.length = 0;
		    index = 0;
		    flushing = false;
		}

		// `requestFlush` is implemented using a strategy based on data collected from
		// every available SauceLabs Selenium web driver worker at time of writing.
		// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

		// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
		// have WebKitMutationObserver but not un-prefixed MutationObserver.
		// Must use `global` instead of `window` to work in both frames and web
		// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.
		var BrowserMutationObserver = global.MutationObserver || global.WebKitMutationObserver;

		// MutationObservers are desirable because they have high priority and work
		// reliably everywhere they are implemented.
		// They are implemented in all modern browsers.
		//
		// - Android 4-4.3
		// - Chrome 26-34
		// - Firefox 14-29
		// - Internet Explorer 11
		// - iPad Safari 6-7.1
		// - iPhone Safari 7-7.1
		// - Safari 6-7
		if (typeof BrowserMutationObserver === "function") {
		    requestFlush = makeRequestCallFromMutationObserver(flush);

		// MessageChannels are desirable because they give direct access to the HTML
		// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
		// 11-12, and in web workers in many engines.
		// Although message channels yield to any queued rendering and IO tasks, they
		// would be better than imposing the 4ms delay of timers.
		// However, they do not work reliably in Internet Explorer or Safari.

		// Internet Explorer 10 is the only browser that has setImmediate but does
		// not have MutationObservers.
		// Although setImmediate yields to the browser's renderer, it would be
		// preferrable to falling back to setTimeout since it does not have
		// the minimum 4ms penalty.
		// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
		// Desktop to a lesser extent) that renders both setImmediate and
		// MessageChannel useless for the purposes of ASAP.
		// https://github.com/kriskowal/q/issues/396

		// Timers are implemented universally.
		// We fall back to timers in workers in most engines, and in foreground
		// contexts in the following browsers.
		// However, note that even this simple case requires nuances to operate in a
		// broad spectrum of browsers.
		//
		// - Firefox 3-13
		// - Internet Explorer 6-9
		// - iPad Safari 4.3
		// - Lynx 2.8.7
		} else {
		    requestFlush = makeRequestCallFromTimer(flush);
		}

		// `requestFlush` requests that the high priority event queue be flushed as
		// soon as possible.
		// This is useful to prevent an error thrown in a task from stalling the event
		// queue if the exception handled by Node.js’s
		// `process.on("uncaughtException")` or by a domain.
		rawAsap.requestFlush = requestFlush;

		// To request a high priority event, we induce a mutation observer by toggling
		// the text of a text node between "1" and "-1".
		function makeRequestCallFromMutationObserver(callback) {
		    var toggle = 1;
		    var observer = new BrowserMutationObserver(callback);
		    var node = document.createTextNode("");
		    observer.observe(node, {characterData: true});
		    return function requestCall() {
		        toggle = -toggle;
		        node.data = toggle;
		    };
		}

		// The message channel technique was discovered by Malte Ubl and was the
		// original foundation for this library.
		// http://www.nonblocking.io/2011/06/windownexttick.html

		// Safari 6.0.5 (at least) intermittently fails to create message ports on a
		// page's first load. Thankfully, this version of Safari supports
		// MutationObservers, so we don't need to fall back in that case.

		// function makeRequestCallFromMessageChannel(callback) {
		//     var channel = new MessageChannel();
		//     channel.port1.onmessage = callback;
		//     return function requestCall() {
		//         channel.port2.postMessage(0);
		//     };
		// }

		// For reasons explained above, we are also unable to use `setImmediate`
		// under any circumstances.
		// Even if we were, there is another bug in Internet Explorer 10.
		// It is not sufficient to assign `setImmediate` to `requestFlush` because
		// `setImmediate` must be called *by name* and therefore must be wrapped in a
		// closure.
		// Never forget.

		// function makeRequestCallFromSetImmediate(callback) {
		//     return function requestCall() {
		//         setImmediate(callback);
		//     };
		// }

		// Safari 6.0 has a problem where timers will get lost while the user is
		// scrolling. This problem does not impact ASAP because Safari 6.0 supports
		// mutation observers, so that implementation is used instead.
		// However, if we ever elect to use timers in Safari, the prevalent work-around
		// is to add a scroll event listener that calls for a flush.

		// `setTimeout` does not call the passed callback if the delay is less than
		// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
		// even then.

		function makeRequestCallFromTimer(callback) {
		    return function requestCall() {
		        // We dispatch a timeout with a specified delay of 0 for engines that
		        // can reliably accommodate that request. This will usually be snapped
		        // to a 4 milisecond delay, but once we're flushing, there's no delay
		        // between events.
		        var timeoutHandle = setTimeout(handleTimer, 0);
		        // However, since this timer gets frequently dropped in Firefox
		        // workers, we enlist an interval handle that will try to fire
		        // an event 20 times per second until it succeeds.
		        var intervalHandle = setInterval(handleTimer, 50);

		        function handleTimer() {
		            // Whichever timer succeeds will cancel both timers and
		            // execute the callback.
		            clearTimeout(timeoutHandle);
		            clearInterval(intervalHandle);
		            callback();
		        }
		    };
		}

		// This is for `asap.js` only.
		// Its name will be periodically randomized to break any code that depends on
		// its existence.
		rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

		// ASAP was originally a nextTick shim included in Q. This was factored out
		// into this ASAP package. It was later adapted to RSVP which made further
		// amendments. These decisions, particularly to marginalize MessageChannel and
		// to capture the MutationObserver implementation in a closure, were integrated
		// back into ASAP proper.
		// https://github.com/tildeio/rsvp.js/blob/cddf7232546a9cf858524b75cde6f9edf72620a7/lib/rsvp/asap.js

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 6 */
	/***/ function(module, exports) {

		'use strict';

		// A simple class system, more documentation to come

		function extend(cls, name, props) {
		    // This does that same thing as Object.create, but with support for IE8
		    var F = function() {};
		    F.prototype = cls.prototype;
		    var prototype = new F();

		    // jshint undef: false
		    var fnTest = /xyz/.test(function(){ xyz; }) ? /\bparent\b/ : /.*/;
		    props = props || {};

		    for(var k in props) {
		        var src = props[k];
		        var parent = prototype[k];

		        if(typeof parent === 'function' &&
		           typeof src === 'function' &&
		           fnTest.test(src)) {
		            /*jshint -W083 */
		            prototype[k] = (function (src, parent) {
		                return function() {
		                    // Save the current parent method
		                    var tmp = this.parent;

		                    // Set parent to the previous method, call, and restore
		                    this.parent = parent;
		                    var res = src.apply(this, arguments);
		                    this.parent = tmp;

		                    return res;
		                };
		            })(src, parent);
		        }
		        else {
		            prototype[k] = src;
		        }
		    }

		    prototype.typename = name;

		    var new_cls = function() {
		        if(prototype.init) {
		            prototype.init.apply(this, arguments);
		        }
		    };

		    new_cls.prototype = prototype;
		    new_cls.prototype.constructor = new_cls;

		    new_cls.extend = function(name, props) {
		        if(typeof name === 'object') {
		            props = name;
		            name = 'anonymous';
		        }
		        return extend(new_cls, name, props);
		    };

		    return new_cls;
		}

		module.exports = extend(Object, 'Object', {});


	/***/ },
	/* 7 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lib = __webpack_require__(1);
		var parser = __webpack_require__(8);
		var transformer = __webpack_require__(11);
		var nodes = __webpack_require__(10);
		// jshint -W079
		var Object = __webpack_require__(6);
		var Frame = __webpack_require__(12).Frame;

		// These are all the same for now, but shouldn't be passed straight
		// through
		var compareOps = {
		    '==': '==',
		    '===': '===',
		    '!=': '!=',
		    '!==': '!==',
		    '<': '<',
		    '>': '>',
		    '<=': '<=',
		    '>=': '>='
		};

		// A common pattern is to emit binary operators
		function binOpEmitter(str) {
		    return function(node, frame) {
		        this.compile(node.left, frame);
		        this.emit(str);
		        this.compile(node.right, frame);
		    };
		}

		var Compiler = Object.extend({
		    init: function(templateName, throwOnUndefined) {
		        this.templateName = templateName;
		        this.codebuf = [];
		        this.lastId = 0;
		        this.buffer = null;
		        this.bufferStack = [];
		        this.scopeClosers = '';
		        this.inBlock = false;
		        this.throwOnUndefined = throwOnUndefined;
		    },

		    fail: function (msg, lineno, colno) {
		        if (lineno !== undefined) lineno += 1;
		        if (colno !== undefined) colno += 1;

		        throw new lib.TemplateError(msg, lineno, colno);
		    },

		    pushBufferId: function(id) {
		        this.bufferStack.push(this.buffer);
		        this.buffer = id;
		        this.emit('var ' + this.buffer + ' = "";');
		    },

		    popBufferId: function() {
		        this.buffer = this.bufferStack.pop();
		    },

		    emit: function(code) {
		        this.codebuf.push(code);
		    },

		    emitLine: function(code) {
		        this.emit(code + '\n');
		    },

		    emitLines: function() {
		        lib.each(lib.toArray(arguments), function(line) {
		            this.emitLine(line);
		        }, this);
		    },

		    emitFuncBegin: function(name) {
		        this.buffer = 'output';
		        this.scopeClosers = '';
		        this.emitLine('function ' + name + '(env, context, frame, runtime, cb) {');
		        this.emitLine('var lineno = null;');
		        this.emitLine('var colno = null;');
		        this.emitLine('var ' + this.buffer + ' = "";');
		        this.emitLine('try {');
		    },

		    emitFuncEnd: function(noReturn) {
		        if(!noReturn) {
		            this.emitLine('cb(null, ' + this.buffer +');');
		        }

		        this.closeScopeLevels();
		        this.emitLine('} catch (e) {');
		        this.emitLine('  cb(runtime.handleError(e, lineno, colno));');
		        this.emitLine('}');
		        this.emitLine('}');
		        this.buffer = null;
		    },

		    addScopeLevel: function() {
		        this.scopeClosers += '})';
		    },

		    closeScopeLevels: function() {
		        this.emitLine(this.scopeClosers + ';');
		        this.scopeClosers = '';
		    },

		    withScopedSyntax: function(func) {
		        var scopeClosers = this.scopeClosers;
		        this.scopeClosers = '';

		        func.call(this);

		        this.closeScopeLevels();
		        this.scopeClosers = scopeClosers;
		    },

		    makeCallback: function(res) {
		        var err = this.tmpid();

		        return 'function(' + err + (res ? ',' + res : '') + ') {\n' +
		            'if(' + err + ') { cb(' + err + '); return; }';
		    },

		    tmpid: function() {
		        this.lastId++;
		        return 't_' + this.lastId;
		    },

		    _templateName: function() {
		        return this.templateName == null? 'undefined' : JSON.stringify(this.templateName);
		    },

		    _compileChildren: function(node, frame) {
		        var children = node.children;
		        for(var i=0, l=children.length; i<l; i++) {
		            this.compile(children[i], frame);
		        }
		    },

		    _compileAggregate: function(node, frame, startChar, endChar) {
		        if(startChar) {
		            this.emit(startChar);
		        }

		        for(var i=0; i<node.children.length; i++) {
		            if(i > 0) {
		                this.emit(',');
		            }

		            this.compile(node.children[i], frame);
		        }

		        if(endChar) {
		            this.emit(endChar);
		        }
		    },

		    _compileExpression: function(node, frame) {
		        // TODO: I'm not really sure if this type check is worth it or
		        // not.
		        this.assertType(
		            node,
		            nodes.Literal,
		            nodes.Symbol,
		            nodes.Group,
		            nodes.Array,
		            nodes.Dict,
		            nodes.FunCall,
		            nodes.Caller,
		            nodes.Filter,
		            nodes.LookupVal,
		            nodes.Compare,
		            nodes.InlineIf,
		            nodes.In,
		            nodes.And,
		            nodes.Or,
		            nodes.Not,
		            nodes.Add,
		            nodes.Concat,
		            nodes.Sub,
		            nodes.Mul,
		            nodes.Div,
		            nodes.FloorDiv,
		            nodes.Mod,
		            nodes.Pow,
		            nodes.Neg,
		            nodes.Pos,
		            nodes.Compare,
		            nodes.NodeList
		        );
		        this.compile(node, frame);
		    },

		    assertType: function(node /*, types */) {
		        var types = lib.toArray(arguments).slice(1);
		        var success = false;

		        for(var i=0; i<types.length; i++) {
		            if(node instanceof types[i]) {
		                success = true;
		            }
		        }

		        if(!success) {
		            this.fail('assertType: invalid type: ' + node.typename,
		                      node.lineno,
		                      node.colno);
		        }
		    },

		    compileCallExtension: function(node, frame, async) {
		        var args = node.args;
		        var contentArgs = node.contentArgs;
		        var autoescape = typeof node.autoescape === 'boolean' ? node.autoescape : true;

		        if(!async) {
		            this.emit(this.buffer + ' += runtime.suppressValue(');
		        }

		        this.emit('env.getExtension("' + node.extName + '")["' + node.prop + '"](');
		        this.emit('context');

		        if(args || contentArgs) {
		            this.emit(',');
		        }

		        if(args) {
		            if(!(args instanceof nodes.NodeList)) {
		                this.fail('compileCallExtension: arguments must be a NodeList, ' +
		                          'use `parser.parseSignature`');
		            }

		            lib.each(args.children, function(arg, i) {
		                // Tag arguments are passed normally to the call. Note
		                // that keyword arguments are turned into a single js
		                // object as the last argument, if they exist.
		                this._compileExpression(arg, frame);

		                if(i !== args.children.length - 1 || contentArgs.length) {
		                    this.emit(',');
		                }
		            }, this);
		        }

		        if(contentArgs.length) {
		            lib.each(contentArgs, function(arg, i) {
		                if(i > 0) {
		                    this.emit(',');
		                }

		                if(arg) {
		                    var id = this.tmpid();

		                    this.emitLine('function(cb) {');
		                    this.emitLine('if(!cb) { cb = function(err) { if(err) { throw err; }}}');
		                    this.pushBufferId(id);

		                    this.withScopedSyntax(function() {
		                        this.compile(arg, frame);
		                        this.emitLine('cb(null, ' + id + ');');
		                    });

		                    this.popBufferId();
		                    this.emitLine('return ' + id + ';');
		                    this.emitLine('}');
		                }
		                else {
		                    this.emit('null');
		                }
		            }, this);
		        }

		        if(async) {
		            var res = this.tmpid();
		            this.emitLine(', ' + this.makeCallback(res));
		            this.emitLine(this.buffer + ' += runtime.suppressValue(' + res + ', ' + autoescape + ' && env.opts.autoescape);');
		            this.addScopeLevel();
		        }
		        else {
		            this.emit(')');
		            this.emit(', ' + autoescape + ' && env.opts.autoescape);\n');
		        }
		    },

		    compileCallExtensionAsync: function(node, frame) {
		        this.compileCallExtension(node, frame, true);
		    },

		    compileNodeList: function(node, frame) {
		        this._compileChildren(node, frame);
		    },

		    compileLiteral: function(node) {
		        if(typeof node.value === 'string') {
		            var val = node.value.replace(/\\/g, '\\\\');
		            val = val.replace(/"/g, '\\"');
		            val = val.replace(/\n/g, '\\n');
		            val = val.replace(/\r/g, '\\r');
		            val = val.replace(/\t/g, '\\t');
		            this.emit('"' + val  + '"');
		        }
		        else if (node.value === null) {
		            this.emit('null');
		        }
		        else {
		            this.emit(node.value.toString());
		        }
		    },

		    compileSymbol: function(node, frame) {
		        var name = node.value;
		        var v;

		        if((v = frame.lookup(name))) {
		            this.emit(v);
		        }
		        else {
		            this.emit('runtime.contextOrFrameLookup(' +
		                      'context, frame, "' + name + '")');
		        }
		    },

		    compileGroup: function(node, frame) {
		        this._compileAggregate(node, frame, '(', ')');
		    },

		    compileArray: function(node, frame) {
		        this._compileAggregate(node, frame, '[', ']');
		    },

		    compileDict: function(node, frame) {
		        this._compileAggregate(node, frame, '{', '}');
		    },

		    compilePair: function(node, frame) {
		        var key = node.key;
		        var val = node.value;

		        if(key instanceof nodes.Symbol) {
		            key = new nodes.Literal(key.lineno, key.colno, key.value);
		        }
		        else if(!(key instanceof nodes.Literal &&
		                  typeof key.value === 'string')) {
		            this.fail('compilePair: Dict keys must be strings or names',
		                      key.lineno,
		                      key.colno);
		        }

		        this.compile(key, frame);
		        this.emit(': ');
		        this._compileExpression(val, frame);
		    },

		    compileInlineIf: function(node, frame) {
		        this.emit('(');
		        this.compile(node.cond, frame);
		        this.emit('?');
		        this.compile(node.body, frame);
		        this.emit(':');
		        if(node.else_ !== null)
		            this.compile(node.else_, frame);
		        else
		            this.emit('""');
		        this.emit(')');
		    },

		    compileIn: function(node, frame) {
		      this.emit('runtime.inOperator(');
		      this.compile(node.left, frame);
		      this.emit(',');
		      this.compile(node.right, frame);
		      this.emit(')');
		    },

		    compileOr: binOpEmitter(' || '),
		    compileAnd: binOpEmitter(' && '),
		    compileAdd: binOpEmitter(' + '),
		    // ensure concatenation instead of addition
		    // by adding empty string in between
		    compileConcat: binOpEmitter(' + "" + '),
		    compileSub: binOpEmitter(' - '),
		    compileMul: binOpEmitter(' * '),
		    compileDiv: binOpEmitter(' / '),
		    compileMod: binOpEmitter(' % '),

		    compileNot: function(node, frame) {
		        this.emit('!');
		        this.compile(node.target, frame);
		    },

		    compileFloorDiv: function(node, frame) {
		        this.emit('Math.floor(');
		        this.compile(node.left, frame);
		        this.emit(' / ');
		        this.compile(node.right, frame);
		        this.emit(')');
		    },

		    compilePow: function(node, frame) {
		        this.emit('Math.pow(');
		        this.compile(node.left, frame);
		        this.emit(', ');
		        this.compile(node.right, frame);
		        this.emit(')');
		    },

		    compileNeg: function(node, frame) {
		        this.emit('-');
		        this.compile(node.target, frame);
		    },

		    compilePos: function(node, frame) {
		        this.emit('+');
		        this.compile(node.target, frame);
		    },

		    compileCompare: function(node, frame) {
		        this.compile(node.expr, frame);

		        for(var i=0; i<node.ops.length; i++) {
		            var n = node.ops[i];
		            this.emit(' ' + compareOps[n.type] + ' ');
		            this.compile(n.expr, frame);
		        }
		    },

		    compileLookupVal: function(node, frame) {
		        this.emit('runtime.memberLookup((');
		        this._compileExpression(node.target, frame);
		        this.emit('),');
		        this._compileExpression(node.val, frame);
		        this.emit(')');
		    },

		    _getNodeName: function(node) {
		        switch (node.typename) {
		            case 'Symbol':
		                return node.value;
		            case 'FunCall':
		                return 'the return value of (' + this._getNodeName(node.name) + ')';
		            case 'LookupVal':
		                return this._getNodeName(node.target) + '["' +
		                       this._getNodeName(node.val) + '"]';
		            case 'Literal':
		                return node.value.toString();
		            default:
		                return '--expression--';
		        }
		    },

		    compileFunCall: function(node, frame) {
		        // Keep track of line/col info at runtime by settings
		        // variables within an expression. An expression in javascript
		        // like (x, y, z) returns the last value, and x and y can be
		        // anything
		        this.emit('(lineno = ' + node.lineno +
		                  ', colno = ' + node.colno + ', ');

		        this.emit('runtime.callWrap(');
		        // Compile it as normal.
		        this._compileExpression(node.name, frame);

		        // Output the name of what we're calling so we can get friendly errors
		        // if the lookup fails.
		        this.emit(', "' + this._getNodeName(node.name).replace(/"/g, '\\"') + '", context, ');

		        this._compileAggregate(node.args, frame, '[', '])');

		        this.emit(')');
		    },

		    compileFilter: function(node, frame) {
		        var name = node.name;
		        this.assertType(name, nodes.Symbol);
		        this.emit('env.getFilter("' + name.value + '").call(context, ');
		        this._compileAggregate(node.args, frame);
		        this.emit(')');
		    },

		    compileFilterAsync: function(node, frame) {
		        var name = node.name;
		        this.assertType(name, nodes.Symbol);

		        var symbol = node.symbol.value;
		        frame.set(symbol, symbol);

		        this.emit('env.getFilter("' + name.value + '").call(context, ');
		        this._compileAggregate(node.args, frame);
		        this.emitLine(', ' + this.makeCallback(symbol));

		        this.addScopeLevel();
		    },

		    compileKeywordArgs: function(node, frame) {
		        var names = [];

		        lib.each(node.children, function(pair) {
		            names.push(pair.key.value);
		        });

		        this.emit('runtime.makeKeywordArgs(');
		        this.compileDict(node, frame);
		        this.emit(')');
		    },

		    compileSet: function(node, frame) {
		        var ids = [];

		        // Lookup the variable names for each identifier and create
		        // new ones if necessary
		        lib.each(node.targets, function(target) {
		            var name = target.value;
		            var id = frame.lookup(name);

		            if (id === null || id === undefined) {
		                id = this.tmpid();

		                // Note: This relies on js allowing scope across
		                // blocks, in case this is created inside an `if`
		                this.emitLine('var ' + id + ';');
		            }

		            ids.push(id);
		        }, this);

		        if (node.value) {
		          this.emit(ids.join(' = ') + ' = ');
		          this._compileExpression(node.value, frame);
		          this.emitLine(';');
		        }
		        else {
		          this.emit(ids.join(' = ') + ' = ');
		          this.compile(node.body, frame);
		          this.emitLine(';');
		        }

		        lib.each(node.targets, function(target, i) {
		            var id = ids[i];
		            var name = target.value;

		            // We are running this for every var, but it's very
		            // uncommon to assign to multiple vars anyway
		            this.emitLine('frame.set("' + name + '", ' + id + ', true);');

		            this.emitLine('if(frame.topLevel) {');
		            this.emitLine('context.setVariable("' + name + '", ' + id + ');');
		            this.emitLine('}');

		            if(name.charAt(0) !== '_') {
		                this.emitLine('if(frame.topLevel) {');
		                this.emitLine('context.addExport("' + name + '", ' + id + ');');
		                this.emitLine('}');
		            }
		        }, this);
		    },

		    compileIf: function(node, frame, async) {
		        this.emit('if(');
		        this._compileExpression(node.cond, frame);
		        this.emitLine(') {');

		        this.withScopedSyntax(function() {
		            this.compile(node.body, frame);

		            if(async) {
		                this.emit('cb()');
		            }
		        });

		        if(node.else_) {
		            this.emitLine('}\nelse {');

		            this.withScopedSyntax(function() {
		                this.compile(node.else_, frame);

		                if(async) {
		                    this.emit('cb()');
		                }
		            });
		        } else if(async) {
		            this.emitLine('}\nelse {');
		            this.emit('cb()');
		        }

		        this.emitLine('}');
		    },

		    compileIfAsync: function(node, frame) {
		        this.emit('(function(cb) {');
		        this.compileIf(node, frame, true);
		        this.emit('})(' + this.makeCallback());
		        this.addScopeLevel();
		    },

		    emitLoopBindings: function(node, arr, i, len) {
		        var bindings = {
		            index: i + ' + 1',
		            index0: i,
		            revindex: len + ' - ' + i,
		            revindex0: len + ' - ' + i + ' - 1',
		            first: i + ' === 0',
		            last: i + ' === ' + len + ' - 1',
		            length: len
		        };

		        for (var name in bindings) {
		            this.emitLine('frame.set("loop.' + name + '", ' + bindings[name] + ');');
		        }
		    },

		    compileFor: function(node, frame) {
		        // Some of this code is ugly, but it keeps the generated code
		        // as fast as possible. ForAsync also shares some of this, but
		        // not much.

		        var v;
		        var i = this.tmpid();
		        var len = this.tmpid();
		        var arr = this.tmpid();
		        frame = frame.push();

		        this.emitLine('frame = frame.push();');

		        this.emit('var ' + arr + ' = ');
		        this._compileExpression(node.arr, frame);
		        this.emitLine(';');

		        this.emit('if(' + arr + ') {');

		        // If multiple names are passed, we need to bind them
		        // appropriately
		        if(node.name instanceof nodes.Array) {
		            this.emitLine('var ' + i + ';');

		            // The object could be an arroy or object. Note that the
		            // body of the loop is duplicated for each condition, but
		            // we are optimizing for speed over size.
		            this.emitLine('if(runtime.isArray(' + arr + ')) {'); {
		                this.emitLine('var ' + len + ' = ' + arr + '.length;');
		                this.emitLine('for(' + i + '=0; ' + i + ' < ' + arr + '.length; '
		                              + i + '++) {');

		                // Bind each declared var
		                for (var u=0; u < node.name.children.length; u++) {
		                    var tid = this.tmpid();
		                    this.emitLine('var ' + tid + ' = ' + arr + '[' + i + '][' + u + ']');
		                    this.emitLine('frame.set("' + node.name.children[u].value
		                                  + '", ' + arr + '[' + i + '][' + u + ']' + ');');
		                    frame.set(node.name.children[u].value, tid);
		                }

		                this.emitLoopBindings(node, arr, i, len);
		                this.withScopedSyntax(function() {
		                    this.compile(node.body, frame);
		                });
		                this.emitLine('}');
		            }

		            this.emitLine('} else {'); {
		                // Iterate over the key/values of an object
		                var key = node.name.children[0];
		                var val = node.name.children[1];
		                var k = this.tmpid();
		                v = this.tmpid();
		                frame.set(key.value, k);
		                frame.set(val.value, v);

		                this.emitLine(i + ' = -1;');
		                this.emitLine('var ' + len + ' = runtime.keys(' + arr + ').length;');
		                this.emitLine('for(var ' + k + ' in ' + arr + ') {');
		                this.emitLine(i + '++;');
		                this.emitLine('var ' + v + ' = ' + arr + '[' + k + '];');
		                this.emitLine('frame.set("' + key.value + '", ' + k + ');');
		                this.emitLine('frame.set("' + val.value + '", ' + v + ');');

		                this.emitLoopBindings(node, arr, i, len);
		                this.withScopedSyntax(function() {
		                    this.compile(node.body, frame);
		                });
		                this.emitLine('}');
		            }

		            this.emitLine('}');
		        }
		        else {
		            // Generate a typical array iteration
		            v = this.tmpid();
		            frame.set(node.name.value, v);

		            this.emitLine('var ' + len + ' = ' + arr + '.length;');
		            this.emitLine('for(var ' + i + '=0; ' + i + ' < ' + arr + '.length; ' +
		                          i + '++) {');
		            this.emitLine('var ' + v + ' = ' + arr + '[' + i + '];');
		            this.emitLine('frame.set("' + node.name.value + '", ' + v + ');');

		            this.emitLoopBindings(node, arr, i, len);

		            this.withScopedSyntax(function() {
		                this.compile(node.body, frame);
		            });

		            this.emitLine('}');
		        }

		        this.emitLine('}');
		        if (node.else_) {
		          this.emitLine('if (!' + len + ') {');
		          this.compile(node.else_, frame);
		          this.emitLine('}');
		        }

		        this.emitLine('frame = frame.pop();');
		    },

		    _compileAsyncLoop: function(node, frame, parallel) {
		        // This shares some code with the For tag, but not enough to
		        // worry about. This iterates across an object asynchronously,
		        // but not in parallel.

		        var i = this.tmpid();
		        var len = this.tmpid();
		        var arr = this.tmpid();
		        var asyncMethod = parallel ? 'asyncAll' : 'asyncEach';
		        frame = frame.push();

		        this.emitLine('frame = frame.push();');

		        this.emit('var ' + arr + ' = ');
		        this._compileExpression(node.arr, frame);
		        this.emitLine(';');

		        if(node.name instanceof nodes.Array) {
		            this.emit('runtime.' + asyncMethod + '(' + arr + ', ' +
		                      node.name.children.length + ', function(');

		            lib.each(node.name.children, function(name) {
		                this.emit(name.value + ',');
		            }, this);

		            this.emit(i + ',' + len + ',next) {');

		            lib.each(node.name.children, function(name) {
		                var id = name.value;
		                frame.set(id, id);
		                this.emitLine('frame.set("' + id + '", ' + id + ');');
		            }, this);
		        }
		        else {
		            var id = node.name.value;
		            this.emitLine('runtime.' + asyncMethod + '(' + arr + ', 1, function(' + id + ', ' + i + ', ' + len + ',next) {');
		            this.emitLine('frame.set("' + id + '", ' + id + ');');
		            frame.set(id, id);
		        }

		        this.emitLoopBindings(node, arr, i, len);

		        this.withScopedSyntax(function() {
		            var buf;
		            if(parallel) {
		                buf = this.tmpid();
		                this.pushBufferId(buf);
		            }

		            this.compile(node.body, frame);
		            this.emitLine('next(' + i + (buf ? ',' + buf : '') + ');');

		            if(parallel) {
		                this.popBufferId();
		            }
		        });

		        var output = this.tmpid();
		        this.emitLine('}, ' + this.makeCallback(output));
		        this.addScopeLevel();

		        if(parallel) {
		            this.emitLine(this.buffer + ' += ' + output + ';');
		        }

		        if (node.else_) {
		          this.emitLine('if (!' + arr + '.length) {');
		          this.compile(node.else_, frame);
		          this.emitLine('}');
		        }

		        this.emitLine('frame = frame.pop();');
		    },

		    compileAsyncEach: function(node, frame) {
		        this._compileAsyncLoop(node, frame);
		    },

		    compileAsyncAll: function(node, frame) {
		        this._compileAsyncLoop(node, frame, true);
		    },

		    _compileMacro: function(node, frame) {
		        var args = [];
		        var kwargs = null;
		        var funcId = 'macro_' + this.tmpid();

		        // Type check the definition of the args
		        lib.each(node.args.children, function(arg, i) {
		            if(i === node.args.children.length - 1 &&
		               arg instanceof nodes.Dict) {
		                kwargs = arg;
		            }
		            else {
		                this.assertType(arg, nodes.Symbol);
		                args.push(arg);
		            }
		        }, this);

		        var realNames = lib.map(args, function(n) { return 'l_' + n.value; });
		        realNames.push('kwargs');

		        // Quoted argument names
		        var argNames = lib.map(args, function(n) { return '"' + n.value + '"'; });
		        var kwargNames = lib.map((kwargs && kwargs.children) || [],
		                                 function(n) { return '"' + n.key.value + '"'; });

		        // We pass a function to makeMacro which destructures the
		        // arguments so support setting positional args with keywords
		        // args and passing keyword args as positional args
		        // (essentially default values). See runtime.js.
		        frame = frame.push();
		        this.emitLines(
		            'var ' + funcId + ' = runtime.makeMacro(',
		            '[' + argNames.join(', ') + '], ',
		            '[' + kwargNames.join(', ') + '], ',
		            'function (' + realNames.join(', ') + ') {',
		            'frame = frame.push(true);',
		            'kwargs = kwargs || {};',
		            'if (kwargs.hasOwnProperty("caller")) {',
		            'frame.set("caller", kwargs.caller); }'
		        );

		        // Expose the arguments to the template. Don't need to use
		        // random names because the function
		        // will create a new run-time scope for us
		        lib.each(args, function(arg) {
		            this.emitLine('frame.set("' + arg.value + '", ' +
		                          'l_' + arg.value + ');');
		            frame.set(arg.value, 'l_' + arg.value);
		        }, this);

		        // Expose the keyword arguments
		        if(kwargs) {
		            lib.each(kwargs.children, function(pair) {
		                var name = pair.key.value;
		                this.emit('frame.set("' + name + '", ' +
		                          'kwargs.hasOwnProperty("' + name + '") ? ' +
		                          'kwargs["' + name + '"] : ');
		                this._compileExpression(pair.value, frame);
		                this.emitLine(');');
		            }, this);
		        }

		        var bufferId = this.tmpid();
		        this.pushBufferId(bufferId);

		        this.withScopedSyntax(function () {
		          this.compile(node.body, frame);
		        });

		        frame = frame.pop();
		        this.emitLine('frame = frame.pop();');
		        this.emitLine('return new runtime.SafeString(' + bufferId + ');');
		        this.emitLine('});');
		        this.popBufferId();

		        return funcId;
		    },

		    compileMacro: function(node, frame) {
		        var funcId = this._compileMacro(node, frame);

		        // Expose the macro to the templates
		        var name = node.name.value;
		        frame.set(name, funcId);

		        if(frame.parent) {
		            this.emitLine('frame.set("' + name + '", ' + funcId + ');');
		        }
		        else {
		            if(node.name.value.charAt(0) !== '_') {
		                this.emitLine('context.addExport("' + name + '");');
		            }
		            this.emitLine('context.setVariable("' + name + '", ' + funcId + ');');
		        }
		    },

		    compileCaller: function(node, frame) {
		        // basically an anonymous "macro expression"
		        this.emit('(function (){');
		        var funcId = this._compileMacro(node, frame);
		        this.emit('return ' + funcId + ';})()');
		    },

		    compileImport: function(node, frame) {
		        var id = this.tmpid();
		        var target = node.target.value;

		        this.emit('env.getTemplate(');
		        this._compileExpression(node.template, frame);
		        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(id));
		        this.addScopeLevel();

		        this.emitLine(id + '.getExported(' +
		            (node.withContext ? 'context.getVariables(), frame, ' : '') +
		            this.makeCallback(id));
		        this.addScopeLevel();

		        frame.set(target, id);

		        if(frame.parent) {
		            this.emitLine('frame.set("' + target + '", ' + id + ');');
		        }
		        else {
		            this.emitLine('context.setVariable("' + target + '", ' + id + ');');
		        }
		    },

		    compileFromImport: function(node, frame) {
		        var importedId = this.tmpid();

		        this.emit('env.getTemplate(');
		        this._compileExpression(node.template, frame);
		        this.emitLine(', false, '+this._templateName()+', false, ' + this.makeCallback(importedId));
		        this.addScopeLevel();

		        this.emitLine(importedId + '.getExported(' +
		            (node.withContext ? 'context.getVariables(), frame, ' : '') +
		            this.makeCallback(importedId));
		        this.addScopeLevel();

		        lib.each(node.names.children, function(nameNode) {
		            var name;
		            var alias;
		            var id = this.tmpid();

		            if(nameNode instanceof nodes.Pair) {
		                name = nameNode.key.value;
		                alias = nameNode.value.value;
		            }
		            else {
		                name = nameNode.value;
		                alias = name;
		            }

		            this.emitLine('if(' + importedId + '.hasOwnProperty("' + name + '")) {');
		            this.emitLine('var ' + id + ' = ' + importedId + '.' + name + ';');
		            this.emitLine('} else {');
		            this.emitLine('cb(new Error("cannot import \'' + name + '\'")); return;');
		            this.emitLine('}');

		            frame.set(alias, id);

		            if(frame.parent) {
		                this.emitLine('frame.set("' + alias + '", ' + id + ');');
		            }
		            else {
		                this.emitLine('context.setVariable("' + alias + '", ' + id + ');');
		            }
		        }, this);
		    },

		    compileBlock: function(node) {
		        var id = this.tmpid();

		        // If we are executing outside a block (creating a top-level
		        // block), we really don't want to execute its code because it
		        // will execute twice: once when the child template runs and
		        // again when the parent template runs. Note that blocks
		        // within blocks will *always* execute immediately *and*
		        // wherever else they are invoked (like used in a parent
		        // template). This may have behavioral differences from jinja
		        // because blocks can have side effects, but it seems like a
		        // waste of performance to always execute huge top-level
		        // blocks twice
		        if(!this.inBlock) {
		            this.emit('(parentTemplate ? function(e, c, f, r, cb) { cb(""); } : ');
		        }
		        this.emit('context.getBlock("' + node.name.value + '")');
		        if(!this.inBlock) {
		            this.emit(')');
		        }
		        this.emitLine('(env, context, frame, runtime, ' + this.makeCallback(id));
		        this.emitLine(this.buffer + ' += ' + id + ';');
		        this.addScopeLevel();
		    },

		    compileSuper: function(node, frame) {
		        var name = node.blockName.value;
		        var id = node.symbol.value;

		        this.emitLine('context.getSuper(env, ' +
		                      '"' + name + '", ' +
		                      'b_' + name + ', ' +
		                      'frame, runtime, '+
		                      this.makeCallback(id));
		        this.emitLine(id + ' = runtime.markSafe(' + id + ');');
		        this.addScopeLevel();
		        frame.set(id, id);
		    },

		    compileExtends: function(node, frame) {
		        var k = this.tmpid();

		        this.emit('env.getTemplate(');
		        this._compileExpression(node.template, frame);
		        this.emitLine(', true, '+this._templateName()+', false, ' + this.makeCallback('_parentTemplate'));

		        // extends is a dynamic tag and can occur within a block like
		        // `if`, so if this happens we need to capture the parent
		        // template in the top-level scope
		        this.emitLine('parentTemplate = _parentTemplate');

		        this.emitLine('for(var ' + k + ' in parentTemplate.blocks) {');
		        this.emitLine('context.addBlock(' + k +
		                      ', parentTemplate.blocks[' + k + ']);');
		        this.emitLine('}');

		        this.addScopeLevel();
		    },

		    compileInclude: function(node, frame) {
		        var id = this.tmpid();
		        var id2 = this.tmpid();

		        this.emit('env.getTemplate(');
		        this._compileExpression(node.template, frame);
		        this.emitLine(', false, '+this._templateName()+', ' + node.ignoreMissing + ', ' + this.makeCallback(id));
		        this.addScopeLevel();

		        this.emitLine(id + '.render(' +
		                      'context.getVariables(), frame, ' + this.makeCallback(id2));
		        this.emitLine(this.buffer + ' += ' + id2);
		        this.addScopeLevel();
		    },

		    compileTemplateData: function(node, frame) {
		        this.compileLiteral(node, frame);
		    },

		    compileCapture: function(node, frame) {
		        this.emitLine('(function() {');
		        this.emitLine('var output = "";');
		        this.withScopedSyntax(function () {
		            this.compile(node.body, frame);
		        });
		        this.emitLine('return output;');
		        this.emitLine('})()');
		    },

		    compileOutput: function(node, frame) {
		        var children = node.children;
		        for(var i=0, l=children.length; i<l; i++) {
		            // TemplateData is a special case because it is never
		            // autoescaped, so simply output it for optimization
		            if(children[i] instanceof nodes.TemplateData) {
		                if(children[i].value) {
		                    this.emit(this.buffer + ' += ');
		                    this.compileLiteral(children[i], frame);
		                    this.emitLine(';');
		                }
		            }
		            else {
		                this.emit(this.buffer + ' += runtime.suppressValue(');
		                if(this.throwOnUndefined) {
		                    this.emit('runtime.ensureDefined(');
		                }
		                this.compile(children[i], frame);
		                if(this.throwOnUndefined) {
		                    this.emit(',' + node.lineno + ',' + node.colno + ')');
		                }
		                this.emit(', env.opts.autoescape);\n');
		            }
		        }
		    },

		    compileRoot: function(node, frame) {
		        if(frame) {
		            this.fail('compileRoot: root node can\'t have frame');
		        }

		        frame = new Frame();

		        this.emitFuncBegin('root');
		        this.emitLine('var parentTemplate = null;');
		        this._compileChildren(node, frame);
		        this.emitLine('if(parentTemplate) {');
		        this.emitLine('parentTemplate.rootRenderFunc(env, context, frame, runtime, cb);');
		        this.emitLine('} else {');
		        this.emitLine('cb(null, ' + this.buffer +');');
		        this.emitLine('}');
		        this.emitFuncEnd(true);

		        this.inBlock = true;

		        var blockNames = [];

		        var i, name, block, blocks = node.findAll(nodes.Block);
		        for (i = 0; i < blocks.length; i++) {
		            block = blocks[i];
		            name = block.name.value;

		            if (blockNames.indexOf(name) !== -1) {
		                throw new Error('Block "' + name + '" defined more than once.');
		            }
		            blockNames.push(name);

		            this.emitFuncBegin('b_' + name);

		            var tmpFrame = new Frame();
		            this.compile(block.body, tmpFrame);
		            this.emitFuncEnd();
		        }

		        this.emitLine('return {');
		        for (i = 0; i < blocks.length; i++) {
		            block = blocks[i];
		            name = 'b_' + block.name.value;
		            this.emitLine(name + ': ' + name + ',');
		        }
		        this.emitLine('root: root\n};');
		    },

		    compile: function (node, frame) {
		        var _compile = this['compile' + node.typename];
		        if(_compile) {
		            _compile.call(this, node, frame);
		        }
		        else {
		            this.fail('compile: Cannot compile node: ' + node.typename,
		                      node.lineno,
		                      node.colno);
		        }
		    },

		    getCode: function() {
		        return this.codebuf.join('');
		    }
		});

		// var c = new Compiler();
		// var src = 'hello {% filter title %}' +
		//     'Hello madam how are you' +
		//     '{% endfilter %}'
		// var ast = transformer.transform(parser.parse(src));
		// nodes.printNodes(ast);
		// c.compile(ast);
		// var tmpl = c.getCode();
		// console.log(tmpl);

		module.exports = {
		    compile: function(src, asyncFilters, extensions, name, opts) {
		        var c = new Compiler(name, opts.throwOnUndefined);

		        // Run the extension preprocessors against the source.
		        if(extensions && extensions.length) {
		            for(var i=0; i<extensions.length; i++) {
		                if('preprocess' in extensions[i]) {
		                    src = extensions[i].preprocess(src, name);
		                }
		            }
		        }

		        c.compile(transformer.transform(
		            parser.parse(src,
		                         extensions,
		                         opts),
		            asyncFilters,
		            name
		        ));
		        return c.getCode();
		    },

		    Compiler: Compiler
		};


	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lexer = __webpack_require__(9);
		var nodes = __webpack_require__(10);
		// jshint -W079
		var Object = __webpack_require__(6);
		var lib = __webpack_require__(1);

		var Parser = Object.extend({
		    init: function (tokens) {
		        this.tokens = tokens;
		        this.peeked = null;
		        this.breakOnBlocks = null;
		        this.dropLeadingWhitespace = false;

		        this.extensions = [];
		    },

		    nextToken: function (withWhitespace) {
		        var tok;

		        if(this.peeked) {
		            if(!withWhitespace && this.peeked.type === lexer.TOKEN_WHITESPACE) {
		                this.peeked = null;
		            }
		            else {
		                tok = this.peeked;
		                this.peeked = null;
		                return tok;
		            }
		        }

		        tok = this.tokens.nextToken();

		        if(!withWhitespace) {
		            while(tok && tok.type === lexer.TOKEN_WHITESPACE) {
		                tok = this.tokens.nextToken();
		            }
		        }

		        return tok;
		    },

		    peekToken: function () {
		        this.peeked = this.peeked || this.nextToken();
		        return this.peeked;
		    },

		    pushToken: function(tok) {
		        if(this.peeked) {
		            throw new Error('pushToken: can only push one token on between reads');
		        }
		        this.peeked = tok;
		    },

		    fail: function (msg, lineno, colno) {
		        if((lineno === undefined || colno === undefined) && this.peekToken()) {
		            var tok = this.peekToken();
		            lineno = tok.lineno;
		            colno = tok.colno;
		        }
		        if (lineno !== undefined) lineno += 1;
		        if (colno !== undefined) colno += 1;

		        throw new lib.TemplateError(msg, lineno, colno);
		    },

		    skip: function(type) {
		        var tok = this.nextToken();
		        if(!tok || tok.type !== type) {
		            this.pushToken(tok);
		            return false;
		        }
		        return true;
		    },

		    expect: function(type) {
		        var tok = this.nextToken();
		        if(tok.type !== type) {
		            this.fail('expected ' + type + ', got ' + tok.type,
		                      tok.lineno,
		                      tok.colno);
		        }
		        return tok;
		    },

		    skipValue: function(type, val) {
		        var tok = this.nextToken();
		        if(!tok || tok.type !== type || tok.value !== val) {
		            this.pushToken(tok);
		            return false;
		        }
		        return true;
		    },

		    skipSymbol: function(val) {
		        return this.skipValue(lexer.TOKEN_SYMBOL, val);
		    },

		    advanceAfterBlockEnd: function(name) {
		        var tok;
		        if(!name) {
		            tok = this.peekToken();

		            if(!tok) {
		                this.fail('unexpected end of file');
		            }

		            if(tok.type !== lexer.TOKEN_SYMBOL) {
		                this.fail('advanceAfterBlockEnd: expected symbol token or ' +
		                          'explicit name to be passed');
		            }

		            name = this.nextToken().value;
		        }

		        tok = this.nextToken();

		        if(tok && tok.type === lexer.TOKEN_BLOCK_END) {
		            if(tok.value.charAt(0) === '-') {
		                this.dropLeadingWhitespace = true;
		            }
		        }
		        else {
		            this.fail('expected block end in ' + name + ' statement');
		        }

		        return tok;
		    },

		    advanceAfterVariableEnd: function() {
		        if(!this.skip(lexer.TOKEN_VARIABLE_END)) {
		            this.fail('expected variable end');
		        }
		    },

		    parseFor: function() {
		        var forTok = this.peekToken();
		        var node;
		        var endBlock;

		        if(this.skipSymbol('for')) {
		            node = new nodes.For(forTok.lineno, forTok.colno);
		            endBlock = 'endfor';
		        }
		        else if(this.skipSymbol('asyncEach')) {
		            node = new nodes.AsyncEach(forTok.lineno, forTok.colno);
		            endBlock = 'endeach';
		        }
		        else if(this.skipSymbol('asyncAll')) {
		            node = new nodes.AsyncAll(forTok.lineno, forTok.colno);
		            endBlock = 'endall';
		        }
		        else {
		            this.fail('parseFor: expected for{Async}', forTok.lineno, forTok.colno);
		        }

		        node.name = this.parsePrimary();

		        if(!(node.name instanceof nodes.Symbol)) {
		            this.fail('parseFor: variable name expected for loop');
		        }

		        var type = this.peekToken().type;
		        if(type === lexer.TOKEN_COMMA) {
		            // key/value iteration
		            var key = node.name;
		            node.name = new nodes.Array(key.lineno, key.colno);
		            node.name.addChild(key);

		            while(this.skip(lexer.TOKEN_COMMA)) {
		                var prim = this.parsePrimary();
		                node.name.addChild(prim);
		            }
		        }

		        if(!this.skipSymbol('in')) {
		            this.fail('parseFor: expected "in" keyword for loop',
		                      forTok.lineno,
		                      forTok.colno);
		        }

		        node.arr = this.parseExpression();
		        this.advanceAfterBlockEnd(forTok.value);

		        node.body = this.parseUntilBlocks(endBlock, 'else');

		        if(this.skipSymbol('else')) {
		            this.advanceAfterBlockEnd('else');
		            node.else_ = this.parseUntilBlocks(endBlock);
		        }

		        this.advanceAfterBlockEnd();

		        return node;
		    },

		    parseMacro: function() {
		        var macroTok = this.peekToken();
		        if(!this.skipSymbol('macro')) {
		            this.fail('expected macro');
		        }

		        var name = this.parsePrimary(true);
		        var args = this.parseSignature();
		        var node = new nodes.Macro(macroTok.lineno,
		                                   macroTok.colno,
		                                   name,
		                                   args);

		        this.advanceAfterBlockEnd(macroTok.value);
		        node.body = this.parseUntilBlocks('endmacro');
		        this.advanceAfterBlockEnd();

		        return node;
		    },

		    parseCall: function() {
		        // a call block is parsed as a normal FunCall, but with an added
		        // 'caller' kwarg which is a Caller node.
		        var callTok = this.peekToken();
		        if(!this.skipSymbol('call')) {
		            this.fail('expected call');
		        }

		        var callerArgs = this.parseSignature(true) || new nodes.NodeList();
		        var macroCall = this.parsePrimary();

		        this.advanceAfterBlockEnd(callTok.value);
		        var body = this.parseUntilBlocks('endcall');
		        this.advanceAfterBlockEnd();

		        var callerName = new nodes.Symbol(callTok.lineno,
		                                          callTok.colno,
		                                          'caller');
		        var callerNode = new nodes.Caller(callTok.lineno,
		                                          callTok.colno,
		                                          callerName,
		                                          callerArgs,
		                                          body);

		        // add the additional caller kwarg, adding kwargs if necessary
		        var args = macroCall.args.children;
		        if (!(args[args.length-1] instanceof nodes.KeywordArgs)) {
		          args.push(new nodes.KeywordArgs());
		        }
		        var kwargs = args[args.length - 1];
		        kwargs.addChild(new nodes.Pair(callTok.lineno,
		                                       callTok.colno,
		                                       callerName,
		                                       callerNode));

		        return new nodes.Output(callTok.lineno,
		                                callTok.colno,
		                                [macroCall]);
		    },

		    parseWithContext: function() {
		        var tok = this.peekToken();

		        var withContext = null;

		        if(this.skipSymbol('with')) {
		            withContext = true;
		        }
		        else if(this.skipSymbol('without')) {
		            withContext = false;
		        }

		        if(withContext !== null) {
		            if(!this.skipSymbol('context')) {
		                this.fail('parseFrom: expected context after with/without',
		                            tok.lineno,
		                            tok.colno);
		            }
		        }

		        return withContext;
		    },

		    parseImport: function() {
		        var importTok = this.peekToken();
		        if(!this.skipSymbol('import')) {
		            this.fail('parseImport: expected import',
		                      importTok.lineno,
		                      importTok.colno);
		        }

		        var template = this.parseExpression();

		        if(!this.skipSymbol('as')) {
		            this.fail('parseImport: expected "as" keyword',
		                            importTok.lineno,
		                            importTok.colno);
		        }

		        var target = this.parseExpression();

		        var withContext = this.parseWithContext();

		        var node = new nodes.Import(importTok.lineno,
		                                    importTok.colno,
		                                    template,
		                                    target,
		                                    withContext);

		        this.advanceAfterBlockEnd(importTok.value);

		        return node;
		    },

		    parseFrom: function() {
		        var fromTok = this.peekToken();
		        if(!this.skipSymbol('from')) {
		            this.fail('parseFrom: expected from');
		        }

		        var template = this.parseExpression();

		        if(!this.skipSymbol('import')) {
		            this.fail('parseFrom: expected import',
		                            fromTok.lineno,
		                            fromTok.colno);
		        }

		        var names = new nodes.NodeList(),
		            withContext;

		        while(1) {
		            var nextTok = this.peekToken();
		            if(nextTok.type === lexer.TOKEN_BLOCK_END) {
		                if(!names.children.length) {
		                    this.fail('parseFrom: Expected at least one import name',
		                              fromTok.lineno,
		                              fromTok.colno);
		                }

		                // Since we are manually advancing past the block end,
		                // need to keep track of whitespace control (normally
		                // this is done in `advanceAfterBlockEnd`
		                if(nextTok.value.charAt(0) === '-') {
		                    this.dropLeadingWhitespace = true;
		                }

		                this.nextToken();
		                break;
		            }

		            if(names.children.length > 0 && !this.skip(lexer.TOKEN_COMMA)) {
		                this.fail('parseFrom: expected comma',
		                                fromTok.lineno,
		                                fromTok.colno);
		            }

		            var name = this.parsePrimary();
		            if(name.value.charAt(0) === '_') {
		                this.fail('parseFrom: names starting with an underscore ' +
		                          'cannot be imported',
		                          name.lineno,
		                          name.colno);
		            }

		            if(this.skipSymbol('as')) {
		                var alias = this.parsePrimary();
		                names.addChild(new nodes.Pair(name.lineno,
		                                              name.colno,
		                                              name,
		                                              alias));
		            }
		            else {
		                names.addChild(name);
		            }

		            withContext = this.parseWithContext();
		        }

		        return new nodes.FromImport(fromTok.lineno,
		                                    fromTok.colno,
		                                    template,
		                                    names,
		                                    withContext);
		    },

		    parseBlock: function() {
		        var tag = this.peekToken();
		        if(!this.skipSymbol('block')) {
		            this.fail('parseBlock: expected block', tag.lineno, tag.colno);
		        }

		        var node = new nodes.Block(tag.lineno, tag.colno);

		        node.name = this.parsePrimary();
		        if(!(node.name instanceof nodes.Symbol)) {
		            this.fail('parseBlock: variable name expected',
		                      tag.lineno,
		                      tag.colno);
		        }

		        this.advanceAfterBlockEnd(tag.value);

		        node.body = this.parseUntilBlocks('endblock');
		        this.skipSymbol('endblock');
		        this.skipSymbol(node.name.value);

		        var tok = this.peekToken();
		        if(!tok) {
		            this.fail('parseBlock: expected endblock, got end of file');
		        }

		        this.advanceAfterBlockEnd(tok.value);

		        return node;
		    },

		    parseExtends: function() {
		        var tagName = 'extends';
		        var tag = this.peekToken();
		        if(!this.skipSymbol(tagName)) {
		            this.fail('parseTemplateRef: expected '+ tagName);
		        }

		        var node = new nodes.Extends(tag.lineno, tag.colno);
		        node.template = this.parseExpression();

		        this.advanceAfterBlockEnd(tag.value);
		        return node;
		    },

		    parseInclude: function() {
		        var tagName = 'include';
		        var tag = this.peekToken();
		        if(!this.skipSymbol(tagName)) {
		            this.fail('parseInclude: expected '+ tagName);
		        }

		        var node = new nodes.Include(tag.lineno, tag.colno);
		        node.template = this.parseExpression();

		        if(this.skipSymbol('ignore') && this.skipSymbol('missing')) {
		            node.ignoreMissing = true;
		        }

		        this.advanceAfterBlockEnd(tag.value);
		        return node;
		    },

		    parseIf: function() {
		        var tag = this.peekToken();
		        var node;

		        if(this.skipSymbol('if') || this.skipSymbol('elif') || this.skipSymbol('elseif')) {
		            node = new nodes.If(tag.lineno, tag.colno);
		        }
		        else if(this.skipSymbol('ifAsync')) {
		            node = new nodes.IfAsync(tag.lineno, tag.colno);
		        }
		        else {
		            this.fail('parseIf: expected if, elif, or elseif',
		                      tag.lineno,
		                      tag.colno);
		        }

		        node.cond = this.parseExpression();
		        this.advanceAfterBlockEnd(tag.value);

		        node.body = this.parseUntilBlocks('elif', 'elseif', 'else', 'endif');
		        var tok = this.peekToken();

		        switch(tok && tok.value) {
		        case 'elseif':
		        case 'elif':
		            node.else_ = this.parseIf();
		            break;
		        case 'else':
		            this.advanceAfterBlockEnd();
		            node.else_ = this.parseUntilBlocks('endif');
		            this.advanceAfterBlockEnd();
		            break;
		        case 'endif':
		            node.else_ = null;
		            this.advanceAfterBlockEnd();
		            break;
		        default:
		            this.fail('parseIf: expected elif, else, or endif, ' +
		                      'got end of file');
		        }

		        return node;
		    },

		    parseSet: function() {
		        var tag = this.peekToken();
		        if(!this.skipSymbol('set')) {
		            this.fail('parseSet: expected set', tag.lineno, tag.colno);
		        }

		        var node = new nodes.Set(tag.lineno, tag.colno, []);

		        var target;
		        while((target = this.parsePrimary())) {
		            node.targets.push(target);

		            if(!this.skip(lexer.TOKEN_COMMA)) {
		                break;
		            }
		        }

		        if(!this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
		            if (!this.skip(lexer.TOKEN_BLOCK_END)) {
		                this.fail('parseSet: expected = or block end in set tag',
		                          tag.lineno,
		                          tag.colno);
		            }
		            else {
		                node.body = new nodes.Capture(
		                    tag.lineno,
		                    tag.colno,
		                    this.parseUntilBlocks('endset')
		                );
		                node.value = null;
		                this.advanceAfterBlockEnd();
		            }
		        }
		        else {
		            node.value = this.parseExpression();
		            this.advanceAfterBlockEnd(tag.value);
		        }

		        return node;
		    },

		    parseStatement: function () {
		        var tok = this.peekToken();
		        var node;

		        if(tok.type !== lexer.TOKEN_SYMBOL) {
		            this.fail('tag name expected', tok.lineno, tok.colno);
		        }

		        if(this.breakOnBlocks &&
		           lib.indexOf(this.breakOnBlocks, tok.value) !== -1) {
		            return null;
		        }

		        switch(tok.value) {
		        case 'raw': return this.parseRaw();
		        case 'if':
		        case 'ifAsync':
		            return this.parseIf();
		        case 'for':
		        case 'asyncEach':
		        case 'asyncAll':
		            return this.parseFor();
		        case 'block': return this.parseBlock();
		        case 'extends': return this.parseExtends();
		        case 'include': return this.parseInclude();
		        case 'set': return this.parseSet();
		        case 'macro': return this.parseMacro();
		        case 'call': return this.parseCall();
		        case 'import': return this.parseImport();
		        case 'from': return this.parseFrom();
		        case 'filter': return this.parseFilterStatement();
		        default:
		            if (this.extensions.length) {
		                for (var i = 0; i < this.extensions.length; i++) {
		                    var ext = this.extensions[i];
		                    if (lib.indexOf(ext.tags || [], tok.value) !== -1) {
		                        return ext.parse(this, nodes, lexer);
		                    }
		                }
		            }
		            this.fail('unknown block tag: ' + tok.value, tok.lineno, tok.colno);
		        }

		        return node;
		    },

		    parseRaw: function() {
		        // Look for upcoming raw blocks (ignore all other kinds of blocks)
		        var rawBlockRegex = /([\s\S]*?){%\s*(raw|endraw)\s*(?=%})%}/;
		        var rawLevel = 1;
		        var str = '';
		        var matches = null;

		        // Skip opening raw token
		        // Keep this token to track line and column numbers
		        var begun = this.advanceAfterBlockEnd();

		        // Exit when there's nothing to match
		        // or when we've found the matching "endraw" block
		        while((matches = this.tokens._extractRegex(rawBlockRegex)) && rawLevel > 0) {
		            var all = matches[0];
		            var pre = matches[1];
		            var blockName = matches[2];

		            // Adjust rawlevel
		            if(blockName === 'raw') {
		                rawLevel += 1;
		            } else if(blockName === 'endraw') {
		                rawLevel -= 1;
		            }

		            // Add to str
		            if(rawLevel === 0) {
		                // We want to exclude the last "endraw"
		                str += pre;
		                // Move tokenizer to beginning of endraw block
		                this.tokens.backN(all.length - pre.length);
		            } else {
		                str += all;
		            }
		        }

		        return new nodes.Output(
		            begun.lineno,
		            begun.colno,
		            [new nodes.TemplateData(begun.lineno, begun.colno, str)]
		        );
		    },

		    parsePostfix: function(node) {
		        var lookup, tok = this.peekToken();

		        while(tok) {
		            if(tok.type === lexer.TOKEN_LEFT_PAREN) {
		                // Function call
		                node = new nodes.FunCall(tok.lineno,
		                                         tok.colno,
		                                         node,
		                                         this.parseSignature());
		            }
		            else if(tok.type === lexer.TOKEN_LEFT_BRACKET) {
		                // Reference
		                lookup = this.parseAggregate();
		                if(lookup.children.length > 1) {
		                    this.fail('invalid index');
		                }

		                node =  new nodes.LookupVal(tok.lineno,
		                                            tok.colno,
		                                            node,
		                                            lookup.children[0]);
		            }
		            else if(tok.type === lexer.TOKEN_OPERATOR && tok.value === '.') {
		                // Reference
		                this.nextToken();
		                var val = this.nextToken();

		                if(val.type !== lexer.TOKEN_SYMBOL) {
		                    this.fail('expected name as lookup value, got ' + val.value,
		                              val.lineno,
		                              val.colno);
		                }

		                // Make a literal string because it's not a variable
		                // reference
		                lookup = new nodes.Literal(val.lineno,
		                                               val.colno,
		                                               val.value);

		                node =  new nodes.LookupVal(tok.lineno,
		                                            tok.colno,
		                                            node,
		                                            lookup);
		            }
		            else {
		                break;
		            }

		            tok = this.peekToken();
		        }

		        return node;
		    },

		    parseExpression: function() {
		        var node = this.parseInlineIf();
		        return node;
		    },

		    parseInlineIf: function() {
		        var node = this.parseOr();
		        if(this.skipSymbol('if')) {
		            var cond_node = this.parseOr();
		            var body_node = node;
		            node = new nodes.InlineIf(node.lineno, node.colno);
		            node.body = body_node;
		            node.cond = cond_node;
		            if(this.skipSymbol('else')) {
		                node.else_ = this.parseOr();
		            } else {
		                node.else_ = null;
		            }
		        }

		        return node;
		    },

		    parseOr: function() {
		        var node = this.parseAnd();
		        while(this.skipSymbol('or')) {
		            var node2 = this.parseAnd();
		            node = new nodes.Or(node.lineno,
		                                node.colno,
		                                node,
		                                node2);
		        }
		        return node;
		    },

		    parseAnd: function() {
		        var node = this.parseNot();
		        while(this.skipSymbol('and')) {
		            var node2 = this.parseNot();
		            node = new nodes.And(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseNot: function() {
		        var tok = this.peekToken();
		        if(this.skipSymbol('not')) {
		            return new nodes.Not(tok.lineno,
		                                 tok.colno,
		                                 this.parseNot());
		        }
		        return this.parseIn();
		    },

		    parseIn: function() {
		      var node = this.parseCompare();
		      while(1) {
		        // check if the next token is 'not'
		        var tok = this.nextToken();
		        if (!tok) { break; }
		        var invert = tok.type === lexer.TOKEN_SYMBOL && tok.value === 'not';
		        // if it wasn't 'not', put it back
		        if (!invert) { this.pushToken(tok); }
		        if (this.skipSymbol('in')) {
		          var node2 = this.parseCompare();
		          node = new nodes.In(node.lineno,
		                              node.colno,
		                              node,
		                              node2);
		          if (invert) {
		            node = new nodes.Not(node.lineno,
		                                 node.colno,
		                                 node);
		          }
		        }
		        else {
		          // if we'd found a 'not' but this wasn't an 'in', put back the 'not'
		          if (invert) { this.pushToken(tok); }
		          break;
		        }
		      }
		      return node;
		    },

		    parseCompare: function() {
		        var compareOps = ['==', '===', '!=', '!==', '<', '>', '<=', '>='];
		        var expr = this.parseConcat();
		        var ops = [];

		        while(1) {
		            var tok = this.nextToken();

		            if(!tok) {
		                break;
		            }
		            else if(lib.indexOf(compareOps, tok.value) !== -1) {
		                ops.push(new nodes.CompareOperand(tok.lineno,
		                                                  tok.colno,
		                                                  this.parseConcat(),
		                                                  tok.value));
		            }
		            else {
		                this.pushToken(tok);
		                break;
		            }
		        }

		        if(ops.length) {
		            return new nodes.Compare(ops[0].lineno,
		                                     ops[0].colno,
		                                     expr,
		                                     ops);
		        }
		        else {
		            return expr;
		        }
		    },

		    // finds the '~' for string concatenation
		    parseConcat: function(){
		        var node = this.parseAdd();
		        while(this.skipValue(lexer.TOKEN_TILDE, '~')) {
		            var node2 = this.parseAdd();
		            node = new nodes.Concat(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseAdd: function() {
		        var node = this.parseSub();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
		            var node2 = this.parseSub();
		            node = new nodes.Add(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseSub: function() {
		        var node = this.parseMul();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
		            var node2 = this.parseMul();
		            node = new nodes.Sub(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseMul: function() {
		        var node = this.parseDiv();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '*')) {
		            var node2 = this.parseDiv();
		            node = new nodes.Mul(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseDiv: function() {
		        var node = this.parseFloorDiv();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '/')) {
		            var node2 = this.parseFloorDiv();
		            node = new nodes.Div(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseFloorDiv: function() {
		        var node = this.parseMod();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '//')) {
		            var node2 = this.parseMod();
		            node = new nodes.FloorDiv(node.lineno,
		                                      node.colno,
		                                      node,
		                                      node2);
		        }
		        return node;
		    },

		    parseMod: function() {
		        var node = this.parsePow();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '%')) {
		            var node2 = this.parsePow();
		            node = new nodes.Mod(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parsePow: function() {
		        var node = this.parseUnary();
		        while(this.skipValue(lexer.TOKEN_OPERATOR, '**')) {
		            var node2 = this.parseUnary();
		            node = new nodes.Pow(node.lineno,
		                                 node.colno,
		                                 node,
		                                 node2);
		        }
		        return node;
		    },

		    parseUnary: function(noFilters) {
		        var tok = this.peekToken();
		        var node;

		        if(this.skipValue(lexer.TOKEN_OPERATOR, '-')) {
		            node = new nodes.Neg(tok.lineno,
		                                 tok.colno,
		                                 this.parseUnary(true));
		        }
		        else if(this.skipValue(lexer.TOKEN_OPERATOR, '+')) {
		            node = new nodes.Pos(tok.lineno,
		                                 tok.colno,
		                                 this.parseUnary(true));
		        }
		        else {
		            node = this.parsePrimary();
		        }

		        if(!noFilters) {
		            node = this.parseFilter(node);
		        }

		        return node;
		    },

		    parsePrimary: function (noPostfix) {
		        var tok = this.nextToken();
		        var val;
		        var node = null;

		        if(!tok) {
		            this.fail('expected expression, got end of file');
		        }
		        else if(tok.type === lexer.TOKEN_STRING) {
		            val = tok.value;
		        }
		        else if(tok.type === lexer.TOKEN_INT) {
		            val = parseInt(tok.value, 10);
		        }
		        else if(tok.type === lexer.TOKEN_FLOAT) {
		            val = parseFloat(tok.value);
		        }
		        else if(tok.type === lexer.TOKEN_BOOLEAN) {
		            if(tok.value === 'true') {
		                val = true;
		            }
		            else if(tok.value === 'false') {
		                val = false;
		            }
		            else {
		                this.fail('invalid boolean: ' + tok.value,
		                          tok.lineno,
		                          tok.colno);
		            }
		        }
		        else if(tok.type === lexer.TOKEN_NONE) {
		            val = null;
		        }
		        else if (tok.type === lexer.TOKEN_REGEX) {
		            val = new RegExp(tok.value.body, tok.value.flags);
		        }

		        if(val !== undefined) {
		            node = new nodes.Literal(tok.lineno, tok.colno, val);
		        }
		        else if(tok.type === lexer.TOKEN_SYMBOL) {
		            node = new nodes.Symbol(tok.lineno, tok.colno, tok.value);

		            if(!noPostfix) {
		                node = this.parsePostfix(node);
		            }
		        }
		        else {
		            // See if it's an aggregate type, we need to push the
		            // current delimiter token back on
		            this.pushToken(tok);
		            node = this.parseAggregate();
		        }

		        if(node) {
		            return node;
		        }
		        else {
		            this.fail('unexpected token: ' + tok.value,
		                      tok.lineno,
		                      tok.colno);
		        }
		    },

		    parseFilterName: function() {
		        var tok = this.expect(lexer.TOKEN_SYMBOL);
		        var name = tok.value;

		        while(this.skipValue(lexer.TOKEN_OPERATOR, '.')) {
		            name += '.' + this.expect(lexer.TOKEN_SYMBOL).value;
		        }

		        return new nodes.Symbol(tok.lineno, tok.colno, name);
		    },

		    parseFilterArgs: function(node) {
		        if(this.peekToken().type === lexer.TOKEN_LEFT_PAREN) {
		            // Get a FunCall node and add the parameters to the
		            // filter
		            var call = this.parsePostfix(node);
		            return call.args.children;
		        }
		        return [];
		    },

		    parseFilter: function(node) {
		        while(this.skip(lexer.TOKEN_PIPE)) {
		            var name = this.parseFilterName();

		            node = new nodes.Filter(
		                name.lineno,
		                name.colno,
		                name,
		                new nodes.NodeList(
		                    name.lineno,
		                    name.colno,
		                    [node].concat(this.parseFilterArgs(node))
		                )
		            );
		        }

		        return node;
		    },

		    parseFilterStatement: function() {
		        var filterTok = this.peekToken();
		        if(!this.skipSymbol('filter')) {
		            this.fail('parseFilterStatement: expected filter');
		        }

		        var name = this.parseFilterName();
		        var args = this.parseFilterArgs(name);

		        this.advanceAfterBlockEnd(filterTok.value);
		        var body = new nodes.Capture(
		            name.lineno,
		            name.colno,
		            this.parseUntilBlocks('endfilter')
		        );
		        this.advanceAfterBlockEnd();

		        var node = new nodes.Filter(
		            name.lineno,
		            name.colno,
		            name,
		            new nodes.NodeList(
		                name.lineno,
		                name.colno,
		                [body].concat(args)
		            )
		        );

		        return new nodes.Output(
		            name.lineno,
		            name.colno,
		            [node]
		        );
		    },

		    parseAggregate: function() {
		        var tok = this.nextToken();
		        var node;

		        switch(tok.type) {
		        case lexer.TOKEN_LEFT_PAREN:
		            node = new nodes.Group(tok.lineno, tok.colno); break;
		        case lexer.TOKEN_LEFT_BRACKET:
		            node = new nodes.Array(tok.lineno, tok.colno); break;
		        case lexer.TOKEN_LEFT_CURLY:
		            node = new nodes.Dict(tok.lineno, tok.colno); break;
		        default:
		            return null;
		        }

		        while(1) {
		            var type = this.peekToken().type;
		            if(type === lexer.TOKEN_RIGHT_PAREN ||
		               type === lexer.TOKEN_RIGHT_BRACKET ||
		               type === lexer.TOKEN_RIGHT_CURLY) {
		                this.nextToken();
		                break;
		            }

		            if(node.children.length > 0) {
		                if(!this.skip(lexer.TOKEN_COMMA)) {
		                    this.fail('parseAggregate: expected comma after expression',
		                              tok.lineno,
		                              tok.colno);
		                }
		            }

		            if(node instanceof nodes.Dict) {
		                // TODO: check for errors
		                var key = this.parsePrimary();

		                // We expect a key/value pair for dicts, separated by a
		                // colon
		                if(!this.skip(lexer.TOKEN_COLON)) {
		                    this.fail('parseAggregate: expected colon after dict key',
		                        tok.lineno,
		                        tok.colno);
		                }

		                // TODO: check for errors
		                var value = this.parseExpression();
		                node.addChild(new nodes.Pair(key.lineno,
		                                             key.colno,
		                                             key,
		                                             value));
		            }
		            else {
		                // TODO: check for errors
		                var expr = this.parseExpression();
		                node.addChild(expr);
		            }
		        }

		        return node;
		    },

		    parseSignature: function(tolerant, noParens) {
		        var tok = this.peekToken();
		        if(!noParens && tok.type !== lexer.TOKEN_LEFT_PAREN) {
		            if(tolerant) {
		                return null;
		            }
		            else {
		                this.fail('expected arguments', tok.lineno, tok.colno);
		            }
		        }

		        if(tok.type === lexer.TOKEN_LEFT_PAREN) {
		            tok = this.nextToken();
		        }

		        var args = new nodes.NodeList(tok.lineno, tok.colno);
		        var kwargs = new nodes.KeywordArgs(tok.lineno, tok.colno);
		        var checkComma = false;

		        while(1) {
		            tok = this.peekToken();
		            if(!noParens && tok.type === lexer.TOKEN_RIGHT_PAREN) {
		                this.nextToken();
		                break;
		            }
		            else if(noParens && tok.type === lexer.TOKEN_BLOCK_END) {
		                break;
		            }

		            if(checkComma && !this.skip(lexer.TOKEN_COMMA)) {
		                this.fail('parseSignature: expected comma after expression',
		                          tok.lineno,
		                          tok.colno);
		            }
		            else {
		                var arg = this.parseExpression();

		                if(this.skipValue(lexer.TOKEN_OPERATOR, '=')) {
		                    kwargs.addChild(
		                        new nodes.Pair(arg.lineno,
		                                       arg.colno,
		                                       arg,
		                                       this.parseExpression())
		                    );
		                }
		                else {
		                    args.addChild(arg);
		                }
		            }

		            checkComma = true;
		        }

		        if(kwargs.children.length) {
		            args.addChild(kwargs);
		        }

		        return args;
		    },

		    parseUntilBlocks: function(/* blockNames */) {
		        var prev = this.breakOnBlocks;
		        this.breakOnBlocks = lib.toArray(arguments);

		        var ret = this.parse();

		        this.breakOnBlocks = prev;
		        return ret;
		    },

		    parseNodes: function () {
		        var tok;
		        var buf = [];

		        while((tok = this.nextToken())) {
		            if(tok.type === lexer.TOKEN_DATA) {
		                var data = tok.value;
		                var nextToken = this.peekToken();
		                var nextVal = nextToken && nextToken.value;

		                // If the last token has "-" we need to trim the
		                // leading whitespace of the data. This is marked with
		                // the `dropLeadingWhitespace` variable.
		                if(this.dropLeadingWhitespace) {
		                    // TODO: this could be optimized (don't use regex)
		                    data = data.replace(/^\s*/, '');
		                    this.dropLeadingWhitespace = false;
		                }

		                // Same for the succeding block start token
		                if(nextToken &&
		                    ((nextToken.type === lexer.TOKEN_BLOCK_START &&
		                      nextVal.charAt(nextVal.length - 1) === '-') ||
		                    (nextToken.type === lexer.TOKEN_COMMENT &&
		                      nextVal.charAt(this.tokens.tags.COMMENT_START.length)
		                        === '-'))) {
		                    // TODO: this could be optimized (don't use regex)
		                    data = data.replace(/\s*$/, '');
		                }

		                buf.push(new nodes.Output(tok.lineno,
		                                          tok.colno,
		                                          [new nodes.TemplateData(tok.lineno,
		                                                                  tok.colno,
		                                                                  data)]));
		            }
		            else if(tok.type === lexer.TOKEN_BLOCK_START) {
		                this.dropLeadingWhitespace = false;
		                var n = this.parseStatement();
		                if(!n) {
		                    break;
		                }
		                buf.push(n);
		            }
		            else if(tok.type === lexer.TOKEN_VARIABLE_START) {
		                var e = this.parseExpression();
		                this.advanceAfterVariableEnd();
		                this.dropLeadingWhitespace = false;
		                buf.push(new nodes.Output(tok.lineno, tok.colno, [e]));
		            }
		            else if(tok.type === lexer.TOKEN_COMMENT) {
		                this.dropLeadingWhitespace = tok.value.charAt(
		                    tok.value.length - this.tokens.tags.COMMENT_END.length - 1
		                ) === '-';
		            } else {
		                // Ignore comments, otherwise this should be an error
		                this.fail('Unexpected token at top-level: ' +
		                                tok.type, tok.lineno, tok.colno);

		            }
		        }

		        return buf;
		    },

		    parse: function() {
		        return new nodes.NodeList(0, 0, this.parseNodes());
		    },

		    parseAsRoot: function() {
		        return new nodes.Root(0, 0, this.parseNodes());
		    }
		});

		// var util = require('util');

		// var l = lexer.lex('{%- if x -%}\n hello {% endif %}');
		// var t;
		// while((t = l.nextToken())) {
		//     console.log(util.inspect(t));
		// }

		// var p = new Parser(lexer.lex('hello {% filter title %}' +
		//                              'Hello madam how are you' +
		//                              '{% endfilter %}'));
		// var n = p.parseAsRoot();
		// nodes.printNodes(n);

		module.exports = {
		    parse: function(src, extensions, opts) {
		        var p = new Parser(lexer.lex(src, opts));
		        if (extensions !== undefined) {
		            p.extensions = extensions;
		        }
		        return p.parseAsRoot();
		    }
		};


	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lib = __webpack_require__(1);

		var whitespaceChars = ' \n\t\r\u00A0';
		var delimChars = '()[]{}%*-+~/#,:|.<>=!';
		var intChars = '0123456789';

		var BLOCK_START = '{%';
		var BLOCK_END = '%}';
		var VARIABLE_START = '{{';
		var VARIABLE_END = '}}';
		var COMMENT_START = '{#';
		var COMMENT_END = '#}';

		var TOKEN_STRING = 'string';
		var TOKEN_WHITESPACE = 'whitespace';
		var TOKEN_DATA = 'data';
		var TOKEN_BLOCK_START = 'block-start';
		var TOKEN_BLOCK_END = 'block-end';
		var TOKEN_VARIABLE_START = 'variable-start';
		var TOKEN_VARIABLE_END = 'variable-end';
		var TOKEN_COMMENT = 'comment';
		var TOKEN_LEFT_PAREN = 'left-paren';
		var TOKEN_RIGHT_PAREN = 'right-paren';
		var TOKEN_LEFT_BRACKET = 'left-bracket';
		var TOKEN_RIGHT_BRACKET = 'right-bracket';
		var TOKEN_LEFT_CURLY = 'left-curly';
		var TOKEN_RIGHT_CURLY = 'right-curly';
		var TOKEN_OPERATOR = 'operator';
		var TOKEN_COMMA = 'comma';
		var TOKEN_COLON = 'colon';
		var TOKEN_TILDE = 'tilde';
		var TOKEN_PIPE = 'pipe';
		var TOKEN_INT = 'int';
		var TOKEN_FLOAT = 'float';
		var TOKEN_BOOLEAN = 'boolean';
		var TOKEN_NONE = 'none';
		var TOKEN_SYMBOL = 'symbol';
		var TOKEN_SPECIAL = 'special';
		var TOKEN_REGEX = 'regex';

		function token(type, value, lineno, colno) {
		    return {
		        type: type,
		        value: value,
		        lineno: lineno,
		        colno: colno
		    };
		}

		function Tokenizer(str, opts) {
		    this.str = str;
		    this.index = 0;
		    this.len = str.length;
		    this.lineno = 0;
		    this.colno = 0;

		    this.in_code = false;

		    opts = opts || {};

		    var tags = opts.tags || {};
		    this.tags = {
		        BLOCK_START: tags.blockStart || BLOCK_START,
		        BLOCK_END: tags.blockEnd || BLOCK_END,
		        VARIABLE_START: tags.variableStart || VARIABLE_START,
		        VARIABLE_END: tags.variableEnd || VARIABLE_END,
		        COMMENT_START: tags.commentStart || COMMENT_START,
		        COMMENT_END: tags.commentEnd || COMMENT_END
		    };

		    this.trimBlocks = !!opts.trimBlocks;
		    this.lstripBlocks = !!opts.lstripBlocks;
		}

		Tokenizer.prototype.nextToken = function() {
		    var lineno = this.lineno;
		    var colno = this.colno;
		    var tok;

		    if(this.in_code) {
		        // Otherwise, if we are in a block parse it as code
		        var cur = this.current();

		        if(this.is_finished()) {
		            // We have nothing else to parse
		            return null;
		        }
		        else if(cur === '"' || cur === '\'') {
		            // We've hit a string
		            return token(TOKEN_STRING, this.parseString(cur), lineno, colno);
		        }
		        else if((tok = this._extract(whitespaceChars))) {
		            // We hit some whitespace
		            return token(TOKEN_WHITESPACE, tok, lineno, colno);
		        }
		        else if((tok = this._extractString(this.tags.BLOCK_END)) ||
		                (tok = this._extractString('-' + this.tags.BLOCK_END))) {
		            // Special check for the block end tag
		            //
		            // It is a requirement that start and end tags are composed of
		            // delimiter characters (%{}[] etc), and our code always
		            // breaks on delimiters so we can assume the token parsing
		            // doesn't consume these elsewhere
		            this.in_code = false;
		            if(this.trimBlocks) {
		                cur = this.current();
		                if(cur === '\n') {
		                    // Skip newline
		                    this.forward();
		                }else if(cur === '\r'){
		                    // Skip CRLF newline
		                    this.forward();
		                    cur = this.current();
		                    if(cur === '\n'){
		                        this.forward();
		                    }else{
		                        // Was not a CRLF, so go back
		                        this.back();
		                    }
		                }
		            }
		            return token(TOKEN_BLOCK_END, tok, lineno, colno);
		        }
		        else if((tok = this._extractString(this.tags.VARIABLE_END))) {
		            // Special check for variable end tag (see above)
		            this.in_code = false;
		            return token(TOKEN_VARIABLE_END, tok, lineno, colno);
		        }
		        else if (cur === 'r' && this.str.charAt(this.index + 1) === '/') {
		            // Skip past 'r/'.
		            this.forwardN(2);

		            // Extract until the end of the regex -- / ends it, \/ does not.
		            var regexBody = '';
		            while (!this.is_finished()) {
		                if (this.current() === '/' && this.previous() !== '\\') {
		                    this.forward();
		                    break;
		                } else {
		                    regexBody += this.current();
		                    this.forward();
		                }
		            }

		            // Check for flags.
		            // The possible flags are according to https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
		            var POSSIBLE_FLAGS = ['g', 'i', 'm', 'y'];
		            var regexFlags = '';
		            while (!this.is_finished()) {
		                var isCurrentAFlag = POSSIBLE_FLAGS.indexOf(this.current()) !== -1;
		                if (isCurrentAFlag) {
		                    regexFlags += this.current();
		                    this.forward();
		                } else {
		                    break;
		                }
		            }

		            return token(TOKEN_REGEX, {body: regexBody, flags: regexFlags}, lineno, colno);
		        }
		        else if(delimChars.indexOf(cur) !== -1) {
		            // We've hit a delimiter (a special char like a bracket)
		            this.forward();
		            var complexOps = ['==', '===', '!=', '!==', '<=', '>=', '//', '**'];
		            var curComplex = cur + this.current();
		            var type;

		            if(lib.indexOf(complexOps, curComplex) !== -1) {
		                this.forward();
		                cur = curComplex;

		                // See if this is a strict equality/inequality comparator
		                if(lib.indexOf(complexOps, curComplex + this.current()) !== -1) {
		                    cur = curComplex + this.current();
		                    this.forward();
		                }
		            }

		            switch(cur) {
		            case '(': type = TOKEN_LEFT_PAREN; break;
		            case ')': type = TOKEN_RIGHT_PAREN; break;
		            case '[': type = TOKEN_LEFT_BRACKET; break;
		            case ']': type = TOKEN_RIGHT_BRACKET; break;
		            case '{': type = TOKEN_LEFT_CURLY; break;
		            case '}': type = TOKEN_RIGHT_CURLY; break;
		            case ',': type = TOKEN_COMMA; break;
		            case ':': type = TOKEN_COLON; break;
		            case '~': type = TOKEN_TILDE; break;
		            case '|': type = TOKEN_PIPE; break;
		            default: type = TOKEN_OPERATOR;
		            }

		            return token(type, cur, lineno, colno);
		        }
		        else {
		            // We are not at whitespace or a delimiter, so extract the
		            // text and parse it
		            tok = this._extractUntil(whitespaceChars + delimChars);

		            if(tok.match(/^[-+]?[0-9]+$/)) {
		                if(this.current() === '.') {
		                    this.forward();
		                    var dec = this._extract(intChars);
		                    return token(TOKEN_FLOAT, tok + '.' + dec, lineno, colno);
		                }
		                else {
		                    return token(TOKEN_INT, tok, lineno, colno);
		                }
		            }
		            else if(tok.match(/^(true|false)$/)) {
		                return token(TOKEN_BOOLEAN, tok, lineno, colno);
		            }
		            else if(tok === 'none') {
		                return token(TOKEN_NONE, tok, lineno, colno);
		            }
		            else if(tok) {
		                return token(TOKEN_SYMBOL, tok, lineno, colno);
		            }
		            else {
		                throw new Error('Unexpected value while parsing: ' + tok);
		            }
		        }
		    }
		    else {
		        // Parse out the template text, breaking on tag
		        // delimiters because we need to look for block/variable start
		        // tags (don't use the full delimChars for optimization)
		        var beginChars = (this.tags.BLOCK_START.charAt(0) +
		                          this.tags.VARIABLE_START.charAt(0) +
		                          this.tags.COMMENT_START.charAt(0) +
		                          this.tags.COMMENT_END.charAt(0));

		        if(this.is_finished()) {
		            return null;
		        }
		        else if((tok = this._extractString(this.tags.BLOCK_START + '-')) ||
		                (tok = this._extractString(this.tags.BLOCK_START))) {
		            this.in_code = true;
		            return token(TOKEN_BLOCK_START, tok, lineno, colno);
		        }
		        else if((tok = this._extractString(this.tags.VARIABLE_START))) {
		            this.in_code = true;
		            return token(TOKEN_VARIABLE_START, tok, lineno, colno);
		        }
		        else {
		            tok = '';
		            var data;
		            var in_comment = false;

		            if(this._matches(this.tags.COMMENT_START)) {
		                in_comment = true;
		                tok = this._extractString(this.tags.COMMENT_START);
		            }

		            // Continually consume text, breaking on the tag delimiter
		            // characters and checking to see if it's a start tag.
		            //
		            // We could hit the end of the template in the middle of
		            // our looping, so check for the null return value from
		            // _extractUntil
		            while((data = this._extractUntil(beginChars)) !== null) {
		                tok += data;

		                if((this._matches(this.tags.BLOCK_START) ||
		                    this._matches(this.tags.VARIABLE_START) ||
		                    this._matches(this.tags.COMMENT_START)) &&
		                  !in_comment) {
		                    if(this.lstripBlocks &&
		                        this._matches(this.tags.BLOCK_START) &&
		                        this.colno > 0 &&
		                        this.colno <= tok.length) {
		                        var lastLine = tok.slice(-this.colno);
		                        if(/^\s+$/.test(lastLine)) {
		                            // Remove block leading whitespace from beginning of the string
		                            tok = tok.slice(0, -this.colno);
		                            if(!tok.length) {
		                                // All data removed, collapse to avoid unnecessary nodes
		                                // by returning next token (block start)
		                                return this.nextToken();
		                            }
		                        }
		                    }
		                    // If it is a start tag, stop looping
		                    break;
		                }
		                else if(this._matches(this.tags.COMMENT_END)) {
		                    if(!in_comment) {
		                        throw new Error('unexpected end of comment');
		                    }
		                    tok += this._extractString(this.tags.COMMENT_END);
		                    break;
		                }
		                else {
		                    // It does not match any tag, so add the character and
		                    // carry on
		                    tok += this.current();
		                    this.forward();
		                }
		            }

		            if(data === null && in_comment) {
		                throw new Error('expected end of comment, got end of file');
		            }

		            return token(in_comment ? TOKEN_COMMENT : TOKEN_DATA,
		                         tok,
		                         lineno,
		                         colno);
		        }
		    }

		    throw new Error('Could not parse text');
		};

		Tokenizer.prototype.parseString = function(delimiter) {
		    this.forward();

		    var str = '';

		    while(!this.is_finished() && this.current() !== delimiter) {
		        var cur = this.current();

		        if(cur === '\\') {
		            this.forward();
		            switch(this.current()) {
		            case 'n': str += '\n'; break;
		            case 't': str += '\t'; break;
		            case 'r': str += '\r'; break;
		            default:
		                str += this.current();
		            }
		            this.forward();
		        }
		        else {
		            str += cur;
		            this.forward();
		        }
		    }

		    this.forward();
		    return str;
		};

		Tokenizer.prototype._matches = function(str) {
		    if(this.index + str.length > this.len) {
		        return null;
		    }

		    var m = this.str.slice(this.index, this.index + str.length);
		    return m === str;
		};

		Tokenizer.prototype._extractString = function(str) {
		    if(this._matches(str)) {
		        this.index += str.length;
		        return str;
		    }
		    return null;
		};

		Tokenizer.prototype._extractUntil = function(charString) {
		    // Extract all non-matching chars, with the default matching set
		    // to everything
		    return this._extractMatching(true, charString || '');
		};

		Tokenizer.prototype._extract = function(charString) {
		    // Extract all matching chars (no default, so charString must be
		    // explicit)
		    return this._extractMatching(false, charString);
		};

		Tokenizer.prototype._extractMatching = function (breakOnMatch, charString) {
		    // Pull out characters until a breaking char is hit.
		    // If breakOnMatch is false, a non-matching char stops it.
		    // If breakOnMatch is true, a matching char stops it.

		    if(this.is_finished()) {
		        return null;
		    }

		    var first = charString.indexOf(this.current());

		    // Only proceed if the first character doesn't meet our condition
		    if((breakOnMatch && first === -1) ||
		       (!breakOnMatch && first !== -1)) {
		        var t = this.current();
		        this.forward();

		        // And pull out all the chars one at a time until we hit a
		        // breaking char
		        var idx = charString.indexOf(this.current());

		        while(((breakOnMatch && idx === -1) ||
		               (!breakOnMatch && idx !== -1)) && !this.is_finished()) {
		            t += this.current();
		            this.forward();

		            idx = charString.indexOf(this.current());
		        }

		        return t;
		    }

		    return '';
		};

		Tokenizer.prototype._extractRegex = function(regex) {
		    var matches = this.currentStr().match(regex);
		    if(!matches) {
		        return null;
		    }

		    // Move forward whatever was matched
		    this.forwardN(matches[0].length);

		    return matches;
		};

		Tokenizer.prototype.is_finished = function() {
		    return this.index >= this.len;
		};

		Tokenizer.prototype.forwardN = function(n) {
		    for(var i=0; i<n; i++) {
		        this.forward();
		    }
		};

		Tokenizer.prototype.forward = function() {
		    this.index++;

		    if(this.previous() === '\n') {
		        this.lineno++;
		        this.colno = 0;
		    }
		    else {
		        this.colno++;
		    }
		};

		Tokenizer.prototype.backN = function(n) {
		    for(var i=0; i<n; i++) {
		        this.back();
		    }
		};

		Tokenizer.prototype.back = function() {
		    this.index--;

		    if(this.current() === '\n') {
		        this.lineno--;

		        var idx = this.src.lastIndexOf('\n', this.index-1);
		        if(idx === -1) {
		            this.colno = this.index;
		        }
		        else {
		            this.colno = this.index - idx;
		        }
		    }
		    else {
		        this.colno--;
		    }
		};

		// current returns current character
		Tokenizer.prototype.current = function() {
		    if(!this.is_finished()) {
		        return this.str.charAt(this.index);
		    }
		    return '';
		};

		// currentStr returns what's left of the unparsed string
		Tokenizer.prototype.currentStr = function() {
		    if(!this.is_finished()) {
		        return this.str.substr(this.index);
		    }
		    return '';
		};

		Tokenizer.prototype.previous = function() {
		    return this.str.charAt(this.index-1);
		};

		module.exports = {
		    lex: function(src, opts) {
		        return new Tokenizer(src, opts);
		    },

		    TOKEN_STRING: TOKEN_STRING,
		    TOKEN_WHITESPACE: TOKEN_WHITESPACE,
		    TOKEN_DATA: TOKEN_DATA,
		    TOKEN_BLOCK_START: TOKEN_BLOCK_START,
		    TOKEN_BLOCK_END: TOKEN_BLOCK_END,
		    TOKEN_VARIABLE_START: TOKEN_VARIABLE_START,
		    TOKEN_VARIABLE_END: TOKEN_VARIABLE_END,
		    TOKEN_COMMENT: TOKEN_COMMENT,
		    TOKEN_LEFT_PAREN: TOKEN_LEFT_PAREN,
		    TOKEN_RIGHT_PAREN: TOKEN_RIGHT_PAREN,
		    TOKEN_LEFT_BRACKET: TOKEN_LEFT_BRACKET,
		    TOKEN_RIGHT_BRACKET: TOKEN_RIGHT_BRACKET,
		    TOKEN_LEFT_CURLY: TOKEN_LEFT_CURLY,
		    TOKEN_RIGHT_CURLY: TOKEN_RIGHT_CURLY,
		    TOKEN_OPERATOR: TOKEN_OPERATOR,
		    TOKEN_COMMA: TOKEN_COMMA,
		    TOKEN_COLON: TOKEN_COLON,
		    TOKEN_TILDE: TOKEN_TILDE,
		    TOKEN_PIPE: TOKEN_PIPE,
		    TOKEN_INT: TOKEN_INT,
		    TOKEN_FLOAT: TOKEN_FLOAT,
		    TOKEN_BOOLEAN: TOKEN_BOOLEAN,
		    TOKEN_NONE: TOKEN_NONE,
		    TOKEN_SYMBOL: TOKEN_SYMBOL,
		    TOKEN_SPECIAL: TOKEN_SPECIAL,
		    TOKEN_REGEX: TOKEN_REGEX
		};


	/***/ },
	/* 10 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(process) {'use strict';

		var lib = __webpack_require__(1);
		// jshint -W079
		var Object = __webpack_require__(6);

		function traverseAndCheck(obj, type, results) {
		    if(obj instanceof type) {
		        results.push(obj);
		    }

		    if(obj instanceof Node) {
		        obj.findAll(type, results);
		    }
		}

		var Node = Object.extend('Node', {
		    init: function(lineno, colno) {
		        this.lineno = lineno;
		        this.colno = colno;

		        var fields = this.fields;
		        for(var i = 0, l = fields.length; i < l; i++) {
		            var field = fields[i];

		            // The first two args are line/col numbers, so offset by 2
		            var val = arguments[i + 2];

		            // Fields should never be undefined, but null. It makes
		            // testing easier to normalize values.
		            if(val === undefined) {
		                val = null;
		            }

		            this[field] = val;
		        }
		    },

		    findAll: function(type, results) {
		        results = results || [];

		        var i, l;
		        if(this instanceof NodeList) {
		            var children = this.children;

		            for(i = 0, l = children.length; i < l; i++) {
		                traverseAndCheck(children[i], type, results);
		            }
		        }
		        else {
		            var fields = this.fields;

		            for(i = 0, l = fields.length; i < l; i++) {
		                traverseAndCheck(this[fields[i]], type, results);
		            }
		        }

		        return results;
		    },

		    iterFields: function(func) {
		        lib.each(this.fields, function(field) {
		            func(this[field], field);
		        }, this);
		    }
		});

		// Abstract nodes
		var Value = Node.extend('Value', { fields: ['value'] });

		// Concrete nodes
		var NodeList = Node.extend('NodeList', {
		    fields: ['children'],

		    init: function(lineno, colno, nodes) {
		        this.parent(lineno, colno, nodes || []);
		    },

		    addChild: function(node) {
		        this.children.push(node);
		    }
		});

		var Root = NodeList.extend('Root');
		var Literal = Value.extend('Literal');
		var Symbol = Value.extend('Symbol');
		var Group = NodeList.extend('Group');
		var Array = NodeList.extend('Array');
		var Pair = Node.extend('Pair', { fields: ['key', 'value'] });
		var Dict = NodeList.extend('Dict');
		var LookupVal = Node.extend('LookupVal', { fields: ['target', 'val'] });
		var If = Node.extend('If', { fields: ['cond', 'body', 'else_'] });
		var IfAsync = If.extend('IfAsync');
		var InlineIf = Node.extend('InlineIf', { fields: ['cond', 'body', 'else_'] });
		var For = Node.extend('For', { fields: ['arr', 'name', 'body', 'else_'] });
		var AsyncEach = For.extend('AsyncEach');
		var AsyncAll = For.extend('AsyncAll');
		var Macro = Node.extend('Macro', { fields: ['name', 'args', 'body'] });
		var Caller = Macro.extend('Caller');
		var Import = Node.extend('Import', { fields: ['template', 'target', 'withContext'] });
		var FromImport = Node.extend('FromImport', {
		    fields: ['template', 'names', 'withContext'],

		    init: function(lineno, colno, template, names, withContext) {
		        this.parent(lineno, colno,
		                    template,
		                    names || new NodeList(), withContext);
		    }
		});
		var FunCall = Node.extend('FunCall', { fields: ['name', 'args'] });
		var Filter = FunCall.extend('Filter');
		var FilterAsync = Filter.extend('FilterAsync', {
		    fields: ['name', 'args', 'symbol']
		});
		var KeywordArgs = Dict.extend('KeywordArgs');
		var Block = Node.extend('Block', { fields: ['name', 'body'] });
		var Super = Node.extend('Super', { fields: ['blockName', 'symbol'] });
		var TemplateRef = Node.extend('TemplateRef', { fields: ['template'] });
		var Extends = TemplateRef.extend('Extends');
		var Include = Node.extend('Include', { fields: ['template', 'ignoreMissing'] });
		var Set = Node.extend('Set', { fields: ['targets', 'value'] });
		var Output = NodeList.extend('Output');
		var Capture = Node.extend('Capture', { fields: ['body'] });
		var TemplateData = Literal.extend('TemplateData');
		var UnaryOp = Node.extend('UnaryOp', { fields: ['target'] });
		var BinOp = Node.extend('BinOp', { fields: ['left', 'right'] });
		var In = BinOp.extend('In');
		var Or = BinOp.extend('Or');
		var And = BinOp.extend('And');
		var Not = UnaryOp.extend('Not');
		var Add = BinOp.extend('Add');
		var Concat = BinOp.extend('Concat');
		var Sub = BinOp.extend('Sub');
		var Mul = BinOp.extend('Mul');
		var Div = BinOp.extend('Div');
		var FloorDiv = BinOp.extend('FloorDiv');
		var Mod = BinOp.extend('Mod');
		var Pow = BinOp.extend('Pow');
		var Neg = UnaryOp.extend('Neg');
		var Pos = UnaryOp.extend('Pos');
		var Compare = Node.extend('Compare', { fields: ['expr', 'ops'] });
		var CompareOperand = Node.extend('CompareOperand', {
		    fields: ['expr', 'type']
		});

		var CallExtension = Node.extend('CallExtension', {
		    fields: ['extName', 'prop', 'args', 'contentArgs'],

		    init: function(ext, prop, args, contentArgs) {
		        this.extName = ext._name || ext;
		        this.prop = prop;
		        this.args = args || new NodeList();
		        this.contentArgs = contentArgs || [];
		        this.autoescape = ext.autoescape;
		    }
		});

		var CallExtensionAsync = CallExtension.extend('CallExtensionAsync');

		// Print the AST in a nicely formatted tree format for debuggin
		function printNodes(node, indent) {
		    indent = indent || 0;

		    // This is hacky, but this is just a debugging function anyway
		    function print(str, indent, inline) {
		        var lines = str.split('\n');

		        for(var i=0; i<lines.length; i++) {
		            if(lines[i]) {
		                if((inline && i > 0) || !inline) {
		                    for(var j=0; j<indent; j++) {
		                        process.stdout.write(' ');
		                    }
		                }
		            }

		            if(i === lines.length-1) {
		                process.stdout.write(lines[i]);
		            }
		            else {
		                process.stdout.write(lines[i] + '\n');
		            }
		        }
		    }

		    print(node.typename + ': ', indent);

		    if(node instanceof NodeList) {
		        print('\n');
		        lib.each(node.children, function(n) {
		            printNodes(n, indent + 2);
		        });
		    }
		    else if(node instanceof CallExtension) {
		        print(node.extName + '.' + node.prop);
		        print('\n');

		        if(node.args) {
		            printNodes(node.args, indent + 2);
		        }

		        if(node.contentArgs) {
		            lib.each(node.contentArgs, function(n) {
		                printNodes(n, indent + 2);
		            });
		        }
		    }
		    else {
		        var nodes = null;
		        var props = null;

		        node.iterFields(function(val, field) {
		            if(val instanceof Node) {
		                nodes = nodes || {};
		                nodes[field] = val;
		            }
		            else {
		                props = props || {};
		                props[field] = val;
		            }
		        });

		        if(props) {
		            print(JSON.stringify(props, null, 2) + '\n', null, true);
		        }
		        else {
		            print('\n');
		        }

		        if(nodes) {
		            for(var k in nodes) {
		                printNodes(nodes[k], indent + 2);
		            }
		        }

		    }
		}

		// var t = new NodeList(0, 0,
		//                      [new Value(0, 0, 3),
		//                       new Value(0, 0, 10),
		//                       new Pair(0, 0,
		//                                new Value(0, 0, 'key'),
		//                                new Value(0, 0, 'value'))]);
		// printNodes(t);

		module.exports = {
		    Node: Node,
		    Root: Root,
		    NodeList: NodeList,
		    Value: Value,
		    Literal: Literal,
		    Symbol: Symbol,
		    Group: Group,
		    Array: Array,
		    Pair: Pair,
		    Dict: Dict,
		    Output: Output,
		    Capture: Capture,
		    TemplateData: TemplateData,
		    If: If,
		    IfAsync: IfAsync,
		    InlineIf: InlineIf,
		    For: For,
		    AsyncEach: AsyncEach,
		    AsyncAll: AsyncAll,
		    Macro: Macro,
		    Caller: Caller,
		    Import: Import,
		    FromImport: FromImport,
		    FunCall: FunCall,
		    Filter: Filter,
		    FilterAsync: FilterAsync,
		    KeywordArgs: KeywordArgs,
		    Block: Block,
		    Super: Super,
		    Extends: Extends,
		    Include: Include,
		    Set: Set,
		    LookupVal: LookupVal,
		    BinOp: BinOp,
		    In: In,
		    Or: Or,
		    And: And,
		    Not: Not,
		    Add: Add,
		    Concat: Concat,
		    Sub: Sub,
		    Mul: Mul,
		    Div: Div,
		    FloorDiv: FloorDiv,
		    Mod: Mod,
		    Pow: Pow,
		    Neg: Neg,
		    Pos: Pos,
		    Compare: Compare,
		    CompareOperand: CompareOperand,

		    CallExtension: CallExtension,
		    CallExtensionAsync: CallExtensionAsync,

		    printNodes: printNodes
		};

		/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

	/***/ },
	/* 11 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var nodes = __webpack_require__(10);
		var lib = __webpack_require__(1);

		var sym = 0;
		function gensym() {
		    return 'hole_' + sym++;
		}

		// copy-on-write version of map
		function mapCOW(arr, func) {
		    var res = null;

		    for(var i=0; i<arr.length; i++) {
		        var item = func(arr[i]);

		        if(item !== arr[i]) {
		            if(!res) {
		                res = arr.slice();
		            }

		            res[i] = item;
		        }
		    }

		    return res || arr;
		}

		function walk(ast, func, depthFirst) {
		    if(!(ast instanceof nodes.Node)) {
		        return ast;
		    }

		    if(!depthFirst) {
		        var astT = func(ast);

		        if(astT && astT !== ast) {
		            return astT;
		        }
		    }

		    if(ast instanceof nodes.NodeList) {
		        var children = mapCOW(ast.children, function(node) {
		            return walk(node, func, depthFirst);
		        });

		        if(children !== ast.children) {
		            ast = new nodes[ast.typename](ast.lineno, ast.colno, children);
		        }
		    }
		    else if(ast instanceof nodes.CallExtension) {
		        var args = walk(ast.args, func, depthFirst);

		        var contentArgs = mapCOW(ast.contentArgs, function(node) {
		            return walk(node, func, depthFirst);
		        });

		        if(args !== ast.args || contentArgs !== ast.contentArgs) {
		            ast = new nodes[ast.typename](ast.extName,
		                                          ast.prop,
		                                          args,
		                                          contentArgs);
		        }
		    }
		    else {
		        var props = ast.fields.map(function(field) {
		            return ast[field];
		        });

		        var propsT = mapCOW(props, function(prop) {
		            return walk(prop, func, depthFirst);
		        });

		        if(propsT !== props) {
		            ast = new nodes[ast.typename](ast.lineno, ast.colno);

		            propsT.forEach(function(prop, i) {
		                ast[ast.fields[i]] = prop;
		            });
		        }
		    }

		    return depthFirst ? (func(ast) || ast) : ast;
		}

		function depthWalk(ast, func) {
		    return walk(ast, func, true);
		}

		function _liftFilters(node, asyncFilters, prop) {
		    var children = [];

		    var walked = depthWalk(prop ? node[prop] : node, function(node) {
		        if(node instanceof nodes.Block) {
		            return node;
		        }
		        else if((node instanceof nodes.Filter &&
		                 lib.indexOf(asyncFilters, node.name.value) !== -1) ||
		                node instanceof nodes.CallExtensionAsync) {
		            var symbol = new nodes.Symbol(node.lineno,
		                                          node.colno,
		                                          gensym());

		            children.push(new nodes.FilterAsync(node.lineno,
		                                                node.colno,
		                                                node.name,
		                                                node.args,
		                                                symbol));
		            return symbol;
		        }
		    });

		    if(prop) {
		        node[prop] = walked;
		    }
		    else {
		        node = walked;
		    }

		    if(children.length) {
		        children.push(node);

		        return new nodes.NodeList(
		            node.lineno,
		            node.colno,
		            children
		        );
		    }
		    else {
		        return node;
		    }
		}

		function liftFilters(ast, asyncFilters) {
		    return depthWalk(ast, function(node) {
		        if(node instanceof nodes.Output) {
		            return _liftFilters(node, asyncFilters);
		        }
		        else if(node instanceof nodes.Set) {
		            return _liftFilters(node, asyncFilters, 'value');
		        }
		        else if(node instanceof nodes.For) {
		            return _liftFilters(node, asyncFilters, 'arr');
		        }
		        else if(node instanceof nodes.If) {
		            return _liftFilters(node, asyncFilters, 'cond');
		        }
		        else if(node instanceof nodes.CallExtension) {
		            return _liftFilters(node, asyncFilters, 'args');
		        }
		    });
		}

		function liftSuper(ast) {
		    return walk(ast, function(blockNode) {
		        if(!(blockNode instanceof nodes.Block)) {
		            return;
		        }

		        var hasSuper = false;
		        var symbol = gensym();

		        blockNode.body = walk(blockNode.body, function(node) {
		            if(node instanceof nodes.FunCall &&
		               node.name.value === 'super') {
		                hasSuper = true;
		                return new nodes.Symbol(node.lineno, node.colno, symbol);
		            }
		        });

		        if(hasSuper) {
		            blockNode.body.children.unshift(new nodes.Super(
		                0, 0, blockNode.name, new nodes.Symbol(0, 0, symbol)
		            ));
		        }
		    });
		}

		function convertStatements(ast) {
		    return depthWalk(ast, function(node) {
		        if(!(node instanceof nodes.If) &&
		           !(node instanceof nodes.For)) {
		            return;
		        }

		        var async = false;
		        walk(node, function(node) {
		            if(node instanceof nodes.FilterAsync ||
		               node instanceof nodes.IfAsync ||
		               node instanceof nodes.AsyncEach ||
		               node instanceof nodes.AsyncAll ||
		               node instanceof nodes.CallExtensionAsync) {
		                async = true;
		                // Stop iterating by returning the node
		                return node;
		            }
		        });

		        if(async) {
			        if(node instanceof nodes.If) {
		                return new nodes.IfAsync(
		                    node.lineno,
		                    node.colno,
		                    node.cond,
		                    node.body,
		                    node.else_
		                );
		            }
		            else if(node instanceof nodes.For) {
		                return new nodes.AsyncEach(
		                    node.lineno,
		                    node.colno,
		                    node.arr,
		                    node.name,
		                    node.body,
		                    node.else_
		                );
		            }
		        }
		    });
		}

		function cps(ast, asyncFilters) {
		    return convertStatements(liftSuper(liftFilters(ast, asyncFilters)));
		}

		function transform(ast, asyncFilters) {
		    return cps(ast, asyncFilters || []);
		}

		// var parser = require('./parser');
		// var src = 'hello {% foo %}{% endfoo %} end';
		// var ast = transform(parser.parse(src, [new FooExtension()]), ['bar']);
		// nodes.printNodes(ast);

		module.exports = {
		    transform: transform
		};


	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lib = __webpack_require__(1);
		var Obj = __webpack_require__(6);

		// Frames keep track of scoping both at compile-time and run-time so
		// we know how to access variables. Block tags can introduce special
		// variables, for example.
		var Frame = Obj.extend({
		    init: function(parent, isolateWrites) {
		        this.variables = {};
		        this.parent = parent;
		        this.topLevel = false;
		        // if this is true, writes (set) should never propagate upwards past
		        // this frame to its parent (though reads may).
		        this.isolateWrites = isolateWrites;
		    },

		    set: function(name, val, resolveUp) {
		        // Allow variables with dots by automatically creating the
		        // nested structure
		        var parts = name.split('.');
		        var obj = this.variables;
		        var frame = this;

		        if(resolveUp) {
		            if((frame = this.resolve(parts[0], true))) {
		                frame.set(name, val);
		                return;
		            }
		        }

		        for(var i=0; i<parts.length - 1; i++) {
		            var id = parts[i];

		            if(!obj[id]) {
		                obj[id] = {};
		            }
		            obj = obj[id];
		        }

		        obj[parts[parts.length - 1]] = val;
		    },

		    get: function(name) {
		        var val = this.variables[name];
		        if(val !== undefined && val !== null) {
		            return val;
		        }
		        return null;
		    },

		    lookup: function(name) {
		        var p = this.parent;
		        var val = this.variables[name];
		        if(val !== undefined && val !== null) {
		            return val;
		        }
		        return p && p.lookup(name);
		    },

		    resolve: function(name, forWrite) {
		        var p = (forWrite && this.isolateWrites) ? undefined : this.parent;
		        var val = this.variables[name];
		        if(val !== undefined && val !== null) {
		            return this;
		        }
		        return p && p.resolve(name);
		    },

		    push: function(isolateWrites) {
		        return new Frame(this, isolateWrites);
		    },

		    pop: function() {
		        return this.parent;
		    }
		});

		function makeMacro(argNames, kwargNames, func) {
		    return function() {
		        var argCount = numArgs(arguments);
		        var args;
		        var kwargs = getKeywordArgs(arguments);
		        var i;

		        if(argCount > argNames.length) {
		            args = Array.prototype.slice.call(arguments, 0, argNames.length);

		            // Positional arguments that should be passed in as
		            // keyword arguments (essentially default values)
		            var vals = Array.prototype.slice.call(arguments, args.length, argCount);
		            for(i = 0; i < vals.length; i++) {
		                if(i < kwargNames.length) {
		                    kwargs[kwargNames[i]] = vals[i];
		                }
		            }

		            args.push(kwargs);
		        }
		        else if(argCount < argNames.length) {
		            args = Array.prototype.slice.call(arguments, 0, argCount);

		            for(i = argCount; i < argNames.length; i++) {
		                var arg = argNames[i];

		                // Keyword arguments that should be passed as
		                // positional arguments, i.e. the caller explicitly
		                // used the name of a positional arg
		                args.push(kwargs[arg]);
		                delete kwargs[arg];
		            }

		            args.push(kwargs);
		        }
		        else {
		            args = arguments;
		        }

		        return func.apply(this, args);
		    };
		}

		function makeKeywordArgs(obj) {
		    obj.__keywords = true;
		    return obj;
		}

		function getKeywordArgs(args) {
		    var len = args.length;
		    if(len) {
		        var lastArg = args[len - 1];
		        if(lastArg && lastArg.hasOwnProperty('__keywords')) {
		            return lastArg;
		        }
		    }
		    return {};
		}

		function numArgs(args) {
		    var len = args.length;
		    if(len === 0) {
		        return 0;
		    }

		    var lastArg = args[len - 1];
		    if(lastArg && lastArg.hasOwnProperty('__keywords')) {
		        return len - 1;
		    }
		    else {
		        return len;
		    }
		}

		// A SafeString object indicates that the string should not be
		// autoescaped. This happens magically because autoescaping only
		// occurs on primitive string objects.
		function SafeString(val) {
		    if(typeof val !== 'string') {
		        return val;
		    }

		    this.val = val;
		    this.length = val.length;
		}

		SafeString.prototype = Object.create(String.prototype, {
		    length: { writable: true, configurable: true, value: 0 }
		});
		SafeString.prototype.valueOf = function() {
		    return this.val;
		};
		SafeString.prototype.toString = function() {
		    return this.val;
		};

		function copySafeness(dest, target) {
		    if(dest instanceof SafeString) {
		        return new SafeString(target);
		    }
		    return target.toString();
		}

		function markSafe(val) {
		    var type = typeof val;

		    if(type === 'string') {
		        return new SafeString(val);
		    }
		    else if(type !== 'function') {
		        return val;
		    }
		    else {
		        return function() {
		            var ret = val.apply(this, arguments);

		            if(typeof ret === 'string') {
		                return new SafeString(ret);
		            }

		            return ret;
		        };
		    }
		}

		function suppressValue(val, autoescape) {
		    val = (val !== undefined && val !== null) ? val : '';

		    if(autoescape && !(val instanceof SafeString)) {
		        val = lib.escape(val.toString());
		    }

		    return val;
		}

		function ensureDefined(val, lineno, colno) {
		    if(val === null || val === undefined) {
		        throw new lib.TemplateError(
		            'attempted to output null or undefined value',
		            lineno + 1,
		            colno + 1
		        );
		    }
		    return val;
		}

		function memberLookup(obj, val) {
		    obj = obj || {};

		    if(typeof obj[val] === 'function') {
		        return function() {
		            return obj[val].apply(obj, arguments);
		        };
		    }

		    return obj[val];
		}

		function callWrap(obj, name, context, args) {
		    if(!obj) {
		        throw new Error('Unable to call `' + name + '`, which is undefined or falsey');
		    }
		    else if(typeof obj !== 'function') {
		        throw new Error('Unable to call `' + name + '`, which is not a function');
		    }

		    // jshint validthis: true
		    return obj.apply(context, args);
		}

		function contextOrFrameLookup(context, frame, name) {
		    var val = frame.lookup(name);
		    return (val !== undefined && val !== null) ?
		        val :
		        context.lookup(name);
		}

		function handleError(error, lineno, colno) {
		    if(error.lineno) {
		        return error;
		    }
		    else {
		        return new lib.TemplateError(error, lineno, colno);
		    }
		}

		function asyncEach(arr, dimen, iter, cb) {
		    if(lib.isArray(arr)) {
		        var len = arr.length;

		        lib.asyncIter(arr, function(item, i, next) {
		            switch(dimen) {
		            case 1: iter(item, i, len, next); break;
		            case 2: iter(item[0], item[1], i, len, next); break;
		            case 3: iter(item[0], item[1], item[2], i, len, next); break;
		            default:
		                item.push(i, next);
		                iter.apply(this, item);
		            }
		        }, cb);
		    }
		    else {
		        lib.asyncFor(arr, function(key, val, i, len, next) {
		            iter(key, val, i, len, next);
		        }, cb);
		    }
		}

		function asyncAll(arr, dimen, func, cb) {
		    var finished = 0;
		    var len, i;
		    var outputArr;

		    function done(i, output) {
		        finished++;
		        outputArr[i] = output;

		        if(finished === len) {
		            cb(null, outputArr.join(''));
		        }
		    }

		    if(lib.isArray(arr)) {
		        len = arr.length;
		        outputArr = new Array(len);

		        if(len === 0) {
		            cb(null, '');
		        }
		        else {
		            for(i = 0; i < arr.length; i++) {
		                var item = arr[i];

		                switch(dimen) {
		                case 1: func(item, i, len, done); break;
		                case 2: func(item[0], item[1], i, len, done); break;
		                case 3: func(item[0], item[1], item[2], i, len, done); break;
		                default:
		                    item.push(i, done);
		                    // jshint validthis: true
		                    func.apply(this, item);
		                }
		            }
		        }
		    }
		    else {
		        var keys = lib.keys(arr);
		        len = keys.length;
		        outputArr = new Array(len);

		        if(len === 0) {
		            cb(null, '');
		        }
		        else {
		            for(i = 0; i < keys.length; i++) {
		                var k = keys[i];
		                func(k, arr[k], i, len, done);
		            }
		        }
		    }
		}

		module.exports = {
		    Frame: Frame,
		    makeMacro: makeMacro,
		    makeKeywordArgs: makeKeywordArgs,
		    numArgs: numArgs,
		    suppressValue: suppressValue,
		    ensureDefined: ensureDefined,
		    memberLookup: memberLookup,
		    contextOrFrameLookup: contextOrFrameLookup,
		    callWrap: callWrap,
		    handleError: handleError,
		    isArray: lib.isArray,
		    keys: lib.keys,
		    SafeString: SafeString,
		    copySafeness: copySafeness,
		    markSafe: markSafe,
		    asyncEach: asyncEach,
		    asyncAll: asyncAll,
		    inOperator: lib.inOperator
		};


	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var lib = __webpack_require__(1);
		var r = __webpack_require__(12);

		function normalize(value, defaultValue) {
		    if(value === null || value === undefined || value === false) {
		        return defaultValue;
		    }
		    return value;
		}

		var filters = {
		    abs: function(n) {
		        return Math.abs(n);
		    },

		    batch: function(arr, linecount, fill_with) {
		        var i;
		        var res = [];
		        var tmp = [];

		        for(i = 0; i < arr.length; i++) {
		            if(i % linecount === 0 && tmp.length) {
		                res.push(tmp);
		                tmp = [];
		            }

		            tmp.push(arr[i]);
		        }

		        if(tmp.length) {
		            if(fill_with) {
		                for(i = tmp.length; i < linecount; i++) {
		                    tmp.push(fill_with);
		                }
		            }

		            res.push(tmp);
		        }

		        return res;
		    },

		    capitalize: function(str) {
		        str = normalize(str, '');
		        var ret = str.toLowerCase();
		        return r.copySafeness(str, ret.charAt(0).toUpperCase() + ret.slice(1));
		    },

		    center: function(str, width) {
		        str = normalize(str, '');
		        width = width || 80;

		        if(str.length >= width) {
		            return str;
		        }

		        var spaces = width - str.length;
		        var pre = lib.repeat(' ', spaces/2 - spaces % 2);
		        var post = lib.repeat(' ', spaces/2);
		        return r.copySafeness(str, pre + str + post);
		    },

		    'default': function(val, def, bool) {
		        if(bool) {
		            return val ? val : def;
		        }
		        else {
		            return (val !== undefined) ? val : def;
		        }
		    },

		    dictsort: function(val, case_sensitive, by) {
		        if (!lib.isObject(val)) {
		            throw new lib.TemplateError('dictsort filter: val must be an object');
		        }

		        var array = [];
		        for (var k in val) {
		            // deliberately include properties from the object's prototype
		            array.push([k,val[k]]);
		        }

		        var si;
		        if (by === undefined || by === 'key') {
		            si = 0;
		        } else if (by === 'value') {
		            si = 1;
		        } else {
		            throw new lib.TemplateError(
		                'dictsort filter: You can only sort by either key or value');
		        }

		        array.sort(function(t1, t2) {
		            var a = t1[si];
		            var b = t2[si];

		            if (!case_sensitive) {
		                if (lib.isString(a)) {
		                    a = a.toUpperCase();
		                }
		                if (lib.isString(b)) {
		                    b = b.toUpperCase();
		                }
		            }

		            return a > b ? 1 : (a === b ? 0 : -1);
		        });

		        return array;
		    },

		    dump: function(obj) {
		        return JSON.stringify(obj);
		    },

		    escape: function(str) {
		        if(str instanceof r.SafeString) {
		            return str;
		        }
		        str = (str === null || str === undefined) ? '' : str;
		        return r.markSafe(lib.escape(str.toString()));
		    },

		    safe: function(str) {
		        if (str instanceof r.SafeString) {
		            return str;
		        }
		        str = (str === null || str === undefined) ? '' : str;
		        return r.markSafe(str.toString());
		    },

		    first: function(arr) {
		        return arr[0];
		    },

		    groupby: function(arr, attr) {
		        return lib.groupBy(arr, attr);
		    },

		    indent: function(str, width, indentfirst) {
		        str = normalize(str, '');

		        if (str === '') return '';

		        width = width || 4;
		        var res = '';
		        var lines = str.split('\n');
		        var sp = lib.repeat(' ', width);

		        for(var i=0; i<lines.length; i++) {
		            if(i === 0 && !indentfirst) {
		                res += lines[i] + '\n';
		            }
		            else {
		                res += sp + lines[i] + '\n';
		            }
		        }

		        return r.copySafeness(str, res);
		    },

		    join: function(arr, del, attr) {
		        del = del || '';

		        if(attr) {
		            arr = lib.map(arr, function(v) {
		                return v[attr];
		            });
		        }

		        return arr.join(del);
		    },

		    last: function(arr) {
		        return arr[arr.length-1];
		    },

		    length: function(val) {
		        var value = normalize(val, '');

		        if(value !== undefined) {
		            if(
		                (typeof Map === 'function' && value instanceof Map) ||
		                (typeof Set === 'function' && value instanceof Set)
		            ) {
		                // ECMAScript 2015 Maps and Sets
		                return value.size;
		            }
		            if(lib.isObject(value) && !(value instanceof r.SafeString)) {
		                // Objects (besides SafeStrings), non-primative Arrays
		                return Object.keys(value).length;
		            }
		            return value.length;
		        }
		        return 0;
		    },

		    list: function(val) {
		        if(lib.isString(val)) {
		            return val.split('');
		        }
		        else if(lib.isObject(val)) {
		            var keys = [];

		            if(Object.keys) {
		                keys = Object.keys(val);
		            }
		            else {
		                for(var k in val) {
		                    keys.push(k);
		                }
		            }

		            return lib.map(keys, function(k) {
		                return { key: k,
		                         value: val[k] };
		            });
		        }
		        else if(lib.isArray(val)) {
		          return val;
		        }
		        else {
		            throw new lib.TemplateError('list filter: type not iterable');
		        }
		    },

		    lower: function(str) {
		        str = normalize(str, '');
		        return str.toLowerCase();
		    },

		    random: function(arr) {
		        return arr[Math.floor(Math.random() * arr.length)];
		    },

		    rejectattr: function(arr, attr) {
		      return arr.filter(function (item) {
		        return !item[attr];
		      });
		    },

		    selectattr: function(arr, attr) {
		      return arr.filter(function (item) {
		        return !!item[attr];
		      });
		    },

		    replace: function(str, old, new_, maxCount) {
		        var originalStr = str;

		        if (old instanceof RegExp) {
		            return str.replace(old, new_);
		        }

		        if(typeof maxCount === 'undefined'){
		            maxCount = -1;
		        }

		        var res = '';  // Output

		        // Cast Numbers in the search term to string
		        if(typeof old === 'number'){
		            old = old + '';
		        }
		        else if(typeof old !== 'string') {
		            // If it is something other than number or string,
		            // return the original string
		            return str;
		        }

		        // Cast numbers in the replacement to string
		        if(typeof str === 'number'){
		            str = str + '';
		        }

		        // If by now, we don't have a string, throw it back
		        if(typeof str !== 'string' && !(str instanceof r.SafeString)){
		            return str;
		        }

		        // ShortCircuits
		        if(old === ''){
		            // Mimic the python behaviour: empty string is replaced
		            // by replacement e.g. "abc"|replace("", ".") -> .a.b.c.
		            res = new_ + str.split('').join(new_) + new_;
		            return r.copySafeness(str, res);
		        }

		        var nextIndex = str.indexOf(old);
		        // if # of replacements to perform is 0, or the string to does
		        // not contain the old value, return the string
		        if(maxCount === 0 || nextIndex === -1){
		            return str;
		        }

		        var pos = 0;
		        var count = 0; // # of replacements made

		        while(nextIndex  > -1 && (maxCount === -1 || count < maxCount)){
		            // Grab the next chunk of src string and add it with the
		            // replacement, to the result
		            res += str.substring(pos, nextIndex) + new_;
		            // Increment our pointer in the src string
		            pos = nextIndex + old.length;
		            count++;
		            // See if there are any more replacements to be made
		            nextIndex = str.indexOf(old, pos);
		        }

		        // We've either reached the end, or done the max # of
		        // replacements, tack on any remaining string
		        if(pos < str.length) {
		            res += str.substring(pos);
		        }

		        return r.copySafeness(originalStr, res);
		    },

		    reverse: function(val) {
		        var arr;
		        if(lib.isString(val)) {
		            arr = filters.list(val);
		        }
		        else {
		            // Copy it
		            arr = lib.map(val, function(v) { return v; });
		        }

		        arr.reverse();

		        if(lib.isString(val)) {
		            return r.copySafeness(val, arr.join(''));
		        }
		        return arr;
		    },

		    round: function(val, precision, method) {
		        precision = precision || 0;
		        var factor = Math.pow(10, precision);
		        var rounder;

		        if(method === 'ceil') {
		            rounder = Math.ceil;
		        }
		        else if(method === 'floor') {
		            rounder = Math.floor;
		        }
		        else {
		            rounder = Math.round;
		        }

		        return rounder(val * factor) / factor;
		    },

		    slice: function(arr, slices, fillWith) {
		        var sliceLength = Math.floor(arr.length / slices);
		        var extra = arr.length % slices;
		        var offset = 0;
		        var res = [];

		        for(var i=0; i<slices; i++) {
		            var start = offset + i * sliceLength;
		            if(i < extra) {
		                offset++;
		            }
		            var end = offset + (i + 1) * sliceLength;

		            var slice = arr.slice(start, end);
		            if(fillWith && i >= extra) {
		                slice.push(fillWith);
		            }
		            res.push(slice);
		        }

		        return res;
		    },

		    sum: function(arr, attr, start) {
		        var sum = 0;

		        if(typeof start === 'number'){
		            sum += start;
		        }

		        if(attr) {
		            arr = lib.map(arr, function(v) {
		                return v[attr];
		            });
		        }

		        for(var i = 0; i < arr.length; i++) {
		            sum += arr[i];
		        }

		        return sum;
		    },

		    sort: r.makeMacro(['value', 'reverse', 'case_sensitive', 'attribute'], [], function(arr, reverse, caseSens, attr) {
		         // Copy it
		        arr = lib.map(arr, function(v) { return v; });

		        arr.sort(function(a, b) {
		            var x, y;

		            if(attr) {
		                x = a[attr];
		                y = b[attr];
		            }
		            else {
		                x = a;
		                y = b;
		            }

		            if(!caseSens && lib.isString(x) && lib.isString(y)) {
		                x = x.toLowerCase();
		                y = y.toLowerCase();
		            }

		            if(x < y) {
		                return reverse ? 1 : -1;
		            }
		            else if(x > y) {
		                return reverse ? -1: 1;
		            }
		            else {
		                return 0;
		            }
		        });

		        return arr;
		    }),

		    string: function(obj) {
		        return r.copySafeness(obj, obj);
		    },

		    striptags: function(input, preserve_linebreaks) {
		        input = normalize(input, '');
		        preserve_linebreaks = preserve_linebreaks || false;
		        var tags = /<\/?([a-z][a-z0-9]*)\b[^>]*>|<!--[\s\S]*?-->/gi;
		        var trimmedInput = filters.trim(input.replace(tags, ''));
		        var res = '';
		        if (preserve_linebreaks) {
		            res = trimmedInput
		                .replace(/^ +| +$/gm, '')     // remove leading and trailing spaces
		                .replace(/ +/g, ' ')          // squash adjacent spaces
		                .replace(/(\r\n)/g, '\n')     // normalize linebreaks (CRLF -> LF)
		                .replace(/\n\n\n+/g, '\n\n'); // squash abnormal adjacent linebreaks
		        } else {
		            res = trimmedInput.replace(/\s+/gi, ' ');
		        }
		        return r.copySafeness(input, res);
		    },

		    title: function(str) {
		        str = normalize(str, '');
		        var words = str.split(' ');
		        for(var i = 0; i < words.length; i++) {
		            words[i] = filters.capitalize(words[i]);
		        }
		        return r.copySafeness(str, words.join(' '));
		    },

		    trim: function(str) {
		        return r.copySafeness(str, str.replace(/^\s*|\s*$/g, ''));
		    },

		    truncate: function(input, length, killwords, end) {
		        var orig = input;
		        input = normalize(input, '');
		        length = length || 255;

		        if (input.length <= length)
		            return input;

		        if (killwords) {
		            input = input.substring(0, length);
		        } else {
		            var idx = input.lastIndexOf(' ', length);
		            if(idx === -1) {
		                idx = length;
		            }

		            input = input.substring(0, idx);
		        }

		        input += (end !== undefined && end !== null) ? end : '...';
		        return r.copySafeness(orig, input);
		    },

		    upper: function(str) {
		        str = normalize(str, '');
		        return str.toUpperCase();
		    },

		    urlencode: function(obj) {
		        var enc = encodeURIComponent;
		        if (lib.isString(obj)) {
		            return enc(obj);
		        } else {
		            var parts;
		            if (lib.isArray(obj)) {
		                parts = obj.map(function(item) {
		                    return enc(item[0]) + '=' + enc(item[1]);
		                });
		            } else {
		                parts = [];
		                for (var k in obj) {
		                    if (obj.hasOwnProperty(k)) {
		                        parts.push(enc(k) + '=' + enc(obj[k]));
		                    }
		                }
		            }
		            return parts.join('&');
		        }
		    },

		    urlize: function(str, length, nofollow) {
		        if (isNaN(length)) length = Infinity;

		        var noFollowAttr = (nofollow === true ? ' rel="nofollow"' : '');

		        // For the jinja regexp, see
		        // https://github.com/mitsuhiko/jinja2/blob/f15b814dcba6aa12bc74d1f7d0c881d55f7126be/jinja2/utils.py#L20-L23
		        var puncRE = /^(?:\(|<|&lt;)?(.*?)(?:\.|,|\)|\n|&gt;)?$/;
		        // from http://blog.gerv.net/2011/05/html5_email_address_regexp/
		        var emailRE = /^[\w.!#$%&'*+\-\/=?\^`{|}~]+@[a-z\d\-]+(\.[a-z\d\-]+)+$/i;
		        var httpHttpsRE = /^https?:\/\/.*$/;
		        var wwwRE = /^www\./;
		        var tldRE = /\.(?:org|net|com)(?:\:|\/|$)/;

		        var words = str.split(/(\s+)/).filter(function(word) {
		          // If the word has no length, bail. This can happen for str with
		          // trailing whitespace.
		          return word && word.length;
		        }).map(function(word) {
		          var matches = word.match(puncRE);
		          var possibleUrl = matches && matches[1] || word;

		          // url that starts with http or https
		          if (httpHttpsRE.test(possibleUrl))
		            return '<a href="' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

		          // url that starts with www.
		          if (wwwRE.test(possibleUrl))
		            return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

		          // an email address of the form username@domain.tld
		          if (emailRE.test(possibleUrl))
		            return '<a href="mailto:' + possibleUrl + '">' + possibleUrl + '</a>';

		          // url that ends in .com, .org or .net that is not an email address
		          if (tldRE.test(possibleUrl))
		            return '<a href="http://' + possibleUrl + '"' + noFollowAttr + '>' + possibleUrl.substr(0, length) + '</a>';

		          return word;

		        });

		        return words.join('');
		    },

		    wordcount: function(str) {
		        str = normalize(str, '');
		        var words = (str) ? str.match(/\w+/g) : null;
		        return (words) ? words.length : null;
		    },

		    'float': function(val, def) {
		        var res = parseFloat(val);
		        return isNaN(res) ? def : res;
		    },

		    'int': function(val, def) {
		        var res = parseInt(val, 10);
		        return isNaN(res) ? def : res;
		    }
		};

		// Aliases
		filters.d = filters['default'];
		filters.e = filters.escape;

		module.exports = filters;


	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var Loader = __webpack_require__(15);
		var PrecompiledLoader = __webpack_require__(16);

		var WebLoader = Loader.extend({
		    init: function(baseURL, opts) {
		        this.baseURL = baseURL || '.';
		        opts = opts || {};

		        // By default, the cache is turned off because there's no way
		        // to "watch" templates over HTTP, so they are re-downloaded
		        // and compiled each time. (Remember, PRECOMPILE YOUR
		        // TEMPLATES in production!)
		        this.useCache = !!opts.useCache;

		        // We default `async` to false so that the simple synchronous
		        // API can be used when you aren't doing anything async in
		        // your templates (which is most of the time). This performs a
		        // sync ajax request, but that's ok because it should *only*
		        // happen in development. PRECOMPILE YOUR TEMPLATES.
		        this.async = !!opts.async;
		    },

		    resolve: function(from, to) { // jshint ignore:line
		        throw new Error('relative templates not support in the browser yet');
		    },

		    getSource: function(name, cb) {
		        var useCache = this.useCache;
		        var result;
		        this.fetch(this.baseURL + '/' + name, function(err, src) {
		            if(err) {
		                if(cb) {
		                    cb(err.content);
		                } else {
		                    if (err.status === 404) {
		                      result = null;
		                    } else {
		                      throw err.content;
		                    }
		                }
		            }
		            else {
		                result = { src: src,
		                           path: name,
		                           noCache: !useCache };
		                if(cb) {
		                    cb(null, result);
		                }
		            }
		        });

		        // if this WebLoader isn't running asynchronously, the
		        // fetch above would actually run sync and we'll have a
		        // result here
		        return result;
		    },

		    fetch: function(url, cb) {
		        // Only in the browser please
		        var ajax;
		        var loading = true;

		        if(window.XMLHttpRequest) { // Mozilla, Safari, ...
		            ajax = new XMLHttpRequest();
		        }
		        else if(window.ActiveXObject) { // IE 8 and older
		            /* global ActiveXObject */
		            ajax = new ActiveXObject('Microsoft.XMLHTTP');
		        }

		        ajax.onreadystatechange = function() {
		            if(ajax.readyState === 4 && loading) {
		                loading = false;
		                if(ajax.status === 0 || ajax.status === 200) {
		                    cb(null, ajax.responseText);
		                }
		                else {
		                    cb({ status: ajax.status, content: ajax.responseText });
		                }
		            }
		        };

		        url += (url.indexOf('?') === -1 ? '?' : '&') + 's=' +
		               (new Date().getTime());

		        ajax.open('GET', url, this.async);
		        ajax.send();
		    }
		});

		module.exports = {
		    WebLoader: WebLoader,
		    PrecompiledLoader: PrecompiledLoader
		};


	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var path = __webpack_require__(3);
		var Obj = __webpack_require__(6);
		var lib = __webpack_require__(1);

		var Loader = Obj.extend({
		    on: function(name, func) {
		        this.listeners = this.listeners || {};
		        this.listeners[name] = this.listeners[name] || [];
		        this.listeners[name].push(func);
		    },

		    emit: function(name /*, arg1, arg2, ...*/) {
		        var args = Array.prototype.slice.call(arguments, 1);

		        if(this.listeners && this.listeners[name]) {
		            lib.each(this.listeners[name], function(listener) {
		                listener.apply(null, args);
		            });
		        }
		    },

		    resolve: function(from, to) {
		        return path.resolve(path.dirname(from), to);
		    },

		    isRelative: function(filename) {
		        return (filename.indexOf('./') === 0 || filename.indexOf('../') === 0);
		    }
		});

		module.exports = Loader;


	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';

		var Loader = __webpack_require__(15);

		var PrecompiledLoader = Loader.extend({
		    init: function(compiledTemplates) {
		        this.precompiled = compiledTemplates || {};
		    },

		    getSource: function(name) {
		        if (this.precompiled[name]) {
		            return {
		                src: { type: 'code',
		                       obj: this.precompiled[name] },
		                path: name
		            };
		        }
		        return null;
		    }
		});

		module.exports = PrecompiledLoader;


	/***/ },
	/* 17 */
	/***/ function(module, exports) {

		'use strict';

		function cycler(items) {
		    var index = -1;

		    return {
		        current: null,
		        reset: function() {
		            index = -1;
		            this.current = null;
		        },

		        next: function() {
		            index++;
		            if(index >= items.length) {
		                index = 0;
		            }

		            this.current = items[index];
		            return this.current;
		        },
		    };

		}

		function joiner(sep) {
		    sep = sep || ',';
		    var first = true;

		    return function() {
		        var val = first ? '' : sep;
		        first = false;
		        return val;
		    };
		}

		// Making this a function instead so it returns a new object
		// each time it's called. That way, if something like an environment
		// uses it, they will each have their own copy.
		function globals() {
		    return {
		        range: function(start, stop, step) {
		            if(typeof stop === 'undefined') {
		                stop = start;
		                start = 0;
		                step = 1;
		            }
		            else if(!step) {
		                step = 1;
		            }

		            var arr = [];
		            var i;
		            if (step > 0) {
		                for (i=start; i<stop; i+=step) {
		                    arr.push(i);
		                }
		            } else {
		                for (i=start; i>stop; i+=step) {
		                    arr.push(i);
		                }
		            }
		            return arr;
		        },

		        // lipsum: function(n, html, min, max) {
		        // },

		        cycler: function() {
		            return cycler(Array.prototype.slice.call(arguments));
		        },

		        joiner: function(sep) {
		            return joiner(sep);
		        }
		    };
		}

		module.exports = globals;


	/***/ },
	/* 18 */
	/***/ function(module, exports) {

		function installCompat() {
		  'use strict';

		  // This must be called like `nunjucks.installCompat` so that `this`
		  // references the nunjucks instance
		  var runtime = this.runtime; // jshint ignore:line
		  var lib = this.lib; // jshint ignore:line

		  var orig_contextOrFrameLookup = runtime.contextOrFrameLookup;
		  runtime.contextOrFrameLookup = function(context, frame, key) {
		    var val = orig_contextOrFrameLookup.apply(this, arguments);
		    if (val === undefined) {
		      switch (key) {
		      case 'True':
		        return true;
		      case 'False':
		        return false;
		      case 'None':
		        return null;
		      }
		    }

		    return val;
		  };

		  var orig_memberLookup = runtime.memberLookup;
		  var ARRAY_MEMBERS = {
		    pop: function(index) {
		      if (index === undefined) {
		        return this.pop();
		      }
		      if (index >= this.length || index < 0) {
		        throw new Error('KeyError');
		      }
		      return this.splice(index, 1);
		    },
		    remove: function(element) {
		      for (var i = 0; i < this.length; i++) {
		        if (this[i] === element) {
		          return this.splice(i, 1);
		        }
		      }
		      throw new Error('ValueError');
		    },
		    count: function(element) {
		      var count = 0;
		      for (var i = 0; i < this.length; i++) {
		        if (this[i] === element) {
		          count++;
		        }
		      }
		      return count;
		    },
		    index: function(element) {
		      var i;
		      if ((i = this.indexOf(element)) === -1) {
		        throw new Error('ValueError');
		      }
		      return i;
		    },
		    find: function(element) {
		      return this.indexOf(element);
		    },
		    insert: function(index, elem) {
		      return this.splice(index, 0, elem);
		    }
		  };
		  var OBJECT_MEMBERS = {
		    items: function() {
		      var ret = [];
		      for(var k in this) {
		        ret.push([k, this[k]]);
		      }
		      return ret;
		    },
		    values: function() {
		      var ret = [];
		      for(var k in this) {
		        ret.push(this[k]);
		      }
		      return ret;
		    },
		    keys: function() {
		      var ret = [];
		      for(var k in this) {
		        ret.push(k);
		      }
		      return ret;
		    },
		    get: function(key, def) {
		      var output = this[key];
		      if (output === undefined) {
		        output = def;
		      }
		      return output;
		    },
		    has_key: function(key) {
		      return this.hasOwnProperty(key);
		    },
		    pop: function(key, def) {
		      var output = this[key];
		      if (output === undefined && def !== undefined) {
		        output = def;
		      } else if (output === undefined) {
		        throw new Error('KeyError');
		      } else {
		        delete this[key];
		      }
		      return output;
		    },
		    popitem: function() {
		      for (var k in this) {
		        // Return the first object pair.
		        var val = this[k];
		        delete this[k];
		        return [k, val];
		      }
		      throw new Error('KeyError');
		    },
		    setdefault: function(key, def) {
		      if (key in this) {
		        return this[key];
		      }
		      if (def === undefined) {
		        def = null;
		      }
		      return this[key] = def;
		    },
		    update: function(kwargs) {
		      for (var k in kwargs) {
		        this[k] = kwargs[k];
		      }
		      return null;  // Always returns None
		    }
		  };
		  OBJECT_MEMBERS.iteritems = OBJECT_MEMBERS.items;
		  OBJECT_MEMBERS.itervalues = OBJECT_MEMBERS.values;
		  OBJECT_MEMBERS.iterkeys = OBJECT_MEMBERS.keys;
		  runtime.memberLookup = function(obj, val, autoescape) { // jshint ignore:line
		    obj = obj || {};

		    // If the object is an object, return any of the methods that Python would
		    // otherwise provide.
		    if (lib.isArray(obj) && ARRAY_MEMBERS.hasOwnProperty(val)) {
		      return function() {return ARRAY_MEMBERS[val].apply(obj, arguments);};
		    }

		    if (lib.isObject(obj) && OBJECT_MEMBERS.hasOwnProperty(val)) {
		      return function() {return OBJECT_MEMBERS[val].apply(obj, arguments);};
		    }

		    return orig_memberLookup.apply(this, arguments);
		  };
		}

		module.exports = installCompat;


	/***/ }
	/******/ ])
	});
	;

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint node:true */

	"use strict";

	var util = __webpack_require__(9);
	var events = __webpack_require__(11);
	var EventEmitter = events.EventEmitter;
	var runTask = __webpack_require__(269);

	var Orchestrator = function () {
		EventEmitter.call(this);
		this.doneCallback = undefined; // call this when all tasks in the queue are done
		this.seq = []; // the order to run the tasks
		this.tasks = {}; // task objects: name, dep (list of names of dependencies), fn (the task to run)
		this.isRunning = false; // is the orchestrator running tasks? .start() to start, .stop() to stop
	};
	util.inherits(Orchestrator, EventEmitter);

		Orchestrator.prototype.reset = function () {
			if (this.isRunning) {
				this.stop(null);
			}
			this.tasks = {};
			this.seq = [];
			this.isRunning = false;
			this.doneCallback = undefined;
			return this;
		};
		Orchestrator.prototype.add = function (name, dep, fn) {
			if (!fn && typeof dep === 'function') {
				fn = dep;
				dep = undefined;
			}
			dep = dep || [];
			fn = fn || function () {}; // no-op
			if (!name) {
				throw new Error('Task requires a name');
			}
			// validate name is a string, dep is an array of strings, and fn is a function
			if (typeof name !== 'string') {
				throw new Error('Task requires a name that is a string');
			}
			if (typeof fn !== 'function') {
				throw new Error('Task '+name+' requires a function that is a function');
			}
			if (!Array.isArray(dep)) {
				throw new Error('Task '+name+' can\'t support dependencies that is not an array of strings');
			}
			dep.forEach(function (item) {
				if (typeof item !== 'string') {
					throw new Error('Task '+name+' dependency '+item+' is not a string');
				}
			});
			this.tasks[name] = {
				fn: fn,
				dep: dep,
				name: name
			};
			return this;
		};
		Orchestrator.prototype.task = function (name, dep, fn) {
			if (dep || fn) {
				// alias for add, return nothing rather than this
				this.add(name, dep, fn);
			} else {
				return this.tasks[name];
			}
		};
		Orchestrator.prototype.hasTask = function (name) {
			return !!this.tasks[name];
		};
		// tasks and optionally a callback
		Orchestrator.prototype.start = function() {
			var args, arg, names = [], lastTask, i, seq = [];
			args = Array.prototype.slice.call(arguments, 0);
			if (args.length) {
				lastTask = args[args.length-1];
				if (typeof lastTask === 'function') {
					this.doneCallback = lastTask;
					args.pop();
				}
				for (i = 0; i < args.length; i++) {
					arg = args[i];
					if (typeof arg === 'string') {
						names.push(arg);
					} else if (Array.isArray(arg)) {
						names = names.concat(arg); // FRAGILE: ASSUME: it's an array of strings
					} else {
						throw new Error('pass strings or arrays of strings');
					}
				}
			}
			if (this.isRunning) {
				// reset specified tasks (and dependencies) as not run
				this._resetSpecificTasks(names);
			} else {
				// reset all tasks as not run
				this._resetAllTasks();
			}
			if (this.isRunning) {
				// if you call start() again while a previous run is still in play
				// prepend the new tasks to the existing task queue
				names = names.concat(this.seq);
			}
			if (names.length < 1) {
				// run all tasks
				for (i in this.tasks) {
					if (this.tasks.hasOwnProperty(i)) {
						names.push(this.tasks[i].name);
					}
				}
			}
			seq = [];
			try {
				this.sequence(this.tasks, names, seq, []);
			} catch (err) {
				// Is this a known error?
				if (err) {
					if (err.missingTask) {
						this.emit('task_not_found', {message: err.message, task:err.missingTask, err: err});
					}
					if (err.recursiveTasks) {
						this.emit('task_recursion', {message: err.message, recursiveTasks:err.recursiveTasks, err: err});
					}
				}
				this.stop(err);
				return this;
			}
			this.seq = seq;
			this.emit('start', {message:'seq: '+this.seq.join(',')});
			if (!this.isRunning) {
				this.isRunning = true;
			}
			this._runStep();
			return this;
		};
		Orchestrator.prototype.stop = function (err, successfulFinish) {
			this.isRunning = false;
			if (err) {
				this.emit('err', {message:'orchestration failed', err:err});
			} else if (successfulFinish) {
				this.emit('stop', {message:'orchestration succeeded'});
			} else {
				// ASSUME
				err = 'orchestration aborted';
				this.emit('err', {message:'orchestration aborted', err: err});
			}
			if (this.doneCallback) {
				// Avoid calling it multiple times
				this.doneCallback(err);
			} else if (err && !this.listeners('err').length) {
				// No one is listening for the error so speak louder
				throw err;
			}
		};
		Orchestrator.prototype.sequence = __webpack_require__(277);
		Orchestrator.prototype.allDone = function () {
			var i, task, allDone = true; // nothing disputed it yet
			for (i = 0; i < this.seq.length; i++) {
				task = this.tasks[this.seq[i]];
				if (!task.done) {
					allDone = false;
					break;
				}
			}
			return allDone;
		};
		Orchestrator.prototype._resetTask = function(task) {
			if (task) {
				if (task.done) {
					task.done = false;
				}
				delete task.start;
				delete task.stop;
				delete task.duration;
				delete task.hrDuration;
				delete task.args;
			}
		};
		Orchestrator.prototype._resetAllTasks = function() {
			var task;
			for (task in this.tasks) {
				if (this.tasks.hasOwnProperty(task)) {
					this._resetTask(this.tasks[task]);
				}
			}
		};
		Orchestrator.prototype._resetSpecificTasks = function (names) {
			var i, name, t;

			if (names && names.length) {
				for (i = 0; i < names.length; i++) {
					name = names[i];
					t = this.tasks[name];
					if (t) {
						this._resetTask(t);
						if (t.dep && t.dep.length) {
							this._resetSpecificTasks(t.dep); // recurse
						}
					//} else {
						// FRAGILE: ignore that the task doesn't exist
					}
				}
			}
		};
		Orchestrator.prototype._runStep = function () {
			var i, task;
			if (!this.isRunning) {
				return; // user aborted, ASSUME: stop called previously
			}
			for (i = 0; i < this.seq.length; i++) {
				task = this.tasks[this.seq[i]];
				if (!task.done && !task.running && this._readyToRunTask(task)) {
					this._runTask(task);
				}
				if (!this.isRunning) {
					return; // task failed or user aborted, ASSUME: stop called previously
				}
			}
			if (this.allDone()) {
				this.stop(null, true);
			}
		};
		Orchestrator.prototype._readyToRunTask = function (task) {
			var ready = true, // no one disproved it yet
				i, name, t;
			if (task.dep.length) {
				for (i = 0; i < task.dep.length; i++) {
					name = task.dep[i];
					t = this.tasks[name];
					if (!t) {
						// FRAGILE: this should never happen
						this.stop("can't run "+task.name+" because it depends on "+name+" which doesn't exist");
						ready = false;
						break;
					}
					if (!t.done) {
						ready = false;
						break;
					}
				}
			}
			return ready;
		};
		Orchestrator.prototype._stopTask = function (task, meta) {
			task.duration = meta.duration;
			task.hrDuration = meta.hrDuration;
			task.running = false;
			task.done = true;
		};
		Orchestrator.prototype._emitTaskDone = function (task, message, err) {
			if (!task.args) {
				task.args = {task:task.name};
			}
			task.args.duration = task.duration;
			task.args.hrDuration = task.hrDuration;
			task.args.message = task.name+' '+message;
			var evt = 'stop';
			if (err) {
				task.args.err = err;
				evt = 'err';
			}
			// 'task_stop' or 'task_err'
			this.emit('task_'+evt, task.args);
		};
		Orchestrator.prototype._runTask = function (task) {
			var that = this;

			task.args = {task:task.name, message:task.name+' started'};
			this.emit('task_start', task.args);
			task.running = true;

			runTask(task.fn.bind(this), function (err, meta) {
				that._stopTask.call(that, task, meta);
				that._emitTaskDone.call(that, task, meta.runMethod, err);
				if (err) {
					return that.stop.call(that, err);
				}
				that._runStep.call(that);
			});
		};

	// FRAGILE: ASSUME: this list is an exhaustive list of events emitted
	var events = ['start','stop','err','task_start','task_stop','task_err','task_not_found','task_recursion'];

	var listenToEvent = function (target, event, callback) {
		target.on(event, function (e) {
			e.src = event;
			callback(e);
		});
	};

		Orchestrator.prototype.onAll = function (callback) {
			var i;
			if (typeof callback !== 'function') {
				throw new Error('No callback specified');
			}

			for (i = 0; i < events.length; i++) {
				listenToEvent(this, events[i], callback);
			}
		};

	module.exports = Orchestrator;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*jshint node:true */

	"use strict";

	var eos = __webpack_require__(182);
	var consume = __webpack_require__(285);

	module.exports = function (task, done) {
		var that = this, finish, cb, isDone = false, start, r;

		finish = function (err, runMethod) {
			var hrDuration = process.hrtime(start);

			if (isDone && !err) {
				err = new Error('task completion callback called too many times');
			}
			isDone = true;

			var duration = hrDuration[0] + (hrDuration[1] / 1e9); // seconds

			done.call(that, err, {
				duration: duration, // seconds
				hrDuration: hrDuration, // [seconds,nanoseconds]
				runMethod: runMethod
			});
		};

		cb = function (err) {
			finish(err, 'callback');
		};

		try {
			start = process.hrtime();
			r = task(cb);
		} catch (err) {
			return finish(err, 'catch');
		}

		if (r && typeof r.then === 'function') {
			// wait for promise to resolve
			// FRAGILE: ASSUME: Promises/A+, see http://promises-aplus.github.io/promises-spec/
			r.then(function () {
				finish(null, 'promise');
			}, function(err) {
				finish(err, 'promise');
			});

		} else if (r && typeof r.pipe === 'function') {
			// wait for stream to end

			eos(r, { error: true, readable: r.readable, writable: r.writable && !r.readable }, function(err){
				finish(err, 'stream');
			});

			// Ensure that the stream completes
	        consume(r);

		} else if (task.length === 0) {
			// synchronous, function took in args.length parameters, and the callback was extra
			finish(null, 'sync');

		//} else {
			// FRAGILE: ASSUME: callback

		}
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	var Readable = __webpack_require__(3).Readable;
	var util = __webpack_require__(9);


	function addStream(streams, stream)
	{
	  if(!stream.readable) throw new Error('All input streams must be readable');

	  if(this._readableState.ended) throw new Error('Adding streams after ended');


	  var self = this;

	  stream._buffer = [];

	  stream.on('data', function(chunk)
	  {
	    if(this === streams[0])
	      self.push(chunk);

	    else
	      this._buffer.push(chunk);
	  });

	  stream.on('end', function()
	  {
	    for(var stream = streams[0];
	        stream && stream._readableState.ended;
	        stream = streams[0])
	    {
	      while(stream._buffer.length)
	        self.push(stream._buffer.shift());

	      streams.shift();
	    }

	    if(!streams.length) self.push(null);
	  });

	  stream.on('error', this.emit.bind(this, 'error'));


	  streams.push(stream);
	}


	function OrderedStreams(streams, options) {
	  if (!(this instanceof(OrderedStreams))) {
	    return new OrderedStreams(streams, options);
	  }

	  streams = streams || [];
	  options = options || {};

	  options.objectMode = true;

	  Readable.call(this, options);


	  if(!Array.isArray(streams)) streams = [streams];
	  if(!streams.length) return this.push(null);  // no streams, close


	  var addStream_bind = addStream.bind(this, []);


	  this.concat = function()
	  {
	    Array.prototype.forEach.call(arguments, function(item)
	    {
	      if(Array.isArray(item))
	        item.forEach(addStream_bind);

	      else
	        addStream_bind(item);
	    });
	  };


	  this.concat(streams);
	}
	util.inherits(OrderedStreams, Readable);

	OrderedStreams.prototype._read = function () {};


	module.exports = OrderedStreams;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(16)


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Buffer = __webpack_require__(2).Buffer;
	/*<replacement>*/
	var bufferShim = __webpack_require__(36);
	/*</replacement>*/

	module.exports = BufferList;

	function BufferList() {
	  this.head = null;
	  this.tail = null;
	  this.length = 0;
	}

	BufferList.prototype.push = function (v) {
	  var entry = { data: v, next: null };
	  if (this.length > 0) this.tail.next = entry;else this.head = entry;
	  this.tail = entry;
	  ++this.length;
	};

	BufferList.prototype.unshift = function (v) {
	  var entry = { data: v, next: this.head };
	  if (this.length === 0) this.tail = entry;
	  this.head = entry;
	  ++this.length;
	};

	BufferList.prototype.shift = function () {
	  if (this.length === 0) return;
	  var ret = this.head.data;
	  if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	  --this.length;
	  return ret;
	};

	BufferList.prototype.clear = function () {
	  this.head = this.tail = null;
	  this.length = 0;
	};

	BufferList.prototype.join = function (s) {
	  if (this.length === 0) return '';
	  var p = this.head;
	  var ret = '' + p.data;
	  while (p = p.next) {
	    ret += s + p.data;
	  }return ret;
	};

	BufferList.prototype.concat = function (n) {
	  if (this.length === 0) return bufferShim.alloc(0);
	  if (this.length === 1) return this.head.data;
	  var ret = bufferShim.allocUnsafe(n >>> 0);
	  var p = this.head;
	  var i = 0;
	  while (p) {
	    p.data.copy(ret, i);
	    i += p.data.length;
	    p = p.next;
	  }
	  return ret;
	};

/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(69)


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var Stream = (function (){
	  try {
	    return __webpack_require__(3); // hack to fix a circular dependency issue when used with browserify
	  } catch(_){}
	}());
	exports = module.exports = __webpack_require__(70);
	exports.Stream = Stream || exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(45);
	exports.Duplex = __webpack_require__(16);
	exports.Transform = __webpack_require__(44);
	exports.PassThrough = __webpack_require__(69);

	if (!process.browser && process.env.READABLE_STREAM === 'disable' && Stream) {
	  module.exports = Stream;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(45)


/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {;(function (sax) { // wrapper for non-node envs
	  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
	  sax.SAXParser = SAXParser
	  sax.SAXStream = SAXStream
	  sax.createStream = createStream

	  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
	  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
	  // since that's the earliest that a buffer overrun could occur.  This way, checks are
	  // as rare as required, but as often as necessary to ensure never crossing this bound.
	  // Furthermore, buffers are only tested at most once per write(), so passing a very
	  // large string into write() might have undesirable effects, but this is manageable by
	  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
	  // edge case, result in creating at most one complete copy of the string passed in.
	  // Set to Infinity to have unlimited buffers.
	  sax.MAX_BUFFER_LENGTH = 64 * 1024

	  var buffers = [
	    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
	    'procInstName', 'procInstBody', 'entity', 'attribName',
	    'attribValue', 'cdata', 'script'
	  ]

	  sax.EVENTS = [
	    'text',
	    'processinginstruction',
	    'sgmldeclaration',
	    'doctype',
	    'comment',
	    'opentagstart',
	    'attribute',
	    'opentag',
	    'closetag',
	    'opencdata',
	    'cdata',
	    'closecdata',
	    'error',
	    'end',
	    'ready',
	    'script',
	    'opennamespace',
	    'closenamespace'
	  ]

	  function SAXParser (strict, opt) {
	    if (!(this instanceof SAXParser)) {
	      return new SAXParser(strict, opt)
	    }

	    var parser = this
	    clearBuffers(parser)
	    parser.q = parser.c = ''
	    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
	    parser.opt = opt || {}
	    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
	    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
	    parser.tags = []
	    parser.closed = parser.closedRoot = parser.sawRoot = false
	    parser.tag = parser.error = null
	    parser.strict = !!strict
	    parser.noscript = !!(strict || parser.opt.noscript)
	    parser.state = S.BEGIN
	    parser.strictEntities = parser.opt.strictEntities
	    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
	    parser.attribList = []

	    // namespaces form a prototype chain.
	    // it always points at the current tag,
	    // which protos to its parent tag.
	    if (parser.opt.xmlns) {
	      parser.ns = Object.create(rootNS)
	    }

	    // mostly just for error reporting
	    parser.trackPosition = parser.opt.position !== false
	    if (parser.trackPosition) {
	      parser.position = parser.line = parser.column = 0
	    }
	    emit(parser, 'onready')
	  }

	  if (!Object.create) {
	    Object.create = function (o) {
	      function F () {}
	      F.prototype = o
	      var newf = new F()
	      return newf
	    }
	  }

	  if (!Object.keys) {
	    Object.keys = function (o) {
	      var a = []
	      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
	      return a
	    }
	  }

	  function checkBufferLength (parser) {
	    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
	    var maxActual = 0
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      var len = parser[buffers[i]].length
	      if (len > maxAllowed) {
	        // Text/cdata nodes can get big, and since they're buffered,
	        // we can get here under normal conditions.
	        // Avoid issues by emitting the text node now,
	        // so at least it won't get any bigger.
	        switch (buffers[i]) {
	          case 'textNode':
	            closeText(parser)
	            break

	          case 'cdata':
	            emitNode(parser, 'oncdata', parser.cdata)
	            parser.cdata = ''
	            break

	          case 'script':
	            emitNode(parser, 'onscript', parser.script)
	            parser.script = ''
	            break

	          default:
	            error(parser, 'Max buffer length exceeded: ' + buffers[i])
	        }
	      }
	      maxActual = Math.max(maxActual, len)
	    }
	    // schedule the next check for the earliest possible buffer overrun.
	    var m = sax.MAX_BUFFER_LENGTH - maxActual
	    parser.bufferCheckPosition = m + parser.position
	  }

	  function clearBuffers (parser) {
	    for (var i = 0, l = buffers.length; i < l; i++) {
	      parser[buffers[i]] = ''
	    }
	  }

	  function flushBuffers (parser) {
	    closeText(parser)
	    if (parser.cdata !== '') {
	      emitNode(parser, 'oncdata', parser.cdata)
	      parser.cdata = ''
	    }
	    if (parser.script !== '') {
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }
	  }

	  SAXParser.prototype = {
	    end: function () { end(this) },
	    write: write,
	    resume: function () { this.error = null; return this },
	    close: function () { return this.write(null) },
	    flush: function () { flushBuffers(this) }
	  }

	  var Stream
	  try {
	    Stream = __webpack_require__(3).Stream
	  } catch (ex) {
	    Stream = function () {}
	  }

	  var streamWraps = sax.EVENTS.filter(function (ev) {
	    return ev !== 'error' && ev !== 'end'
	  })

	  function createStream (strict, opt) {
	    return new SAXStream(strict, opt)
	  }

	  function SAXStream (strict, opt) {
	    if (!(this instanceof SAXStream)) {
	      return new SAXStream(strict, opt)
	    }

	    Stream.apply(this)

	    this._parser = new SAXParser(strict, opt)
	    this.writable = true
	    this.readable = true

	    var me = this

	    this._parser.onend = function () {
	      me.emit('end')
	    }

	    this._parser.onerror = function (er) {
	      me.emit('error', er)

	      // if didn't throw, then means error was handled.
	      // go ahead and clear error, so we can write again.
	      me._parser.error = null
	    }

	    this._decoder = null

	    streamWraps.forEach(function (ev) {
	      Object.defineProperty(me, 'on' + ev, {
	        get: function () {
	          return me._parser['on' + ev]
	        },
	        set: function (h) {
	          if (!h) {
	            me.removeAllListeners(ev)
	            me._parser['on' + ev] = h
	            return h
	          }
	          me.on(ev, h)
	        },
	        enumerable: true,
	        configurable: false
	      })
	    })
	  }

	  SAXStream.prototype = Object.create(Stream.prototype, {
	    constructor: {
	      value: SAXStream
	    }
	  })

	  SAXStream.prototype.write = function (data) {
	    if (typeof Buffer === 'function' &&
	      typeof Buffer.isBuffer === 'function' &&
	      Buffer.isBuffer(data)) {
	      if (!this._decoder) {
	        var SD = __webpack_require__(17).StringDecoder
	        this._decoder = new SD('utf8')
	      }
	      data = this._decoder.write(data)
	    }

	    this._parser.write(data.toString())
	    this.emit('data', data)
	    return true
	  }

	  SAXStream.prototype.end = function (chunk) {
	    if (chunk && chunk.length) {
	      this.write(chunk)
	    }
	    this._parser.end()
	    return true
	  }

	  SAXStream.prototype.on = function (ev, handler) {
	    var me = this
	    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
	      me._parser['on' + ev] = function () {
	        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
	        args.splice(0, 0, ev)
	        me.emit.apply(me, args)
	      }
	    }

	    return Stream.prototype.on.call(me, ev, handler)
	  }

	  // character classes and tokens
	  var whitespace = '\r\n\t '

	  // this really needs to be replaced with character classes.
	  // XML allows all manner of ridiculous numbers and digits.

	  // (Letter | "_" | ":")
	  var quote = '\'"'
	  var attribEnd = whitespace + '>'
	  var CDATA = '[CDATA['
	  var DOCTYPE = 'DOCTYPE'
	  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
	  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
	  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

	  // turn all the string character sets into character class objects.
	  whitespace = charClass(whitespace)

	  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
	  // This implementation works on strings, a single character at a time
	  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
	  // without a significant breaking change to either this  parser, or the
	  // JavaScript language.  Implementation of an emoji-capable xml parser
	  // is left as an exercise for the reader.
	  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

	  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

	  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
	  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

	  quote = charClass(quote)
	  attribEnd = charClass(attribEnd)

	  function charClass (str) {
	    return str.split('').reduce(function (s, c) {
	      s[c] = true
	      return s
	    }, {})
	  }

	  function isMatch (regex, c) {
	    return regex.test(c)
	  }

	  function is (charclass, c) {
	    return charclass[c]
	  }

	  function notMatch (regex, c) {
	    return !isMatch(regex, c)
	  }

	  function not (charclass, c) {
	    return !is(charclass, c)
	  }

	  var S = 0
	  sax.STATE = {
	    BEGIN: S++, // leading byte order mark or whitespace
	    BEGIN_WHITESPACE: S++, // leading whitespace
	    TEXT: S++, // general stuff
	    TEXT_ENTITY: S++, // &amp and such.
	    OPEN_WAKA: S++, // <
	    SGML_DECL: S++, // <!BLARG
	    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
	    DOCTYPE: S++, // <!DOCTYPE
	    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
	    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
	    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
	    COMMENT_STARTING: S++, // <!-
	    COMMENT: S++, // <!--
	    COMMENT_ENDING: S++, // <!-- blah -
	    COMMENT_ENDED: S++, // <!-- blah --
	    CDATA: S++, // <![CDATA[ something
	    CDATA_ENDING: S++, // ]
	    CDATA_ENDING_2: S++, // ]]
	    PROC_INST: S++, // <?hi
	    PROC_INST_BODY: S++, // <?hi there
	    PROC_INST_ENDING: S++, // <?hi "there" ?
	    OPEN_TAG: S++, // <strong
	    OPEN_TAG_SLASH: S++, // <strong /
	    ATTRIB: S++, // <a
	    ATTRIB_NAME: S++, // <a foo
	    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
	    ATTRIB_VALUE: S++, // <a foo=
	    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
	    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
	    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
	    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
	    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
	    CLOSE_TAG: S++, // </a
	    CLOSE_TAG_SAW_WHITE: S++, // </a   >
	    SCRIPT: S++, // <script> ...
	    SCRIPT_ENDING: S++ // <script> ... <
	  }

	  sax.XML_ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'"
	  }

	  sax.ENTITIES = {
	    'amp': '&',
	    'gt': '>',
	    'lt': '<',
	    'quot': '"',
	    'apos': "'",
	    'AElig': 198,
	    'Aacute': 193,
	    'Acirc': 194,
	    'Agrave': 192,
	    'Aring': 197,
	    'Atilde': 195,
	    'Auml': 196,
	    'Ccedil': 199,
	    'ETH': 208,
	    'Eacute': 201,
	    'Ecirc': 202,
	    'Egrave': 200,
	    'Euml': 203,
	    'Iacute': 205,
	    'Icirc': 206,
	    'Igrave': 204,
	    'Iuml': 207,
	    'Ntilde': 209,
	    'Oacute': 211,
	    'Ocirc': 212,
	    'Ograve': 210,
	    'Oslash': 216,
	    'Otilde': 213,
	    'Ouml': 214,
	    'THORN': 222,
	    'Uacute': 218,
	    'Ucirc': 219,
	    'Ugrave': 217,
	    'Uuml': 220,
	    'Yacute': 221,
	    'aacute': 225,
	    'acirc': 226,
	    'aelig': 230,
	    'agrave': 224,
	    'aring': 229,
	    'atilde': 227,
	    'auml': 228,
	    'ccedil': 231,
	    'eacute': 233,
	    'ecirc': 234,
	    'egrave': 232,
	    'eth': 240,
	    'euml': 235,
	    'iacute': 237,
	    'icirc': 238,
	    'igrave': 236,
	    'iuml': 239,
	    'ntilde': 241,
	    'oacute': 243,
	    'ocirc': 244,
	    'ograve': 242,
	    'oslash': 248,
	    'otilde': 245,
	    'ouml': 246,
	    'szlig': 223,
	    'thorn': 254,
	    'uacute': 250,
	    'ucirc': 251,
	    'ugrave': 249,
	    'uuml': 252,
	    'yacute': 253,
	    'yuml': 255,
	    'copy': 169,
	    'reg': 174,
	    'nbsp': 160,
	    'iexcl': 161,
	    'cent': 162,
	    'pound': 163,
	    'curren': 164,
	    'yen': 165,
	    'brvbar': 166,
	    'sect': 167,
	    'uml': 168,
	    'ordf': 170,
	    'laquo': 171,
	    'not': 172,
	    'shy': 173,
	    'macr': 175,
	    'deg': 176,
	    'plusmn': 177,
	    'sup1': 185,
	    'sup2': 178,
	    'sup3': 179,
	    'acute': 180,
	    'micro': 181,
	    'para': 182,
	    'middot': 183,
	    'cedil': 184,
	    'ordm': 186,
	    'raquo': 187,
	    'frac14': 188,
	    'frac12': 189,
	    'frac34': 190,
	    'iquest': 191,
	    'times': 215,
	    'divide': 247,
	    'OElig': 338,
	    'oelig': 339,
	    'Scaron': 352,
	    'scaron': 353,
	    'Yuml': 376,
	    'fnof': 402,
	    'circ': 710,
	    'tilde': 732,
	    'Alpha': 913,
	    'Beta': 914,
	    'Gamma': 915,
	    'Delta': 916,
	    'Epsilon': 917,
	    'Zeta': 918,
	    'Eta': 919,
	    'Theta': 920,
	    'Iota': 921,
	    'Kappa': 922,
	    'Lambda': 923,
	    'Mu': 924,
	    'Nu': 925,
	    'Xi': 926,
	    'Omicron': 927,
	    'Pi': 928,
	    'Rho': 929,
	    'Sigma': 931,
	    'Tau': 932,
	    'Upsilon': 933,
	    'Phi': 934,
	    'Chi': 935,
	    'Psi': 936,
	    'Omega': 937,
	    'alpha': 945,
	    'beta': 946,
	    'gamma': 947,
	    'delta': 948,
	    'epsilon': 949,
	    'zeta': 950,
	    'eta': 951,
	    'theta': 952,
	    'iota': 953,
	    'kappa': 954,
	    'lambda': 955,
	    'mu': 956,
	    'nu': 957,
	    'xi': 958,
	    'omicron': 959,
	    'pi': 960,
	    'rho': 961,
	    'sigmaf': 962,
	    'sigma': 963,
	    'tau': 964,
	    'upsilon': 965,
	    'phi': 966,
	    'chi': 967,
	    'psi': 968,
	    'omega': 969,
	    'thetasym': 977,
	    'upsih': 978,
	    'piv': 982,
	    'ensp': 8194,
	    'emsp': 8195,
	    'thinsp': 8201,
	    'zwnj': 8204,
	    'zwj': 8205,
	    'lrm': 8206,
	    'rlm': 8207,
	    'ndash': 8211,
	    'mdash': 8212,
	    'lsquo': 8216,
	    'rsquo': 8217,
	    'sbquo': 8218,
	    'ldquo': 8220,
	    'rdquo': 8221,
	    'bdquo': 8222,
	    'dagger': 8224,
	    'Dagger': 8225,
	    'bull': 8226,
	    'hellip': 8230,
	    'permil': 8240,
	    'prime': 8242,
	    'Prime': 8243,
	    'lsaquo': 8249,
	    'rsaquo': 8250,
	    'oline': 8254,
	    'frasl': 8260,
	    'euro': 8364,
	    'image': 8465,
	    'weierp': 8472,
	    'real': 8476,
	    'trade': 8482,
	    'alefsym': 8501,
	    'larr': 8592,
	    'uarr': 8593,
	    'rarr': 8594,
	    'darr': 8595,
	    'harr': 8596,
	    'crarr': 8629,
	    'lArr': 8656,
	    'uArr': 8657,
	    'rArr': 8658,
	    'dArr': 8659,
	    'hArr': 8660,
	    'forall': 8704,
	    'part': 8706,
	    'exist': 8707,
	    'empty': 8709,
	    'nabla': 8711,
	    'isin': 8712,
	    'notin': 8713,
	    'ni': 8715,
	    'prod': 8719,
	    'sum': 8721,
	    'minus': 8722,
	    'lowast': 8727,
	    'radic': 8730,
	    'prop': 8733,
	    'infin': 8734,
	    'ang': 8736,
	    'and': 8743,
	    'or': 8744,
	    'cap': 8745,
	    'cup': 8746,
	    'int': 8747,
	    'there4': 8756,
	    'sim': 8764,
	    'cong': 8773,
	    'asymp': 8776,
	    'ne': 8800,
	    'equiv': 8801,
	    'le': 8804,
	    'ge': 8805,
	    'sub': 8834,
	    'sup': 8835,
	    'nsub': 8836,
	    'sube': 8838,
	    'supe': 8839,
	    'oplus': 8853,
	    'otimes': 8855,
	    'perp': 8869,
	    'sdot': 8901,
	    'lceil': 8968,
	    'rceil': 8969,
	    'lfloor': 8970,
	    'rfloor': 8971,
	    'lang': 9001,
	    'rang': 9002,
	    'loz': 9674,
	    'spades': 9824,
	    'clubs': 9827,
	    'hearts': 9829,
	    'diams': 9830
	  }

	  Object.keys(sax.ENTITIES).forEach(function (key) {
	    var e = sax.ENTITIES[key]
	    var s = typeof e === 'number' ? String.fromCharCode(e) : e
	    sax.ENTITIES[key] = s
	  })

	  for (var s in sax.STATE) {
	    sax.STATE[sax.STATE[s]] = s
	  }

	  // shorthand
	  S = sax.STATE

	  function emit (parser, event, data) {
	    parser[event] && parser[event](data)
	  }

	  function emitNode (parser, nodeType, data) {
	    if (parser.textNode) closeText(parser)
	    emit(parser, nodeType, data)
	  }

	  function closeText (parser) {
	    parser.textNode = textopts(parser.opt, parser.textNode)
	    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
	    parser.textNode = ''
	  }

	  function textopts (opt, text) {
	    if (opt.trim) text = text.trim()
	    if (opt.normalize) text = text.replace(/\s+/g, ' ')
	    return text
	  }

	  function error (parser, er) {
	    closeText(parser)
	    if (parser.trackPosition) {
	      er += '\nLine: ' + parser.line +
	        '\nColumn: ' + parser.column +
	        '\nChar: ' + parser.c
	    }
	    er = new Error(er)
	    parser.error = er
	    emit(parser, 'onerror', er)
	    return parser
	  }

	  function end (parser) {
	    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
	    if ((parser.state !== S.BEGIN) &&
	      (parser.state !== S.BEGIN_WHITESPACE) &&
	      (parser.state !== S.TEXT)) {
	      error(parser, 'Unexpected end')
	    }
	    closeText(parser)
	    parser.c = ''
	    parser.closed = true
	    emit(parser, 'onend')
	    SAXParser.call(parser, parser.strict, parser.opt)
	    return parser
	  }

	  function strictFail (parser, message) {
	    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
	      throw new Error('bad call to strictFail')
	    }
	    if (parser.strict) {
	      error(parser, message)
	    }
	  }

	  function newTag (parser) {
	    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
	    var parent = parser.tags[parser.tags.length - 1] || parser
	    var tag = parser.tag = { name: parser.tagName, attributes: {} }

	    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
	    if (parser.opt.xmlns) {
	      tag.ns = parent.ns
	    }
	    parser.attribList.length = 0
	    emitNode(parser, 'onopentagstart', tag)
	  }

	  function qname (name, attribute) {
	    var i = name.indexOf(':')
	    var qualName = i < 0 ? [ '', name ] : name.split(':')
	    var prefix = qualName[0]
	    var local = qualName[1]

	    // <x "xmlns"="http://foo">
	    if (attribute && name === 'xmlns') {
	      prefix = 'xmlns'
	      local = ''
	    }

	    return { prefix: prefix, local: local }
	  }

	  function attrib (parser) {
	    if (!parser.strict) {
	      parser.attribName = parser.attribName[parser.looseCase]()
	    }

	    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
	      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
	      parser.attribName = parser.attribValue = ''
	      return
	    }

	    if (parser.opt.xmlns) {
	      var qn = qname(parser.attribName, true)
	      var prefix = qn.prefix
	      var local = qn.local

	      if (prefix === 'xmlns') {
	        // namespace binding attribute. push the binding into scope
	        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
	          strictFail(parser,
	            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
	          strictFail(parser,
	            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
	            'Actual: ' + parser.attribValue)
	        } else {
	          var tag = parser.tag
	          var parent = parser.tags[parser.tags.length - 1] || parser
	          if (tag.ns === parent.ns) {
	            tag.ns = Object.create(parent.ns)
	          }
	          tag.ns[local] = parser.attribValue
	        }
	      }

	      // defer onattribute events until all attributes have been seen
	      // so any new bindings can take effect. preserve attribute order
	      // so deferred events can be emitted in document order
	      parser.attribList.push([parser.attribName, parser.attribValue])
	    } else {
	      // in non-xmlns mode, we can emit the event right away
	      parser.tag.attributes[parser.attribName] = parser.attribValue
	      emitNode(parser, 'onattribute', {
	        name: parser.attribName,
	        value: parser.attribValue
	      })
	    }

	    parser.attribName = parser.attribValue = ''
	  }

	  function openTag (parser, selfClosing) {
	    if (parser.opt.xmlns) {
	      // emit namespace binding events
	      var tag = parser.tag

	      // add namespace info to tag
	      var qn = qname(parser.tagName)
	      tag.prefix = qn.prefix
	      tag.local = qn.local
	      tag.uri = tag.ns[qn.prefix] || ''

	      if (tag.prefix && !tag.uri) {
	        strictFail(parser, 'Unbound namespace prefix: ' +
	          JSON.stringify(parser.tagName))
	        tag.uri = qn.prefix
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (tag.ns && parent.ns !== tag.ns) {
	        Object.keys(tag.ns).forEach(function (p) {
	          emitNode(parser, 'onopennamespace', {
	            prefix: p,
	            uri: tag.ns[p]
	          })
	        })
	      }

	      // handle deferred onattribute events
	      // Note: do not apply default ns to attributes:
	      //   http://www.w3.org/TR/REC-xml-names/#defaulting
	      for (var i = 0, l = parser.attribList.length; i < l; i++) {
	        var nv = parser.attribList[i]
	        var name = nv[0]
	        var value = nv[1]
	        var qualName = qname(name, true)
	        var prefix = qualName.prefix
	        var local = qualName.local
	        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
	        var a = {
	          name: name,
	          value: value,
	          prefix: prefix,
	          local: local,
	          uri: uri
	        }

	        // if there's any attributes with an undefined namespace,
	        // then fail on them now.
	        if (prefix && prefix !== 'xmlns' && !uri) {
	          strictFail(parser, 'Unbound namespace prefix: ' +
	            JSON.stringify(prefix))
	          a.uri = prefix
	        }
	        parser.tag.attributes[name] = a
	        emitNode(parser, 'onattribute', a)
	      }
	      parser.attribList.length = 0
	    }

	    parser.tag.isSelfClosing = !!selfClosing

	    // process the tag
	    parser.sawRoot = true
	    parser.tags.push(parser.tag)
	    emitNode(parser, 'onopentag', parser.tag)
	    if (!selfClosing) {
	      // special case for <script> in non-strict mode.
	      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
	        parser.state = S.SCRIPT
	      } else {
	        parser.state = S.TEXT
	      }
	      parser.tag = null
	      parser.tagName = ''
	    }
	    parser.attribName = parser.attribValue = ''
	    parser.attribList.length = 0
	  }

	  function closeTag (parser) {
	    if (!parser.tagName) {
	      strictFail(parser, 'Weird empty close tag.')
	      parser.textNode += '</>'
	      parser.state = S.TEXT
	      return
	    }

	    if (parser.script) {
	      if (parser.tagName !== 'script') {
	        parser.script += '</' + parser.tagName + '>'
	        parser.tagName = ''
	        parser.state = S.SCRIPT
	        return
	      }
	      emitNode(parser, 'onscript', parser.script)
	      parser.script = ''
	    }

	    // first make sure that the closing tag actually exists.
	    // <a><b></c></b></a> will close everything, otherwise.
	    var t = parser.tags.length
	    var tagName = parser.tagName
	    if (!parser.strict) {
	      tagName = tagName[parser.looseCase]()
	    }
	    var closeTo = tagName
	    while (t--) {
	      var close = parser.tags[t]
	      if (close.name !== closeTo) {
	        // fail the first time in strict mode
	        strictFail(parser, 'Unexpected close tag')
	      } else {
	        break
	      }
	    }

	    // didn't find it.  we already failed for strict, so just abort.
	    if (t < 0) {
	      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
	      parser.textNode += '</' + parser.tagName + '>'
	      parser.state = S.TEXT
	      return
	    }
	    parser.tagName = tagName
	    var s = parser.tags.length
	    while (s-- > t) {
	      var tag = parser.tag = parser.tags.pop()
	      parser.tagName = parser.tag.name
	      emitNode(parser, 'onclosetag', parser.tagName)

	      var x = {}
	      for (var i in tag.ns) {
	        x[i] = tag.ns[i]
	      }

	      var parent = parser.tags[parser.tags.length - 1] || parser
	      if (parser.opt.xmlns && tag.ns !== parent.ns) {
	        // remove namespace bindings introduced by tag
	        Object.keys(tag.ns).forEach(function (p) {
	          var n = tag.ns[p]
	          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
	        })
	      }
	    }
	    if (t === 0) parser.closedRoot = true
	    parser.tagName = parser.attribValue = parser.attribName = ''
	    parser.attribList.length = 0
	    parser.state = S.TEXT
	  }

	  function parseEntity (parser) {
	    var entity = parser.entity
	    var entityLC = entity.toLowerCase()
	    var num
	    var numStr = ''

	    if (parser.ENTITIES[entity]) {
	      return parser.ENTITIES[entity]
	    }
	    if (parser.ENTITIES[entityLC]) {
	      return parser.ENTITIES[entityLC]
	    }
	    entity = entityLC
	    if (entity.charAt(0) === '#') {
	      if (entity.charAt(1) === 'x') {
	        entity = entity.slice(2)
	        num = parseInt(entity, 16)
	        numStr = num.toString(16)
	      } else {
	        entity = entity.slice(1)
	        num = parseInt(entity, 10)
	        numStr = num.toString(10)
	      }
	    }
	    entity = entity.replace(/^0+/, '')
	    if (numStr.toLowerCase() !== entity) {
	      strictFail(parser, 'Invalid character entity')
	      return '&' + parser.entity + ';'
	    }

	    return String.fromCodePoint(num)
	  }

	  function beginWhiteSpace (parser, c) {
	    if (c === '<') {
	      parser.state = S.OPEN_WAKA
	      parser.startTagPosition = parser.position
	    } else if (not(whitespace, c)) {
	      // have to process this as a text node.
	      // weird, but happens.
	      strictFail(parser, 'Non-whitespace before first tag.')
	      parser.textNode = c
	      parser.state = S.TEXT
	    }
	  }

	  function charAt (chunk, i) {
	    var result = ''
	    if (i < chunk.length) {
	      result = chunk.charAt(i)
	    }
	    return result
	  }

	  function write (chunk) {
	    var parser = this
	    if (this.error) {
	      throw this.error
	    }
	    if (parser.closed) {
	      return error(parser,
	        'Cannot write after close. Assign an onready handler.')
	    }
	    if (chunk === null) {
	      return end(parser)
	    }
	    if (typeof chunk === 'object') {
	      chunk = chunk.toString()
	    }
	    var i = 0
	    var c = ''
	    while (true) {
	      c = charAt(chunk, i++)
	      parser.c = c

	      if (!c) {
	        break
	      }

	      if (parser.trackPosition) {
	        parser.position++
	        if (c === '\n') {
	          parser.line++
	          parser.column = 0
	        } else {
	          parser.column++
	        }
	      }

	      switch (parser.state) {
	        case S.BEGIN:
	          parser.state = S.BEGIN_WHITESPACE
	          if (c === '\uFEFF') {
	            continue
	          }
	          beginWhiteSpace(parser, c)
	          continue

	        case S.BEGIN_WHITESPACE:
	          beginWhiteSpace(parser, c)
	          continue

	        case S.TEXT:
	          if (parser.sawRoot && !parser.closedRoot) {
	            var starti = i - 1
	            while (c && c !== '<' && c !== '&') {
	              c = charAt(chunk, i++)
	              if (c && parser.trackPosition) {
	                parser.position++
	                if (c === '\n') {
	                  parser.line++
	                  parser.column = 0
	                } else {
	                  parser.column++
	                }
	              }
	            }
	            parser.textNode += chunk.substring(starti, i - 1)
	          }
	          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
	            parser.state = S.OPEN_WAKA
	            parser.startTagPosition = parser.position
	          } else {
	            if (not(whitespace, c) && (!parser.sawRoot || parser.closedRoot)) {
	              strictFail(parser, 'Text data outside of root node.')
	            }
	            if (c === '&') {
	              parser.state = S.TEXT_ENTITY
	            } else {
	              parser.textNode += c
	            }
	          }
	          continue

	        case S.SCRIPT:
	          // only non-strict
	          if (c === '<') {
	            parser.state = S.SCRIPT_ENDING
	          } else {
	            parser.script += c
	          }
	          continue

	        case S.SCRIPT_ENDING:
	          if (c === '/') {
	            parser.state = S.CLOSE_TAG
	          } else {
	            parser.script += '<' + c
	            parser.state = S.SCRIPT
	          }
	          continue

	        case S.OPEN_WAKA:
	          // either a /, ?, !, or text is coming next.
	          if (c === '!') {
	            parser.state = S.SGML_DECL
	            parser.sgmlDecl = ''
	          } else if (is(whitespace, c)) {
	            // wait for it...
	          } else if (isMatch(nameStart, c)) {
	            parser.state = S.OPEN_TAG
	            parser.tagName = c
	          } else if (c === '/') {
	            parser.state = S.CLOSE_TAG
	            parser.tagName = ''
	          } else if (c === '?') {
	            parser.state = S.PROC_INST
	            parser.procInstName = parser.procInstBody = ''
	          } else {
	            strictFail(parser, 'Unencoded <')
	            // if there was some whitespace, then add that in.
	            if (parser.startTagPosition + 1 < parser.position) {
	              var pad = parser.position - parser.startTagPosition
	              c = new Array(pad).join(' ') + c
	            }
	            parser.textNode += '<' + c
	            parser.state = S.TEXT
	          }
	          continue

	        case S.SGML_DECL:
	          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
	            emitNode(parser, 'onopencdata')
	            parser.state = S.CDATA
	            parser.sgmlDecl = ''
	            parser.cdata = ''
	          } else if (parser.sgmlDecl + c === '--') {
	            parser.state = S.COMMENT
	            parser.comment = ''
	            parser.sgmlDecl = ''
	          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
	            parser.state = S.DOCTYPE
	            if (parser.doctype || parser.sawRoot) {
	              strictFail(parser,
	                'Inappropriately located doctype declaration')
	            }
	            parser.doctype = ''
	            parser.sgmlDecl = ''
	          } else if (c === '>') {
	            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
	            parser.sgmlDecl = ''
	            parser.state = S.TEXT
	          } else if (is(quote, c)) {
	            parser.state = S.SGML_DECL_QUOTED
	            parser.sgmlDecl += c
	          } else {
	            parser.sgmlDecl += c
	          }
	          continue

	        case S.SGML_DECL_QUOTED:
	          if (c === parser.q) {
	            parser.state = S.SGML_DECL
	            parser.q = ''
	          }
	          parser.sgmlDecl += c
	          continue

	        case S.DOCTYPE:
	          if (c === '>') {
	            parser.state = S.TEXT
	            emitNode(parser, 'ondoctype', parser.doctype)
	            parser.doctype = true // just remember that we saw it.
	          } else {
	            parser.doctype += c
	            if (c === '[') {
	              parser.state = S.DOCTYPE_DTD
	            } else if (is(quote, c)) {
	              parser.state = S.DOCTYPE_QUOTED
	              parser.q = c
	            }
	          }
	          continue

	        case S.DOCTYPE_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.q = ''
	            parser.state = S.DOCTYPE
	          }
	          continue

	        case S.DOCTYPE_DTD:
	          parser.doctype += c
	          if (c === ']') {
	            parser.state = S.DOCTYPE
	          } else if (is(quote, c)) {
	            parser.state = S.DOCTYPE_DTD_QUOTED
	            parser.q = c
	          }
	          continue

	        case S.DOCTYPE_DTD_QUOTED:
	          parser.doctype += c
	          if (c === parser.q) {
	            parser.state = S.DOCTYPE_DTD
	            parser.q = ''
	          }
	          continue

	        case S.COMMENT:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDING
	          } else {
	            parser.comment += c
	          }
	          continue

	        case S.COMMENT_ENDING:
	          if (c === '-') {
	            parser.state = S.COMMENT_ENDED
	            parser.comment = textopts(parser.opt, parser.comment)
	            if (parser.comment) {
	              emitNode(parser, 'oncomment', parser.comment)
	            }
	            parser.comment = ''
	          } else {
	            parser.comment += '-' + c
	            parser.state = S.COMMENT
	          }
	          continue

	        case S.COMMENT_ENDED:
	          if (c !== '>') {
	            strictFail(parser, 'Malformed comment')
	            // allow <!-- blah -- bloo --> in non-strict mode,
	            // which is a comment of " blah -- bloo "
	            parser.comment += '--' + c
	            parser.state = S.COMMENT
	          } else {
	            parser.state = S.TEXT
	          }
	          continue

	        case S.CDATA:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING
	          } else {
	            parser.cdata += c
	          }
	          continue

	        case S.CDATA_ENDING:
	          if (c === ']') {
	            parser.state = S.CDATA_ENDING_2
	          } else {
	            parser.cdata += ']' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.CDATA_ENDING_2:
	          if (c === '>') {
	            if (parser.cdata) {
	              emitNode(parser, 'oncdata', parser.cdata)
	            }
	            emitNode(parser, 'onclosecdata')
	            parser.cdata = ''
	            parser.state = S.TEXT
	          } else if (c === ']') {
	            parser.cdata += ']'
	          } else {
	            parser.cdata += ']]' + c
	            parser.state = S.CDATA
	          }
	          continue

	        case S.PROC_INST:
	          if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else if (is(whitespace, c)) {
	            parser.state = S.PROC_INST_BODY
	          } else {
	            parser.procInstName += c
	          }
	          continue

	        case S.PROC_INST_BODY:
	          if (!parser.procInstBody && is(whitespace, c)) {
	            continue
	          } else if (c === '?') {
	            parser.state = S.PROC_INST_ENDING
	          } else {
	            parser.procInstBody += c
	          }
	          continue

	        case S.PROC_INST_ENDING:
	          if (c === '>') {
	            emitNode(parser, 'onprocessinginstruction', {
	              name: parser.procInstName,
	              body: parser.procInstBody
	            })
	            parser.procInstName = parser.procInstBody = ''
	            parser.state = S.TEXT
	          } else {
	            parser.procInstBody += '?' + c
	            parser.state = S.PROC_INST_BODY
	          }
	          continue

	        case S.OPEN_TAG:
	          if (isMatch(nameBody, c)) {
	            parser.tagName += c
	          } else {
	            newTag(parser)
	            if (c === '>') {
	              openTag(parser)
	            } else if (c === '/') {
	              parser.state = S.OPEN_TAG_SLASH
	            } else {
	              if (not(whitespace, c)) {
	                strictFail(parser, 'Invalid character in tag name')
	              }
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.OPEN_TAG_SLASH:
	          if (c === '>') {
	            openTag(parser, true)
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Forward-slash in opening tag not followed by >')
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.ATTRIB:
	          // haven't read the attribute name yet.
	          if (is(whitespace, c)) {
	            continue
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (isMatch(nameStart, c)) {
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (c === '>') {
	            strictFail(parser, 'Attribute without value')
	            parser.attribValue = parser.attribName
	            attrib(parser)
	            openTag(parser)
	          } else if (is(whitespace, c)) {
	            parser.state = S.ATTRIB_NAME_SAW_WHITE
	          } else if (isMatch(nameBody, c)) {
	            parser.attribName += c
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_NAME_SAW_WHITE:
	          if (c === '=') {
	            parser.state = S.ATTRIB_VALUE
	          } else if (is(whitespace, c)) {
	            continue
	          } else {
	            strictFail(parser, 'Attribute without value')
	            parser.tag.attributes[parser.attribName] = ''
	            parser.attribValue = ''
	            emitNode(parser, 'onattribute', {
	              name: parser.attribName,
	              value: ''
	            })
	            parser.attribName = ''
	            if (c === '>') {
	              openTag(parser)
	            } else if (isMatch(nameStart, c)) {
	              parser.attribName = c
	              parser.state = S.ATTRIB_NAME
	            } else {
	              strictFail(parser, 'Invalid attribute name')
	              parser.state = S.ATTRIB
	            }
	          }
	          continue

	        case S.ATTRIB_VALUE:
	          if (is(whitespace, c)) {
	            continue
	          } else if (is(quote, c)) {
	            parser.q = c
	            parser.state = S.ATTRIB_VALUE_QUOTED
	          } else {
	            strictFail(parser, 'Unquoted attribute value')
	            parser.state = S.ATTRIB_VALUE_UNQUOTED
	            parser.attribValue = c
	          }
	          continue

	        case S.ATTRIB_VALUE_QUOTED:
	          if (c !== parser.q) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_Q
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          parser.q = ''
	          parser.state = S.ATTRIB_VALUE_CLOSED
	          continue

	        case S.ATTRIB_VALUE_CLOSED:
	          if (is(whitespace, c)) {
	            parser.state = S.ATTRIB
	          } else if (c === '>') {
	            openTag(parser)
	          } else if (c === '/') {
	            parser.state = S.OPEN_TAG_SLASH
	          } else if (isMatch(nameStart, c)) {
	            strictFail(parser, 'No whitespace between attributes')
	            parser.attribName = c
	            parser.attribValue = ''
	            parser.state = S.ATTRIB_NAME
	          } else {
	            strictFail(parser, 'Invalid attribute name')
	          }
	          continue

	        case S.ATTRIB_VALUE_UNQUOTED:
	          if (not(attribEnd, c)) {
	            if (c === '&') {
	              parser.state = S.ATTRIB_VALUE_ENTITY_U
	            } else {
	              parser.attribValue += c
	            }
	            continue
	          }
	          attrib(parser)
	          if (c === '>') {
	            openTag(parser)
	          } else {
	            parser.state = S.ATTRIB
	          }
	          continue

	        case S.CLOSE_TAG:
	          if (!parser.tagName) {
	            if (is(whitespace, c)) {
	              continue
	            } else if (notMatch(nameStart, c)) {
	              if (parser.script) {
	                parser.script += '</' + c
	                parser.state = S.SCRIPT
	              } else {
	                strictFail(parser, 'Invalid tagname in closing tag.')
	              }
	            } else {
	              parser.tagName = c
	            }
	          } else if (c === '>') {
	            closeTag(parser)
	          } else if (isMatch(nameBody, c)) {
	            parser.tagName += c
	          } else if (parser.script) {
	            parser.script += '</' + parser.tagName
	            parser.tagName = ''
	            parser.state = S.SCRIPT
	          } else {
	            if (not(whitespace, c)) {
	              strictFail(parser, 'Invalid tagname in closing tag')
	            }
	            parser.state = S.CLOSE_TAG_SAW_WHITE
	          }
	          continue

	        case S.CLOSE_TAG_SAW_WHITE:
	          if (is(whitespace, c)) {
	            continue
	          }
	          if (c === '>') {
	            closeTag(parser)
	          } else {
	            strictFail(parser, 'Invalid characters in closing tag')
	          }
	          continue

	        case S.TEXT_ENTITY:
	        case S.ATTRIB_VALUE_ENTITY_Q:
	        case S.ATTRIB_VALUE_ENTITY_U:
	          var returnState
	          var buffer
	          switch (parser.state) {
	            case S.TEXT_ENTITY:
	              returnState = S.TEXT
	              buffer = 'textNode'
	              break

	            case S.ATTRIB_VALUE_ENTITY_Q:
	              returnState = S.ATTRIB_VALUE_QUOTED
	              buffer = 'attribValue'
	              break

	            case S.ATTRIB_VALUE_ENTITY_U:
	              returnState = S.ATTRIB_VALUE_UNQUOTED
	              buffer = 'attribValue'
	              break
	          }

	          if (c === ';') {
	            parser[buffer] += parseEntity(parser)
	            parser.entity = ''
	            parser.state = returnState
	          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
	            parser.entity += c
	          } else {
	            strictFail(parser, 'Invalid character in entity name')
	            parser[buffer] += '&' + parser.entity + c
	            parser.entity = ''
	            parser.state = returnState
	          }

	          continue

	        default:
	          throw new Error(parser, 'Unknown state: ' + parser.state)
	      }
	    } // while

	    if (parser.position >= parser.bufferCheckPosition) {
	      checkBufferLength(parser)
	    }
	    return parser
	  }

	  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
	  /* istanbul ignore next */
	  if (!String.fromCodePoint) {
	    (function () {
	      var stringFromCharCode = String.fromCharCode
	      var floor = Math.floor
	      var fromCodePoint = function () {
	        var MAX_SIZE = 0x4000
	        var codeUnits = []
	        var highSurrogate
	        var lowSurrogate
	        var index = -1
	        var length = arguments.length
	        if (!length) {
	          return ''
	        }
	        var result = ''
	        while (++index < length) {
	          var codePoint = Number(arguments[index])
	          if (
	            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
	            codePoint < 0 || // not a valid Unicode code point
	            codePoint > 0x10FFFF || // not a valid Unicode code point
	            floor(codePoint) !== codePoint // not an integer
	          ) {
	            throw RangeError('Invalid code point: ' + codePoint)
	          }
	          if (codePoint <= 0xFFFF) { // BMP code point
	            codeUnits.push(codePoint)
	          } else { // Astral code point; split in surrogate halves
	            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
	            codePoint -= 0x10000
	            highSurrogate = (codePoint >> 10) + 0xD800
	            lowSurrogate = (codePoint % 0x400) + 0xDC00
	            codeUnits.push(highSurrogate, lowSurrogate)
	          }
	          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
	            result += stringFromCharCode.apply(null, codeUnits)
	            codeUnits.length = 0
	          }
	        }
	        return result
	      }
	      /* istanbul ignore next */
	      if (Object.defineProperty) {
	        Object.defineProperty(String, 'fromCodePoint', {
	          value: fromCodePoint,
	          configurable: true,
	          writable: true
	        })
	      } else {
	        String.fromCodePoint = fromCodePoint
	      }
	    }())
	  }
	})( false ? this.sax = {} : exports)

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 277 */
/***/ function(module, exports) {

	/*jshint node:true */

	"use strict";

	var sequence = function (tasks, names, results, nest) {
		var i, name, node, e, j;
		nest = nest || [];
		for (i = 0; i < names.length; i++) {
			name = names[i];
			// de-dup results
			if (results.indexOf(name) === -1) {
				node = tasks[name];
				if (!node) {
					e = new Error('task "'+name+'" is not defined');
					e.missingTask = name;
					e.taskList = [];
					for (j in tasks) {
						if (tasks.hasOwnProperty(j)) {
							e.taskList.push(tasks[j].name);
						}
					}
					throw e;
				}
				if (nest.indexOf(name) > -1) {
					nest.push(name);
					e = new Error('Recursive dependencies detected: '+nest.join(' -> '));
					e.recursiveTasks = nest;
					e.taskList = [];
					for (j in tasks) {
						if (tasks.hasOwnProperty(j)) {
							e.taskList.push(tasks[j].name);
						}
					}
					throw e;
				}
				if (node.dep.length) {
					nest.push(name);
					sequence(tasks, node.dep, results, nest); // recurse
					nest.pop(name);
				}
				results.push(name);
			}
		}
	};

	module.exports = sequence;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
	    "use strict";

	    if (global.setImmediate) {
	        return;
	    }

	    var nextHandle = 1; // Spec says greater than zero
	    var tasksByHandle = {};
	    var currentlyRunningATask = false;
	    var doc = global.document;
	    var registerImmediate;

	    function setImmediate(callback) {
	      // Callback can either be a function or a string
	      if (typeof callback !== "function") {
	        callback = new Function("" + callback);
	      }
	      // Copy function arguments
	      var args = new Array(arguments.length - 1);
	      for (var i = 0; i < args.length; i++) {
	          args[i] = arguments[i + 1];
	      }
	      // Store and register the task
	      var task = { callback: callback, args: args };
	      tasksByHandle[nextHandle] = task;
	      registerImmediate(nextHandle);
	      return nextHandle++;
	    }

	    function clearImmediate(handle) {
	        delete tasksByHandle[handle];
	    }

	    function run(task) {
	        var callback = task.callback;
	        var args = task.args;
	        switch (args.length) {
	        case 0:
	            callback();
	            break;
	        case 1:
	            callback(args[0]);
	            break;
	        case 2:
	            callback(args[0], args[1]);
	            break;
	        case 3:
	            callback(args[0], args[1], args[2]);
	            break;
	        default:
	            callback.apply(undefined, args);
	            break;
	        }
	    }

	    function runIfPresent(handle) {
	        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
	        // So if we're currently running a task, we'll need to delay this invocation.
	        if (currentlyRunningATask) {
	            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
	            // "too much recursion" error.
	            setTimeout(runIfPresent, 0, handle);
	        } else {
	            var task = tasksByHandle[handle];
	            if (task) {
	                currentlyRunningATask = true;
	                try {
	                    run(task);
	                } finally {
	                    clearImmediate(handle);
	                    currentlyRunningATask = false;
	                }
	            }
	        }
	    }

	    function installNextTickImplementation() {
	        registerImmediate = function(handle) {
	            process.nextTick(function () { runIfPresent(handle); });
	        };
	    }

	    function canUsePostMessage() {
	        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
	        // where `global.postMessage` means something completely different and can't be used for this purpose.
	        if (global.postMessage && !global.importScripts) {
	            var postMessageIsAsynchronous = true;
	            var oldOnMessage = global.onmessage;
	            global.onmessage = function() {
	                postMessageIsAsynchronous = false;
	            };
	            global.postMessage("", "*");
	            global.onmessage = oldOnMessage;
	            return postMessageIsAsynchronous;
	        }
	    }

	    function installPostMessageImplementation() {
	        // Installs an event handler on `global` for the `message` event: see
	        // * https://developer.mozilla.org/en/DOM/window.postMessage
	        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

	        var messagePrefix = "setImmediate$" + Math.random() + "$";
	        var onGlobalMessage = function(event) {
	            if (event.source === global &&
	                typeof event.data === "string" &&
	                event.data.indexOf(messagePrefix) === 0) {
	                runIfPresent(+event.data.slice(messagePrefix.length));
	            }
	        };

	        if (global.addEventListener) {
	            global.addEventListener("message", onGlobalMessage, false);
	        } else {
	            global.attachEvent("onmessage", onGlobalMessage);
	        }

	        registerImmediate = function(handle) {
	            global.postMessage(messagePrefix + handle, "*");
	        };
	    }

	    function installMessageChannelImplementation() {
	        var channel = new MessageChannel();
	        channel.port1.onmessage = function(event) {
	            var handle = event.data;
	            runIfPresent(handle);
	        };

	        registerImmediate = function(handle) {
	            channel.port2.postMessage(handle);
	        };
	    }

	    function installReadyStateChangeImplementation() {
	        var html = doc.documentElement;
	        registerImmediate = function(handle) {
	            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
	            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
	            var script = doc.createElement("script");
	            script.onreadystatechange = function () {
	                runIfPresent(handle);
	                script.onreadystatechange = null;
	                html.removeChild(script);
	                script = null;
	            };
	            html.appendChild(script);
	        };
	    }

	    function installSetTimeoutImplementation() {
	        registerImmediate = function(handle) {
	            setTimeout(runIfPresent, 0, handle);
	        };
	    }

	    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
	    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
	    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

	    // Don't get fooled by e.g. browserify environments.
	    if ({}.toString.call(global.process) === "[object process]") {
	        // For Node.js before 0.9
	        installNextTickImplementation();

	    } else if (canUsePostMessage()) {
	        // For non-IE10 modern browsers
	        installPostMessageImplementation();

	    } else if (global.MessageChannel) {
	        // For web workers, where supported
	        installMessageChannelImplementation();

	    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
	        // For IE 6–8
	        installReadyStateChangeImplementation();

	    } else {
	        // For older browsers
	        installSetTimeoutImplementation();
	    }

	    attachTo.setImmediate = setImmediate;
	    attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(1)))

/***/ },
/* 279 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	exports.encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	exports.decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};


/***/ },
/* 280 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	exports.GREATEST_LOWER_BOUND = 1;
	exports.LEAST_UPPER_BOUND = 2;

	/**
	 * Recursive implementation of binary search.
	 *
	 * @param aLow Indices here and lower do not contain the needle.
	 * @param aHigh Indices here and higher do not contain the needle.
	 * @param aNeedle The element being searched for.
	 * @param aHaystack The non-empty array being searched.
	 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 */
	function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
	  // This function terminates when one of the following is true:
	  //
	  //   1. We find the exact element we are looking for.
	  //
	  //   2. We did not find the exact element, but we can return the index of
	  //      the next-closest element.
	  //
	  //   3. We did not find the exact element, and there is no next-closest
	  //      element than the one we are searching for, so we return -1.
	  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
	  var cmp = aCompare(aNeedle, aHaystack[mid], true);
	  if (cmp === 0) {
	    // Found the element we are looking for.
	    return mid;
	  }
	  else if (cmp > 0) {
	    // Our needle is greater than aHaystack[mid].
	    if (aHigh - mid > 1) {
	      // The element is in the upper half.
	      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // The exact needle element was not found in this haystack. Determine if
	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return aHigh < aHaystack.length ? aHigh : -1;
	    } else {
	      return mid;
	    }
	  }
	  else {
	    // Our needle is less than aHaystack[mid].
	    if (mid - aLow > 1) {
	      // The element is in the lower half.
	      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
	    }

	    // we are in termination case (3) or (2) and return the appropriate thing.
	    if (aBias == exports.LEAST_UPPER_BOUND) {
	      return mid;
	    } else {
	      return aLow < 0 ? -1 : aLow;
	    }
	  }
	}

	/**
	 * This is an implementation of binary search which will always try and return
	 * the index of the closest element if there is no exact hit. This is because
	 * mappings between original and generated line/col pairs are single points,
	 * and there is an implicit region between each of them, so a miss just means
	 * that you aren't on the very start of a region.
	 *
	 * @param aNeedle The element you are looking for.
	 * @param aHaystack The array that is being searched.
	 * @param aCompare A function which takes the needle and an element in the
	 *     array and returns -1, 0, or 1 depending on whether the needle is less
	 *     than, equal to, or greater than the element, respectively.
	 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
	 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
	 */
	exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
	  if (aHaystack.length === 0) {
	    return -1;
	  }

	  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
	                              aCompare, aBias || exports.GREATEST_LOWER_BOUND);
	  if (index < 0) {
	    return -1;
	  }

	  // We have found either the exact element, or the next-closest element than
	  // the one we are searching for. However, there may be more than one such
	  // element. Make sure we always return the smallest of these.
	  while (index - 1 >= 0) {
	    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
	      break;
	    }
	    --index;
	  }

	  return index;
	};


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = __webpack_require__(28);

	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	exports.MappingList = MappingList;


/***/ },
/* 282 */
/***/ function(module, exports) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	// It turns out that some (most?) JavaScript engines don't self-host
	// `Array.prototype.sort`. This makes sense because C++ will likely remain
	// faster than JS when doing raw CPU-intensive sorting. However, when using a
	// custom comparator function, calling back and forth between the VM's C++ and
	// JIT'd JS is rather slow *and* loses JIT type information, resulting in
	// worse generated code for the comparator function than would be optimal. In
	// fact, when sorting with a comparator, these costs outweigh the benefits of
	// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
	// a ~3500ms mean speed-up in `bench/bench.html`.

	/**
	 * Swap the elements indexed by `x` and `y` in the array `ary`.
	 *
	 * @param {Array} ary
	 *        The array.
	 * @param {Number} x
	 *        The index of the first item.
	 * @param {Number} y
	 *        The index of the second item.
	 */
	function swap(ary, x, y) {
	  var temp = ary[x];
	  ary[x] = ary[y];
	  ary[y] = temp;
	}

	/**
	 * Returns a random integer within the range `low .. high` inclusive.
	 *
	 * @param {Number} low
	 *        The lower bound on the range.
	 * @param {Number} high
	 *        The upper bound on the range.
	 */
	function randomIntInRange(low, high) {
	  return Math.round(low + (Math.random() * (high - low)));
	}

	/**
	 * The Quick Sort algorithm.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 * @param {Number} p
	 *        Start index of the array
	 * @param {Number} r
	 *        End index of the array
	 */
	function doQuickSort(ary, comparator, p, r) {
	  // If our lower bound is less than our upper bound, we (1) partition the
	  // array into two pieces and (2) recurse on each half. If it is not, this is
	  // the empty array and our base case.

	  if (p < r) {
	    // (1) Partitioning.
	    //
	    // The partitioning chooses a pivot between `p` and `r` and moves all
	    // elements that are less than or equal to the pivot to the before it, and
	    // all the elements that are greater than it after it. The effect is that
	    // once partition is done, the pivot is in the exact place it will be when
	    // the array is put in sorted order, and it will not need to be moved
	    // again. This runs in O(n) time.

	    // Always choose a random pivot so that an input array which is reverse
	    // sorted does not cause O(n^2) running time.
	    var pivotIndex = randomIntInRange(p, r);
	    var i = p - 1;

	    swap(ary, pivotIndex, r);
	    var pivot = ary[r];

	    // Immediately after `j` is incremented in this loop, the following hold
	    // true:
	    //
	    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
	    //
	    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
	    for (var j = p; j < r; j++) {
	      if (comparator(ary[j], pivot) <= 0) {
	        i += 1;
	        swap(ary, i, j);
	      }
	    }

	    swap(ary, i + 1, j);
	    var q = i + 1;

	    // (2) Recurse on each half.

	    doQuickSort(ary, comparator, p, q - 1);
	    doQuickSort(ary, comparator, q + 1, r);
	  }
	}

	/**
	 * Sort the given array in-place with the given comparator function.
	 *
	 * @param {Array} ary
	 *        An array to sort.
	 * @param {function} comparator
	 *        Function to use to compare two items.
	 */
	exports.quickSort = function (ary, comparator) {
	  doQuickSort(ary, comparator, 0, ary.length - 1);
	};


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var util = __webpack_require__(28);
	var binarySearch = __webpack_require__(280);
	var ArraySet = __webpack_require__(73).ArraySet;
	var base64VLQ = __webpack_require__(74);
	var quickSort = __webpack_require__(282).quickSort;

	function SourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  return sourceMap.sections != null
	    ? new IndexedSourceMapConsumer(sourceMap)
	    : new BasicSourceMapConsumer(sourceMap);
	}

	SourceMapConsumer.fromSourceMap = function(aSourceMap) {
	  return BasicSourceMapConsumer.fromSourceMap(aSourceMap);
	}

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	SourceMapConsumer.prototype._version = 3;

	// `__generatedMappings` and `__originalMappings` are arrays that hold the
	// parsed mapping coordinates from the source map's "mappings" attribute. They
	// are lazily instantiated, accessed via the `_generatedMappings` and
	// `_originalMappings` getters respectively, and we only parse the mappings
	// and create these arrays once queried for a source location. We jump through
	// these hoops because there can be many thousands of mappings, and parsing
	// them is expensive, so we only want to do it if we must.
	//
	// Each object in the arrays is of the form:
	//
	//     {
	//       generatedLine: The line number in the generated code,
	//       generatedColumn: The column number in the generated code,
	//       source: The path to the original source file that generated this
	//               chunk of code,
	//       originalLine: The line number in the original source that
	//                     corresponds to this chunk of generated code,
	//       originalColumn: The column number in the original source that
	//                       corresponds to this chunk of generated code,
	//       name: The name of the original symbol which generated this chunk of
	//             code.
	//     }
	//
	// All properties except for `generatedLine` and `generatedColumn` can be
	// `null`.
	//
	// `_generatedMappings` is ordered by the generated positions.
	//
	// `_originalMappings` is ordered by the original positions.

	SourceMapConsumer.prototype.__generatedMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
	  get: function () {
	    if (!this.__generatedMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__generatedMappings;
	  }
	});

	SourceMapConsumer.prototype.__originalMappings = null;
	Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
	  get: function () {
	    if (!this.__originalMappings) {
	      this._parseMappings(this._mappings, this.sourceRoot);
	    }

	    return this.__originalMappings;
	  }
	});

	SourceMapConsumer.prototype._charIsMappingSeparator =
	  function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
	    var c = aStr.charAt(index);
	    return c === ";" || c === ",";
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	SourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    throw new Error("Subclasses must implement _parseMappings");
	  };

	SourceMapConsumer.GENERATED_ORDER = 1;
	SourceMapConsumer.ORIGINAL_ORDER = 2;

	SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
	SourceMapConsumer.LEAST_UPPER_BOUND = 2;

	/**
	 * Iterate over each mapping between an original source/line/column and a
	 * generated line/column in this source map.
	 *
	 * @param Function aCallback
	 *        The function that is called with each mapping.
	 * @param Object aContext
	 *        Optional. If specified, this object will be the value of `this` every
	 *        time that `aCallback` is called.
	 * @param aOrder
	 *        Either `SourceMapConsumer.GENERATED_ORDER` or
	 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
	 *        iterate over the mappings sorted by the generated file's line/column
	 *        order or the original's source/line/column order, respectively. Defaults to
	 *        `SourceMapConsumer.GENERATED_ORDER`.
	 */
	SourceMapConsumer.prototype.eachMapping =
	  function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
	    var context = aContext || null;
	    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;

	    var mappings;
	    switch (order) {
	    case SourceMapConsumer.GENERATED_ORDER:
	      mappings = this._generatedMappings;
	      break;
	    case SourceMapConsumer.ORIGINAL_ORDER:
	      mappings = this._originalMappings;
	      break;
	    default:
	      throw new Error("Unknown order of iteration.");
	    }

	    var sourceRoot = this.sourceRoot;
	    mappings.map(function (mapping) {
	      var source = mapping.source === null ? null : this._sources.at(mapping.source);
	      if (source != null && sourceRoot != null) {
	        source = util.join(sourceRoot, source);
	      }
	      return {
	        source: source,
	        generatedLine: mapping.generatedLine,
	        generatedColumn: mapping.generatedColumn,
	        originalLine: mapping.originalLine,
	        originalColumn: mapping.originalColumn,
	        name: mapping.name === null ? null : this._names.at(mapping.name)
	      };
	    }, this).forEach(aCallback, context);
	  };

	/**
	 * Returns all generated line and column information for the original source,
	 * line, and column provided. If no column is provided, returns all mappings
	 * corresponding to a either the line we are searching for or the next
	 * closest line that has any mappings. Otherwise, returns all mappings
	 * corresponding to the given line and either the column we are searching for
	 * or the next closest column that has any offsets.
	 *
	 * The only argument is an object with the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: Optional. the column number in the original source.
	 *
	 * and an array of objects is returned, each with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	SourceMapConsumer.prototype.allGeneratedPositionsFor =
	  function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
	    var line = util.getArg(aArgs, 'line');

	    // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
	    // returns the index of the closest mapping less than the needle. By
	    // setting needle.originalColumn to 0, we thus find the last mapping for
	    // the given line, provided such a mapping exists.
	    var needle = {
	      source: util.getArg(aArgs, 'source'),
	      originalLine: line,
	      originalColumn: util.getArg(aArgs, 'column', 0)
	    };

	    if (this.sourceRoot != null) {
	      needle.source = util.relative(this.sourceRoot, needle.source);
	    }
	    if (!this._sources.has(needle.source)) {
	      return [];
	    }
	    needle.source = this._sources.indexOf(needle.source);

	    var mappings = [];

	    var index = this._findMapping(needle,
	                                  this._originalMappings,
	                                  "originalLine",
	                                  "originalColumn",
	                                  util.compareByOriginalPositions,
	                                  binarySearch.LEAST_UPPER_BOUND);
	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (aArgs.column === undefined) {
	        var originalLine = mapping.originalLine;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we found. Since
	        // mappings are sorted, this is guaranteed to find all mappings for
	        // the line we found.
	        while (mapping && mapping.originalLine === originalLine) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      } else {
	        var originalColumn = mapping.originalColumn;

	        // Iterate until either we run out of mappings, or we run into
	        // a mapping for a different line than the one we were searching for.
	        // Since mappings are sorted, this is guaranteed to find all mappings for
	        // the line we are searching for.
	        while (mapping &&
	               mapping.originalLine === line &&
	               mapping.originalColumn == originalColumn) {
	          mappings.push({
	            line: util.getArg(mapping, 'generatedLine', null),
	            column: util.getArg(mapping, 'generatedColumn', null),
	            lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	          });

	          mapping = this._originalMappings[++index];
	        }
	      }
	    }

	    return mappings;
	  };

	exports.SourceMapConsumer = SourceMapConsumer;

	/**
	 * A BasicSourceMapConsumer instance represents a parsed source map which we can
	 * query for information about the original file positions by giving it a file
	 * position in the generated source.
	 *
	 * The only parameter is the raw source map (either as a JSON string, or
	 * already parsed to an object). According to the spec, source maps have the
	 * following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - sources: An array of URLs to the original source files.
	 *   - names: An array of identifiers which can be referrenced by individual mappings.
	 *   - sourceRoot: Optional. The URL root from which all sources are relative.
	 *   - sourcesContent: Optional. An array of contents of the original source files.
	 *   - mappings: A string of base64 VLQs which contain the actual mappings.
	 *   - file: Optional. The generated file this source map is associated with.
	 *
	 * Here is an example source map, taken from the source map spec[0]:
	 *
	 *     {
	 *       version : 3,
	 *       file: "out.js",
	 *       sourceRoot : "",
	 *       sources: ["foo.js", "bar.js"],
	 *       names: ["src", "maps", "are", "fun"],
	 *       mappings: "AA,AB;;ABCDE;"
	 *     }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
	 */
	function BasicSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sources = util.getArg(sourceMap, 'sources');
	  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
	  // requires the array) to play nice here.
	  var names = util.getArg(sourceMap, 'names', []);
	  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
	  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
	  var mappings = util.getArg(sourceMap, 'mappings');
	  var file = util.getArg(sourceMap, 'file', null);

	  // Once again, Sass deviates from the spec and supplies the version as a
	  // string rather than a number, so we use loose equality checking here.
	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  sources = sources
	    .map(String)
	    // Some source maps produce relative source paths like "./foo.js" instead of
	    // "foo.js".  Normalize these first so that future comparisons will succeed.
	    // See bugzil.la/1090768.
	    .map(util.normalize)
	    // Always ensure that absolute sources are internally stored relative to
	    // the source root, if the source root is absolute. Not doing this would
	    // be particularly problematic when the source root is a prefix of the
	    // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
	    .map(function (source) {
	      return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
	        ? util.relative(sourceRoot, source)
	        : source;
	    });

	  // Pass `true` below to allow duplicate names and sources. While source maps
	  // are intended to be compressed and deduplicated, the TypeScript compiler
	  // sometimes generates source maps with duplicates in them. See Github issue
	  // #72 and bugzil.la/889492.
	  this._names = ArraySet.fromArray(names.map(String), true);
	  this._sources = ArraySet.fromArray(sources, true);

	  this.sourceRoot = sourceRoot;
	  this.sourcesContent = sourcesContent;
	  this._mappings = mappings;
	  this.file = file;
	}

	BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;

	/**
	 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
	 *
	 * @param SourceMapGenerator aSourceMap
	 *        The source map that will be consumed.
	 * @returns BasicSourceMapConsumer
	 */
	BasicSourceMapConsumer.fromSourceMap =
	  function SourceMapConsumer_fromSourceMap(aSourceMap) {
	    var smc = Object.create(BasicSourceMapConsumer.prototype);

	    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
	    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
	    smc.sourceRoot = aSourceMap._sourceRoot;
	    smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
	                                                            smc.sourceRoot);
	    smc.file = aSourceMap._file;

	    // Because we are modifying the entries (by converting string sources and
	    // names to indices into the sources and names ArraySets), we have to make
	    // a copy of the entry or else bad things happen. Shared mutable state
	    // strikes again! See github issue #191.

	    var generatedMappings = aSourceMap._mappings.toArray().slice();
	    var destGeneratedMappings = smc.__generatedMappings = [];
	    var destOriginalMappings = smc.__originalMappings = [];

	    for (var i = 0, length = generatedMappings.length; i < length; i++) {
	      var srcMapping = generatedMappings[i];
	      var destMapping = new Mapping;
	      destMapping.generatedLine = srcMapping.generatedLine;
	      destMapping.generatedColumn = srcMapping.generatedColumn;

	      if (srcMapping.source) {
	        destMapping.source = sources.indexOf(srcMapping.source);
	        destMapping.originalLine = srcMapping.originalLine;
	        destMapping.originalColumn = srcMapping.originalColumn;

	        if (srcMapping.name) {
	          destMapping.name = names.indexOf(srcMapping.name);
	        }

	        destOriginalMappings.push(destMapping);
	      }

	      destGeneratedMappings.push(destMapping);
	    }

	    quickSort(smc.__originalMappings, util.compareByOriginalPositions);

	    return smc;
	  };

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	BasicSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    return this._sources.toArray().map(function (s) {
	      return this.sourceRoot != null ? util.join(this.sourceRoot, s) : s;
	    }, this);
	  }
	});

	/**
	 * Provide the JIT with a nice shape / hidden class.
	 */
	function Mapping() {
	  this.generatedLine = 0;
	  this.generatedColumn = 0;
	  this.source = null;
	  this.originalLine = null;
	  this.originalColumn = null;
	  this.name = null;
	}

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	BasicSourceMapConsumer.prototype._parseMappings =
	  function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    var generatedLine = 1;
	    var previousGeneratedColumn = 0;
	    var previousOriginalLine = 0;
	    var previousOriginalColumn = 0;
	    var previousSource = 0;
	    var previousName = 0;
	    var length = aStr.length;
	    var index = 0;
	    var cachedSegments = {};
	    var temp = {};
	    var originalMappings = [];
	    var generatedMappings = [];
	    var mapping, str, segment, end, value;

	    while (index < length) {
	      if (aStr.charAt(index) === ';') {
	        generatedLine++;
	        index++;
	        previousGeneratedColumn = 0;
	      }
	      else if (aStr.charAt(index) === ',') {
	        index++;
	      }
	      else {
	        mapping = new Mapping();
	        mapping.generatedLine = generatedLine;

	        // Because each offset is encoded relative to the previous one,
	        // many segments often have the same encoding. We can exploit this
	        // fact by caching the parsed variable length fields of each segment,
	        // allowing us to avoid a second parse if we encounter the same
	        // segment again.
	        for (end = index; end < length; end++) {
	          if (this._charIsMappingSeparator(aStr, end)) {
	            break;
	          }
	        }
	        str = aStr.slice(index, end);

	        segment = cachedSegments[str];
	        if (segment) {
	          index += str.length;
	        } else {
	          segment = [];
	          while (index < end) {
	            base64VLQ.decode(aStr, index, temp);
	            value = temp.value;
	            index = temp.rest;
	            segment.push(value);
	          }

	          if (segment.length === 2) {
	            throw new Error('Found a source, but no line and column');
	          }

	          if (segment.length === 3) {
	            throw new Error('Found a source and line, but no column');
	          }

	          cachedSegments[str] = segment;
	        }

	        // Generated column.
	        mapping.generatedColumn = previousGeneratedColumn + segment[0];
	        previousGeneratedColumn = mapping.generatedColumn;

	        if (segment.length > 1) {
	          // Original source.
	          mapping.source = previousSource + segment[1];
	          previousSource += segment[1];

	          // Original line.
	          mapping.originalLine = previousOriginalLine + segment[2];
	          previousOriginalLine = mapping.originalLine;
	          // Lines are stored 0-based
	          mapping.originalLine += 1;

	          // Original column.
	          mapping.originalColumn = previousOriginalColumn + segment[3];
	          previousOriginalColumn = mapping.originalColumn;

	          if (segment.length > 4) {
	            // Original name.
	            mapping.name = previousName + segment[4];
	            previousName += segment[4];
	          }
	        }

	        generatedMappings.push(mapping);
	        if (typeof mapping.originalLine === 'number') {
	          originalMappings.push(mapping);
	        }
	      }
	    }

	    quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
	    this.__generatedMappings = generatedMappings;

	    quickSort(originalMappings, util.compareByOriginalPositions);
	    this.__originalMappings = originalMappings;
	  };

	/**
	 * Find the mapping that best matches the hypothetical "needle" mapping that
	 * we are searching for in the given "haystack" of mappings.
	 */
	BasicSourceMapConsumer.prototype._findMapping =
	  function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
	                                         aColumnName, aComparator, aBias) {
	    // To return the position we are searching for, we must first find the
	    // mapping for the given position and then return the opposite position it
	    // points to. Because the mappings are sorted, we can use binary search to
	    // find the best mapping.

	    if (aNeedle[aLineName] <= 0) {
	      throw new TypeError('Line must be greater than or equal to 1, got '
	                          + aNeedle[aLineName]);
	    }
	    if (aNeedle[aColumnName] < 0) {
	      throw new TypeError('Column must be greater than or equal to 0, got '
	                          + aNeedle[aColumnName]);
	    }

	    return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
	  };

	/**
	 * Compute the last column for each generated mapping. The last column is
	 * inclusive.
	 */
	BasicSourceMapConsumer.prototype.computeColumnSpans =
	  function SourceMapConsumer_computeColumnSpans() {
	    for (var index = 0; index < this._generatedMappings.length; ++index) {
	      var mapping = this._generatedMappings[index];

	      // Mappings do not contain a field for the last generated columnt. We
	      // can come up with an optimistic estimate, however, by assuming that
	      // mappings are contiguous (i.e. given two consecutive mappings, the
	      // first mapping ends where the second one starts).
	      if (index + 1 < this._generatedMappings.length) {
	        var nextMapping = this._generatedMappings[index + 1];

	        if (mapping.generatedLine === nextMapping.generatedLine) {
	          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
	          continue;
	        }
	      }

	      // The last mapping for each line spans the entire line.
	      mapping.lastGeneratedColumn = Infinity;
	    }
	  };

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	BasicSourceMapConsumer.prototype.originalPositionFor =
	  function SourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._generatedMappings,
	      "generatedLine",
	      "generatedColumn",
	      util.compareByGeneratedPositionsDeflated,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._generatedMappings[index];

	      if (mapping.generatedLine === needle.generatedLine) {
	        var source = util.getArg(mapping, 'source', null);
	        if (source !== null) {
	          source = this._sources.at(source);
	          if (this.sourceRoot != null) {
	            source = util.join(this.sourceRoot, source);
	          }
	        }
	        var name = util.getArg(mapping, 'name', null);
	        if (name !== null) {
	          name = this._names.at(name);
	        }
	        return {
	          source: source,
	          line: util.getArg(mapping, 'originalLine', null),
	          column: util.getArg(mapping, 'originalColumn', null),
	          name: name
	        };
	      }
	    }

	    return {
	      source: null,
	      line: null,
	      column: null,
	      name: null
	    };
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function BasicSourceMapConsumer_hasContentsOfAllSources() {
	    if (!this.sourcesContent) {
	      return false;
	    }
	    return this.sourcesContent.length >= this._sources.size() &&
	      !this.sourcesContent.some(function (sc) { return sc == null; });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	BasicSourceMapConsumer.prototype.sourceContentFor =
	  function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    if (!this.sourcesContent) {
	      return null;
	    }

	    if (this.sourceRoot != null) {
	      aSource = util.relative(this.sourceRoot, aSource);
	    }

	    if (this._sources.has(aSource)) {
	      return this.sourcesContent[this._sources.indexOf(aSource)];
	    }

	    var url;
	    if (this.sourceRoot != null
	        && (url = util.urlParse(this.sourceRoot))) {
	      // XXX: file:// URIs and absolute paths lead to unexpected behavior for
	      // many users. We can help them out when they expect file:// URIs to
	      // behave like it would if they were running a local HTTP server. See
	      // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
	      var fileUriAbsPath = aSource.replace(/^file:\/\//, "");
	      if (url.scheme == "file"
	          && this._sources.has(fileUriAbsPath)) {
	        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
	      }

	      if ((!url.path || url.path == "/")
	          && this._sources.has("/" + aSource)) {
	        return this.sourcesContent[this._sources.indexOf("/" + aSource)];
	      }
	    }

	    // This function is used recursively from
	    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
	    // don't want to throw if we can't find the source - we just want to
	    // return null, so we provide a flag to exit gracefully.
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
	 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
	 *     closest element that is smaller than or greater than the one we are
	 *     searching for, respectively, if the exact element cannot be found.
	 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	BasicSourceMapConsumer.prototype.generatedPositionFor =
	  function SourceMapConsumer_generatedPositionFor(aArgs) {
	    var source = util.getArg(aArgs, 'source');
	    if (this.sourceRoot != null) {
	      source = util.relative(this.sourceRoot, source);
	    }
	    if (!this._sources.has(source)) {
	      return {
	        line: null,
	        column: null,
	        lastColumn: null
	      };
	    }
	    source = this._sources.indexOf(source);

	    var needle = {
	      source: source,
	      originalLine: util.getArg(aArgs, 'line'),
	      originalColumn: util.getArg(aArgs, 'column')
	    };

	    var index = this._findMapping(
	      needle,
	      this._originalMappings,
	      "originalLine",
	      "originalColumn",
	      util.compareByOriginalPositions,
	      util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
	    );

	    if (index >= 0) {
	      var mapping = this._originalMappings[index];

	      if (mapping.source === needle.source) {
	        return {
	          line: util.getArg(mapping, 'generatedLine', null),
	          column: util.getArg(mapping, 'generatedColumn', null),
	          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
	        };
	      }
	    }

	    return {
	      line: null,
	      column: null,
	      lastColumn: null
	    };
	  };

	exports.BasicSourceMapConsumer = BasicSourceMapConsumer;

	/**
	 * An IndexedSourceMapConsumer instance represents a parsed source map which
	 * we can query for information. It differs from BasicSourceMapConsumer in
	 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
	 * input.
	 *
	 * The only parameter is a raw source map (either as a JSON string, or already
	 * parsed to an object). According to the spec for indexed source maps, they
	 * have the following attributes:
	 *
	 *   - version: Which version of the source map spec this map is following.
	 *   - file: Optional. The generated file this source map is associated with.
	 *   - sections: A list of section definitions.
	 *
	 * Each value under the "sections" field has two fields:
	 *   - offset: The offset into the original specified at which this section
	 *       begins to apply, defined as an object with a "line" and "column"
	 *       field.
	 *   - map: A source map definition. This source map could also be indexed,
	 *       but doesn't have to be.
	 *
	 * Instead of the "map" field, it's also possible to have a "url" field
	 * specifying a URL to retrieve a source map from, but that's currently
	 * unsupported.
	 *
	 * Here's an example source map, taken from the source map spec[0], but
	 * modified to omit a section which uses the "url" field.
	 *
	 *  {
	 *    version : 3,
	 *    file: "app.js",
	 *    sections: [{
	 *      offset: {line:100, column:10},
	 *      map: {
	 *        version : 3,
	 *        file: "section.js",
	 *        sources: ["foo.js", "bar.js"],
	 *        names: ["src", "maps", "are", "fun"],
	 *        mappings: "AAAA,E;;ABCDE;"
	 *      }
	 *    }],
	 *  }
	 *
	 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
	 */
	function IndexedSourceMapConsumer(aSourceMap) {
	  var sourceMap = aSourceMap;
	  if (typeof aSourceMap === 'string') {
	    sourceMap = JSON.parse(aSourceMap.replace(/^\)\]\}'/, ''));
	  }

	  var version = util.getArg(sourceMap, 'version');
	  var sections = util.getArg(sourceMap, 'sections');

	  if (version != this._version) {
	    throw new Error('Unsupported version: ' + version);
	  }

	  this._sources = new ArraySet();
	  this._names = new ArraySet();

	  var lastOffset = {
	    line: -1,
	    column: 0
	  };
	  this._sections = sections.map(function (s) {
	    if (s.url) {
	      // The url field will require support for asynchronicity.
	      // See https://github.com/mozilla/source-map/issues/16
	      throw new Error('Support for url field in sections not implemented.');
	    }
	    var offset = util.getArg(s, 'offset');
	    var offsetLine = util.getArg(offset, 'line');
	    var offsetColumn = util.getArg(offset, 'column');

	    if (offsetLine < lastOffset.line ||
	        (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
	      throw new Error('Section offsets must be ordered and non-overlapping.');
	    }
	    lastOffset = offset;

	    return {
	      generatedOffset: {
	        // The offset fields are 0-based, but we use 1-based indices when
	        // encoding/decoding from VLQ.
	        generatedLine: offsetLine + 1,
	        generatedColumn: offsetColumn + 1
	      },
	      consumer: new SourceMapConsumer(util.getArg(s, 'map'))
	    }
	  });
	}

	IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
	IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;

	/**
	 * The version of the source mapping spec that we are consuming.
	 */
	IndexedSourceMapConsumer.prototype._version = 3;

	/**
	 * The list of original sources.
	 */
	Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
	  get: function () {
	    var sources = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
	        sources.push(this._sections[i].consumer.sources[j]);
	      }
	    }
	    return sources;
	  }
	});

	/**
	 * Returns the original source, line, and column information for the generated
	 * source's line and column positions provided. The only argument is an object
	 * with the following properties:
	 *
	 *   - line: The line number in the generated source.
	 *   - column: The column number in the generated source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - source: The original source file, or null.
	 *   - line: The line number in the original source, or null.
	 *   - column: The column number in the original source, or null.
	 *   - name: The original identifier, or null.
	 */
	IndexedSourceMapConsumer.prototype.originalPositionFor =
	  function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
	    var needle = {
	      generatedLine: util.getArg(aArgs, 'line'),
	      generatedColumn: util.getArg(aArgs, 'column')
	    };

	    // Find the section containing the generated position we're trying to map
	    // to an original position.
	    var sectionIndex = binarySearch.search(needle, this._sections,
	      function(needle, section) {
	        var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
	        if (cmp) {
	          return cmp;
	        }

	        return (needle.generatedColumn -
	                section.generatedOffset.generatedColumn);
	      });
	    var section = this._sections[sectionIndex];

	    if (!section) {
	      return {
	        source: null,
	        line: null,
	        column: null,
	        name: null
	      };
	    }

	    return section.consumer.originalPositionFor({
	      line: needle.generatedLine -
	        (section.generatedOffset.generatedLine - 1),
	      column: needle.generatedColumn -
	        (section.generatedOffset.generatedLine === needle.generatedLine
	         ? section.generatedOffset.generatedColumn - 1
	         : 0),
	      bias: aArgs.bias
	    });
	  };

	/**
	 * Return true if we have the source content for every source in the source
	 * map, false otherwise.
	 */
	IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
	  function IndexedSourceMapConsumer_hasContentsOfAllSources() {
	    return this._sections.every(function (s) {
	      return s.consumer.hasContentsOfAllSources();
	    });
	  };

	/**
	 * Returns the original source content. The only argument is the url of the
	 * original source file. Returns null if no original source content is
	 * available.
	 */
	IndexedSourceMapConsumer.prototype.sourceContentFor =
	  function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      var content = section.consumer.sourceContentFor(aSource, true);
	      if (content) {
	        return content;
	      }
	    }
	    if (nullOnMissing) {
	      return null;
	    }
	    else {
	      throw new Error('"' + aSource + '" is not in the SourceMap.');
	    }
	  };

	/**
	 * Returns the generated line and column information for the original source,
	 * line, and column positions provided. The only argument is an object with
	 * the following properties:
	 *
	 *   - source: The filename of the original source.
	 *   - line: The line number in the original source.
	 *   - column: The column number in the original source.
	 *
	 * and an object is returned with the following properties:
	 *
	 *   - line: The line number in the generated source, or null.
	 *   - column: The column number in the generated source, or null.
	 */
	IndexedSourceMapConsumer.prototype.generatedPositionFor =
	  function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];

	      // Only consider this section if the requested source is in the list of
	      // sources of the consumer.
	      if (section.consumer.sources.indexOf(util.getArg(aArgs, 'source')) === -1) {
	        continue;
	      }
	      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
	      if (generatedPosition) {
	        var ret = {
	          line: generatedPosition.line +
	            (section.generatedOffset.generatedLine - 1),
	          column: generatedPosition.column +
	            (section.generatedOffset.generatedLine === generatedPosition.line
	             ? section.generatedOffset.generatedColumn - 1
	             : 0)
	        };
	        return ret;
	      }
	    }

	    return {
	      line: null,
	      column: null
	    };
	  };

	/**
	 * Parse the mappings in a string in to a data structure which we can easily
	 * query (the ordered arrays in the `this.__generatedMappings` and
	 * `this.__originalMappings` properties).
	 */
	IndexedSourceMapConsumer.prototype._parseMappings =
	  function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
	    this.__generatedMappings = [];
	    this.__originalMappings = [];
	    for (var i = 0; i < this._sections.length; i++) {
	      var section = this._sections[i];
	      var sectionMappings = section.consumer._generatedMappings;
	      for (var j = 0; j < sectionMappings.length; j++) {
	        var mapping = sectionMappings[j];

	        var source = section.consumer._sources.at(mapping.source);
	        if (section.consumer.sourceRoot !== null) {
	          source = util.join(section.consumer.sourceRoot, source);
	        }
	        this._sources.add(source);
	        source = this._sources.indexOf(source);

	        var name = section.consumer._names.at(mapping.name);
	        this._names.add(name);
	        name = this._names.indexOf(name);

	        // The mappings coming from the consumer for the section have
	        // generated positions relative to the start of the section, so we
	        // need to offset them to be relative to the start of the concatenated
	        // generated file.
	        var adjustedMapping = {
	          source: source,
	          generatedLine: mapping.generatedLine +
	            (section.generatedOffset.generatedLine - 1),
	          generatedColumn: mapping.generatedColumn +
	            (section.generatedOffset.generatedLine === mapping.generatedLine
	            ? section.generatedOffset.generatedColumn - 1
	            : 0),
	          originalLine: mapping.originalLine,
	          originalColumn: mapping.originalColumn,
	          name: name
	        };

	        this.__generatedMappings.push(adjustedMapping);
	        if (typeof adjustedMapping.originalLine === 'number') {
	          this.__originalMappings.push(adjustedMapping);
	        }
	      }
	    }

	    quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
	    quickSort(this.__originalMappings, util.compareByOriginalPositions);
	  };

	exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;


/***/ },
/* 284 */
/***/ function(module, exports, __webpack_require__) {

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var SourceMapGenerator = __webpack_require__(75).SourceMapGenerator;
	var util = __webpack_require__(28);

	// Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
	// operating systems these days (capturing the result).
	var REGEX_NEWLINE = /(\r?\n)/;

	// Newline character code for charCodeAt() comparisons
	var NEWLINE_CODE = 10;

	// Private symbol for identifying `SourceNode`s when multiple versions of
	// the source-map library are loaded. This MUST NOT CHANGE across
	// versions!
	var isSourceNode = "$$$isSourceNode$$$";

	/**
	 * SourceNodes provide a way to abstract over interpolating/concatenating
	 * snippets of generated JavaScript source code while maintaining the line and
	 * column information associated with the original source code.
	 *
	 * @param aLine The original line number.
	 * @param aColumn The original column number.
	 * @param aSource The original source's filename.
	 * @param aChunks Optional. An array of strings which are snippets of
	 *        generated JS, or other SourceNodes.
	 * @param aName The original identifier.
	 */
	function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
	  this.children = [];
	  this.sourceContents = {};
	  this.line = aLine == null ? null : aLine;
	  this.column = aColumn == null ? null : aColumn;
	  this.source = aSource == null ? null : aSource;
	  this.name = aName == null ? null : aName;
	  this[isSourceNode] = true;
	  if (aChunks != null) this.add(aChunks);
	}

	/**
	 * Creates a SourceNode from generated code and a SourceMapConsumer.
	 *
	 * @param aGeneratedCode The generated code
	 * @param aSourceMapConsumer The SourceMap for the generated code
	 * @param aRelativePath Optional. The path that relative sources in the
	 *        SourceMapConsumer should be relative to.
	 */
	SourceNode.fromStringWithSourceMap =
	  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
	    // The SourceNode we want to fill with the generated code
	    // and the SourceMap
	    var node = new SourceNode();

	    // All even indices of this array are one line of the generated code,
	    // while all odd indices are the newlines between two adjacent lines
	    // (since `REGEX_NEWLINE` captures its match).
	    // Processed fragments are removed from this array, by calling `shiftNextLine`.
	    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
	    var shiftNextLine = function() {
	      var lineContents = remainingLines.shift();
	      // The last line of a file might not have a newline.
	      var newLine = remainingLines.shift() || "";
	      return lineContents + newLine;
	    };

	    // We need to remember the position of "remainingLines"
	    var lastGeneratedLine = 1, lastGeneratedColumn = 0;

	    // The generate SourceNodes we need a code range.
	    // To extract it current and last mapping is used.
	    // Here we store the last mapping.
	    var lastMapping = null;

	    aSourceMapConsumer.eachMapping(function (mapping) {
	      if (lastMapping !== null) {
	        // We add the code from "lastMapping" to "mapping":
	        // First check if there is a new line in between.
	        if (lastGeneratedLine < mapping.generatedLine) {
	          // Associate first line with "lastMapping"
	          addMappingWithCode(lastMapping, shiftNextLine());
	          lastGeneratedLine++;
	          lastGeneratedColumn = 0;
	          // The remaining code is added without mapping
	        } else {
	          // There is no new line in between.
	          // Associate the code between "lastGeneratedColumn" and
	          // "mapping.generatedColumn" with "lastMapping"
	          var nextLine = remainingLines[0];
	          var code = nextLine.substr(0, mapping.generatedColumn -
	                                        lastGeneratedColumn);
	          remainingLines[0] = nextLine.substr(mapping.generatedColumn -
	                                              lastGeneratedColumn);
	          lastGeneratedColumn = mapping.generatedColumn;
	          addMappingWithCode(lastMapping, code);
	          // No more remaining code, continue
	          lastMapping = mapping;
	          return;
	        }
	      }
	      // We add the generated code until the first mapping
	      // to the SourceNode without any mapping.
	      // Each line is added as separate string.
	      while (lastGeneratedLine < mapping.generatedLine) {
	        node.add(shiftNextLine());
	        lastGeneratedLine++;
	      }
	      if (lastGeneratedColumn < mapping.generatedColumn) {
	        var nextLine = remainingLines[0];
	        node.add(nextLine.substr(0, mapping.generatedColumn));
	        remainingLines[0] = nextLine.substr(mapping.generatedColumn);
	        lastGeneratedColumn = mapping.generatedColumn;
	      }
	      lastMapping = mapping;
	    }, this);
	    // We have processed all mappings.
	    if (remainingLines.length > 0) {
	      if (lastMapping) {
	        // Associate the remaining code in the current line with "lastMapping"
	        addMappingWithCode(lastMapping, shiftNextLine());
	      }
	      // and add the remaining lines without any mapping
	      node.add(remainingLines.join(""));
	    }

	    // Copy sourcesContent into SourceNode
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aRelativePath != null) {
	          sourceFile = util.join(aRelativePath, sourceFile);
	        }
	        node.setSourceContent(sourceFile, content);
	      }
	    });

	    return node;

	    function addMappingWithCode(mapping, code) {
	      if (mapping === null || mapping.source === undefined) {
	        node.add(code);
	      } else {
	        var source = aRelativePath
	          ? util.join(aRelativePath, mapping.source)
	          : mapping.source;
	        node.add(new SourceNode(mapping.originalLine,
	                                mapping.originalColumn,
	                                source,
	                                code,
	                                mapping.name));
	      }
	    }
	  };

	/**
	 * Add a chunk of generated JS to this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.add = function SourceNode_add(aChunk) {
	  if (Array.isArray(aChunk)) {
	    aChunk.forEach(function (chunk) {
	      this.add(chunk);
	    }, this);
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    if (aChunk) {
	      this.children.push(aChunk);
	    }
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Add a chunk of generated JS to the beginning of this source node.
	 *
	 * @param aChunk A string snippet of generated JS code, another instance of
	 *        SourceNode, or an array where each member is one of those things.
	 */
	SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
	  if (Array.isArray(aChunk)) {
	    for (var i = aChunk.length-1; i >= 0; i--) {
	      this.prepend(aChunk[i]);
	    }
	  }
	  else if (aChunk[isSourceNode] || typeof aChunk === "string") {
	    this.children.unshift(aChunk);
	  }
	  else {
	    throw new TypeError(
	      "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
	    );
	  }
	  return this;
	};

	/**
	 * Walk over the tree of JS snippets in this node and its children. The
	 * walking function is called once for each snippet of JS and is passed that
	 * snippet and the its original associated source's line/column location.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walk = function SourceNode_walk(aFn) {
	  var chunk;
	  for (var i = 0, len = this.children.length; i < len; i++) {
	    chunk = this.children[i];
	    if (chunk[isSourceNode]) {
	      chunk.walk(aFn);
	    }
	    else {
	      if (chunk !== '') {
	        aFn(chunk, { source: this.source,
	                     line: this.line,
	                     column: this.column,
	                     name: this.name });
	      }
	    }
	  }
	};

	/**
	 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
	 * each of `this.children`.
	 *
	 * @param aSep The separator.
	 */
	SourceNode.prototype.join = function SourceNode_join(aSep) {
	  var newChildren;
	  var i;
	  var len = this.children.length;
	  if (len > 0) {
	    newChildren = [];
	    for (i = 0; i < len-1; i++) {
	      newChildren.push(this.children[i]);
	      newChildren.push(aSep);
	    }
	    newChildren.push(this.children[i]);
	    this.children = newChildren;
	  }
	  return this;
	};

	/**
	 * Call String.prototype.replace on the very right-most source snippet. Useful
	 * for trimming whitespace from the end of a source node, etc.
	 *
	 * @param aPattern The pattern to replace.
	 * @param aReplacement The thing to replace the pattern with.
	 */
	SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
	  var lastChild = this.children[this.children.length - 1];
	  if (lastChild[isSourceNode]) {
	    lastChild.replaceRight(aPattern, aReplacement);
	  }
	  else if (typeof lastChild === 'string') {
	    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
	  }
	  else {
	    this.children.push(''.replace(aPattern, aReplacement));
	  }
	  return this;
	};

	/**
	 * Set the source content for a source file. This will be added to the SourceMapGenerator
	 * in the sourcesContent field.
	 *
	 * @param aSourceFile The filename of the source file
	 * @param aSourceContent The content of the source file
	 */
	SourceNode.prototype.setSourceContent =
	  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
	    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
	  };

	/**
	 * Walk over the tree of SourceNodes. The walking function is called for each
	 * source file content and is passed the filename and source content.
	 *
	 * @param aFn The traversal function.
	 */
	SourceNode.prototype.walkSourceContents =
	  function SourceNode_walkSourceContents(aFn) {
	    for (var i = 0, len = this.children.length; i < len; i++) {
	      if (this.children[i][isSourceNode]) {
	        this.children[i].walkSourceContents(aFn);
	      }
	    }

	    var sources = Object.keys(this.sourceContents);
	    for (var i = 0, len = sources.length; i < len; i++) {
	      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
	    }
	  };

	/**
	 * Return the string representation of this source node. Walks over the tree
	 * and concatenates all the various snippets together to one string.
	 */
	SourceNode.prototype.toString = function SourceNode_toString() {
	  var str = "";
	  this.walk(function (chunk) {
	    str += chunk;
	  });
	  return str;
	};

	/**
	 * Returns the string representation of this source node along with a source
	 * map.
	 */
	SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
	  var generated = {
	    code: "",
	    line: 1,
	    column: 0
	  };
	  var map = new SourceMapGenerator(aArgs);
	  var sourceMappingActive = false;
	  var lastOriginalSource = null;
	  var lastOriginalLine = null;
	  var lastOriginalColumn = null;
	  var lastOriginalName = null;
	  this.walk(function (chunk, original) {
	    generated.code += chunk;
	    if (original.source !== null
	        && original.line !== null
	        && original.column !== null) {
	      if(lastOriginalSource !== original.source
	         || lastOriginalLine !== original.line
	         || lastOriginalColumn !== original.column
	         || lastOriginalName !== original.name) {
	        map.addMapping({
	          source: original.source,
	          original: {
	            line: original.line,
	            column: original.column
	          },
	          generated: {
	            line: generated.line,
	            column: generated.column
	          },
	          name: original.name
	        });
	      }
	      lastOriginalSource = original.source;
	      lastOriginalLine = original.line;
	      lastOriginalColumn = original.column;
	      lastOriginalName = original.name;
	      sourceMappingActive = true;
	    } else if (sourceMappingActive) {
	      map.addMapping({
	        generated: {
	          line: generated.line,
	          column: generated.column
	        }
	      });
	      lastOriginalSource = null;
	      sourceMappingActive = false;
	    }
	    for (var idx = 0, length = chunk.length; idx < length; idx++) {
	      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
	        generated.line++;
	        generated.column = 0;
	        // Mappings end at eol
	        if (idx + 1 === length) {
	          lastOriginalSource = null;
	          sourceMappingActive = false;
	        } else if (sourceMappingActive) {
	          map.addMapping({
	            source: original.source,
	            original: {
	              line: original.line,
	              column: original.column
	            },
	            generated: {
	              line: generated.line,
	              column: generated.column
	            },
	            name: original.name
	          });
	        }
	      } else {
	        generated.column++;
	      }
	    }
	  });
	  this.walkSourceContents(function (sourceFile, sourceContent) {
	    map.setSourceContent(sourceFile, sourceContent);
	  });

	  return { code: generated.code, map: map };
	};

	exports.SourceNode = SourceNode;


/***/ },
/* 285 */
/***/ function(module, exports) {

	module.exports = function(stream) {
	    if (stream.readable && typeof stream.resume === 'function') {
	        var state = stream._readableState;
	        if (!state || state.pipesCount === 0) {
	            // Either a classic stream or streams2 that's not piped to another destination
	            try {
	                stream.resume();
	            } catch (err) {
	                console.error("Got error: " + err);
	                // If we can't, it's not worth dying over
	            }
	        }
	    }
	};


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ansiRegex = __webpack_require__(287)();

	module.exports = function (str) {
		return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
	};


/***/ },
/* 287 */
/***/ function(module, exports) {

	'use strict';
	module.exports = function () {
		return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-PRZcf-nqry=><]/g;
	};


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * SVGO is a Nodejs-based tool for optimizing SVG vector graphics files.
	 *
	 * @see https://github.com/svg/svgo
	 *
	 * @author Kir Belevich <kir@soulshine.in> (https://github.com/deepsweet)
	 * @copyright © 2012 Kir Belevich
	 * @license MIT https://raw.githubusercontent.com/svg/svgo/master/LICENSE
	 */

	var CONFIG = __webpack_require__(289),
	    SVG2JS = __webpack_require__(292),
	    PLUGINS = __webpack_require__(291),
	    JSAPI = __webpack_require__(79),
	    JS2SVG = __webpack_require__(290);

	var SVGO = module.exports = function(config) {

	    this.config = CONFIG(config);

	};

	SVGO.prototype.optimize = function(svgstr, callback) {
	    if (this.config.error) return callback(this.config);

	    var _this = this,
	        config = this.config,
	        maxPassCount = config.multipass ? 10 : 1,
	        counter = 0,
	        prevResultSize = Number.POSITIVE_INFINITY,
	        optimizeOnceCallback = function(svgjs) {

	            if (svgjs.error) {
	                callback(svgjs);
	                return;
	            }

	            if (++counter < maxPassCount && svgjs.data.length < prevResultSize) {
	                prevResultSize = svgjs.data.length;
	                _this._optimizeOnce(svgjs.data, optimizeOnceCallback);
	            } else {
	                callback(svgjs);
	            }

	        };

	    _this._optimizeOnce(svgstr, optimizeOnceCallback);

	};

	SVGO.prototype._optimizeOnce = function(svgstr, callback) {
	    var config = this.config;

	    SVG2JS(svgstr, function(svgjs) {

	        if (svgjs.error) {
	            callback(svgjs);
	            return;
	        }

	        svgjs = PLUGINS(svgjs, config.plugins);

	        callback(JS2SVG(svgjs, config.js2svg));

	    });
	};

	/**
	 * The factory that creates a content item with the helper methods.
	 *
	 * @param {Object} data which passed to jsAPI constructor
	 * @returns {JSAPI} content item
	 */
	SVGO.prototype.createContentItem = function(data) {

	    return new JSAPI(data);

	};


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__dirname) {'use strict';

	var FS = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var yaml = __webpack_require__(228);

	var EXTEND = __webpack_require__(24);

	/**
	 * Read and/or extend/replace default config file,
	 * prepare and optimize plugins array.
	 *
	 * @param {Object} [config] input config
	 * @return {Object} output config
	 */
	module.exports = function(config) {

	    var defaults;
	    config = typeof config == 'object' && config || {};

	    if (config.plugins && !Array.isArray(config.plugins)) {
	        return { error: 'Error: Invalid plugins list. Provided \'plugins\' in config should be an array.' };
	    }

	    if (config.full) {
	        defaults = config;

	        if (Array.isArray(defaults.plugins)) {
	            defaults.plugins = preparePluginsArray(defaults.plugins);
	        }
	    } else {
	        defaults = EXTEND({}, yaml.safeLoad(FS.readFileSync(__dirname + '/../../.svgo.yml', 'utf8')));
	        defaults.plugins = preparePluginsArray(defaults.plugins);
	        defaults = extendConfig(defaults, config);
	    }

	    if ('floatPrecision' in config && Array.isArray(defaults.plugins)) {
	        defaults.plugins.forEach(function(plugin) {
	            if (plugin.params && ('floatPrecision' in plugin.params)) {
	                // Don't touch default plugin params
	                plugin.params = EXTEND({}, plugin.params, { floatPrecision: config.floatPrecision });
	            }
	        });
	    }

	    if (Array.isArray(defaults.plugins)) {
	        defaults.plugins = optimizePluginsArray(defaults.plugins);
	    }

	    return defaults;

	};

	/**
	 * Require() all plugins in array.
	 *
	 * @param {Array} plugins input plugins array
	 * @return {Array} input plugins array of arrays
	 */
	function preparePluginsArray(plugins) {

	    var plugin,
	        key;

	    return plugins.map(function(item) {

	        // {}
	        if (typeof item === 'object') {

	            key = Object.keys(item)[0];

	            // custom
	            if (typeof item[key] === 'object' && item[key].fn && typeof item[key].fn === 'function') {
	                plugin = setupCustomPlugin(key, item[key]);

	            } else {

	              plugin = EXTEND({}, __webpack_require__(80)("./" + key));

	              // name: {}
	              if (typeof item[key] === 'object') {
	                  plugin.params = EXTEND({}, plugin.params || {}, item[key]);
	                  plugin.active = true;

	              // name: false
	              } else if (item[key] === false) {
	                 plugin.active = false;

	              // name: true
	              } else if (item[key] === true) {
	                 plugin.active = true;
	              }

	              plugin.name = key;
	            }

	        // name
	        } else {

	            plugin = EXTEND({}, __webpack_require__(80)("./" + item));
	            plugin.name = item;

	        }

	        return plugin;

	    });

	}

	/**
	 * Extend plugins with the custom config object.
	 *
	 * @param {Array} plugins input plugins
	 * @param {Object} config config
	 * @return {Array} output plugins
	 */
	function extendConfig(defaults, config) {

	    var key;

	    // plugins
	    if (config.plugins) {

	        config.plugins.forEach(function(item) {

	            // {}
	            if (typeof item === 'object') {

	                key = Object.keys(item)[0];

	                // custom
	                if (typeof item[key] === 'object' && item[key].fn && typeof item[key].fn === 'function') {
	                    defaults.plugins.push(setupCustomPlugin(key, item[key]));

	                } else {
	                    defaults.plugins.forEach(function(plugin) {

	                        if (plugin.name === key) {
	                            // name: {}
	                            if (typeof item[key] === 'object') {
	                                plugin.params = EXTEND({}, plugin.params || {}, item[key]);
	                                plugin.active = true;

	                            // name: false
	                            } else if (item[key] === false) {
	                               plugin.active = false;

	                            // name: true
	                            } else if (item[key] === true) {
	                               plugin.active = true;
	                            }
	                        }
	                    });
	                }

	            }

	        });

	    }

	    defaults.multipass = config.multipass;

	    // svg2js
	    if (config.svg2js) {
	        defaults.svg2js = config.svg2js;
	    }

	    // js2svg
	    if (config.js2svg) {
	        defaults.js2svg = config.js2svg;
	    }

	    return defaults;

	}

	/**
	 * Setup and enable a custom plugin
	 *
	 * @param {String} plugin name
	 * @param {Object} custom plugin
	 * @return {Array} enabled plugin
	 */
	function setupCustomPlugin(name, plugin) {
	    plugin.active = true;
	    plugin.params = EXTEND({}, plugin.params || {});
	    plugin.name = name;

	    return plugin;
	}

	/**
	 * Try to group sequential elements of plugins array.
	 *
	 * @param {Object} plugins input plugins
	 * @return {Array} output plugins
	 */
	function optimizePluginsArray(plugins) {

	    var prev;

	    return plugins.reduce(function(plugins, item) {
	        if (prev && item.type == prev[0].type) {
	            prev.push(item);
	        } else {
	            plugins.push(prev = [item]);
	        }
	        return plugins;
	    }, []);

	}

	/* WEBPACK VAR INJECTION */}.call(exports, "/"))

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var EXTEND = __webpack_require__(24),
	    textElem = __webpack_require__(4).elemsGroups.textContent.concat('title');

	var defaults = {
	    doctypeStart: '<!DOCTYPE',
	    doctypeEnd: '>',
	    procInstStart: '<?',
	    procInstEnd: '?>',
	    tagOpenStart: '<',
	    tagOpenEnd: '>',
	    tagCloseStart: '</',
	    tagCloseEnd: '>',
	    tagShortStart: '<',
	    tagShortEnd: '/>',
	    attrStart: '="',
	    attrEnd: '"',
	    commentStart: '<!--',
	    commentEnd: '-->',
	    cdataStart: '<![CDATA[',
	    cdataEnd: ']]>',
	    textStart: '',
	    textEnd: '',
	    indent: 4,
	    regEntities: /[&'"<>]/g,
	    regValEntities: /[&"<>]/g,
	    encodeEntity: encodeEntity,
	    pretty: false,
	    useShortTags: true
	};

	var entities = {
	      '&': '&amp;',
	      '\'': '&apos;',
	      '"': '&quot;',
	      '>': '&gt;',
	      '<': '&lt;',
	    };

	/**
	 * Convert SVG-as-JS object to SVG (XML) string.
	 *
	 * @param {Object} data input data
	 * @param {Object} config config
	 *
	 * @return {Object} output data
	 */
	module.exports = function(data, config) {

	    return new JS2SVG(config).convert(data);

	};

	function JS2SVG(config) {

	    if (config) {
	        this.config = EXTEND(true, {}, defaults, config);
	    } else {
	        this.config = defaults;
	    }

	    var indent = this.config.indent;
	    if (typeof indent == 'number' && !isNaN(indent)) {
	        this.config.indent = '';
	        for (var i = indent; i-- > 0;) this.config.indent += ' ';
	    } else if (typeof indent != 'string') {
	        this.config.indent = '    ';
	    }

	    if (this.config.pretty) {
	        this.config.doctypeEnd += '\n';
	        this.config.procInstEnd += '\n';
	        this.config.commentEnd += '\n';
	        this.config.cdataEnd += '\n';
	        this.config.tagShortEnd += '\n';
	        this.config.tagOpenEnd += '\n';
	        this.config.tagCloseEnd += '\n';
	        this.config.textEnd += '\n';
	    }

	    this.indentLevel = 0;
	    this.textContext = null;

	}

	function encodeEntity(char) {
	    return entities[char];
	}

	/**
	 * Start conversion.
	 *
	 * @param {Object} data input data
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.convert = function(data) {

	    var svg = '';

	    if (data.content) {

	        this.indentLevel++;

	        data.content.forEach(function(item) {

	            if (item.elem) {
	               svg += this.createElem(item);
	            } else if (item.text) {
	               svg += this.createText(item.text);
	            } else if (item.doctype) {
	                svg += this.createDoctype(item.doctype);
	            } else if (item.processinginstruction) {
	                svg += this.createProcInst(item.processinginstruction);
	            } else if (item.comment) {
	                svg += this.createComment(item.comment);
	            } else if (item.cdata) {
	                svg += this.createCDATA(item.cdata);
	            }

	        }, this);

	    }

	    this.indentLevel--;

	    return {
	        data: svg,
	        info: {
	            width: this.width,
	            height: this.height
	        }
	    };

	};

	/**
	 * Create indent string in accordance with the current node level.
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createIndent = function() {

	    var indent = '';

	    if (this.config.pretty && !this.textContext) {
	        for (var i = 1; i < this.indentLevel; i++) {
	            indent += this.config.indent;
	        }
	    }

	    return indent;

	};

	/**
	 * Create doctype tag.
	 *
	 * @param {String} doctype doctype body string
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createDoctype = function(doctype) {

	    return  this.config.doctypeStart +
	            doctype +
	            this.config.doctypeEnd;

	};

	/**
	 * Create XML Processing Instruction tag.
	 *
	 * @param {Object} instruction instruction object
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createProcInst = function(instruction) {

	    return  this.config.procInstStart +
	            instruction.name +
	            ' ' +
	            instruction.body +
	            this.config.procInstEnd;

	};

	/**
	 * Create comment tag.
	 *
	 * @param {String} comment comment body
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createComment = function(comment) {

	    return  this.config.commentStart +
	            comment +
	            this.config.commentEnd;

	};

	/**
	 * Create CDATA section.
	 *
	 * @param {String} cdata CDATA body
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createCDATA = function(cdata) {

	    return  this.createIndent() +
	            this.config.cdataStart +
	            cdata +
	            this.config.cdataEnd;

	};

	/**
	 * Create element tag.
	 *
	 * @param {Object} data element object
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createElem = function(data) {

	    // beautiful injection for obtaining SVG information :)
	    if (
	        data.isElem('svg') &&
	        data.hasAttr('width') &&
	        data.hasAttr('height')
	    ) {
	        this.width = data.attr('width').value;
	        this.height = data.attr('height').value;
	    }

	    // empty element and short tag
	    if (data.isEmpty()) {
	        if (this.config.useShortTags) {
	            return this.createIndent() +
	                   this.config.tagShortStart +
	                   data.elem +
	                   this.createAttrs(data) +
	                   this.config.tagShortEnd;
	        } else {
	            return this.createIndent() +
	                   this.config.tagShortStart +
	                   data.elem +
	                   this.createAttrs(data) +
	                   this.config.tagOpenEnd +
	                   this.config.tagCloseStart +
	                   data.elem +
	                   this.config.tagCloseEnd;
	        }
	    // non-empty element
	    } else {
	        var tagOpenStart = this.config.tagOpenStart,
	            tagOpenEnd = this.config.tagOpenEnd,
	            tagCloseStart = this.config.tagCloseStart,
	            tagCloseEnd = this.config.tagCloseEnd,
	            openIndent = this.createIndent(),
	            textIndent = '',
	            processedData = '',
	            dataEnd = '';

	        if (this.textContext) {
	            tagOpenStart = defaults.tagOpenStart;
	            tagOpenEnd = defaults.tagOpenEnd;
	            tagCloseStart = defaults.tagCloseStart;
	            tagCloseEnd = defaults.tagCloseEnd;
	            openIndent = '';
	        } else if (data.isElem(textElem)) {
	            if (this.config.pretty) {
	                textIndent += openIndent + this.config.indent;
	            }
	            this.textContext = data;
	        }

	        processedData += this.convert(data).data;

	        if (this.textContext == data) {
	            this.textContext = null;
	            if (this.config.pretty) dataEnd = '\n';
	        }

	        return  openIndent +
	                tagOpenStart +
	                data.elem +
	                this.createAttrs(data) +
	                tagOpenEnd +
	                textIndent +
	                processedData +
	                dataEnd +
	                this.createIndent() +
	                tagCloseStart +
	                data.elem +
	                tagCloseEnd;

	    }

	};

	/**
	 * Create element attributes.
	 *
	 * @param {Object} elem attributes object
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createAttrs = function(elem) {

	    var attrs = '';

	    elem.eachAttr(function(attr) {

	        attrs +=    ' ' +
	                    attr.name +
	                    this.config.attrStart +
	                    String(attr.value).replace(this.config.regValEntities, this.config.encodeEntity) +
	                    this.config.attrEnd;

	    }, this);

	    return attrs;

	};

	/**
	 * Create text node.
	 *
	 * @param {String} text text
	 *
	 * @return {String}
	 */
	JS2SVG.prototype.createText = function(text) {

	    return  this.createIndent() +
	            this.config.textStart +
	            text.replace(this.config.regEntities, this.config.encodeEntity) +
	            (this.textContext ? '' : this.config.textEnd);

	};


/***/ },
/* 291 */
/***/ function(module, exports) {

	'use strict';

	/**
	 * Plugins engine.
	 *
	 * @module plugins
	 *
	 * @param {Object} data input data
	 * @param {Object} plugins plugins object from config
	 * @return {Object} output data
	 */
	module.exports = function(data, plugins) {

	    plugins.forEach(function(group) {

	        switch(group[0].type) {
	            case 'perItem':
	                data = perItem(data, group);
	                break;
	            case 'perItemReverse':
	                data = perItem(data, group, true);
	                break;
	            case 'full':
	                data = full(data, group);
	                break;
	        }

	    });

	    return data;

	};

	/**
	 * Direct or reverse per-item loop.
	 *
	 * @param {Object} data input data
	 * @param {Array} plugins plugins list to process
	 * @param {Boolean} [reverse] reverse pass?
	 * @return {Object} output data
	 */
	function perItem(data, plugins, reverse) {

	    function monkeys(items) {

	        items.content = items.content.filter(function(item) {

	            // reverse pass
	            if (reverse && item.content) {
	                monkeys(item);
	            }

	            // main filter
	            var filter = true;

	            for (var i = 0; filter && i < plugins.length; i++) {
	                var plugin = plugins[i];

	                if (plugin.active && plugin.fn(item, plugin.params) === false) {
	                    filter = false;
	                }
	            }

	            // direct pass
	            if (!reverse && item.content) {
	                monkeys(item);
	            }

	            return filter;

	        });

	        return items;

	    }

	    return monkeys(data);

	}

	/**
	 * "Full" plugins.
	 *
	 * @param {Object} data input data
	 * @param {Array} plugins plugins list to process
	 * @return {Object} output data
	 */
	function full(data, plugins) {

	    plugins.forEach(function(plugin) {
	        if (plugin.active) {
	            data = plugin.fn(data, plugin.params);
	        }
	    });

	    return data;

	}


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var SAX = __webpack_require__(276),
	    JSAPI = __webpack_require__(79),
	    entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^\']+)'|"([^\"]+)")\s*>/g;

	var config = {
	    strict: true,
	    trim: false,
	    normalize: true,
	    lowercase: true,
	    xmlns: true,
	    position: true
	};

	/**
	 * Convert SVG (XML) string to SVG-as-JS object.
	 *
	 * @param {String} data input data
	 * @param {Function} callback
	 */
	module.exports = function(data, callback) {

	    var sax = SAX.parser(config.strict, config),
	        root = new JSAPI({ elem: '#document' }),
	        current = root,
	        stack = [root],
	        textContext = null,
	        parsingError = false;

	    function pushToContent(content) {

	        content = new JSAPI(content, current);

	        (current.content = current.content || []).push(content);

	        return content;

	    }

	    sax.ondoctype = function(doctype) {

	        pushToContent({
	            doctype: doctype
	        });

	        var subsetStart = doctype.indexOf('['),
	            entityMatch;

	        if (subsetStart >= 0) {
	            entityDeclaration.lastIndex = subsetStart;

	            while ((entityMatch = entityDeclaration.exec(data)) != null) {
	                sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
	            }
	        }
	    };

	    sax.onprocessinginstruction = function(data) {

	        pushToContent({
	            processinginstruction: data
	        });

	    };

	    sax.oncomment = function(comment) {

	        pushToContent({
	            comment: comment.trim()
	        });

	    };

	    sax.oncdata = function(cdata) {

	        pushToContent({
	            cdata: cdata
	        });

	    };

	    sax.onopentag = function(data) {

	        var elem = {
	            elem: data.name,
	            prefix: data.prefix,
	            local: data.local
	        };

	        if (Object.keys(data.attributes).length) {
	            elem.attrs = {};

	            for (var name in data.attributes) {
	                elem.attrs[name] = {
	                    name: name,
	                    value: data.attributes[name].value,
	                    prefix: data.attributes[name].prefix,
	                    local: data.attributes[name].local
	                };
	            }
	        }

	        elem = pushToContent(elem);
	        current = elem;

	        // Save info about <text> tag to prevent trimming of meaningful whitespace
	        if (data.name == 'text' && !data.prefix) {
	            textContext = current;
	        }

	        stack.push(elem);

	    };

	    sax.ontext = function(text) {

	        if (/\S/.test(text) || textContext) {

	            if (!textContext)
	                text = text.trim();

	            pushToContent({
	                text: text
	            });

	        }

	    };

	    sax.onclosetag = function() {

	        var last = stack.pop();

	        // Trim text inside <text> tag.
	        if (last == textContext) {
	            trim(textContext);
	            textContext = null;
	        }
	        current = stack[stack.length - 1];

	    };

	    sax.onerror = function(e) {

	        e.message = 'Error in parsing SVG: ' + e.message;
	        if (e.message.indexOf('Unexpected end') < 0) {
	            throw e;
	        }

	    };

	    sax.onend = function() {

	        if (!this.error) {
	            callback(root);
	        } else {
	            callback({ error: this.error.message });
	        }

	    };

	    try {
	        sax.write(data);
	    } catch (e) {
	        callback({ error: e.message });
	        parsingError = true;
	    }
	    if (!parsingError) sax.close();

	    function trim(elem) {
	        if (!elem.content) return elem;

	        var start = elem.content[0],
	            end = elem.content[elem.content.length - 1];

	        while (start && start.content && !start.text) start = start.content[0];
	        if (start && start.text) start.text = start.text.replace(/^\s+/, '');

	        while (end && end.content && !end.text) end = end.content[end.content.length - 1];
	        if (end && end.text) end.text = end.text.replace(/\s+$/, '');

	        return elem;

	    }

	};


/***/ },
/* 293 */
/***/ function(module, exports) {

	module.exports = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	module.exports = Readable;

	/*<replacement>*/
	var isArray = __webpack_require__(293);
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = __webpack_require__(11).EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var StringDecoder;

	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = false;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // In streams that never have any data, and do push(null) right away,
	  // the consumer can miss the 'end' event if they do some I/O before
	  // consuming the stream.  So, we don't emit('end') until some reading
	  // happens.
	  this.calledRead = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = __webpack_require__(17).StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (typeof chunk === 'string' && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (chunk === null || chunk === undefined) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      // update the buffer info.
	      state.length += state.objectMode ? 1 : chunk.length;
	      if (addToFront) {
	        state.buffer.unshift(chunk);
	      } else {
	        state.reading = false;
	        state.buffer.push(chunk);
	      }

	      if (state.needReadable)
	        emitReadable(stream);

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = __webpack_require__(17).StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (n === null || isNaN(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  var state = this._readableState;
	  state.calledRead = true;
	  var nOrig = n;
	  var ret;

	  if (typeof n !== 'number' || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    ret = null;

	    // In cases where the decoder did not receive enough data
	    // to produce a full chunk, then immediately received an
	    // EOF, state.buffer will contain [<Buffer >, <Buffer 00 ...>].
	    // howMuchToRead will see this and coerce the amount to
	    // read to zero (because it's looking at the length of the
	    // first <Buffer > in state.buffer), and we'll end up here.
	    //
	    // This can only happen via state.decoder -- no other venue
	    // exists for pushing a zero-length chunk into state.buffer
	    // and triggering this behavior. In this case, we return our
	    // remaining data and end the stream, if appropriate.
	    if (state.length > 0 && state.decoder) {
	      ret = fromList(n, state);
	      state.length -= ret.length;
	    }

	    if (state.length === 0)
	      endReadable(this);

	    return ret;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length - n <= state.highWaterMark)
	    doRead = true;

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading)
	    doRead = false;

	  if (doRead) {
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read called its callback synchronously, then `reading`
	  // will be false, and we need to re-evaluate how much data we
	  // can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we happened to read() exactly the remaining amount in the
	  // buffer, and the EOF has been seen at this point, then make sure
	  // that we emit 'end' on the very next tick.
	  if (state.ended && !state.endEmitted && state.length === 0)
	    endReadable(this);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // if we've ended and we have some data left, then emit
	  // 'readable' now to make sure it gets picked up.
	  if (state.length > 0)
	    emitReadable(stream);
	  else
	    endReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (state.emittedReadable)
	    return;

	  state.emittedReadable = true;
	  if (state.sync)
	    process.nextTick(function() {
	      emitReadable_(stream);
	    });
	  else
	    emitReadable_(stream);
	}

	function emitReadable_(stream) {
	  stream.emit('readable');
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process.stdout &&
	              dest !== process.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    if (readable !== src) return;
	    cleanup();
	  }

	  function onend() {
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (!dest._writableState || dest._writableState.needDrain)
	      ondrain();
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    // the handler that waits for readable events after all
	    // the data gets sucked out in flow.
	    // This would be easier to follow with a .once() handler
	    // in flow(), but that is too slow.
	    this.on('readable', pipeOnReadable);

	    state.flowing = true;
	    process.nextTick(function() {
	      flow(src);
	    });
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var dest = this;
	    var state = src._readableState;
	    state.awaitDrain--;
	    if (state.awaitDrain === 0)
	      flow(src);
	  };
	}

	function flow(src) {
	  var state = src._readableState;
	  var chunk;
	  state.awaitDrain = 0;

	  function write(dest, i, list) {
	    var written = dest.write(chunk);
	    if (false === written) {
	      state.awaitDrain++;
	    }
	  }

	  while (state.pipesCount && null !== (chunk = src.read())) {

	    if (state.pipesCount === 1)
	      write(state.pipes, 0, null);
	    else
	      forEach(state.pipes, write);

	    src.emit('data', chunk);

	    // if anyone needs a drain, then we have to wait for that.
	    if (state.awaitDrain > 0)
	      return;
	  }

	  // if every destination was unpiped, either before entering this
	  // function, or in the while loop, then stop flowing.
	  //
	  // NB: This is a pretty rare edge case.
	  if (state.pipesCount === 0) {
	    state.flowing = false;

	    // if there were data event listeners added, then switch to old mode.
	    if (EE.listenerCount(src, 'data') > 0)
	      emitDataEvents(src);
	    return;
	  }

	  // at this point, no one needed a drain, so we just ran out of data
	  // on the next readable event, start it over again.
	  state.ranOut = true;
	}

	function pipeOnReadable() {
	  if (this._readableState.ranOut) {
	    this._readableState.ranOut = false;
	    flow(this);
	  }
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    this.removeListener('readable', pipeOnReadable);
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data' && !this._readableState.flowing)
	    emitDataEvents(this);

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        this.read(0);
	      } else if (state.length) {
	        emitReadable(this, state);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  emitDataEvents(this);
	  this.read(0);
	  this.emit('resume');
	};

	Readable.prototype.pause = function() {
	  emitDataEvents(this, true);
	  this.emit('pause');
	};

	function emitDataEvents(stream, startPaused) {
	  var state = stream._readableState;

	  if (state.flowing) {
	    // https://github.com/isaacs/readable-stream/issues/16
	    throw new Error('Cannot switch to old mode now.');
	  }

	  var paused = startPaused || false;
	  var readable = false;

	  // convert to an old-style stream.
	  stream.readable = true;
	  stream.pipe = Stream.prototype.pipe;
	  stream.on = stream.addListener = Stream.prototype.on;

	  stream.on('readable', function() {
	    readable = true;

	    var c;
	    while (!paused && (null !== (c = stream.read())))
	      stream.emit('data', c);

	    if (c === null) {
	      readable = false;
	      stream._readableState.needReadable = true;
	    }
	  });

	  stream.pause = function() {
	    paused = true;
	    this.emit('pause');
	  };

	  stream.resume = function() {
	    paused = false;
	    if (readable)
	      process.nextTick(function() {
	        stream.emit('readable');
	      });
	    else
	      this.read(0);
	    this.emit('resume');
	  };

	  // now make it start, just in case it hadn't already.
	  stream.emit('readable');
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    //if (state.objectMode && util.isNullOrUndefined(chunk))
	    if (state.objectMode && (chunk === null || chunk === undefined))
	      return;
	    else if (!state.objectMode && (!chunk || !chunk.length))
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (typeof stream[i] === 'function' &&
	        typeof this[i] === 'undefined') {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted && state.calledRead) {
	    state.ended = true;
	    process.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	module.exports = Transform;

	var Duplex = __webpack_require__(120);

	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data !== null && data !== undefined)
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  var ts = this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('finish', function() {
	    if ('function' === typeof this._flush)
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var rs = stream._readableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	module.exports = Writable;

	/*<replacement>*/
	var Buffer = __webpack_require__(2).Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = __webpack_require__(8);
	util.inherits = __webpack_require__(7);
	/*</replacement>*/

	var Stream = __webpack_require__(3);

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : 16 * 1024;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, becuase any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = __webpack_require__(120);

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!Buffer.isBuffer(chunk) &&
	      'string' !== typeof chunk &&
	      chunk !== null &&
	      chunk !== undefined &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (typeof cb !== 'function')
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb))
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);

	  return ret;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      typeof chunk === 'string') {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (Buffer.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process.nextTick(function() {
	      cb(er);
	    });
	  else
	    cb(er);

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished && !state.bufferProcessing && state.buffer.length)
	      clearBuffer(stream, state);

	    if (sync) {
	      process.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  cb();
	  if (finished)
	    finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  for (var c = 0; c < state.buffer.length; c++) {
	    var entry = state.buffer[c];
	    var chunk = entry.chunk;
	    var encoding = entry.encoding;
	    var cb = entry.callback;
	    var len = state.objectMode ? 1 : chunk.length;

	    doWrite(stream, state, len, chunk, encoding, cb);

	    // if we didn't call the onwrite immediately, then
	    // it means that we need to wait until it does.
	    // also, that means that the chunk and cb are currently
	    // being processed, so move the buffer counter past them.
	    if (state.writing) {
	      c++;
	      break;
	    }
	  }

	  state.bufferProcessing = false;
	  if (c < state.buffer.length)
	    state.buffer = state.buffer.slice(c);
	  else
	    state.buffer.length = 0;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));
	};

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (typeof chunk !== 'undefined' && chunk !== null)
	    this.write(chunk, encoding);

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    state.finished = true;
	    stream.emit('finish');
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(295)


/***/ },
/* 298 */
/***/ function(module, exports) {

	/*!
	 * time-stamp <https://github.com/jonschlinkert/time-stamp>
	 *
	 * Copyright (c) 2015, Jon Schlinkert.
	 * Licensed under the MIT License.
	 */

	'use strict';

	/**
	 * Parse the given pattern and return a formatted
	 * timestamp.
	 *
	 * @param  {String} `pattern` Date pattern.
	 * @param  {Date} `date` Date object.
	 * @return {String}
	 */

	module.exports = function timestamp(pattern, date) {
	  if (typeof pattern !== 'string') {
	    date = pattern;
	    pattern = 'YYYY:MM:DD';
	  }
	  date = date || new Date();
	  return pattern.replace(/([YMDHms]{2,4})(:\/)?/g, function(_, key, sep) {
	    var increment = method(key);
	    if (!increment) return _;
	    sep = sep || '';

	    var res = '00' + String(date[increment[0]]() + (increment[2] || 0));
	    return res.slice(-increment[1]) + sep;
	  });
	};

	function method(key) {
	  return ({
	   YYYY: ['getFullYear', 4],
	   YY: ['getFullYear', 2],
	   // getMonth is zero-based, thus the extra increment field
	   MM: ['getMonth', 2, 1],
	   DD: ['getDate', 2],
	   HH: ['getHours', 2],
	   mm: ['getMinutes', 2],
	   ss: ['getSeconds', 2],
	   ms: ['getMilliseconds', 3]
	  })[key];
	}


/***/ },
/* 299 */
/***/ function(module, exports, __webpack_require__) {

	var Stream = __webpack_require__(3);

	function prop(propName) {
	  return function (data) {
	    return data[propName];
	  };
	}

	module.exports = unique;
	function unique(propName) {
	  var keyfn = JSON.stringify;
	  if (typeof propName === 'string') {
	    keyfn = prop(propName);
	  } else if (typeof propName === 'function') {
	    keyfn = propName;
	  }
	  var seen = {};
	  var s = new Stream();
	  s.readable = true;
	  s.writable = true;
	  var pipes = 0;

	  s.write = function (data) {
	    var key = keyfn(data);
	    if (seen[key] === undefined) {
	      seen[key] = true;
	      s.emit('data', data);
	    }
	  };

	  var ended = 0;
	  s.end = function (data) {
	    if (arguments.length) s.write(data);
	    ended++;
	    if (ended === pipes || pipes === 0) {
	      s.writable = false;
	      s.emit('end');
	    }
	  };

	  s.destroy = function (data) {
	    s.writable = false;
	  };

	  s.on('pipe', function () {
	    pipes++;
	  });

	  s.on('unpipe', function () {
	    pipes--;
	  });

	  return s;
	}


/***/ },
/* 300 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */

	module.exports = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!global.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = global.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 301 */
/***/ function(module, exports) {

	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    ctor.prototype = Object.create(superCtor.prototype, {
	      constructor: {
	        value: ctor,
	        enumerable: false,
	        writable: true,
	        configurable: true
	      }
	    });
	  };
	} else {
	  // old school shim for old browsers
	  module.exports = function inherits(ctor, superCtor) {
	    ctor.super_ = superCtor
	    var TempCtor = function () {}
	    TempCtor.prototype = superCtor.prototype
	    ctor.prototype = new TempCtor()
	    ctor.prototype.constructor = ctor
	  }
	}


/***/ },
/* 302 */
/***/ function(module, exports) {

	module.exports = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	}

/***/ },
/* 303 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	module.exports = {
	  src: __webpack_require__(313),
	  dest: __webpack_require__(304),
	  watch: __webpack_require__(193)
	};


/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var defaults = __webpack_require__(51);
	var path = __webpack_require__(6);
	var through2 = __webpack_require__(29);
	var mkdirp = __webpack_require__(67);
	var fs = __webpack_require__(23);

	var writeContents = __webpack_require__(305);


	function dest(outFolder, opt) {
	  opt = opt || {};
	  if (typeof outFolder !== 'string' && typeof outFolder !== 'function') {
	    throw new Error('Invalid output folder');
	  }

	  var options = defaults(opt, {
	    cwd: process.cwd()
	  });

	  if (typeof options.mode === 'string') {
	    options.mode = parseInt(options.mode, 8);
	  }

	  var cwd = path.resolve(options.cwd);

	  function saveFile (file, enc, cb) {
	    var basePath;
	    if (typeof outFolder === 'string') {
	      basePath = path.resolve(cwd, outFolder);
	    }
	    if (typeof outFolder === 'function') {
	      basePath = path.resolve(cwd, outFolder(file));
	    }
	    var writePath = path.resolve(basePath, file.relative);
	    var writeFolder = path.dirname(writePath);

	    // wire up new properties
	    file.stat = file.stat ? file.stat : new fs.Stats();
	    file.stat.mode = (options.mode || file.stat.mode);
	    file.cwd = cwd;
	    file.base = basePath;
	    file.path = writePath;

	    // mkdirp the folder the file is going in
	    mkdirp(writeFolder, function(err){
	      if (err) {
	        return cb(err);
	      }
	      writeContents(writePath, file, cb);
	    });
	  }

	  var stream = through2.obj(saveFile);
	  // TODO: option for either backpressure or lossy
	  stream.resume();
	  return stream;
	}

	module.exports = dest;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"fs\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
	var writeDir = __webpack_require__(307);
	var writeStream = __webpack_require__(308);
	var writeBuffer = __webpack_require__(306);

	function writeContents(writePath, file, cb) {
	  var written = function(err) {
	    var done = function(err) {
	      cb(err, file);
	    };
	    if (err) {
	      return done(err);
	    }

	    if (!file.stat || typeof file.stat.mode !== 'number') {
	      return done();
	    }

	    fs.stat(writePath, function(err, st) {
	      if (err) {
	        return done(err);
	      }
	      // octal 7777 = decimal 4095
	      var currentMode = (st.mode & 4095);
	      if (currentMode === file.stat.mode) {
	        return done();
	      }
	      fs.chmod(writePath, file.stat.mode, done);
	    });
	  };

	  // if directory then mkdirp it
	  if (file.isDirectory()) {
	    writeDir(writePath, file, written);
	    return;
	  }

	  // stream it to disk yo
	  if (file.isStream()) {
	    writeStream(writePath, file, written);
	    return;
	  }

	  // write it like normal
	  if (file.isBuffer()) {
	    writeBuffer(writePath, file, written);
	    return;
	  }

	  // if no contents then do nothing
	  if (file.isNull()) {
	    cb(null, file);
	    return;
	  }
	}

	module.exports = writeContents;


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(23);

	function writeBuffer(writePath, file, cb) {
	  var opt = {
	    mode: file.stat.mode
	  };

	  fs.writeFile(writePath, file.contents, opt, cb);
	}

	module.exports = writeBuffer;


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var mkdirp = __webpack_require__(67);

	function writeDir (writePath, file, cb) {
	  mkdirp(writePath, file.stat.mode, cb);
	}

	module.exports = writeDir;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var streamFile = __webpack_require__(121);
	var fs = __webpack_require__(23);

	function writeStream (writePath, file, cb) {
	  var opt = {
	    mode: file.stat.mode
	  };

	  var outStream = fs.createWriteStream(writePath, opt);

	  file.contents.once('error', cb);
	  outStream.once('error', cb);
	  outStream.once('finish', function() {
	    streamFile(file, cb);
	  });

	  file.contents.pipe(outStream);
	}

	module.exports = writeStream;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var fs = __webpack_require__(23);
	var stripBom = __webpack_require__(78);

	function bufferFile(file, cb) {
	  fs.readFile(file.path, function (err, data) {
	    if (err) {
	      return cb(err);
	    }
	    file.contents = stripBom(data);
	    cb(null, file);
	  });
	}

	module.exports = bufferFile;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var through2 = __webpack_require__(29);

	var readDir = __webpack_require__(311);
	var bufferFile = __webpack_require__(309);
	var streamFile = __webpack_require__(121);

	function getContents(opt) {
	  return through2.obj(function (file, enc, cb) {
	    // don't fail to read a directory
	    if (file.isDirectory()) {
	      return readDir(file, cb);
	    }

	    // read and pass full contents
	    if (opt.buffer !== false) {
	      return bufferFile(file, cb);
	    }

	    // dont buffer anything - just pass streams
	    return streamFile(file, cb);
	  });
	}

	module.exports = getContents;


/***/ },
/* 311 */
/***/ function(module, exports) {

	'use strict';

	function readDir(file, cb) {
	  // do nothing for now
	  cb(null, file);
	}

	module.exports = readDir;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var through2 = __webpack_require__(29);
	var fs = __webpack_require__(23);

	function getStats() {
	  return through2.obj(fetchStats);
	}

	function fetchStats(file, enc, cb) {
	  fs.lstat(file.path, function (err, stat) {
	    if (stat) {
	      file.stat = stat;
	    }
	    cb(err, file);
	  });
	}

	module.exports = getStats;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';

	var defaults = __webpack_require__(51);
	var through = __webpack_require__(29);
	var gs = __webpack_require__(191);
	var File = __webpack_require__(315);

	var getContents = __webpack_require__(310);
	var getStats = __webpack_require__(312);

	function createFile (globFile, enc, cb) {
	  cb(null, new File(globFile));
	}

	function src(glob, opt) {
	  opt = opt || {};
	  var pass = through.obj();

	  if (!isValidGlob(glob)) {
	    throw new Error('Invalid glob argument: ' + glob);
	  }
	  // return dead stream if empty array
	  if (Array.isArray(glob) && glob.length === 0) {
	    process.nextTick(pass.end.bind(pass));
	    return pass;
	  }

	  var options = defaults(opt, {
	    read: true,
	    buffer: true
	  });

	  var globStream = gs.create(glob, options);

	  // when people write to use just pass it through
	  var outputStream = globStream
	    .pipe(through.obj(createFile))
	    .pipe(getStats(options));

	  if (options.read !== false) {
	    outputStream = outputStream
	      .pipe(getContents(options));
	  }

	  return outputStream.pipe(pass);
	}

	function isValidGlob(glob) {
	  if (typeof glob === 'string') {
	    return true;
	  }
	  if (Array.isArray(glob) && glob.length !== 0) {
	    return glob.every(isValidGlob);
	  }
	  if (Array.isArray(glob) && glob.length === 0) {
	    return true;
	  }
	  return false;
	}

	module.exports = src;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var fs = __webpack_require__(122)
	var constants = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"constants\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()))

	var origCwd = process.cwd
	var cwd = null
	process.cwd = function() {
	  if (!cwd)
	    cwd = origCwd.call(process)
	  return cwd
	}
	var chdir = process.chdir
	process.chdir = function(d) {
	  cwd = null
	  chdir.call(process, d)
	}

	// (re-)implement some things that are known busted or missing.

	// lchmod, broken prior to 0.6.2
	// back-port the fix here.
	if (constants.hasOwnProperty('O_SYMLINK') &&
	    process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
	  fs.lchmod = function (path, mode, callback) {
	    callback = callback || noop
	    fs.open( path
	           , constants.O_WRONLY | constants.O_SYMLINK
	           , mode
	           , function (err, fd) {
	      if (err) {
	        callback(err)
	        return
	      }
	      // prefer to return the chmod error, if one occurs,
	      // but still try to close, and report closing errors if they occur.
	      fs.fchmod(fd, mode, function (err) {
	        fs.close(fd, function(err2) {
	          callback(err || err2)
	        })
	      })
	    })
	  }

	  fs.lchmodSync = function (path, mode) {
	    var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

	    // prefer to return the chmod error, if one occurs,
	    // but still try to close, and report closing errors if they occur.
	    var err, err2
	    try {
	      var ret = fs.fchmodSync(fd, mode)
	    } catch (er) {
	      err = er
	    }
	    try {
	      fs.closeSync(fd)
	    } catch (er) {
	      err2 = er
	    }
	    if (err || err2) throw (err || err2)
	    return ret
	  }
	}


	// lutimes implementation, or no-op
	if (!fs.lutimes) {
	  if (constants.hasOwnProperty("O_SYMLINK")) {
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.open(path, constants.O_SYMLINK, function (er, fd) {
	        cb = cb || noop
	        if (er) return cb(er)
	        fs.futimes(fd, at, mt, function (er) {
	          fs.close(fd, function (er2) {
	            return cb(er || er2)
	          })
	        })
	      })
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      var fd = fs.openSync(path, constants.O_SYMLINK)
	        , err
	        , err2
	        , ret

	      try {
	        var ret = fs.futimesSync(fd, at, mt)
	      } catch (er) {
	        err = er
	      }
	      try {
	        fs.closeSync(fd)
	      } catch (er) {
	        err2 = er
	      }
	      if (err || err2) throw (err || err2)
	      return ret
	    }

	  } else if (fs.utimensat && constants.hasOwnProperty("AT_SYMLINK_NOFOLLOW")) {
	    // maybe utimensat will be bound soonish?
	    fs.lutimes = function (path, at, mt, cb) {
	      fs.utimensat(path, at, mt, constants.AT_SYMLINK_NOFOLLOW, cb)
	    }

	    fs.lutimesSync = function (path, at, mt) {
	      return fs.utimensatSync(path, at, mt, constants.AT_SYMLINK_NOFOLLOW)
	    }

	  } else {
	    fs.lutimes = function (_a, _b, _c, cb) { process.nextTick(cb) }
	    fs.lutimesSync = function () {}
	  }
	}


	// https://github.com/isaacs/node-graceful-fs/issues/4
	// Chown should not fail on einval or eperm if non-root.
	// It should not fail on enosys ever, as this just indicates
	// that a fs doesn't support the intended operation.

	fs.chown = chownFix(fs.chown)
	fs.fchown = chownFix(fs.fchown)
	fs.lchown = chownFix(fs.lchown)

	fs.chmod = chownFix(fs.chmod)
	fs.fchmod = chownFix(fs.fchmod)
	fs.lchmod = chownFix(fs.lchmod)

	fs.chownSync = chownFixSync(fs.chownSync)
	fs.fchownSync = chownFixSync(fs.fchownSync)
	fs.lchownSync = chownFixSync(fs.lchownSync)

	fs.chmodSync = chownFix(fs.chmodSync)
	fs.fchmodSync = chownFix(fs.fchmodSync)
	fs.lchmodSync = chownFix(fs.lchmodSync)

	function chownFix (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid, cb) {
	    return orig.call(fs, target, uid, gid, function (er, res) {
	      if (chownErOk(er)) er = null
	      cb(er, res)
	    })
	  }
	}

	function chownFixSync (orig) {
	  if (!orig) return orig
	  return function (target, uid, gid) {
	    try {
	      return orig.call(fs, target, uid, gid)
	    } catch (er) {
	      if (!chownErOk(er)) throw er
	    }
	  }
	}

	// ENOSYS means that the fs doesn't support the op. Just ignore
	// that, because it doesn't matter.
	//
	// if there's no getuid, or if getuid() is something other
	// than 0, and the error is EINVAL or EPERM, then just ignore
	// it.
	//
	// This specific case is a silent failure in cp, install, tar,
	// and most other unix tools that manage permissions.
	//
	// When running as root, or if other types of errors are
	// encountered, then it's strict.
	function chownErOk (er) {
	  if (!er)
	    return true

	  if (er.code === "ENOSYS")
	    return true

	  var nonroot = !process.getuid || process.getuid() !== 0
	  if (nonroot) {
	    if (er.code === "EINVAL" || er.code === "EPERM")
	      return true
	  }

	  return false
	}


	// if lchmod/lchown do not exist, then make them no-ops
	if (!fs.lchmod) {
	  fs.lchmod = function (path, mode, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchmodSync = function () {}
	}
	if (!fs.lchown) {
	  fs.lchown = function (path, uid, gid, cb) {
	    process.nextTick(cb)
	  }
	  fs.lchownSync = function () {}
	}



	// on Windows, A/V software can lock the directory, causing this
	// to fail with an EACCES or EPERM if the directory contains newly
	// created files.  Try again on failure, for up to 1 second.
	if (process.platform === "win32") {
	  var rename_ = fs.rename
	  fs.rename = function rename (from, to, cb) {
	    var start = Date.now()
	    rename_(from, to, function CB (er) {
	      if (er
	          && (er.code === "EACCES" || er.code === "EPERM")
	          && Date.now() - start < 1000) {
	        return rename_(from, to, CB)
	      }
	      if(cb) cb(er)
	    })
	  }
	}


	// if read() returns EAGAIN, then just try it again.
	var read = fs.read
	fs.read = function (fd, buffer, offset, length, position, callback_) {
	  var callback
	  if (callback_ && typeof callback_ === 'function') {
	    var eagCounter = 0
	    callback = function (er, _, __) {
	      if (er && er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        return read.call(fs, fd, buffer, offset, length, position, callback)
	      }
	      callback_.apply(this, arguments)
	    }
	  }
	  return read.call(fs, fd, buffer, offset, length, position, callback)
	}

	var readSync = fs.readSync
	fs.readSync = function (fd, buffer, offset, length, position) {
	  var eagCounter = 0
	  while (true) {
	    try {
	      return readSync.call(fs, fd, buffer, offset, length, position)
	    } catch (er) {
	      if (er.code === 'EAGAIN' && eagCounter < 10) {
	        eagCounter ++
	        continue
	      }
	      throw er
	    }
	  }
	}


	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {var path = __webpack_require__(6);
	var clone = __webpack_require__(320);
	var cloneStats = __webpack_require__(47);
	var cloneBuffer = __webpack_require__(316);
	var isBuffer = __webpack_require__(318);
	var isStream = __webpack_require__(123);
	var isNull = __webpack_require__(319);
	var inspectStream = __webpack_require__(317);
	var Stream = __webpack_require__(3);

	function File(file) {
	  if (!file) file = {};

	  // record path change
	  var history = file.path ? [file.path] : file.history;
	  this.history = history || [];

	  // TODO: should this be moved to vinyl-fs?
	  this.cwd = file.cwd || process.cwd();
	  this.base = file.base || this.cwd;

	  // stat = fs stats object
	  // TODO: should this be moved to vinyl-fs?
	  this.stat = file.stat || null;

	  // contents = stream, buffer, or null if not read
	  this.contents = file.contents || null;
	}

	File.prototype.isBuffer = function() {
	  return isBuffer(this.contents);
	};

	File.prototype.isStream = function() {
	  return isStream(this.contents);
	};

	File.prototype.isNull = function() {
	  return isNull(this.contents);
	};

	// TODO: should this be moved to vinyl-fs?
	File.prototype.isDirectory = function() {
	  return this.isNull() && this.stat && this.stat.isDirectory();
	};

	File.prototype.clone = function(opt) {
	  if (typeof opt === 'boolean') {
	    opt = {
	      deep: opt,
	      contents: true
	    };
	  } else if (!opt) {
	    opt = {
	      deep: false,
	      contents: true
	    };
	  } else {
	    opt.deep = opt.deep === true;
	    opt.contents = opt.contents !== false;
	  }

	  // clone our file contents
	  var contents;
	  if (this.isStream()) {
	    contents = this.contents.pipe(new Stream.PassThrough());
	    this.contents = this.contents.pipe(new Stream.PassThrough());
	  } else if (this.isBuffer()) {
	    contents = opt.contents ? cloneBuffer(this.contents) : this.contents;
	  }

	  var file = new File({
	    cwd: this.cwd,
	    base: this.base,
	    stat: (this.stat ? cloneStats(this.stat) : null),
	    history: this.history.slice(),
	    contents: contents
	  });

	  // clone our custom properties
	  Object.keys(this).forEach(function(key) {
	    // ignore built-in fields
	    if (key === '_contents' || key === 'stat' ||
	      key === 'history' || key === 'path' ||
	      key === 'base' || key === 'cwd') {
	      return;
	    }
	    file[key] = opt.deep ? clone(this[key], true) : this[key];
	  }, this);
	  return file;
	};

	File.prototype.pipe = function(stream, opt) {
	  if (!opt) opt = {};
	  if (typeof opt.end === 'undefined') opt.end = true;

	  if (this.isStream()) {
	    return this.contents.pipe(stream, opt);
	  }
	  if (this.isBuffer()) {
	    if (opt.end) {
	      stream.end(this.contents);
	    } else {
	      stream.write(this.contents);
	    }
	    return stream;
	  }

	  // isNull
	  if (opt.end) stream.end();
	  return stream;
	};

	File.prototype.inspect = function() {
	  var inspect = [];

	  // use relative path if possible
	  var filePath = (this.base && this.path) ? this.relative : this.path;

	  if (filePath) {
	    inspect.push('"'+filePath+'"');
	  }

	  if (this.isBuffer()) {
	    inspect.push(this.contents.inspect());
	  }

	  if (this.isStream()) {
	    inspect.push(inspectStream(this.contents));
	  }

	  return '<File '+inspect.join(' ')+'>';
	};

	// virtual attributes
	// or stuff with extra logic
	Object.defineProperty(File.prototype, 'contents', {
	  get: function() {
	    return this._contents;
	  },
	  set: function(val) {
	    if (!isBuffer(val) && !isStream(val) && !isNull(val)) {
	      throw new Error('File.contents can only be a Buffer, a Stream, or null.');
	    }
	    this._contents = val;
	  }
	});

	// TODO: should this be moved to vinyl-fs?
	Object.defineProperty(File.prototype, 'relative', {
	  get: function() {
	    if (!this.base) throw new Error('No base specified! Can not get relative.');
	    if (!this.path) throw new Error('No path specified! Can not get relative.');
	    return path.relative(this.base, this.path);
	  },
	  set: function() {
	    throw new Error('File.relative is generated from the base and path attributes. Do not modify it.');
	  }
	});

	Object.defineProperty(File.prototype, 'path', {
	  get: function() {
	    return this.history[this.history.length - 1];
	  },
	  set: function(path) {
	    if (typeof path !== 'string') throw new Error('path should be string');

	    // record history only when path changed
	    if (path && path !== this.path) {
	      this.history.push(path);
	    }
	  }
	});

	module.exports = File;

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var Buffer = __webpack_require__(2).Buffer;

	module.exports = function(buf) {
	  var out = new Buffer(buf.length);
	  buf.copy(out);
	  return out;
	};


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	var isStream = __webpack_require__(123);

	module.exports = function(stream) {
	  if (!isStream(stream)) return;

	  var streamType = stream.constructor.name;
	  // avoid StreamStream
	  if (streamType === 'Stream') streamType = '';

	  return '<'+streamType+'Stream>';
	};


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	var buf = __webpack_require__(2);
	var Buffer = buf.Buffer;

	// could use Buffer.isBuffer but this is the same exact thing...
	module.exports = function(o) {
	  return typeof o === 'object' && o instanceof Buffer;
	};

/***/ },
/* 319 */
/***/ function(module, exports) {

	module.exports = function(v) {
	  return v === null;
	};


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(Buffer) {'use strict';

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}

	// shim for Node's 'util' package
	// DO NOT REMOVE THIS! It is required for compatibility with EnderJS (http://enderjs.com/).
	var util = {
	  isArray: function (ar) {
	    return Array.isArray(ar) || (typeof ar === 'object' && objectToString(ar) === '[object Array]');
	  },
	  isDate: function (d) {
	    return typeof d === 'object' && objectToString(d) === '[object Date]';
	  },
	  isRegExp: function (re) {
	    return typeof re === 'object' && objectToString(re) === '[object RegExp]';
	  },
	  getRegExpFlags: function (re) {
	    var flags = '';
	    re.global && (flags += 'g');
	    re.ignoreCase && (flags += 'i');
	    re.multiline && (flags += 'm');
	    return flags;
	  }
	};


	if (true)
	  module.exports = clone;

	/**
	 * Clones (copies) an Object using deep copying.
	 *
	 * This function supports circular references by default, but if you are certain
	 * there are no circular references in your object, you can save some CPU time
	 * by calling clone(obj, false).
	 *
	 * Caution: if `circular` is false and `parent` contains circular references,
	 * your program may enter an infinite loop and crash.
	 *
	 * @param `parent` - the object to be cloned
	 * @param `circular` - set to true if the object to be cloned may contain
	 *    circular references. (optional - true by default)
	 * @param `depth` - set to a number if the object is only to be cloned to
	 *    a particular depth. (optional - defaults to Infinity)
	 * @param `prototype` - sets the prototype to be used when cloning an object.
	 *    (optional - defaults to parent prototype).
	*/

	function clone(parent, circular, depth, prototype) {
	  // maintain two arrays for circular references, where corresponding parents
	  // and children have the same index
	  var allParents = [];
	  var allChildren = [];

	  var useBuffer = typeof Buffer != 'undefined';

	  if (typeof circular == 'undefined')
	    circular = true;

	  if (typeof depth == 'undefined')
	    depth = Infinity;

	  // recurse this function so we don't reset allParents and allChildren
	  function _clone(parent, depth) {
	    // cloning null always returns null
	    if (parent === null)
	      return null;

	    if (depth == 0)
	      return parent;

	    var child;
	    var proto;
	    if (typeof parent != 'object') {
	      return parent;
	    }

	    if (util.isArray(parent)) {
	      child = [];
	    } else if (util.isRegExp(parent)) {
	      child = new RegExp(parent.source, util.getRegExpFlags(parent));
	      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
	    } else if (util.isDate(parent)) {
	      child = new Date(parent.getTime());
	    } else if (useBuffer && Buffer.isBuffer(parent)) {
	      child = new Buffer(parent.length);
	      parent.copy(child);
	      return child;
	    } else {
	      if (typeof prototype == 'undefined') {
	        proto = Object.getPrototypeOf(parent);
	        child = Object.create(proto);
	      }
	      else {
	        child = Object.create(prototype);
	        proto = prototype;
	      }
	    }

	    if (circular) {
	      var index = allParents.indexOf(parent);

	      if (index != -1) {
	        return allChildren[index];
	      }
	      allParents.push(parent);
	      allChildren.push(child);
	    }

	    for (var i in parent) {
	      var attrs;
	      if (proto) {
	        attrs = Object.getOwnPropertyDescriptor(proto, i);
	      }
	      
	      if (attrs && attrs.set == null) {
	        continue;
	      }
	      child[i] = _clone(parent[i], depth - 1);
	    }

	    return child;
	  }

	  return _clone(parent, depth);
	}

	/**
	 * Simple flat clone using prototype, accepts only objects, usefull for property
	 * override on FLAT configuration object (no nested props).
	 *
	 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
	 * works.
	 */
	clone.clonePrototype = function(parent) {
	  if (parent === null)
	    return null;

	  var c = function () {};
	  c.prototype = parent;
	  return new c();
	};

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2).Buffer))

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	var indexOf = __webpack_require__(225);

	var Object_keys = function (obj) {
	    if (Object.keys) return Object.keys(obj)
	    else {
	        var res = [];
	        for (var key in obj) res.push(key)
	        return res;
	    }
	};

	var forEach = function (xs, fn) {
	    if (xs.forEach) return xs.forEach(fn)
	    else for (var i = 0; i < xs.length; i++) {
	        fn(xs[i], i, xs);
	    }
	};

	var defineProp = (function() {
	    try {
	        Object.defineProperty({}, '_', {});
	        return function(obj, name, value) {
	            Object.defineProperty(obj, name, {
	                writable: true,
	                enumerable: false,
	                configurable: true,
	                value: value
	            })
	        };
	    } catch(e) {
	        return function(obj, name, value) {
	            obj[name] = value;
	        };
	    }
	}());

	var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
	'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
	'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
	'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
	'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

	function Context() {}
	Context.prototype = {};

	var Script = exports.Script = function NodeScript (code) {
	    if (!(this instanceof Script)) return new Script(code);
	    this.code = code;
	};

	Script.prototype.runInContext = function (context) {
	    if (!(context instanceof Context)) {
	        throw new TypeError("needs a 'context' argument.");
	    }
	    
	    var iframe = document.createElement('iframe');
	    if (!iframe.style) iframe.style = {};
	    iframe.style.display = 'none';
	    
	    document.body.appendChild(iframe);
	    
	    var win = iframe.contentWindow;
	    var wEval = win.eval, wExecScript = win.execScript;

	    if (!wEval && wExecScript) {
	        // win.eval() magically appears when this is called in IE:
	        wExecScript.call(win, 'null');
	        wEval = win.eval;
	    }
	    
	    forEach(Object_keys(context), function (key) {
	        win[key] = context[key];
	    });
	    forEach(globals, function (key) {
	        if (context[key]) {
	            win[key] = context[key];
	        }
	    });
	    
	    var winKeys = Object_keys(win);

	    var res = wEval.call(win, this.code);
	    
	    forEach(Object_keys(win), function (key) {
	        // Avoid copying circular objects like `top` and `window` by only
	        // updating existing context properties or new properties in the `win`
	        // that was only introduced after the eval.
	        if (key in context || indexOf(winKeys, key) === -1) {
	            context[key] = win[key];
	        }
	    });

	    forEach(globals, function (key) {
	        if (!(key in context)) {
	            defineProp(context, key, win[key]);
	        }
	    });
	    
	    document.body.removeChild(iframe);
	    
	    return res;
	};

	Script.prototype.runInThisContext = function () {
	    return eval(this.code); // maybe...
	};

	Script.prototype.runInNewContext = function (context) {
	    var ctx = Script.createContext(context);
	    var res = this.runInContext(ctx);

	    forEach(Object_keys(ctx), function (key) {
	        context[key] = ctx[key];
	    });

	    return res;
	};

	forEach(Object_keys(Script.prototype), function (name) {
	    exports[name] = Script[name] = function (code) {
	        var s = Script(code);
	        return s[name].apply(s, [].slice.call(arguments, 1));
	    };
	});

	exports.createScript = function (code) {
	    return exports.Script(code);
	};

	exports.createContext = Script.createContext = function (context) {
	    var copy = new Context();
	    if(typeof context === 'object') {
	        forEach(Object_keys(context), function (key) {
	            copy[key] = context[key];
	        });
	    }
	    return copy;
	};


/***/ },
/* 322 */
/***/ function(module, exports) {

	// Generated by CoffeeScript 1.3.3

	/*
	 * whet.extend v0.9.7
	 * Standalone port of jQuery.extend that actually works on node.js
	 * https://github.com/Meettya/whet.extend
	 *
	 * Copyright 2012, Dmitrii Karpich
	 * Released under the MIT License
	*/


	(function() {
	  var extend, _findValue, _isClass, _isOwnProp, _isPlainObj, _isPrimitiveType, _isTypeOf, _prepareClone,
	    __slice = [].slice;

	  module.exports = extend = function() {
	    var args, copy, deep, name, options, target, _i, _len, _ref;
	    deep = arguments[0], target = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
	    if (!_isClass(deep, 'Boolean')) {
	      args.unshift(target);
	      _ref = [deep || {}, false], target = _ref[0], deep = _ref[1];
	    }
	    if (_isPrimitiveType(target)) {
	      target = {};
	    }
	    for (_i = 0, _len = args.length; _i < _len; _i++) {
	      options = args[_i];
	      if (options != null) {
	        for (name in options) {
	          copy = options[name];
	          target[name] = _findValue(deep, copy, target[name]);
	        }
	      }
	    }
	    return target;
	  };

	  /*
	  Internal methods from now
	  */


	  _isClass = function(obj, str) {
	    return ("[object " + str + "]") === Object.prototype.toString.call(obj);
	  };

	  _isOwnProp = function(obj, prop) {
	    return Object.prototype.hasOwnProperty.call(obj, prop);
	  };

	  _isTypeOf = function(obj, str) {
	    return str === typeof obj;
	  };

	  _isPlainObj = function(obj) {
	    var key;
	    if (!obj) {
	      return false;
	    }
	    if (obj.nodeType || obj.setInterval || !_isClass(obj, 'Object')) {
	      return false;
	    }
	    if (obj.constructor && !_isOwnProp(obj, 'constructor') && !_isOwnProp(obj.constructor.prototype, 'isPrototypeOf')) {
	      return false;
	    }
	    for (key in obj) {
	      key;

	    }
	    return key === void 0 || _isOwnProp(obj, key);
	  };

	  _isPrimitiveType = function(obj) {
	    return !(_isTypeOf(obj, 'object') || _isTypeOf(obj, 'function'));
	  };

	  _prepareClone = function(copy, src) {
	    if (_isClass(copy, 'Array')) {
	      if (_isClass(src, 'Array')) {
	        return src;
	      } else {
	        return [];
	      }
	    } else {
	      if (_isPlainObj(src)) {
	        return src;
	      } else {
	        return {};
	      }
	    }
	  };

	  _findValue = function(deep, copy, src) {
	    var clone;
	    if (deep && (_isClass(copy, 'Array') || _isPlainObj(copy))) {
	      clone = _prepareClone(copy, src);
	      return extend(deep, clone, copy);
	    } else {
	      return copy;
	    }
	  };

	}).call(this);


/***/ },
/* 323 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 324 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ }
/******/ ])
});
;